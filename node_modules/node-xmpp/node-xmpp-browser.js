require=(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
var punycode = { encode : function (s) { return s } };

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

function arrayIndexOf(array, subject) {
    for (var i = 0, j = array.length; i < j; i++) {
        if(array[i] == subject) return i;
    }
    return -1;
}

var objectKeys = Object.keys || function objectKeys(object) {
    if (object !== Object(object)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in object) if (object.hasOwnProperty(key)) keys[keys.length] = key;
    return keys;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]+$/,
    // RFC 2396: characters reserved for delimiting URLs.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '~', '[', ']', '`'].concat(delims),
    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''],
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#']
      .concat(unwise).concat(autoEscape),
    nonAuthChars = ['/', '@', '?', '#'].concat(delims),
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-zA-Z0-9][a-z0-9A-Z_-]{0,62}$/,
    hostnamePartStart = /^([a-zA-Z0-9][a-z0-9A-Z_-]{0,62})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always have a path component.
    pathedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof(url) === 'object' && url.href) return url;

  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var out = {},
      rest = url;

  // cut off any delimiters.
  // This is to support parse stuff like "<http://foo.com>"
  for (var i = 0, l = rest.length; i < l; i++) {
    if (arrayIndexOf(delims, rest.charAt(i)) === -1) break;
  }
  if (i !== 0) rest = rest.substr(i);


  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    out.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      out.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    // don't enforce full RFC correctness, just be unstupid about it.

    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the first @ sign, unless some non-auth character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    var atSign = arrayIndexOf(rest, '@');
    if (atSign !== -1) {
      // there *may be* an auth
      var hasAuth = true;
      for (var i = 0, l = nonAuthChars.length; i < l; i++) {
        var index = arrayIndexOf(rest, nonAuthChars[i]);
        if (index !== -1 && index < atSign) {
          // not a valid auth.  Something like http://foo.com/bar@baz/
          hasAuth = false;
          break;
        }
      }
      if (hasAuth) {
        // pluck off the auth portion.
        out.auth = rest.substr(0, atSign);
        rest = rest.substr(atSign + 1);
      }
    }

    var firstNonHost = -1;
    for (var i = 0, l = nonHostChars.length; i < l; i++) {
      var index = arrayIndexOf(rest, nonHostChars[i]);
      if (index !== -1 &&
          (firstNonHost < 0 || index < firstNonHost)) firstNonHost = index;
    }

    if (firstNonHost !== -1) {
      out.host = rest.substr(0, firstNonHost);
      rest = rest.substr(firstNonHost);
    } else {
      out.host = rest;
      rest = '';
    }

    // pull out port.
    var p = parseHost(out.host);
    var keys = objectKeys(p);
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      out[key] = p[key];
    }

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    out.hostname = out.hostname || '';

    // validate a little.
    if (out.hostname.length > hostnameMaxLen) {
      out.hostname = '';
    } else {
      var hostparts = out.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            out.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    // hostnames are always lower case.
    out.hostname = out.hostname.toLowerCase();

    // IDNA Support: Returns a puny coded representation of "domain".
    // It only converts the part of the domain name that
    // has non ASCII characters. I.e. it dosent matter if
    // you call it with a domain that already is in ASCII.
    var domainArray = out.hostname.split('.');
    var newOut = [];
    for (var i = 0; i < domainArray.length; ++i) {
      var s = domainArray[i];
      newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
          'xn--' + punycode.encode(s) : s);
    }
    out.hostname = newOut.join('.');

    out.host = (out.hostname || '') +
        ((out.port) ? ':' + out.port : '');
    out.href += out.host;
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }

    // Now make sure that delims never appear in a url.
    var chop = rest.length;
    for (var i = 0, l = delims.length; i < l; i++) {
      var c = arrayIndexOf(rest, delims[i]);
      if (c !== -1) {
        chop = Math.min(c, chop);
      }
    }
    rest = rest.substr(0, chop);
  }


  // chop off from the tail first.
  var hash = arrayIndexOf(rest, '#');
  if (hash !== -1) {
    // got a fragment string.
    out.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = arrayIndexOf(rest, '?');
  if (qm !== -1) {
    out.search = rest.substr(qm);
    out.query = rest.substr(qm + 1);
    if (parseQueryString) {
      out.query = querystring.parse(out.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    out.search = '';
    out.query = {};
  }
  if (rest) out.pathname = rest;
  if (slashedProtocol[proto] &&
      out.hostname && !out.pathname) {
    out.pathname = '/';
  }

  //to support http.request
  if (out.pathname || out.search) {
    out.path = (out.pathname ? out.pathname : '') +
               (out.search ? out.search : '');
  }

  // finally, reconstruct the href based on what has been validated.
  out.href = urlFormat(out);
  return out;
}

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (typeof(obj) === 'string') obj = urlParse(obj);

  var auth = obj.auth || '';
  if (auth) {
    auth = auth.split('@').join('%40');
    for (var i = 0, l = nonAuthChars.length; i < l; i++) {
      var nAC = nonAuthChars[i];
      auth = auth.split(nAC).join(encodeURIComponent(nAC));
    }
    auth += '@';
  }

  var protocol = obj.protocol || '',
      host = (obj.host !== undefined) ? auth + obj.host :
          obj.hostname !== undefined ? (
              auth + obj.hostname +
              (obj.port ? ':' + obj.port : '')
          ) :
          false,
      pathname = obj.pathname || '',
      query = obj.query &&
              ((typeof obj.query === 'object' &&
                objectKeys(obj.query).length) ?
                 querystring.stringify(obj.query) :
                 '') || '',
      search = obj.search || (query && ('?' + query)) || '',
      hash = obj.hash || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (obj.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  return protocol + host + pathname + search + hash;
}

function urlResolve(source, relative) {
  return urlFormat(urlResolveObject(source, relative));
}

function urlResolveObject(source, relative) {
  if (!source) return relative;

  source = urlParse(urlFormat(source), false, true);
  relative = urlParse(urlFormat(relative), false, true);

  // hash is always overridden, no matter what.
  source.hash = relative.hash;

  if (relative.href === '') {
    source.href = urlFormat(source);
    return source;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    relative.protocol = source.protocol;
    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[relative.protocol] &&
        relative.hostname && !relative.pathname) {
      relative.path = relative.pathname = '/';
    }
    relative.href = urlFormat(relative);
    return relative;
  }

  if (relative.protocol && relative.protocol !== source.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      relative.href = urlFormat(relative);
      return relative;
    }
    source.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      relative.pathname = relPath.join('/');
    }
    source.pathname = relative.pathname;
    source.search = relative.search;
    source.query = relative.query;
    source.host = relative.host || '';
    source.auth = relative.auth;
    source.hostname = relative.hostname || relative.host;
    source.port = relative.port;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.slashes = source.slashes || relative.slashes;
    source.href = urlFormat(source);
    return source;
  }

  var isSourceAbs = (source.pathname && source.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host !== undefined ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (source.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = source.pathname && source.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = source.protocol &&
          !slashedProtocol[source.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // source.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {

    delete source.hostname;
    delete source.port;
    if (source.host) {
      if (srcPath[0] === '') srcPath[0] = source.host;
      else srcPath.unshift(source.host);
    }
    delete source.host;
    if (relative.protocol) {
      delete relative.hostname;
      delete relative.port;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      delete relative.host;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    source.host = (relative.host || relative.host === '') ?
                      relative.host : source.host;
    source.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : source.hostname;
    source.search = relative.search;
    source.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    source.search = relative.search;
    source.query = relative.query;
  } else if ('search' in relative) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      source.hostname = source.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ?
                       source.host.split('@') : false;
      if (authInHost) {
        source.auth = authInHost.shift();
        source.host = source.hostname = authInHost.shift();
      }
    }
    source.search = relative.search;
    source.query = relative.query;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.href = urlFormat(source);
    return source;
  }
  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    delete source.pathname;
    //to support http.request
    if (!source.search) {
      source.path = '/' + source.search;
    } else {
      delete source.path;
    }
    source.href = urlFormat(source);
    return source;
  }
  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (source.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    source.hostname = source.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ?
                     source.host.split('@') : false;
    if (authInHost) {
      source.auth = authInHost.shift();
      source.host = source.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (source.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  source.pathname = srcPath.join('/');
  //to support request.http
  if (source.pathname !== undefined || source.search !== undefined) {
    source.path = (source.pathname ? source.pathname : '') +
                  (source.search ? source.search : '');
  }
  source.auth = relative.auth || source.auth;
  source.slashes = source.slashes || relative.slashes;
  source.href = urlFormat(source);
  return source;
}

function parseHost(host) {
  var out = {};
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    out.port = port.substr(1);
    host = host.substr(0, host.length - port.length);
  }
  if (host) out.hostname = host;
  return out;
}

},{"querystring":2}],3:[function(require,module,exports){
var events = require('events');
var util = require('util');

function Stream() {
  events.EventEmitter.call(this);
}
util.inherits(Stream, events.EventEmitter);
module.exports = Stream;
// Backwards-compat with node 0.4.x
Stream.Stream = Stream;

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once, and
  // only when all sources have ended.
  if (!dest._isStdio && (!options || options.end !== false)) {
    dest._pipeCount = dest._pipeCount || 0;
    dest._pipeCount++;

    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest._pipeCount--;

    // remove the listeners
    cleanup();

    if (dest._pipeCount > 0) {
      // waiting for other incoming streams to end.
      return;
    }

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest._pipeCount--;

    // remove the listeners
    cleanup();

    if (dest._pipeCount > 0) {
      // waiting for other incoming streams to end.
      return;
    }

    dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (this.listeners('error').length === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('end', cleanup);
    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('end', cleanup);
  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":4,"util":5}],5:[function(require,module,exports){
var events = require('events');

exports.isArray = isArray;
exports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};
exports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};


exports.print = function () {};
exports.puts = function () {};
exports.debug = function() {};

exports.inspect = function(obj, showHidden, depth, colors) {
  var seen = [];

  var stylize = function(str, styleType) {
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    var styles =
        { 'bold' : [1, 22],
          'italic' : [3, 23],
          'underline' : [4, 24],
          'inverse' : [7, 27],
          'white' : [37, 39],
          'grey' : [90, 39],
          'black' : [30, 39],
          'blue' : [34, 39],
          'cyan' : [36, 39],
          'green' : [32, 39],
          'magenta' : [35, 39],
          'red' : [31, 39],
          'yellow' : [33, 39] };

    var style =
        { 'special': 'cyan',
          'number': 'blue',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red' }[styleType];

    if (style) {
      return '\033[' + styles[style][0] + 'm' + str +
             '\033[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (! colors) {
    stylize = function(str, styleType) { return str; };
  }

  function format(value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' &&
        // Filter out the util module, it's inspect function is special
        value !== exports &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      return value.inspect(recurseTimes);
    }

    // Primitive types cannot have properties
    switch (typeof value) {
      case 'undefined':
        return stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return stylize(simple, 'string');

      case 'number':
        return stylize('' + value, 'number');

      case 'boolean':
        return stylize('' + value, 'boolean');
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
      return stylize('null', 'null');
    }

    // Look up the keys of the object.
    var visible_keys = Object_keys(value);
    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;

    // Functions without properties can be shortcutted.
    if (typeof value === 'function' && keys.length === 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        var name = value.name ? ': ' + value.name : '';
        return stylize('[Function' + name + ']', 'special');
      }
    }

    // Dates without properties can be shortcutted
    if (isDate(value) && keys.length === 0) {
      return stylize(value.toUTCString(), 'date');
    }

    var base, type, braces;
    // Determine the object type
    if (isArray(value)) {
      type = 'Array';
      braces = ['[', ']'];
    } else {
      type = 'Object';
      braces = ['{', '}'];
    }

    // Make functions say that they are functions
    if (typeof value === 'function') {
      var n = value.name ? ': ' + value.name : '';
      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
    } else {
      base = '';
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + value.toUTCString();
    }

    if (keys.length === 0) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        return stylize('[Object]', 'special');
      }
    }

    seen.push(value);

    var output = keys.map(function(key) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Getter/Setter]', 'special');
          } else {
            str = stylize('[Getter]', 'special');
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Setter]', 'special');
          }
        }
      }
      if (visible_keys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = format(value[key]);
          } else {
            str = format(value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (isArray(value)) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (type === 'Array' && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    });

    seen.pop();

    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.length + 1;
    }, 0);

    if (length > 50) {
      output = braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];

    } else {
      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    return output;
  }
  return format(obj, (typeof depth === 'undefined' ? 2 : depth));
};


function isArray(ar) {
  return ar instanceof Array ||
         Array.isArray(ar) ||
         (ar && ar !== Object.prototype && isArray(ar.__proto__));
}


function isRegExp(re) {
  return re instanceof RegExp ||
    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');
}


function isDate(d) {
  if (d instanceof Date) return true;
  if (typeof d !== 'object') return false;
  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);
  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);
  return JSON.stringify(proto) === JSON.stringify(properties);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

exports.log = function (msg) {};

exports.pump = null;

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

var Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
    var res = [];
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
};

var Object_create = Object.create || function (prototype, properties) {
    // from es5-shim
    var object;
    if (prototype === null) {
        object = { '__proto__' : null };
    }
    else {
        if (typeof prototype !== 'object') {
            throw new TypeError(
                'typeof prototype[' + (typeof prototype) + '] != \'object\''
            );
        }
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
        Object.defineProperties(object, properties);
    }
    return object;
};

exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object_create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (typeof f !== 'string') {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(exports.inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j': return JSON.stringify(args[i++]);
      default:
        return x;
    }
  });
  for(var x = args[i]; i < len; x = args[++i]){
    if (x === null || typeof x !== 'object') {
      str += ' ' + x;
    } else {
      str += ' ' + exports.inspect(x);
    }
  }
  return str;
};

},{"events":4}],2:[function(require,module,exports){

/**
 * Object#toString() ref for stringify().
 */

var toString = Object.prototype.toString;

/**
 * Array#indexOf shim.
 */

var indexOf = typeof Array.prototype.indexOf === 'function'
  ? function(arr, el) { return arr.indexOf(el); }
  : function(arr, el) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === el) return i;
      }
      return -1;
    };

/**
 * Array.isArray shim.
 */

var isArray = Array.isArray || function(arr) {
  return toString.call(arr) == '[object Array]';
};

/**
 * Object.keys shim.
 */

var objectKeys = Object.keys || function(obj) {
  var ret = [];
  for (var key in obj) ret.push(key);
  return ret;
};

/**
 * Array#forEach shim.
 */

var forEach = typeof Array.prototype.forEach === 'function'
  ? function(arr, fn) { return arr.forEach(fn); }
  : function(arr, fn) {
      for (var i = 0; i < arr.length; i++) fn(arr[i]);
    };

/**
 * Array#reduce shim.
 */

var reduce = function(arr, fn, initial) {
  if (typeof arr.reduce === 'function') return arr.reduce(fn, initial);
  var res = initial;
  for (var i = 0; i < arr.length; i++) res = fn(res, arr[i]);
  return res;
};

/**
 * Cache non-integer test regexp.
 */

var isint = /^[0-9]+$/;

function promote(parent, key) {
  if (parent[key].length == 0) return parent[key] = {};
  var t = {};
  for (var i in parent[key]) t[i] = parent[key][i];
  parent[key] = t;
  return t;
}

function parse(parts, parent, key, val) {
  var part = parts.shift();
  // end
  if (!part) {
    if (isArray(parent[key])) {
      parent[key].push(val);
    } else if ('object' == typeof parent[key]) {
      parent[key] = val;
    } else if ('undefined' == typeof parent[key]) {
      parent[key] = val;
    } else {
      parent[key] = [parent[key], val];
    }
    // array
  } else {
    var obj = parent[key] = parent[key] || [];
    if (']' == part) {
      if (isArray(obj)) {
        if ('' != val) obj.push(val);
      } else if ('object' == typeof obj) {
        obj[objectKeys(obj).length] = val;
      } else {
        obj = parent[key] = [parent[key], val];
      }
      // prop
    } else if (~indexOf(part, ']')) {
      part = part.substr(0, part.length - 1);
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
      // key
    } else {
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
    }
  }
}

/**
 * Merge parent key/val pair.
 */

function merge(parent, key, val){
  if (~indexOf(key, ']')) {
    var parts = key.split('[')
      , len = parts.length
      , last = len - 1;
    parse(parts, parent, 'base', val);
    // optimize
  } else {
    if (!isint.test(key) && isArray(parent.base)) {
      var t = {};
      for (var k in parent.base) t[k] = parent.base[k];
      parent.base = t;
    }
    set(parent.base, key, val);
  }

  return parent;
}

/**
 * Parse the given obj.
 */

function parseObject(obj){
  var ret = { base: {} };
  forEach(objectKeys(obj), function(name){
    merge(ret, name, obj[name]);
  });
  return ret.base;
}

/**
 * Parse the given str.
 */

function parseString(str){
  return reduce(String(str).split('&'), function(ret, pair){
    var eql = indexOf(pair, '=')
      , brace = lastBraceInKey(pair)
      , key = pair.substr(0, brace || eql)
      , val = pair.substr(brace || eql, pair.length)
      , val = val.substr(indexOf(val, '=') + 1, val.length);

    // ?foo
    if ('' == key) key = pair, val = '';
    if ('' == key) return ret;

    return merge(ret, decode(key), decode(val));
  }, { base: {} }).base;
}

/**
 * Parse the given query `str` or `obj`, returning an object.
 *
 * @param {String} str | {Object} obj
 * @return {Object}
 * @api public
 */

exports.parse = function(str){
  if (null == str || '' == str) return {};
  return 'object' == typeof str
    ? parseObject(str)
    : parseString(str);
};

/**
 * Turn the given `obj` into a query string
 *
 * @param {Object} obj
 * @return {String}
 * @api public
 */

var stringify = exports.stringify = function(obj, prefix) {
  if (isArray(obj)) {
    return stringifyArray(obj, prefix);
  } else if ('[object Object]' == toString.call(obj)) {
    return stringifyObject(obj, prefix);
  } else if ('string' == typeof obj) {
    return stringifyString(obj, prefix);
  } else {
    return prefix + '=' + encodeURIComponent(String(obj));
  }
};

/**
 * Stringify the given `str`.
 *
 * @param {String} str
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyString(str, prefix) {
  if (!prefix) throw new TypeError('stringify expects an object');
  return prefix + '=' + encodeURIComponent(str);
}

/**
 * Stringify the given `arr`.
 *
 * @param {Array} arr
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyArray(arr, prefix) {
  var ret = [];
  if (!prefix) throw new TypeError('stringify expects an object');
  for (var i = 0; i < arr.length; i++) {
    ret.push(stringify(arr[i], prefix + '[' + i + ']'));
  }
  return ret.join('&');
}

/**
 * Stringify the given `obj`.
 *
 * @param {Object} obj
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyObject(obj, prefix) {
  var ret = []
    , keys = objectKeys(obj)
    , key;

  for (var i = 0, len = keys.length; i < len; ++i) {
    key = keys[i];
    if (null == obj[key]) {
      ret.push(encodeURIComponent(key) + '=');
    } else {
      ret.push(stringify(obj[key], prefix
        ? prefix + '[' + encodeURIComponent(key) + ']'
        : encodeURIComponent(key)));
    }
  }

  return ret.join('&');
}

/**
 * Set `obj`'s `key` to `val` respecting
 * the weird and wonderful syntax of a qs,
 * where "foo=bar&foo=baz" becomes an array.
 *
 * @param {Object} obj
 * @param {String} key
 * @param {String} val
 * @api private
 */

function set(obj, key, val) {
  var v = obj[key];
  if (undefined === v) {
    obj[key] = val;
  } else if (isArray(v)) {
    v.push(val);
  } else {
    obj[key] = [v, val];
  }
}

/**
 * Locate last brace in `str` within the key.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function lastBraceInKey(str) {
  var len = str.length
    , brace
    , c;
  for (var i = 0; i < len; ++i) {
    c = str[i];
    if (']' == c) brace = false;
    if ('[' == c) brace = true;
    if ('=' == c && !brace) return i;
  }
}

/**
 * Decode `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function decode(str) {
  try {
    return decodeURIComponent(str.replace(/\+/g, ' '));
  } catch (err) {
    return str;
  }
}

},{}],6:[function(require,module,exports){
var http = require('http');

var https = module.exports;

for (var key in http) {
    if (http.hasOwnProperty(key)) https[key] = http[key];
};

https.request = function (params, cb) {
    if (!params) params = {};
    params.scheme = 'https';
    return http.request.call(this, params, cb);
}
},{"http":7}],8:[function(require,module,exports){
// todo

},{}],9:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],4:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":9}],7:[function(require,module,exports){
var http = module.exports;
var EventEmitter = require('events').EventEmitter;
var Request = require('./lib/request');

http.request = function (params, cb) {
    if (!params) params = {};
    if (!params.host) params.host = window.location.host.split(':')[0];
    if (!params.port) params.port = window.location.port;
    if (!params.scheme) params.scheme = window.location.protocol.split(':')[0];
    
    var req = new Request(new xhrHttp, params);
    if (cb) req.on('response', cb);
    return req;
};

http.get = function (params, cb) {
    params.method = 'GET';
    var req = http.request(params, cb);
    req.end();
    return req;
};

http.Agent = function () {};
http.Agent.defaultMaxSockets = 4;

var xhrHttp = (function () {
    if (typeof window === 'undefined') {
        throw new Error('no window object present');
    }
    else if (window.XMLHttpRequest) {
        return window.XMLHttpRequest;
    }
    else if (window.ActiveXObject) {
        var axs = [
            'Msxml2.XMLHTTP.6.0',
            'Msxml2.XMLHTTP.3.0',
            'Microsoft.XMLHTTP'
        ];
        for (var i = 0; i < axs.length; i++) {
            try {
                var ax = new(window.ActiveXObject)(axs[i]);
                return function () {
                    if (ax) {
                        var ax_ = ax;
                        ax = null;
                        return ax_;
                    }
                    else {
                        return new(window.ActiveXObject)(axs[i]);
                    }
                };
            }
            catch (e) {}
        }
        throw new Error('ajax not supported in this browser')
    }
    else {
        throw new Error('ajax not supported in this browser');
    }
})();

},{"events":4,"./lib/request":10}],11:[function(require,module,exports){
(function(){var Buffer = require('buffer').Buffer
var sha = require('./sha')
var rng = require('./rng')
var md5 = require('./md5')

var algorithms = {
  sha1: {
    hex: sha.hex_sha1,
    binary: sha.b64_sha1,
    ascii: sha.str_sha1
  },
  md5: {
    hex: md5.hex_md5,
    binary: md5.b64_md5,
    ascii: md5.any_md5
  }
}

function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/dominictarr/crypto-browserify'
    ].join('\n'))
}

exports.createHash = function (alg) {
  alg = alg || 'sha1'
  if(!algorithms[alg])
    error('algorithm:', alg, 'is not yet supported')
  var s = ''
  var _alg = algorithms[alg]
  return {
    update: function (data) {
      s += data
      return this
    },
    digest: function (enc) {
      enc = enc || 'binary'
      var fn
      if(!(fn = _alg[enc]))
        error('encoding:', enc , 'is not yet supported for algorithm', alg)
      var r = fn(s)
      s = null //not meant to use the hash after you've called digest.
      return r
    }
  }
}

exports.randomBytes = function(size, callback) {
  if (callback && callback.call) {
    try {
      callback.call(this, undefined, new Buffer(rng(size)));
    } catch (err) { callback(err); }
  } else {
    return new Buffer(rng(size));
  }
}

function each(a, f) {
  for(var i in a)
    f(a[i], i)
}

// the least I can do is make error messages for the rest of the node.js/crypto api.
each(['createCredentials'
, 'createHmac'
, 'createCypher'
, 'createCypheriv'
, 'createDecipher'
, 'createDecipheriv'
, 'createSign'
, 'createVerify'
, 'createDeffieHellman'
, 'pbkdf2'], function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
})

})()
},{"buffer":12,"./rng":13,"./sha":14,"./md5":15}],16:[function(require,module,exports){
try {
    var StringPrep = require('node-stringprep').StringPrep;
    var toUnicode = require('node-stringprep').toUnicode;
    var c = function(n) {
	var p = new StringPrep(n);
	return function(s) {
	    return p.prepare(s);
	};
    };
    var nameprep = c('nameprep');
    var nodeprep = c('nodeprep');
    var resourceprep = c('resourceprep');
} catch(ex) {
    console.warn("Cannot load StringPrep-0.1.0 bindings. You may need to `npm install node-stringprep'");
    var identity = function(a) { return a; };
    var toLower = function(a) { return a.toLowerCase(); };
    var toUnicode = identity;
    var nameprep = toLower;
    var nodeprep = toLower;
    var resourceprep = identity;
}

function JID(a, b, c) {
    if (a && b == null && c == null) {
        this.parseJID(a);
    } else if (b) {
        this.setUser(a);
        this.setDomain(b);
        this.setResource(c);
    } else
        throw new Error('Argument error');
}

JID.prototype.parseJID = function(s) {
    if (s.indexOf('@') >= 0) {
        this.setUser(s.substr(0, s.indexOf('@')));
        s = s.substr(s.indexOf('@') + 1);
    }
    if (s.indexOf('/') >= 0) {
        this.setResource(s.substr(s.indexOf('/') + 1));
        s = s.substr(0, s.indexOf('/'));
    }
    this.setDomain(s);
};

JID.prototype.toString = function() {
    var s = this.domain;
    if (this.user)
        s = this.user + '@' + s;
    if (this.resource)
        s = s + '/' + this.resource;
    return s;
};

/**
 * Convenience method to distinguish users
 **/
JID.prototype.bare = function() {
    if (this.resource)
        return new JID(this.user, this.domain, null);
    else
        return this;
};

/**
 * Comparison function
 **/
JID.prototype.equals = function(other) {
    return this.user == other.user &&
        this.domain == other.domain &&
        this.resource == other.resource;
};

/**
 * Setters that do stringprep normalization.
 **/
JID.prototype.setUser = function(user) {
    this.user = user && nodeprep(user);
};
/**
 * http://xmpp.org/rfcs/rfc6122.html#addressing-domain
 */
JID.prototype.setDomain = function(domain) {
    this.domain = domain &&
        nameprep(domain.split(".").
                 map(toUnicode).
                 join("."));
};
JID.prototype.setResource = function(resource) {
    this.resource = resource && resourceprep(resource);
};

if (typeof exports !== "undefined" && exports !== null) {
  exports.JID = JID;
} else if (typeof window !== "undefined" && window !== null) {
  window.JID = JID;
}

},{"node-stringprep":17}],18:[function(require,module,exports){
(function(){// UTILITY
var util = require('util');
var Buffer = require("buffer").Buffer;
var pSlice = Array.prototype.slice;

function objectKeys(object) {
  if (Object.keys) return Object.keys(object);
  var result = [];
  for (var name in object) {
    if (Object.prototype.hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.message = options.message;
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
};
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (value === undefined) {
    return '' + value;
  }
  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (typeof value === 'function' || value instanceof RegExp) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (typeof s == 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

assert.AssertionError.prototype.toString = function() {
  if (this.message) {
    return [this.name + ':', this.message].join(' ');
  } else {
    return [
      this.name + ':',
      truncate(JSON.stringify(this.actual, replacer), 128),
      this.operator,
      truncate(JSON.stringify(this.expected, replacer), 128)
    ].join(' ');
  }
};

// assert.AssertionError instanceof Error

assert.AssertionError.__proto__ = Error.prototype;

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!!!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (expected instanceof RegExp) {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail('Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail('Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

})()
},{"util":5,"buffer":12}],"browser-request":[function(require,module,exports){
module.exports=require('Rqhtau');
},{}],19:[function(require,module,exports){
require=(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error("Cannot find module '"+r+"'")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!=="undefined"&&require,{1:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],2:[function(require,module,exports){
(function(){// UTILITY
var util = require('util');
var Buffer = require("buffer").Buffer;
var pSlice = Array.prototype.slice;

function objectKeys(object) {
  if (Object.keys) return Object.keys(object);
  var result = [];
  for (var name in object) {
    if (Object.prototype.hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.message = options.message;
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
};
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (value === undefined) {
    return '' + value;
  }
  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (typeof value === 'function' || value instanceof RegExp) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (typeof s == 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

assert.AssertionError.prototype.toString = function() {
  if (this.message) {
    return [this.name + ':', this.message].join(' ');
  } else {
    return [
      this.name + ':',
      truncate(JSON.stringify(this.actual, replacer), 128),
      this.operator,
      truncate(JSON.stringify(this.expected, replacer), 128)
    ].join(' ');
  }
};

// assert.AssertionError instanceof Error

assert.AssertionError.__proto__ = Error.prototype;

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!!!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (expected instanceof RegExp) {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail('Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail('Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

})()
},{"util":3,"buffer":4}],"buffer-browserify":[function(require,module,exports){
module.exports=require('q9TxCC');
},{}],"q9TxCC":[function(require,module,exports){
(function(){function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.binaryWrite = SlowBuffer.prototype.asciiWrite;

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.binarySlice = SlowBuffer.prototype.asciiSlice;

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

SlowBuffer.prototype.fill = function(value, start, end) {
  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this.parent[i + this.offset] = subject.readUInt8(i);
        }
        else {
          this.parent[i + this.offset] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1];
    }
  } else {
    val = buffer.parent[buffer.offset + offset];
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer.parent[buffer.offset + offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

})()
},{"assert":2,"./buffer_ieee754":1,"base64-js":5}],3:[function(require,module,exports){
var events = require('events');

exports.isArray = isArray;
exports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};
exports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};


exports.print = function () {};
exports.puts = function () {};
exports.debug = function() {};

exports.inspect = function(obj, showHidden, depth, colors) {
  var seen = [];

  var stylize = function(str, styleType) {
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    var styles =
        { 'bold' : [1, 22],
          'italic' : [3, 23],
          'underline' : [4, 24],
          'inverse' : [7, 27],
          'white' : [37, 39],
          'grey' : [90, 39],
          'black' : [30, 39],
          'blue' : [34, 39],
          'cyan' : [36, 39],
          'green' : [32, 39],
          'magenta' : [35, 39],
          'red' : [31, 39],
          'yellow' : [33, 39] };

    var style =
        { 'special': 'cyan',
          'number': 'blue',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red' }[styleType];

    if (style) {
      return '\033[' + styles[style][0] + 'm' + str +
             '\033[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (! colors) {
    stylize = function(str, styleType) { return str; };
  }

  function format(value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' &&
        // Filter out the util module, it's inspect function is special
        value !== exports &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      return value.inspect(recurseTimes);
    }

    // Primitive types cannot have properties
    switch (typeof value) {
      case 'undefined':
        return stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return stylize(simple, 'string');

      case 'number':
        return stylize('' + value, 'number');

      case 'boolean':
        return stylize('' + value, 'boolean');
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
      return stylize('null', 'null');
    }

    // Look up the keys of the object.
    var visible_keys = Object_keys(value);
    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;

    // Functions without properties can be shortcutted.
    if (typeof value === 'function' && keys.length === 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        var name = value.name ? ': ' + value.name : '';
        return stylize('[Function' + name + ']', 'special');
      }
    }

    // Dates without properties can be shortcutted
    if (isDate(value) && keys.length === 0) {
      return stylize(value.toUTCString(), 'date');
    }

    var base, type, braces;
    // Determine the object type
    if (isArray(value)) {
      type = 'Array';
      braces = ['[', ']'];
    } else {
      type = 'Object';
      braces = ['{', '}'];
    }

    // Make functions say that they are functions
    if (typeof value === 'function') {
      var n = value.name ? ': ' + value.name : '';
      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
    } else {
      base = '';
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + value.toUTCString();
    }

    if (keys.length === 0) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        return stylize('[Object]', 'special');
      }
    }

    seen.push(value);

    var output = keys.map(function(key) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Getter/Setter]', 'special');
          } else {
            str = stylize('[Getter]', 'special');
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Setter]', 'special');
          }
        }
      }
      if (visible_keys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = format(value[key]);
          } else {
            str = format(value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (isArray(value)) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (type === 'Array' && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    });

    seen.pop();

    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.length + 1;
    }, 0);

    if (length > 50) {
      output = braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];

    } else {
      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    return output;
  }
  return format(obj, (typeof depth === 'undefined' ? 2 : depth));
};


function isArray(ar) {
  return ar instanceof Array ||
         Array.isArray(ar) ||
         (ar && ar !== Object.prototype && isArray(ar.__proto__));
}


function isRegExp(re) {
  return re instanceof RegExp ||
    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');
}


function isDate(d) {
  if (d instanceof Date) return true;
  if (typeof d !== 'object') return false;
  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);
  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);
  return JSON.stringify(proto) === JSON.stringify(properties);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

exports.log = function (msg) {};

exports.pump = null;

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

var Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
    var res = [];
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
};

var Object_create = Object.create || function (prototype, properties) {
    // from es5-shim
    var object;
    if (prototype === null) {
        object = { '__proto__' : null };
    }
    else {
        if (typeof prototype !== 'object') {
            throw new TypeError(
                'typeof prototype[' + (typeof prototype) + '] != \'object\''
            );
        }
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
        Object.defineProperties(object, properties);
    }
    return object;
};

exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object_create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (typeof f !== 'string') {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(exports.inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j': return JSON.stringify(args[i++]);
      default:
        return x;
    }
  });
  for(var x = args[i]; i < len; x = args[++i]){
    if (x === null || typeof x !== 'object') {
      str += ' ' + x;
    } else {
      str += ' ' + exports.inspect(x);
    }
  }
  return str;
};

},{"events":6}],5:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],7:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],8:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],6:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":8}],4:[function(require,module,exports){
(function(){function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        this.parent[i + this.offset] = subject[i];
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    val |= buffer.parent[buffer.offset + offset + 1];
  } else {
    val = buffer.parent[buffer.offset + offset];
    val |= buffer.parent[buffer.offset + offset + 1] << 8;
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset + 1] << 16;
    val |= buffer.parent[buffer.offset + offset + 2] << 8;
    val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    val = buffer.parent[buffer.offset + offset + 2] << 16;
    val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  buffer.parent[buffer.offset + offset] = value;
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  if (isBigEndian) {
    buffer.parent[buffer.offset + offset] = (value & 0xff00) >>> 8;
    buffer.parent[buffer.offset + offset + 1] = value & 0x00ff;
  } else {
    buffer.parent[buffer.offset + offset + 1] = (value & 0xff00) >>> 8;
    buffer.parent[buffer.offset + offset] = value & 0x00ff;
  }
}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  if (isBigEndian) {
    buffer.parent[buffer.offset + offset] = (value >>> 24) & 0xff;
    buffer.parent[buffer.offset + offset + 1] = (value >>> 16) & 0xff;
    buffer.parent[buffer.offset + offset + 2] = (value >>> 8) & 0xff;
    buffer.parent[buffer.offset + offset + 3] = value & 0xff;
  } else {
    buffer.parent[buffer.offset + offset + 3] = (value >>> 24) & 0xff;
    buffer.parent[buffer.offset + offset + 2] = (value >>> 16) & 0xff;
    buffer.parent[buffer.offset + offset + 1] = (value >>> 8) & 0xff;
    buffer.parent[buffer.offset + offset] = value & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

})()
},{"assert":2,"./buffer_ieee754":7,"base64-js":9}],9:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}]},{},[])
;;module.exports=require("buffer-browserify")

},{}],"Rqhtau":[function(require,module,exports){
(function(process,Buffer){// Copyright 2010-2012 Mikeal Rogers
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

var http = require('http')
  , https = false
  , tls = false
  , url = require('url')
  , util = require('util')
  , stream = require('stream')
  , qs = require('qs')
  , querystring = require('querystring')
  , crypto = require('crypto')

  , oauth = require('oauth-sign')
  , hawk = require('hawk')
  , aws = require('aws-sign')
  , httpSignature = require('http-signature')
  , uuid = require('node-uuid')
  , mime = require('mime')
  , tunnel = require('tunnel-agent')
  , safeStringify = require('json-stringify-safe')

  , ForeverAgent = require('forever-agent')
  , FormData = require('form-data')

  , Cookie = require('cookie-jar')
  , CookieJar = Cookie.Jar
  , cookieJar = new CookieJar
  ;

try {
  https = require('https')
} catch (e) {}

try {
  tls = require('tls')
} catch (e) {}

var debug
if (/\brequest\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    console.error('REQUEST %s', util.format.apply(util, arguments))
  }
} else {
  debug = function() {}
}

function toBase64 (str) {
  return (new Buffer(str || "", "ascii")).toString("base64")
}

function md5 (str) {
  return crypto.createHash('md5').update(str).digest('hex')
}

// Hacky fix for pre-0.4.4 https
if (https && !https.Agent) {
  https.Agent = function (options) {
    http.Agent.call(this, options)
  }
  util.inherits(https.Agent, http.Agent)
  https.Agent.prototype._getConnection = function (host, port, cb) {
    var s = tls.connect(port, host, this.options, function () {
      // do other checks here?
      if (cb) cb()
    })
    return s
  }
}

function isReadStream (rs) {
  if (rs.readable && rs.path && rs.mode) {
    return true
  }
}

function copy (obj) {
  var o = {}
  Object.keys(obj).forEach(function (i) {
    o[i] = obj[i]
  })
  return o
}

var isUrl = /^https?:/

var globalPool = {}

function Request (options) {
  stream.Stream.call(this)
  this.readable = true
  this.writable = true

  if (typeof options === 'string') {
    options = {uri:options}
  }

  var reserved = Object.keys(Request.prototype)
  for (var i in options) {
    if (reserved.indexOf(i) === -1) {
      this[i] = options[i]
    } else {
      if (typeof options[i] === 'function') {
        delete options[i]
      }
    }
  }

  if (options.method) {
    this.explicitMethod = true
  }

  this.init(options)
}
util.inherits(Request, stream.Stream)
Request.prototype.init = function (options) {
  // init() contains all the code to setup the request object.
  // the actual outgoing request is not started until start() is called
  // this function is called from both the constructor and on redirect.
  var self = this
  if (!options) options = {}

  if (!self.method) self.method = options.method || 'GET'
  self.localAddress = options.localAddress

  debug(options)
  if (!self.pool && self.pool !== false) self.pool = globalPool
  self.dests = self.dests || []
  self.__isRequestRequest = true

  // Protect against double callback
  if (!self._callback && self.callback) {
    self._callback = self.callback
    self.callback = function () {
      if (self._callbackCalled) return // Print a warning maybe?
      self._callbackCalled = true
      self._callback.apply(self, arguments)
    }
    self.on('error', self.callback.bind())
    self.on('complete', self.callback.bind(self, null))
  }

  if (self.url && !self.uri) {
    // People use this property instead all the time so why not just support it.
    self.uri = self.url
    delete self.url
  }

  if (!self.uri) {
    // this will throw if unhandled but is handleable when in a redirect
    return self.emit('error', new Error("options.uri is a required argument"))
  } else {
    if (typeof self.uri == "string") self.uri = url.parse(self.uri)
  }

  if (self.strictSSL === false) {
    self.rejectUnauthorized = false
  }

  if (self.proxy) {
    if (typeof self.proxy == 'string') self.proxy = url.parse(self.proxy)

    // do the HTTP CONNECT dance using koichik/node-tunnel
    if (http.globalAgent && self.uri.protocol === "https:") {
      var tunnelFn = self.proxy.protocol === "http:"
                   ? tunnel.httpsOverHttp : tunnel.httpsOverHttps

      var tunnelOptions = { proxy: { host: self.proxy.hostname
                                   , port: +self.proxy.port
                                   , proxyAuth: self.proxy.auth
                                   , headers: { Host: self.uri.hostname + ':' +
                                        (self.uri.port || self.uri.protocol === 'https:' ? 443 : 80) }}
                          , rejectUnauthorized: self.rejectUnauthorized
                          , ca: this.ca }

      self.agent = tunnelFn(tunnelOptions)
      self.tunnel = true
    }
  }

  if (!self.uri.host || !self.uri.pathname) {
    // Invalid URI: it may generate lot of bad errors, like "TypeError: Cannot call method 'indexOf' of undefined" in CookieJar
    // Detect and reject it as soon as possible
    var faultyUri = url.format(self.uri)
    var message = 'Invalid URI "' + faultyUri + '"'
    if (Object.keys(options).length === 0) {
      // No option ? This can be the sign of a redirect
      // As this is a case where the user cannot do anything (he didn't call request directly with this URL)
      // he should be warned that it can be caused by a redirection (can save some hair)
      message += '. This can be caused by a crappy redirection.'
    }
    self.emit('error', new Error(message))
    return // This error was fatal
  }

  self._redirectsFollowed = self._redirectsFollowed || 0
  self.maxRedirects = (self.maxRedirects !== undefined) ? self.maxRedirects : 10
  self.followRedirect = (self.followRedirect !== undefined) ? self.followRedirect : true
  self.followAllRedirects = (self.followAllRedirects !== undefined) ? self.followAllRedirects : false
  if (self.followRedirect || self.followAllRedirects)
    self.redirects = self.redirects || []

  self.headers = self.headers ? copy(self.headers) : {}

  self.setHost = false
  if (!(self.headers.host || self.headers.Host)) {
    self.headers.host = self.uri.hostname
    if (self.uri.port) {
      if ( !(self.uri.port === 80 && self.uri.protocol === 'http:') &&
           !(self.uri.port === 443 && self.uri.protocol === 'https:') )
      self.headers.host += (':'+self.uri.port)
    }
    self.setHost = true
  }

  self.jar(self._jar || options.jar)

  if (!self.uri.pathname) {self.uri.pathname = '/'}
  if (!self.uri.port) {
    if (self.uri.protocol == 'http:') {self.uri.port = 80}
    else if (self.uri.protocol == 'https:') {self.uri.port = 443}
  }

  if (self.proxy && !self.tunnel) {
    self.port = self.proxy.port
    self.host = self.proxy.hostname
  } else {
    self.port = self.uri.port
    self.host = self.uri.hostname
  }

  self.clientErrorHandler = function (error) {
    if (self._aborted) return

    if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET'
        && self.agent.addRequestNoreuse) {
      self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }
      self.start()
      self.req.end()
      return
    }
    if (self.timeout && self.timeoutTimer) {
      clearTimeout(self.timeoutTimer)
      self.timeoutTimer = null
    }
    self.emit('error', error)
  }

  self._parserErrorHandler = function (error) {
    if (this.res) {
      if (this.res.request) {
        this.res.request.emit('error', error)
      } else {
        this.res.emit('error', error)
      }
    } else {
      this._httpMessage.emit('error', error)
    }
  }

  if (options.form) {
    self.form(options.form)
  }

  if (options.qs) self.qs(options.qs)

  if (self.uri.path) {
    self.path = self.uri.path
  } else {
    self.path = self.uri.pathname + (self.uri.search || "")
  }

  if (self.path.length === 0) self.path = '/'


  // Auth must happen last in case signing is dependent on other headers
  if (options.oauth) {
    self.oauth(options.oauth)
  }

  if (options.aws) {
    self.aws(options.aws)
  }

  if (options.hawk) {
    self.hawk(options.hawk)
  }

  if (options.httpSignature) {
    self.httpSignature(options.httpSignature)
  }

  if (options.auth) {
    self.auth(
      (options.auth.user==="") ? options.auth.user : (options.auth.user || options.auth.username ),
      options.auth.pass || options.auth.password,
      options.auth.sendImmediately)
  }

  if (self.uri.auth && !self.headers.authorization) {
    var authPieces = self.uri.auth.split(':').map(function(item){ return querystring.unescape(item) })
    self.auth(authPieces[0], authPieces.slice(1).join(':'), true)
  }
  if (self.proxy && self.proxy.auth && !self.headers['proxy-authorization'] && !self.tunnel) {
    self.headers['proxy-authorization'] = "Basic " + toBase64(self.proxy.auth.split(':').map(function(item){ return querystring.unescape(item)}).join(':'))
  }


  if (self.proxy && !self.tunnel) self.path = (self.uri.protocol + '//' + self.uri.host + self.path)

  if (options.json) {
    self.json(options.json)
  } else if (options.multipart) {
    self.boundary = uuid()
    self.multipart(options.multipart)
  }

  if (self.body) {
    var length = 0
    if (!Buffer.isBuffer(self.body)) {
      if (Array.isArray(self.body)) {
        for (var i = 0; i < self.body.length; i++) {
          length += self.body[i].length
        }
      } else {
        self.body = new Buffer(self.body)
        length = self.body.length
      }
    } else {
      length = self.body.length
    }
    if (length) {
      if(!self.headers['content-length'] && !self.headers['Content-Length'])
      self.headers['content-length'] = length
    } else {
      throw new Error('Argument error, options.body.')
    }
  }

  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol
    , defaultModules = {'http:':http, 'https:':https}
    , httpModules = self.httpModules || {}
    ;
  self.httpModule = httpModules[protocol] || defaultModules[protocol]

  if (!self.httpModule) return this.emit('error', new Error("Invalid protocol"))

  if (options.ca) self.ca = options.ca

  if (!self.agent) {
    if (options.agentOptions) self.agentOptions = options.agentOptions

    if (options.agentClass) {
      self.agentClass = options.agentClass
    } else if (options.forever) {
      self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL
    } else {
      self.agentClass = self.httpModule.Agent
    }
  }

  if (self.pool === false) {
    self.agent = false
  } else {
    self.agent = self.agent || self.getAgent()
    if (self.maxSockets) {
      // Don't use our pooling if node has the refactored client
      self.agent.maxSockets = self.maxSockets
    }
    if (self.pool.maxSockets) {
      // Don't use our pooling if node has the refactored client
      self.agent.maxSockets = self.pool.maxSockets
    }
  }

  self.on('pipe', function (src) {
    if (self.ntick && self._started) throw new Error("You cannot pipe to this stream after the outbound request has started.")
    self.src = src
    if (isReadStream(src)) {
      if (!self.headers['content-type'] && !self.headers['Content-Type'])
        self.headers['content-type'] = mime.lookup(src.path)
    } else {
      if (src.headers) {
        for (var i in src.headers) {
          if (!self.headers[i]) {
            self.headers[i] = src.headers[i]
          }
        }
      }
      if (self._json && !self.headers['content-type'] && !self.headers['Content-Type'])
        self.headers['content-type'] = 'application/json'
      if (src.method && !self.explicitMethod) {
        self.method = src.method
      }
    }

    // self.on('pipe', function () {
    //   console.error("You have already piped to this stream. Pipeing twice is likely to break the request.")
    // })
  })

  process.nextTick(function () {
    if (self._aborted) return

    if (self._form) {
      self.setHeaders(self._form.getHeaders())
      self._form.pipe(self)
    }
    if (self.body) {
      if (Array.isArray(self.body)) {
        self.body.forEach(function (part) {
          self.write(part)
        })
      } else {
        self.write(self.body)
      }
      self.end()
    } else if (self.requestBodyStream) {
      console.warn("options.requestBodyStream is deprecated, please pass the request object to stream.pipe.")
      self.requestBodyStream.pipe(self)
    } else if (!self.src) {
      if (self.method !== 'GET' && typeof self.method !== 'undefined') {
        self.headers['content-length'] = 0
      }
      self.end()
    }
    self.ntick = true
  })
}

// Must call this when following a redirect from https to http or vice versa
// Attempts to keep everything as identical as possible, but update the
// httpModule, Tunneling agent, and/or Forever Agent in use.
Request.prototype._updateProtocol = function () {
  var self = this
  var protocol = self.uri.protocol

  if (protocol === 'https:') {
    // previously was doing http, now doing https
    // if it's https, then we might need to tunnel now.
    if (self.proxy) {
      self.tunnel = true
      var tunnelFn = self.proxy.protocol === 'http:'
                   ? tunnel.httpsOverHttp : tunnel.httpsOverHttps
      var tunnelOptions = { proxy: { host: self.proxy.hostname
                                   , port: +self.proxy.port
                                   , proxyAuth: self.proxy.auth }
                          , rejectUnauthorized: self.rejectUnauthorized
                          , ca: self.ca }
      self.agent = tunnelFn(tunnelOptions)
      return
    }

    self.httpModule = https
    switch (self.agentClass) {
      case ForeverAgent:
        self.agentClass = ForeverAgent.SSL
        break
      case http.Agent:
        self.agentClass = https.Agent
        break
      default:
        // nothing we can do.  Just hope for the best.
        return
    }

    // if there's an agent, we need to get a new one.
    if (self.agent) self.agent = self.getAgent()

  } else {
    // previously was doing https, now doing http
    // stop any tunneling.
    if (self.tunnel) self.tunnel = false
    self.httpModule = http
    switch (self.agentClass) {
      case ForeverAgent.SSL:
        self.agentClass = ForeverAgent
        break
      case https.Agent:
        self.agentClass = http.Agent
        break
      default:
        // nothing we can do.  just hope for the best
        return
    }

    // if there's an agent, then get a new one.
    if (self.agent) {
      self.agent = null
      self.agent = self.getAgent()
    }
  }
}

Request.prototype.getAgent = function () {
  var Agent = this.agentClass
  var options = {}
  if (this.agentOptions) {
    for (var i in this.agentOptions) {
      options[i] = this.agentOptions[i]
    }
  }
  if (this.ca) options.ca = this.ca
  if (typeof this.rejectUnauthorized !== 'undefined') options.rejectUnauthorized = this.rejectUnauthorized

  if (this.cert && this.key) {
    options.key = this.key
    options.cert = this.cert
  }

  var poolKey = ''

  // different types of agents are in different pools
  if (Agent !== this.httpModule.Agent) {
    poolKey += Agent.name
  }

  if (!this.httpModule.globalAgent) {
    // node 0.4.x
    options.host = this.host
    options.port = this.port
    if (poolKey) poolKey += ':'
    poolKey += this.host + ':' + this.port
  }

  // ca option is only relevant if proxy or destination are https
  var proxy = this.proxy
  if (typeof proxy === 'string') proxy = url.parse(proxy)
  var isHttps = (proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:'
  if (isHttps) {
    if (options.ca) {
      if (poolKey) poolKey += ':'
      poolKey += options.ca
    }

    if (typeof options.rejectUnauthorized !== 'undefined') {
      if (poolKey) poolKey += ':'
      poolKey += options.rejectUnauthorized
    }

    if (options.cert)
      poolKey += options.cert.toString('ascii') + options.key.toString('ascii')

    if (options.ciphers) {
      if (poolKey) poolKey += ':'
      poolKey += options.ciphers
    }

    if (options.secureOptions) {
      if (poolKey) poolKey += ':'
      poolKey += options.secureOptions
    }
  }

  if (!poolKey && Object.keys(options).length === 0 && this.httpModule.globalAgent) {
    // not doing anything special.  Use the globalAgent
    return this.httpModule.globalAgent
  }

  // we're using a stored agent.  Make sure it's protocol-specific
  poolKey = this.uri.protocol + poolKey

  // already generated an agent for this setting
  if (this.pool[poolKey]) return this.pool[poolKey]

  return this.pool[poolKey] = new Agent(options)
}

Request.prototype.start = function () {
  // start() is called once we are ready to send the outgoing HTTP request.
  // this is usually called on the first write(), end() or on nextTick()
  var self = this

  if (self._aborted) return

  self._started = true
  self.method = self.method || 'GET'
  self.href = self.uri.href

  if (self.src && self.src.stat && self.src.stat.size && !self.headers['content-length'] && !self.headers['Content-Length']) {
    self.headers['content-length'] = self.src.stat.size
  }
  if (self._aws) {
    self.aws(self._aws, true)
  }

  // We have a method named auth, which is completely different from the http.request
  // auth option.  If we don't remove it, we're gonna have a bad time.
  var reqOptions = copy(self)
  delete reqOptions.auth

  debug('make request', self.uri.href)
  self.req = self.httpModule.request(reqOptions, self.onResponse.bind(self))

  if (self.timeout && !self.timeoutTimer) {
    self.timeoutTimer = setTimeout(function () {
      self.req.abort()
      var e = new Error("ETIMEDOUT")
      e.code = "ETIMEDOUT"
      self.emit("error", e)
    }, self.timeout)

    // Set additional timeout on socket - in case if remote
    // server freeze after sending headers
    if (self.req.setTimeout) { // only works on node 0.6+
      self.req.setTimeout(self.timeout, function () {
        if (self.req) {
          self.req.abort()
          var e = new Error("ESOCKETTIMEDOUT")
          e.code = "ESOCKETTIMEDOUT"
          self.emit("error", e)
        }
      })
    }
  }

  self.req.on('error', self.clientErrorHandler)
  self.req.on('drain', function() {
    self.emit('drain')
  })
  self.on('end', function() {
    if ( self.req.connection ) self.req.connection.removeListener('error', self._parserErrorHandler)
  })
  self.emit('request', self.req)
}
Request.prototype.onResponse = function (response) {
  var self = this
  debug('onResponse', self.uri.href, response.statusCode, response.headers)
  response.on('end', function() {
    debug('response end', self.uri.href, response.statusCode, response.headers)
  });

  if (response.connection.listeners('error').indexOf(self._parserErrorHandler) === -1) {
    response.connection.once('error', self._parserErrorHandler)
  }
  if (self._aborted) {
    debug('aborted', self.uri.href)
    response.resume()
    return
  }
  if (self._paused) response.pause()
  else response.resume()

  self.response = response
  response.request = self
  response.toJSON = toJSON

  // XXX This is different on 0.10, because SSL is strict by default
  if (self.httpModule === https &&
      self.strictSSL &&
      !response.client.authorized) {
    debug('strict ssl error', self.uri.href)
    var sslErr = response.client.authorizationError
    self.emit('error', new Error('SSL Error: '+ sslErr))
    return
  }

  if (self.setHost) delete self.headers.host
  if (self.timeout && self.timeoutTimer) {
    clearTimeout(self.timeoutTimer)
    self.timeoutTimer = null
  }

  var addCookie = function (cookie) {
    if (self._jar) self._jar.add(new Cookie(cookie))
    else cookieJar.add(new Cookie(cookie))
  }

  if (response.headers['set-cookie'] && (!self._disableCookies)) {
    if (Array.isArray(response.headers['set-cookie'])) response.headers['set-cookie'].forEach(addCookie)
    else addCookie(response.headers['set-cookie'])
  }

  var redirectTo = null
  if (response.statusCode >= 300 && response.statusCode < 400 && response.headers.location) {
    debug('redirect', response.headers.location)

    if (self.followAllRedirects) {
      redirectTo = response.headers.location
    } else if (self.followRedirect) {
      switch (self.method) {
        case 'PATCH':
        case 'PUT':
        case 'POST':
        case 'DELETE':
          // Do not follow redirects
          break
        default:
          redirectTo = response.headers.location
          break
      }
    }
  } else if (response.statusCode == 401 && self._hasAuth && !self._sentAuth) {
    var authHeader = response.headers['www-authenticate']
    var authVerb = authHeader && authHeader.split(' ')[0]
    debug('reauth', authVerb)

    switch (authVerb) {
      case 'Basic':
        self.auth(self._user, self._pass, true)
        redirectTo = self.uri
        break

      case 'Digest':
        // TODO: More complete implementation of RFC 2617.  For reference:
        // http://tools.ietf.org/html/rfc2617#section-3
        // https://github.com/bagder/curl/blob/master/lib/http_digest.c

        var matches = authHeader.match(/([a-z0-9_-]+)="([^"]+)"/gi)
        var challenge = {}

        for (var i = 0; i < matches.length; i++) {
          var eqPos = matches[i].indexOf('=')
          var key = matches[i].substring(0, eqPos)
          var quotedValue = matches[i].substring(eqPos + 1)
          challenge[key] = quotedValue.substring(1, quotedValue.length - 1)
        }

        var ha1 = md5(self._user + ':' + challenge.realm + ':' + self._pass)
        var ha2 = md5(self.method + ':' + self.uri.path)
        var digestResponse = md5(ha1 + ':' + challenge.nonce + ':1::auth:' + ha2)
        var authValues = {
          username: self._user,
          realm: challenge.realm,
          nonce: challenge.nonce,
          uri: self.uri.path,
          qop: challenge.qop,
          response: digestResponse,
          nc: 1,
          cnonce: ''
        }

        authHeader = []
        for (var k in authValues) {
          authHeader.push(k + '="' + authValues[k] + '"')
        }
        authHeader = 'Digest ' + authHeader.join(', ')
        self.setHeader('authorization', authHeader)
        self._sentAuth = true

        redirectTo = self.uri
        break
    }
  }

  if (redirectTo) {
    debug('redirect to', redirectTo)

    // ignore any potential response body.  it cannot possibly be useful
    // to us at this point.
    if (self._paused) response.resume()

    if (self._redirectsFollowed >= self.maxRedirects) {
      self.emit('error', new Error("Exceeded maxRedirects. Probably stuck in a redirect loop "+self.uri.href))
      return
    }
    self._redirectsFollowed += 1

    if (!isUrl.test(redirectTo)) {
      redirectTo = url.resolve(self.uri.href, redirectTo)
    }

    var uriPrev = self.uri
    self.uri = url.parse(redirectTo)

    // handle the case where we change protocol from https to http or vice versa
    if (self.uri.protocol !== uriPrev.protocol) {
      self._updateProtocol()
    }

    self.redirects.push(
      { statusCode : response.statusCode
      , redirectUri: redirectTo
      }
    )
    if (self.followAllRedirects && response.statusCode != 401) self.method = 'GET'
    // self.method = 'GET' // Force all redirects to use GET || commented out fixes #215
    delete self.src
    delete self.req
    delete self.agent
    delete self._started
    if (response.statusCode != 401) {
      // Remove parameters from the previous response, unless this is the second request
      // for a server that requires digest authentication.
      delete self.body
      delete self._form
      if (self.headers) {
        delete self.headers.host
        delete self.headers['content-type']
        delete self.headers['content-length']
      }
    }

    self.emit('redirect');

    self.init()
    return // Ignore the rest of the response
  } else {
    self._redirectsFollowed = self._redirectsFollowed || 0
    // Be a good stream and emit end when the response is finished.
    // Hack to emit end on close because of a core bug that never fires end
    response.on('close', function () {
      if (!self._ended) self.response.emit('end')
    })

    if (self.encoding) {
      if (self.dests.length !== 0) {
        console.error("Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.")
      } else {
        response.setEncoding(self.encoding)
      }
    }

    self.emit('response', response)

    self.dests.forEach(function (dest) {
      self.pipeDest(dest)
    })

    response.on("data", function (chunk) {
      self._destdata = true
      self.emit("data", chunk)
    })
    response.on("end", function (chunk) {
      self._ended = true
      self.emit("end", chunk)
    })
    response.on("close", function () {self.emit("close")})

    if (self.callback) {
      var buffer = []
      var bodyLen = 0
      self.on("data", function (chunk) {
        buffer.push(chunk)
        bodyLen += chunk.length
      })
      self.on("end", function () {
        debug('end event', self.uri.href)
        if (self._aborted) {
          debug('aborted', self.uri.href)
          return
        }

        if (buffer.length && Buffer.isBuffer(buffer[0])) {
          debug('has body', self.uri.href, bodyLen)
          var body = new Buffer(bodyLen)
          var i = 0
          buffer.forEach(function (chunk) {
            chunk.copy(body, i, 0, chunk.length)
            i += chunk.length
          })
          if (self.encoding === null) {
            response.body = body
          } else {
            response.body = body.toString(self.encoding)
          }
        } else if (buffer.length) {
          // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.
          // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().
          if (self.encoding === 'utf8' && buffer[0].length > 0 && buffer[0][0] === "\uFEFF") {
            buffer[0] = buffer[0].substring(1)
          }
          response.body = buffer.join('')
        }

        if (self._json) {
          try {
            response.body = JSON.parse(response.body)
          } catch (e) {}
        }
        debug('emitting complete', self.uri.href)
        if(response.body == undefined && !self._json) {
          response.body = "";
        }
        self.emit('complete', response, response.body)
      })
    }
  }
  debug('finish init function', self.uri.href)
}

Request.prototype.abort = function () {
  this._aborted = true

  if (this.req) {
    this.req.abort()
  }
  else if (this.response) {
    this.response.abort()
  }

  this.emit("abort")
}

Request.prototype.pipeDest = function (dest) {
  var response = this.response
  // Called after the response is received
  if (dest.headers) {
    dest.headers['content-type'] = response.headers['content-type']
    if (response.headers['content-length']) {
      dest.headers['content-length'] = response.headers['content-length']
    }
  }
  if (dest.setHeader) {
    for (var i in response.headers) {
      dest.setHeader(i, response.headers[i])
    }
    dest.statusCode = response.statusCode
  }
  if (this.pipefilter) this.pipefilter(response, dest)
}

// Composable API
Request.prototype.setHeader = function (name, value, clobber) {
  if (clobber === undefined) clobber = true
  if (clobber || !this.headers.hasOwnProperty(name)) this.headers[name] = value
  else this.headers[name] += ',' + value
  return this
}
Request.prototype.setHeaders = function (headers) {
  for (var i in headers) {this.setHeader(i, headers[i])}
  return this
}
Request.prototype.qs = function (q, clobber) {
  var base
  if (!clobber && this.uri.query) base = qs.parse(this.uri.query)
  else base = {}

  for (var i in q) {
    base[i] = q[i]
  }

  if (qs.stringify(base) === ''){
    return this
  }

  this.uri = url.parse(this.uri.href.split('?')[0] + '?' + qs.stringify(base))
  this.url = this.uri
  this.path = this.uri.path

  return this
}
Request.prototype.form = function (form) {
  if (form) {
    this.headers['content-type'] = 'application/x-www-form-urlencoded; charset=utf-8'
    this.body = qs.stringify(form).toString('utf8')
    return this
  }
  // create form-data object
  this._form = new FormData()
  return this._form
}
Request.prototype.multipart = function (multipart) {
  var self = this
  self.body = []

  if (!self.headers['content-type']) {
    self.headers['content-type'] = 'multipart/related; boundary=' + self.boundary
  } else {
    self.headers['content-type'] = self.headers['content-type'].split(';')[0] + '; boundary=' + self.boundary
  }

  if (!multipart.forEach) throw new Error('Argument error, options.multipart.')

  if (self.preambleCRLF) {
    self.body.push(new Buffer('\r\n'))
  }

  multipart.forEach(function (part) {
    var body = part.body
    if(body == null) throw Error('Body attribute missing in multipart.')
    delete part.body
    var preamble = '--' + self.boundary + '\r\n'
    Object.keys(part).forEach(function (key) {
      preamble += key + ': ' + part[key] + '\r\n'
    })
    preamble += '\r\n'
    self.body.push(new Buffer(preamble))
    self.body.push(new Buffer(body))
    self.body.push(new Buffer('\r\n'))
  })
  self.body.push(new Buffer('--' + self.boundary + '--'))
  return self
}
Request.prototype.json = function (val) {
  var self = this;
  var setAcceptHeader = function() {
  	if (!self.headers['accept'] && !self.headers['Accept']) {
			  self.setHeader('accept', 'application/json')
		}
	}
  setAcceptHeader();
  this._json = true
  if (typeof val === 'boolean') {
    if (typeof this.body === 'object') {
      setAcceptHeader();
      this.body = safeStringify(this.body)
      self.setHeader('content-type', 'application/json')
    }
  } else {
    setAcceptHeader();
    this.body = safeStringify(val)
    self.setHeader('content-type', 'application/json')
  }
  return this
}
function getHeader(name, headers) {
    var result, re, match
    Object.keys(headers).forEach(function (key) {
        re = new RegExp(name, 'i')
        match = key.match(re)
        if (match) result = headers[key]
    })
    return result
}
Request.prototype.auth = function (user, pass, sendImmediately) {
  if (typeof user !== 'string' || (pass !== undefined && typeof pass !== 'string')) {
    throw new Error('auth() received invalid user or password')
  }
  this._user = user
  this._pass = pass
  this._hasAuth = true
  if (sendImmediately || typeof sendImmediately == 'undefined') {
    this.setHeader('authorization', 'Basic ' + toBase64(user + ':' + pass))
    this._sentAuth = true
  }
  return this
}
Request.prototype.aws = function (opts, now) {
  if (!now) {
    this._aws = opts
    return this
  }
  var date = new Date()
  this.setHeader('date', date.toUTCString())
  var auth =
    { key: opts.key
    , secret: opts.secret
    , verb: this.method.toUpperCase()
    , date: date
    , contentType: getHeader('content-type', this.headers) || ''
    , md5: getHeader('content-md5', this.headers) || ''
    , amazonHeaders: aws.canonicalizeHeaders(this.headers)
    }
  if (opts.bucket && this.path) {
    auth.resource = '/' + opts.bucket + this.path
  } else if (opts.bucket && !this.path) {
    auth.resource = '/' + opts.bucket
  } else if (!opts.bucket && this.path) {
    auth.resource = this.path
  } else if (!opts.bucket && !this.path) {
    auth.resource = '/'
  }
  auth.resource = aws.canonicalizeResource(auth.resource)
  this.setHeader('authorization', aws.authorization(auth))

  return this
}
Request.prototype.httpSignature = function (opts) {
  var req = this
  httpSignature.signRequest({
    getHeader: function(header) {
      return getHeader(header, req.headers)
    },
    setHeader: function(header, value) {
      req.setHeader(header, value)
    },
    method: this.method,
    path: this.path
  }, opts)
  debug('httpSignature authorization', getHeader('authorization', this.headers))

  return this
}

Request.prototype.hawk = function (opts) {
  this.headers.Authorization = hawk.client.header(this.uri, this.method, opts).field
}

Request.prototype.oauth = function (_oauth) {
  var form
  if (this.headers['content-type'] &&
      this.headers['content-type'].slice(0, 'application/x-www-form-urlencoded'.length) ===
        'application/x-www-form-urlencoded'
     ) {
    form = qs.parse(this.body)
  }
  if (this.uri.query) {
    form = qs.parse(this.uri.query)
  }
  if (!form) form = {}
  var oa = {}
  for (var i in form) oa[i] = form[i]
  for (var i in _oauth) oa['oauth_'+i] = _oauth[i]
  if (!oa.oauth_version) oa.oauth_version = '1.0'
  if (!oa.oauth_timestamp) oa.oauth_timestamp = Math.floor( Date.now() / 1000 ).toString()
  if (!oa.oauth_nonce) oa.oauth_nonce = uuid().replace(/-/g, '')

  oa.oauth_signature_method = 'HMAC-SHA1'

  var consumer_secret = oa.oauth_consumer_secret
  delete oa.oauth_consumer_secret
  var token_secret = oa.oauth_token_secret
  delete oa.oauth_token_secret
  var timestamp = oa.oauth_timestamp

  var baseurl = this.uri.protocol + '//' + this.uri.host + this.uri.pathname
  var signature = oauth.hmacsign(this.method, baseurl, oa, consumer_secret, token_secret)

  // oa.oauth_signature = signature
  for (var i in form) {
    if ( i.slice(0, 'oauth_') in _oauth) {
      // skip
    } else {
      delete oa['oauth_'+i]
      if (i !== 'x_auth_mode') delete oa[i]
    }
  }
  oa.oauth_timestamp = timestamp
  this.headers.Authorization =
    'OAuth '+Object.keys(oa).sort().map(function (i) {return i+'="'+oauth.rfc3986(oa[i])+'"'}).join(',')
  this.headers.Authorization += ',oauth_signature="' + oauth.rfc3986(signature) + '"'
  return this
}
Request.prototype.jar = function (jar) {
  var cookies

  if (this._redirectsFollowed === 0) {
    this.originalCookieHeader = this.headers.cookie
  }

  if (jar === false) {
    // disable cookies
    cookies = false
    this._disableCookies = true
  } else if (jar) {
    // fetch cookie from the user defined cookie jar
    cookies = jar.get({ url: this.uri.href })
  } else {
    // fetch cookie from the global cookie jar
    cookies = cookieJar.get({ url: this.uri.href })
  }

  if (cookies && cookies.length) {
    var cookieString = cookies.map(function (c) {
      return c.name + "=" + c.value
    }).join("; ")

    if (this.originalCookieHeader) {
      // Don't overwrite existing Cookie header
      this.headers.cookie = this.originalCookieHeader + '; ' + cookieString
    } else {
      this.headers.cookie = cookieString
    }
  }
  this._jar = jar
  return this
}


// Stream API
Request.prototype.pipe = function (dest, opts) {
  if (this.response) {
    if (this._destdata) {
      throw new Error("You cannot pipe after data has been emitted from the response.")
    } else if (this._ended) {
      throw new Error("You cannot pipe after the response has been ended.")
    } else {
      stream.Stream.prototype.pipe.call(this, dest, opts)
      this.pipeDest(dest)
      return dest
    }
  } else {
    this.dests.push(dest)
    stream.Stream.prototype.pipe.call(this, dest, opts)
    return dest
  }
}
Request.prototype.write = function () {
  if (!this._started) this.start()
  return this.req.write.apply(this.req, arguments)
}
Request.prototype.end = function (chunk) {
  if (chunk) this.write(chunk)
  if (!this._started) this.start()
  this.req.end()
}
Request.prototype.pause = function () {
  if (!this.response) this._paused = true
  else this.response.pause.apply(this.response, arguments)
}
Request.prototype.resume = function () {
  if (!this.response) this._paused = false
  else this.response.resume.apply(this.response, arguments)
}
Request.prototype.destroy = function () {
  if (!this._ended) this.end()
  else if (this.response) this.response.destroy()
}

// organize params for patch, post, put, head, del
function initParams(uri, options, callback) {
  if ((typeof options === 'function') && !callback) callback = options
  if (options && typeof options === 'object') {
    options.uri = uri
  } else if (typeof uri === 'string') {
    options = {uri:uri}
  } else {
    options = uri
    uri = options.uri
  }
  return { uri: uri, options: options, callback: callback }
}

function request (uri, options, callback) {
  if (typeof uri === 'undefined') throw new Error('undefined is not a valid uri or options object.')
  if ((typeof options === 'function') && !callback) callback = options
  if (options && typeof options === 'object') {
    options.uri = uri
  } else if (typeof uri === 'string') {
    options = {uri:uri}
  } else {
    options = uri
  }

  options = copy(options)

  if (callback) options.callback = callback
  var r = new Request(options)
  return r
}

module.exports = request

request.Request = Request;

request.debug = process.env.NODE_DEBUG && /request/.test(process.env.NODE_DEBUG)

request.initParams = initParams

request.defaults = function (options, requester) {
  var def = function (method) {
    var d = function (uri, opts, callback) {
      var params = initParams(uri, opts, callback)
      for (var i in options) {
        if (params.options[i] === undefined) params.options[i] = options[i]
      }
      if(typeof requester === 'function') {
        if(method === request) {
          method = requester
        } else {
          params.options._requester = requester
        }
      }
      return method(params.options, params.callback)
    }
    return d
  }
  var de = def(request)
  de.get = def(request.get)
  de.patch = def(request.patch)
  de.post = def(request.post)
  de.put = def(request.put)
  de.head = def(request.head)
  de.del = def(request.del)
  de.cookie = def(request.cookie)
  de.jar = request.jar
  return de
}

request.forever = function (agentOptions, optionsArg) {
  var options = {}
  if (optionsArg) {
    for (option in optionsArg) {
      options[option] = optionsArg[option]
    }
  }
  if (agentOptions) options.agentOptions = agentOptions
  options.forever = true
  return request.defaults(options)
}

request.get = request
request.post = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.options.method = 'POST'
  return request(params.uri || null, params.options, params.callback)
}
request.put = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.options.method = 'PUT'
  return request(params.uri || null, params.options, params.callback)
}
request.patch = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.options.method = 'PATCH'
  return request(params.uri || null, params.options, params.callback)
}
request.head = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.options.method = 'HEAD'
  if (params.options.body ||
      params.options.requestBodyStream ||
      (params.options.json && typeof params.options.json !== 'boolean') ||
      params.options.multipart) {
    throw new Error("HTTP HEAD requests MUST NOT include a request body.")
  }
  return request(params.uri || null, params.options, params.callback)
}
request.del = function (uri, options, callback) {
  var params = initParams(uri, options, callback)
  params.options.method = 'DELETE'
  if(typeof params.options._requester === 'function') {
    request = params.options._requester
  }
  return request(params.uri || null, params.options, params.callback)
}
request.jar = function () {
  return new CookieJar
}
request.cookie = function (str) {
  if (str && str.uri) str = str.uri
  if (typeof str !== 'string') throw new Error("The cookie function only accepts STRING as param")
  return new Cookie(str)
}

// Safe toJSON

function getSafe (self, uuid) {
  if (typeof self === 'object' || typeof self === 'function') var safe = {}
  if (Array.isArray(self)) var safe = []

  var recurse = []

  Object.defineProperty(self, uuid, {})

  var attrs = Object.keys(self).filter(function (i) {
    if (i === uuid) return false
    if ( (typeof self[i] !== 'object' && typeof self[i] !== 'function') || self[i] === null) return true
    return !(Object.getOwnPropertyDescriptor(self[i], uuid))
  })


  for (var i=0;i<attrs.length;i++) {
    if ( (typeof self[attrs[i]] !== 'object' && typeof self[attrs[i]] !== 'function') ||
          self[attrs[i]] === null
        ) {
      safe[attrs[i]] = self[attrs[i]]
    } else {
      recurse.push(attrs[i])
      Object.defineProperty(self[attrs[i]], uuid, {})
    }
  }

  for (var i=0;i<recurse.length;i++) {
    safe[recurse[i]] = getSafe(self[recurse[i]], uuid)
  }

  return safe
}

function toJSON () {
  return getSafe(this, '__' + (((1+Math.random())*0x10000)|0).toString(16))
}

Request.prototype.toJSON = toJSON

})(require("__browserify_process"),require("__browserify_buffer").Buffer)
},{"http":7,"url":1,"util":5,"stream":3,"querystring":2,"crypto":11,"https":6,"tls":8,"oauth-sign":20,"aws-sign":21,"http-signature":22,"mime":23,"node-uuid":24,"tunnel-agent":25,"forever-agent":26,"json-stringify-safe":27,"cookie-jar":28,"qs":29,"hawk":30,"form-data":31,"__browserify_process":9,"__browserify_buffer":19}],13:[function(require,module,exports){
// Original code adapted from Robert Kieffer.
// details at https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  var mathRNG, whatwgRNG;

  // NOTE: Math.random() does not guarantee "cryptographic quality"
  mathRNG = function(size) {
    var bytes = new Array(size);
    var r;

    for (var i = 0, r; i < size; i++) {
      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return bytes;
  }

  // currently only available in webkit-based browsers.
  if (_global.crypto && crypto.getRandomValues) {
    var _rnds = new Uint32Array(4);
    whatwgRNG = function(size) {
      var bytes = new Array(size);
      crypto.getRandomValues(_rnds);

      for (var c = 0 ; c < size; c++) {
        bytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;
      }
      return bytes;
    }
  }

  module.exports = whatwgRNG || mathRNG;

}())
},{}],14:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

exports.hex_sha1 = hex_sha1;
exports.b64_sha1 = b64_sha1;
exports.str_sha1 = str_sha1;
exports.hex_hmac_sha1 = hex_hmac_sha1;
exports.b64_hmac_sha1 = b64_hmac_sha1;
exports.str_hmac_sha1 = str_hmac_sha1;

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1("abc") == "a9993e364706816aba3e25717850c26c9cd0d89d";
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters >255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < str.length * chrsz; i += chrsz)
    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = "";
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)
                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )
                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
    }
  }
  return str;
}


},{}],15:[function(require,module,exports){
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;   /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = "";  /* base-64 pad character. "=" for strict RFC compliance   */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_md5(s)    { return rstr2hex(rstr_md5(str2rstr_utf8(s))); }
function b64_md5(s)    { return rstr2b64(rstr_md5(str2rstr_utf8(s))); }
function any_md5(s, e) { return rstr2any(rstr_md5(str2rstr_utf8(s)), e); }
function hex_hmac_md5(k, d)
  { return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function b64_hmac_md5(k, d)
  { return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function any_hmac_md5(k, d, e)
  { return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc").toLowerCase() == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of a raw string
 */
function rstr_md5(s)
{
  return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
}

/*
 * Calculate the HMAC-MD5, of a key and some data (raw strings)
 */
function rstr_hmac_md5(key, data)
{
  var bkey = rstr2binl(key);
  if(bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input)
{
  try { hexcase } catch(e) { hexcase=0; }
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var output = "";
  var x;
  for(var i = 0; i < input.length; i++)
  {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0F)
           +  hex_tab.charAt( x        & 0x0F);
  }
  return output;
}

/*
 * Convert a raw string to a base-64 string
 */
function rstr2b64(input)
{
  try { b64pad } catch(e) { b64pad=''; }
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var output = "";
  var len = input.length;
  for(var i = 0; i < len; i += 3)
  {
    var triplet = (input.charCodeAt(i) << 16)
                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > input.length * 8) output += b64pad;
      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);
    }
  }
  return output;
}

/*
 * Convert a raw string to an arbitrary string encoding
 */
function rstr2any(input, encoding)
{
  var divisor = encoding.length;
  var i, j, q, x, quotient;

  /* Convert to an array of 16-bit big-endian values, forming the dividend */
  var dividend = Array(Math.ceil(input.length / 2));
  for(i = 0; i < dividend.length; i++)
  {
    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
  }

  /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. All remainders are stored for later
   * use.
   */
  var full_length = Math.ceil(input.length * 8 /
                                    (Math.log(encoding.length) / Math.log(2)));
  var remainders = Array(full_length);
  for(j = 0; j < full_length; j++)
  {
    quotient = Array();
    x = 0;
    for(i = 0; i < dividend.length; i++)
    {
      x = (x << 16) + dividend[i];
      q = Math.floor(x / divisor);
      x -= q * divisor;
      if(quotient.length > 0 || q > 0)
        quotient[quotient.length] = q;
    }
    remainders[j] = x;
    dividend = quotient;
  }

  /* Convert the remainders to the output string */
  var output = "";
  for(i = remainders.length - 1; i >= 0; i--)
    output += encoding.charAt(remainders[i]);

  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while(++i < input.length)
  {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if(x <= 0x7F)
      output += String.fromCharCode(x);
    else if(x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
}

/*
 * Encode a string as utf-16
 */
function str2rstr_utf16le(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
                                  (input.charCodeAt(i) >>> 8) & 0xFF);
  return output;
}

function str2rstr_utf16be(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                                   input.charCodeAt(i)        & 0xFF);
  return output;
}

/*
 * Convert a raw string to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binl(input)
{
  var output = Array(input.length >> 2);
  for(var i = 0; i < output.length; i++)
    output[i] = 0;
  for(var i = 0; i < input.length * 8; i += 8)
    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (i%32);
  return output;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2rstr(input)
{
  var output = "";
  for(var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i>>5] >>> (i % 32)) & 0xFF);
  return output;
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */
function binl_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}


exports.hex_md5 = hex_md5;
exports.b64_md5 = b64_md5;
exports.any_md5 = any_md5;

},{}],32:[function(require,module,exports){
// todo

},{}],17:[function(require,module,exports){

},{}],20:[function(require,module,exports){
var crypto = require('crypto')
  , qs = require('querystring')
  ;

function sha1 (key, body) {
  return crypto.createHmac('sha1', key).update(body).digest('base64')
}

function rfc3986 (str) {
  return encodeURIComponent(str)
    .replace(/!/g,'%21')
    .replace(/\*/g,'%2A')
    .replace(/\(/g,'%28')
    .replace(/\)/g,'%29')
    .replace(/'/g,'%27')
    ;
}

function hmacsign (httpMethod, base_uri, params, consumer_secret, token_secret) {
  // adapted from https://dev.twitter.com/docs/auth/oauth and 
  // https://dev.twitter.com/docs/auth/creating-signature

  var querystring = Object.keys(params).sort().map(function(key){
    // big WTF here with the escape + encoding but it's what twitter wants
    return escape(rfc3986(key)) + "%3D" + escape(rfc3986(params[key]))
  }).join('%26')

  var base = [
    httpMethod ? httpMethod.toUpperCase() : 'GET',
    rfc3986(base_uri),
    querystring
  ].join('&')

  var key = [
    consumer_secret,
    token_secret || ''
  ].map(rfc3986).join('&')

  return sha1(key, base)
}

exports.hmacsign = hmacsign
exports.rfc3986 = rfc3986

},{"crypto":11,"querystring":2}],21:[function(require,module,exports){

/*!
 * knox - auth
 * Copyright(c) 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var crypto = require('crypto')
  , parse = require('url').parse
  ;

/**
 * Valid keys.
 */

var keys = 
  [ 'acl'
  , 'location'
  , 'logging'
  , 'notification'
  , 'partNumber'
  , 'policy'
  , 'requestPayment'
  , 'torrent'
  , 'uploadId'
  , 'uploads'
  , 'versionId'
  , 'versioning'
  , 'versions'
  , 'website'
  ]

/**
 * Return an "Authorization" header value with the given `options`
 * in the form of "AWS <key>:<signature>"
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function authorization (options) {
  return 'AWS ' + options.key + ':' + sign(options)
}

module.exports = authorization
module.exports.authorization = authorization

/**
 * Simple HMAC-SHA1 Wrapper
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */ 

function hmacSha1 (options) {
  return crypto.createHmac('sha1', options.secret).update(options.message).digest('base64')
}

module.exports.hmacSha1 = hmacSha1

/**
 * Create a base64 sha1 HMAC for `options`. 
 * 
 * @param {Object} options
 * @return {String}
 * @api private
 */

function sign (options) {
  options.message = stringToSign(options)
  return hmacSha1(options)
}
module.exports.sign = sign

/**
 * Create a base64 sha1 HMAC for `options`. 
 *
 * Specifically to be used with S3 presigned URLs
 * 
 * @param {Object} options
 * @return {String}
 * @api private
 */

function signQuery (options) {
  options.message = queryStringToSign(options)
  return hmacSha1(options)
}
module.exports.signQuery= signQuery

/**
 * Return a string for sign() with the given `options`.
 *
 * Spec:
 * 
 *    <verb>\n
 *    <md5>\n
 *    <content-type>\n
 *    <date>\n
 *    [headers\n]
 *    <resource>
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function stringToSign (options) {
  var headers = options.amazonHeaders || ''
  if (headers) headers += '\n'
  var r = 
    [ options.verb
    , options.md5
    , options.contentType
    , options.date.toUTCString()
    , headers + options.resource
    ]
  return r.join('\n')
}
module.exports.queryStringToSign = stringToSign

/**
 * Return a string for sign() with the given `options`, but is meant exclusively
 * for S3 presigned URLs
 *
 * Spec:
 * 
 *    <date>\n
 *    <resource>
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function queryStringToSign (options){
  return 'GET\n\n\n' + options.date + '\n' + options.resource
}
module.exports.queryStringToSign = queryStringToSign

/**
 * Perform the following:
 *
 *  - ignore non-amazon headers
 *  - lowercase fields
 *  - sort lexicographically
 *  - trim whitespace between ":"
 *  - join with newline
 *
 * @param {Object} headers
 * @return {String}
 * @api private
 */

function canonicalizeHeaders (headers) {
  var buf = []
    , fields = Object.keys(headers)
    ;
  for (var i = 0, len = fields.length; i < len; ++i) {
    var field = fields[i]
      , val = headers[field]
      , field = field.toLowerCase()
      ;
    if (0 !== field.indexOf('x-amz')) continue
    buf.push(field + ':' + val)
  }
  return buf.sort().join('\n')
}
module.exports.canonicalizeHeaders = canonicalizeHeaders

/**
 * Perform the following:
 *
 *  - ignore non sub-resources
 *  - sort lexicographically
 *
 * @param {String} resource
 * @return {String}
 * @api private
 */

function canonicalizeResource (resource) {
  var url = parse(resource, true)
    , path = url.pathname
    , buf = []
    ;

  Object.keys(url.query).forEach(function(key){
    if (!~keys.indexOf(key)) return
    var val = '' == url.query[key] ? '' : '=' + encodeURIComponent(url.query[key])
    buf.push(key + val)
  })

  return path + (buf.length ? '?' + buf.sort().join('&') : '')
}
module.exports.canonicalizeResource = canonicalizeResource

},{"crypto":11,"url":1}],23:[function(require,module,exports){
(function(process,__dirname){var path = require('path');
var fs = require('fs');

function Mime() {
  // Map of extension -> mime type
  this.types = Object.create(null);

  // Map of mime type -> extension
  this.extensions = Object.create(null);
}

/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * @param map (Object) type definitions
 */
Mime.prototype.define = function (map) {
  for (var type in map) {
    var exts = map[type];

    for (var i = 0; i < exts.length; i++) {
      if (process.env.DEBUG_MIME && this.types[exts]) {
        console.warn(this._loading.replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' +
          this.types[exts] + ' to ' + type);
      }

      this.types[exts[i]] = type;
    }

    // Default extension is the first one we encounter
    if (!this.extensions[type]) {
      this.extensions[type] = exts[0];
    }
  }
};

/**
 * Load an Apache2-style ".types" file
 *
 * This may be called multiple times (it's expected).  Where files declare
 * overlapping types/extensions, the last file wins.
 *
 * @param file (String) path of file to load.
 */
Mime.prototype.load = function(file) {

  this._loading = file;
  // Read file and split into lines
  var map = {},
      content = fs.readFileSync(file, 'ascii'),
      lines = content.split(/[\r\n]+/);

  lines.forEach(function(line) {
    // Clean up whitespace/comments, and split into fields
    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
    map[fields.shift()] = fields;
  });

  this.define(map);

  this._loading = null;
};

/**
 * Lookup a mime type based on extension
 */
Mime.prototype.lookup = function(path, fallback) {
  var ext = path.replace(/.*[\.\/]/, '').toLowerCase();

  return this.types[ext] || fallback || this.default_type;
};

/**
 * Return file extension associated with a mime type
 */
Mime.prototype.extension = function(mimeType) {
  return this.extensions[mimeType];
};

// Default instance
var mime = new Mime();

// Load local copy of
// http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types
mime.load(path.join(__dirname, 'types/mime.types'));

// Load additional types from node.js community
mime.load(path.join(__dirname, 'types/node.types'));

// Default type
mime.default_type = mime.lookup('bin');

//
// Additional API specific to the default instance
//

mime.Mime = Mime;

/**
 * Lookup a charset based on mime type.
 */
mime.charsets = {
  lookup: function(mimeType, fallback) {
    // Assume text types are utf8
    return (/^text\//).test(mimeType) ? 'UTF-8' : fallback;
  }
};

module.exports = mime;

})(require("__browserify_process"),"/request/node_modules/mime")
},{"path":33,"fs":34,"__browserify_process":9}],24:[function(require,module,exports){
(function(Buffer){//     uuid.js
//
//     (c) 2010-2012 Robert Kieffer
//     MIT License
//     https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng;

  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
  //
  // Moderately fast, high quality
  if (typeof(require) == 'function') {
    try {
      var _rb = require('crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    //
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  // Buffer class to use
  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (_global.define && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});
  } else if (typeof(module) != 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else {
    // Publish as global (in browsers)
    var _previousRoot = _global.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}());

})(require("__browserify_buffer").Buffer)
},{"crypto":11,"__browserify_buffer":19}],25:[function(require,module,exports){
(function(process,Buffer){'use strict'

var net = require('net')
  , tls = require('tls')
  , http = require('http')
  , https = require('https')
  , events = require('events')
  , assert = require('assert')
  , util = require('util')
  ;

exports.httpOverHttp = httpOverHttp
exports.httpsOverHttp = httpsOverHttp
exports.httpOverHttps = httpOverHttps
exports.httpsOverHttps = httpsOverHttps


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options)
  agent.request = http.request
  return agent
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options)
  agent.request = http.request
  agent.createSocket = createSecureSocket
  return agent
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options)
  agent.request = https.request
  return agent
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options)
  agent.request = https.request
  agent.createSocket = createSecureSocket
  return agent
}


function TunnelingAgent(options) {
  var self = this
  self.options = options || {}
  self.proxyOptions = self.options.proxy || {}
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets
  self.requests = []
  self.sockets = []

  self.on('free', function onFree(socket, host, port) {
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i]
      if (pending.host === host && pending.port === port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1)
        pending.request.onSocket(socket)
        return
      }
    }
    socket.destroy()
    self.removeSocket(socket)
  })
}
util.inherits(TunnelingAgent, events.EventEmitter)

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port) {
  var self = this

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push({host: host, port: port, request: req})
    return
  }

  // If we are under maxSockets create a new one.
  self.createSocket({host: host, port: port, request: req}, function(socket) {
    socket.on('free', onFree)
    socket.on('close', onCloseOrRemove)
    socket.on('agentRemove', onCloseOrRemove)
    req.onSocket(socket)

    function onFree() {
      self.emit('free', socket, host, port)
    }

    function onCloseOrRemove(err) {
      self.removeSocket()
      socket.removeListener('free', onFree)
      socket.removeListener('close', onCloseOrRemove)
      socket.removeListener('agentRemove', onCloseOrRemove)
    }
  })
}

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this
  var placeholder = {}
  self.sockets.push(placeholder)

  var connectOptions = mergeOptions({}, self.proxyOptions, 
    { method: 'CONNECT'
    , path: options.host + ':' + options.port
    , agent: false
    }
  )
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {}
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64')
  }

  debug('making CONNECT request')
  var connectReq = self.request(connectOptions)
  connectReq.useChunkedEncodingByDefault = false // for v0.6
  connectReq.once('response', onResponse) // for v0.6
  connectReq.once('upgrade', onUpgrade)   // for v0.6
  connectReq.once('connect', onConnect)   // for v0.7 or later
  connectReq.once('error', onError)
  connectReq.end()

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head)
    })
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners()
    socket.removeAllListeners()

    if (res.statusCode === 200) {
      assert.equal(head.length, 0)
      debug('tunneling connection has established')
      self.sockets[self.sockets.indexOf(placeholder)] = socket
      cb(socket)
    } else {
      debug('tunneling socket could not be established, statusCode=%d', res.statusCode)
      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode)
      error.code = 'ECONNRESET'
      options.request.emit('error', error)
      self.removeSocket(placeholder)
    }
  }

  function onError(cause) {
    connectReq.removeAllListeners()

    debug('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack)
    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message)
    error.code = 'ECONNRESET'
    options.request.emit('error', error)
    self.removeSocket(placeholder)
  }
}

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) return
  
  this.sockets.splice(pos, 1)

  var pending = this.requests.shift()
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket)
    })
  }
}

function createSecureSocket(options, cb) {
  var self = this
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, mergeOptions({}, self.options, 
      { servername: options.host
      , socket: socket
      }
    ))
    cb(secureSocket)
  })
}


function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i]
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides)
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j]
        if (overrides[k] !== undefined) {
          target[k] = overrides[k]
        }
      }
    }
  }
  return target
}


var debug
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments)
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0]
    } else {
      args.unshift('TUNNEL:')
    }
    console.error.apply(console, args)
  }
} else {
  debug = function() {}
}
exports.debug = debug // for test

})(require("__browserify_process"),require("__browserify_buffer").Buffer)
},{"net":32,"tls":8,"http":7,"https":6,"events":4,"assert":18,"util":5,"__browserify_process":9,"__browserify_buffer":19}],26:[function(require,module,exports){
module.exports = ForeverAgent
ForeverAgent.SSL = ForeverAgentSSL

var util = require('util')
  , Agent = require('http').Agent
  , net = require('net')
  , tls = require('tls')
  , AgentSSL = require('https').Agent

function ForeverAgent(options) {
  var self = this
  self.options = options || {}
  self.requests = {}
  self.sockets = {}
  self.freeSockets = {}
  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets
  self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets
  self.on('free', function(socket, host, port) {
    var name = host + ':' + port
    if (self.requests[name] && self.requests[name].length) {
      self.requests[name].shift().onSocket(socket)
    } else if (self.sockets[name].length < self.minSockets) {
      if (!self.freeSockets[name]) self.freeSockets[name] = []
      self.freeSockets[name].push(socket)
      
      // if an error happens while we don't use the socket anyway, meh, throw the socket away
      function onIdleError() {
        socket.destroy()
      }
      socket._onIdleError = onIdleError
      socket.on('error', onIdleError)
    } else {
      // If there are no pending requests just destroy the
      // socket and it will get removed from the pool. This
      // gets us out of timeout issues and allows us to
      // default to Connection:keep-alive.
      socket.destroy()
    }
  })

}
util.inherits(ForeverAgent, Agent)

ForeverAgent.defaultMinSockets = 5


ForeverAgent.prototype.createConnection = net.createConnection
ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest
ForeverAgent.prototype.addRequest = function(req, host, port) {
  var name = host + ':' + port
  if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
    var idleSocket = this.freeSockets[name].pop()
    idleSocket.removeListener('error', idleSocket._onIdleError)
    delete idleSocket._onIdleError
    req._reusedSocket = true
    req.onSocket(idleSocket)
  } else {
    this.addRequestNoreuse(req, host, port)
  }
}

ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
  if (this.sockets[name]) {
    var index = this.sockets[name].indexOf(s)
    if (index !== -1) {
      this.sockets[name].splice(index, 1)
    }
  } else if (this.sockets[name] && this.sockets[name].length === 0) {
    // don't leak
    delete this.sockets[name]
    delete this.requests[name]
  }
  
  if (this.freeSockets[name]) {
    var index = this.freeSockets[name].indexOf(s)
    if (index !== -1) {
      this.freeSockets[name].splice(index, 1)
      if (this.freeSockets[name].length === 0) {
        delete this.freeSockets[name]
      }
    }
  }

  if (this.requests[name] && this.requests[name].length) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(name, host, port).emit('free')
  }
}

function ForeverAgentSSL (options) {
  ForeverAgent.call(this, options)
}
util.inherits(ForeverAgentSSL, ForeverAgent)

ForeverAgentSSL.prototype.createConnection = createConnectionSSL
ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest

function createConnectionSSL (port, host, options) {
  if (typeof port === 'object') {
    options = port;
  } else if (typeof host === 'object') {
    options = host;
  } else if (typeof options === 'object') {
    options = options;
  } else {
    options = {};
  }

  if (typeof port === 'number') {
    options.port = port;
  }

  if (typeof host === 'string') {
    options.host = host;
  }

  return tls.connect(options);
}

},{"util":5,"http":7,"net":32,"tls":8,"https":6}],27:[function(require,module,exports){
module.exports = stringify;

function getSerialize (fn, decycle) {
  var seen = [];
  decycle = decycle || function(key, value) {
    return '[Circular]';
  };
  return function(key, value) {
    var ret = value;
    if (typeof value === 'object' && value) {
      if (seen.indexOf(value) !== -1)
        ret = decycle(key, value);
      else
        seen.push(value);
    }
    if (fn) ret = fn(key, ret);
    return ret;
  }
}

function stringify(obj, fn, spaces, decycle) {
  return JSON.stringify(obj, getSerialize(fn, decycle), spaces);
}

stringify.getSerialize = getSerialize;

},{}],29:[function(require,module,exports){
/**
 * Object#toString() ref for stringify().
 */

var toString = Object.prototype.toString;

/**
 * Object#hasOwnProperty ref
 */

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Array#indexOf shim.
 */

var indexOf = typeof Array.prototype.indexOf === 'function'
  ? function(arr, el) { return arr.indexOf(el); }
  : function(arr, el) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] === el) return i;
      }
      return -1;
    };

/**
 * Array.isArray shim.
 */

var isArray = Array.isArray || function(arr) {
  return toString.call(arr) == '[object Array]';
};

/**
 * Object.keys shim.
 */

var objectKeys = Object.keys || function(obj) {
  var ret = [];
  for (var key in obj) ret.push(key);
  return ret;
};

/**
 * Array#forEach shim.
 */

var forEach = typeof Array.prototype.forEach === 'function'
  ? function(arr, fn) { return arr.forEach(fn); }
  : function(arr, fn) {
      for (var i = 0; i < arr.length; i++) fn(arr[i]);
    };

/**
 * Array#reduce shim.
 */

var reduce = function(arr, fn, initial) {
  if (typeof arr.reduce === 'function') return arr.reduce(fn, initial);
  var res = initial;
  for (var i = 0; i < arr.length; i++) res = fn(res, arr[i]);
  return res;
};

/**
 * Create a nullary object if possible
 */

function createObject() {
  return Object.create
    ? Object.create(null)
    : {};
}

/**
 * Cache non-integer test regexp.
 */

var isint = /^[0-9]+$/;

function promote(parent, key) {
  if (parent[key].length == 0) return parent[key] = createObject();
  var t = createObject();
  for (var i in parent[key]) {
    if (hasOwnProperty.call(parent[key], i)) {
      t[i] = parent[key][i];
    }
  }
  parent[key] = t;
  return t;
}

function parse(parts, parent, key, val) {
  var part = parts.shift();
  // end
  if (!part) {
    if (isArray(parent[key])) {
      parent[key].push(val);
    } else if ('object' == typeof parent[key]) {
      parent[key] = val;
    } else if ('undefined' == typeof parent[key]) {
      parent[key] = val;
    } else {
      parent[key] = [parent[key], val];
    }
    // array
  } else {
    var obj = parent[key] = parent[key] || [];
    if (']' == part) {
      if (isArray(obj)) {
        if ('' != val) obj.push(val);
      } else if ('object' == typeof obj) {
        obj[objectKeys(obj).length] = val;
      } else {
        obj = parent[key] = [parent[key], val];
      }
      // prop
    } else if (~indexOf(part, ']')) {
      part = part.substr(0, part.length - 1);
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
      // key
    } else {
      if (!isint.test(part) && isArray(obj)) obj = promote(parent, key);
      parse(parts, obj, part, val);
    }
  }
}

/**
 * Merge parent key/val pair.
 */

function merge(parent, key, val){
  if (~indexOf(key, ']')) {
    var parts = key.split('[')
      , len = parts.length
      , last = len - 1;
    parse(parts, parent, 'base', val);
    // optimize
  } else {
    if (!isint.test(key) && isArray(parent.base)) {
      var t = createObject();
      for (var k in parent.base) t[k] = parent.base[k];
      parent.base = t;
    }
    set(parent.base, key, val);
  }

  return parent;
}

/**
 * Compact sparse arrays.
 */

function compact(obj) {
  if ('object' != typeof obj) return obj;

  if (isArray(obj)) {
    var ret = [];

    for (var i in obj) {
      if (hasOwnProperty.call(obj, i)) {
        ret.push(obj[i]);
      }
    }

    return ret;
  }

  for (var key in obj) {
    obj[key] = compact(obj[key]);
  }

  return obj;
}

/**
 * Restore Object.prototype.
 * see pull-request #58
 */

function restoreProto(obj) {
  if (!Object.create) return obj;
  if (isArray(obj)) return obj;
  if (obj && 'object' != typeof obj) return obj;

  for (var key in obj) {
    if (hasOwnProperty.call(obj, key)) {
      obj[key] = restoreProto(obj[key]);
    }
  }

  obj.__proto__ = Object.prototype;
  return obj;
}

/**
 * Parse the given obj.
 */

function parseObject(obj){
  var ret = { base: {} };

  forEach(objectKeys(obj), function(name){
    merge(ret, name, obj[name]);
  });

  return compact(ret.base);
}

/**
 * Parse the given str.
 */

function parseString(str){
  var ret = reduce(String(str).split('&'), function(ret, pair){
    var eql = indexOf(pair, '=')
      , brace = lastBraceInKey(pair)
      , key = pair.substr(0, brace || eql)
      , val = pair.substr(brace || eql, pair.length)
      , val = val.substr(indexOf(val, '=') + 1, val.length);

    // ?foo
    if ('' == key) key = pair, val = '';
    if ('' == key) return ret;

    return merge(ret, decode(key), decode(val));
  }, { base: createObject() }).base;

  return restoreProto(compact(ret));
}

/**
 * Parse the given query `str` or `obj`, returning an object.
 *
 * @param {String} str | {Object} obj
 * @return {Object}
 * @api public
 */

exports.parse = function(str){
  if (null == str || '' == str) return {};
  return 'object' == typeof str
    ? parseObject(str)
    : parseString(str);
};

/**
 * Turn the given `obj` into a query string
 *
 * @param {Object} obj
 * @return {String}
 * @api public
 */

var stringify = exports.stringify = function(obj, prefix) {
  if (isArray(obj)) {
    return stringifyArray(obj, prefix);
  } else if ('[object Object]' == toString.call(obj)) {
    return stringifyObject(obj, prefix);
  } else if ('string' == typeof obj) {
    return stringifyString(obj, prefix);
  } else {
    return prefix + '=' + encodeURIComponent(String(obj));
  }
};

/**
 * Stringify the given `str`.
 *
 * @param {String} str
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyString(str, prefix) {
  if (!prefix) throw new TypeError('stringify expects an object');
  return prefix + '=' + encodeURIComponent(str);
}

/**
 * Stringify the given `arr`.
 *
 * @param {Array} arr
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyArray(arr, prefix) {
  var ret = [];
  if (!prefix) throw new TypeError('stringify expects an object');
  for (var i = 0; i < arr.length; i++) {
    ret.push(stringify(arr[i], prefix + '[' + i + ']'));
  }
  return ret.join('&');
}

/**
 * Stringify the given `obj`.
 *
 * @param {Object} obj
 * @param {String} prefix
 * @return {String}
 * @api private
 */

function stringifyObject(obj, prefix) {
  var ret = []
    , keys = objectKeys(obj)
    , key;

  for (var i = 0, len = keys.length; i < len; ++i) {
    key = keys[i];
    if ('' == key) continue;
    if (null == obj[key]) {
      ret.push(encodeURIComponent(key) + '=');
    } else {
      ret.push(stringify(obj[key], prefix
        ? prefix + '[' + encodeURIComponent(key) + ']'
        : encodeURIComponent(key)));
    }
  }

  return ret.join('&');
}

/**
 * Set `obj`'s `key` to `val` respecting
 * the weird and wonderful syntax of a qs,
 * where "foo=bar&foo=baz" becomes an array.
 *
 * @param {Object} obj
 * @param {String} key
 * @param {String} val
 * @api private
 */

function set(obj, key, val) {
  var v = obj[key];
  if (undefined === v) {
    obj[key] = val;
  } else if (isArray(v)) {
    v.push(val);
  } else {
    obj[key] = [v, val];
  }
}

/**
 * Locate last brace in `str` within the key.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function lastBraceInKey(str) {
  var len = str.length
    , brace
    , c;
  for (var i = 0; i < len; ++i) {
    c = str[i];
    if (']' == c) brace = false;
    if ('[' == c) brace = true;
    if ('=' == c && !brace) return i;
  }
}

/**
 * Decode `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function decode(str) {
  try {
    return decodeURIComponent(str.replace(/\+/g, ' '));
  } catch (err) {
    return str;
  }
}

},{}],35:[function(require,module,exports){
var Connection = require('./xmpp/connection');
var Client = require('./xmpp/client').Client;
var JID = require('./xmpp/jid');
var ltx = require('ltx');
var Stanza = require('./xmpp/stanza');

exports.Connection = Connection;
exports.Client = Client;
exports.JID = JID;
exports.Element = ltx.Element;
exports.Stanza = Stanza.Stanza;
exports.Message = Stanza.Message;
exports.Presence = Stanza.Presence;
exports.Iq = Stanza.Iq;

window.XMPP = exports;

},{"./xmpp/connection":36,"./xmpp/client":37,"./xmpp/jid":16,"./xmpp/stanza":38,"ltx":39}],40:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],12:[function(require,module,exports){
(function(){var assert = require('assert');
exports.Buffer = Buffer;
exports.SlowBuffer = Buffer;
Buffer.poolSize = 8192;
exports.INSPECT_MAX_BYTES = 50;

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }
  this.parent = this;
  this.offset = 0;

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this[i] = subject.readUInt8(i);
        }
        else {
          this[i] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    } else if (type === 'number') {
      for (var i = 0; i < this.length; i++) {
        this[i] = 0;
      }
    }
  }
}

Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i];
};

Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i] = v;
};

Buffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

Buffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

Buffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;

Buffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

Buffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
};

Buffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

Buffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;

Buffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


Buffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  Buffer._charsWritten = i * 2;
  return i;
};


Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  if (end === undefined || isNaN(end)) {
    end = this.length;
  }
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  var temp = [];
  for (var i=start; i<end; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=target_start; i<target_start+temp.length; i++) {
    target[i] = temp[i-target_start];
  }
};

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof Buffer;
};

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// helpers

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}

function isArray(subject) {
  return (Array.isArray ||
    function(subject){
      return {}.toString.apply(subject) == '[object Array]'
    })
    (subject)
}

function isArrayIsh(subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

// read/write bit-twiddling

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer[offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer[offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1];
    }
  } else {
    val = buffer[offset];
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer[offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer[offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer[offset + 3];
    val = val + (buffer[offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer[offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer[offset + 1] << 8;
    val |= buffer[offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer[offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer[offset] & 0x80;
  if (!neg) {
    return (buffer[offset]);
  }

  return ((0xff - buffer[offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer[offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer[offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer[offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

})()
},{"assert":18,"./buffer_ieee754":40,"base64-js":41}],34:[function(require,module,exports){
// nothing to see here... no file methods for the browser

},{}],33:[function(require,module,exports){
(function(process){function filter (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (fn(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length; i >= 0; i--) {
    var last = parts[i];
    if (last == '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Regex to split a filename into [*, dir, basename, ext]
// posix version
var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
var resolvedPath = '',
    resolvedAbsolute = false;

for (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
  var path = (i >= 0)
      ? arguments[i]
      : process.cwd();

  // Skip empty and invalid entries
  if (typeof path !== 'string' || !path) {
    continue;
  }

  resolvedPath = path + '/' + resolvedPath;
  resolvedAbsolute = path.charAt(0) === '/';
}

// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)

// Normalize the path
resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
var isAbsolute = path.charAt(0) === '/',
    trailingSlash = path.slice(-1) === '/';

// Normalize the path
path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }
  
  return (isAbsolute ? '/' : '') + path;
};


// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    return p && typeof p === 'string';
  }).join('/'));
};


exports.dirname = function(path) {
  var dir = splitPathRe.exec(path)[1] || '';
  var isWindows = false;
  if (!dir) {
    // No dirname
    return '.';
  } else if (dir.length === 1 ||
      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {
    // It is just a slash or a drive letter with a slash
    return dir;
  } else {
    // It is a full dirname, strip trailing slash
    return dir.substring(0, dir.length - 1);
  }
};


exports.basename = function(path, ext) {
  var f = splitPathRe.exec(path)[2] || '';
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPathRe.exec(path)[3] || '';
};

exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

})(require("__browserify_process"))
},{"__browserify_process":9}],28:[function(require,module,exports){
/*!
 * Tobi - Cookie
 * Copyright(c) 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var url = require('url');

/**
 * Initialize a new `Cookie` with the given cookie `str` and `req`.
 *
 * @param {String} str
 * @param {IncomingRequest} req
 * @api private
 */

var Cookie = exports = module.exports = function Cookie(str, req) {
  this.str = str;

  // Map the key/val pairs
  str.split(/ *; */).reduce(function(obj, pair){
   var p = pair.indexOf('=');
   var key = p > 0 ? pair.substring(0, p).trim() : pair.trim();
   var lowerCasedKey = key.toLowerCase();
   var value = p > 0 ? pair.substring(p + 1).trim() : true;

   if (!obj.name) {
    // First key is the name
    obj.name = key;
    obj.value = value;
   }
   else if (lowerCasedKey === 'httponly') {
    obj.httpOnly = value;
   }
   else {
    obj[lowerCasedKey] = value;
   }
   return obj;
  }, this);

  // Expires
  this.expires = this.expires
    ? new Date(this.expires)
    : Infinity;

  // Default or trim path
  this.path = this.path
    ? this.path.trim(): req 
    ? url.parse(req.url).pathname: '/';
};

/**
 * Return the original cookie string.
 *
 * @return {String}
 * @api public
 */

Cookie.prototype.toString = function(){
  return this.str;
};

module.exports.Jar = require('./jar')
},{"url":1,"./jar":42}],43:[function(require,module,exports){
// Target API:
//
//  var s = require('net').createStream(25, 'smtp.example.com');
//  s.on('connect', function() {
//   require('starttls')(s, creds, false, function() {
//      if (!s.authorized) {
//        s.destroy();
//        return;
//      }
//
//      s.end("hello world\n");
//    });
//  });

var crypto = require('crypto');
var tls = require('tls');

module.exports = function starttls(socket, credentials, isServer, cb) {

  var pair = tls.createSecurePair(credentials, isServer, false, !isServer);

  var cleartext = pipe(pair, socket);

  pair.on('secure', function() {
    var ssl = pair._ssl || pair.ssl;
    var verifyError = ssl.verifyError();

    if (verifyError) {
      cleartext.authorized = false;
      cleartext.authorizationError = verifyError;
    } else {
      cleartext.authorized = true;
    }

    if (cb) cb();
  });

  cleartext._controlReleased = true;
  return cleartext;
};


function pipe(pair, socket) {
  pair.encrypted.pipe(socket);
  socket.pipe(pair.encrypted);

  pair.fd = socket.fd;
  var cleartext = pair.cleartext;
  cleartext.socket = socket;
  cleartext.encrypted = pair.encrypted;
  cleartext.authorized = false;

  function onerror(e) {
    if (cleartext._controlReleased) {
      cleartext.emit('error', e);
    }
  }

  function onclose() {
    socket.removeListener('error', onerror);
    socket.removeListener('close', onclose);
  }

  socket.on('error', onerror);
  socket.on('close', onclose);

  return cleartext;
}

},{"crypto":11,"tls":8}],22:[function(require,module,exports){
// Copyright 2011 Joyent, Inc.  All rights reserved.

var parser = require('./parser');
var signer = require('./signer');
var verify = require('./verify');
var util = require('./util');



///--- API

module.exports = {

  parse: parser.parseRequest,
  parseRequest: parser.parseRequest,

  sign: signer.signRequest,
  signRequest: signer.signRequest,

  sshKeyToPEM: util.sshKeyToPEM,
  sshKeyFingerprint: util.fingerprint,

  verify: verify.verifySignature,
  verifySignature: verify.verifySignature
};

},{"./parser":44,"./signer":45,"./util":46,"./verify":47}],41:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],48:[function(require,module,exports){
var Stream = require('stream');

var Response = module.exports = function (res) {
    this.offset = 0;
    this.readable = true;
};

Response.prototype = new Stream;

var capable = {
    streaming : true,
    status2 : true
};

function parseHeaders (res) {
    var lines = res.getAllResponseHeaders().split(/\r?\n/);
    var headers = {};
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line === '') continue;
        
        var m = line.match(/^([^:]+):\s*(.*)/);
        if (m) {
            var key = m[1].toLowerCase(), value = m[2];
            
            if (headers[key] !== undefined) {
            
                if (isArray(headers[key])) {
                    headers[key].push(value);
                }
                else {
                    headers[key] = [ headers[key], value ];
                }
            }
            else {
                headers[key] = value;
            }
        }
        else {
            headers[line] = true;
        }
    }
    return headers;
}

Response.prototype.getResponse = function (xhr) {
    var respType = String(xhr.responseType).toLowerCase();
    if (respType === 'blob') return xhr.responseBlob || xhr.response;
    if (respType === 'arraybuffer') return xhr.response;
    return xhr.responseText;
}

Response.prototype.getHeader = function (key) {
    return this.headers[key.toLowerCase()];
};

Response.prototype.handle = function (res) {
    if (res.readyState === 2 && capable.status2) {
        try {
            this.statusCode = res.status;
            this.headers = parseHeaders(res);
        }
        catch (err) {
            capable.status2 = false;
        }
        
        if (capable.status2) {
            this.emit('ready');
        }
    }
    else if (capable.streaming && res.readyState === 3) {
        try {
            if (!this.statusCode) {
                this.statusCode = res.status;
                this.headers = parseHeaders(res);
                this.emit('ready');
            }
        }
        catch (err) {}
        
        try {
            this._emitData(res);
        }
        catch (err) {
            capable.streaming = false;
        }
    }
    else if (res.readyState === 4) {
        if (!this.statusCode) {
            this.statusCode = res.status;
            this.emit('ready');
        }
        this._emitData(res);
        
        if (res.error) {
            this.emit('error', this.getResponse(res));
        }
        else this.emit('end');
        
        this.emit('close');
    }
};

Response.prototype._emitData = function (res) {
    var respBody = this.getResponse(res);
    if (respBody.toString().match(/ArrayBuffer/)) {
        this.emit('data', new Uint8Array(respBody, this.offset));
        this.offset = respBody.byteLength;
        return;
    }
    if (respBody.length > this.offset) {
        this.emit('data', respBody.slice(this.offset));
        this.offset = respBody.length;
    }
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{"stream":3}],30:[function(require,module,exports){
module.exports = require('./lib');
},{"./lib":49}],42:[function(require,module,exports){
/*!
* Tobi - CookieJar
* Copyright(c) 2010 LearnBoost <dev@learnboost.com>
* MIT Licensed
*/

/**
* Module dependencies.
*/

var url = require('url');

/**
* Initialize a new `CookieJar`.
*
* @api private
*/

var CookieJar = exports = module.exports = function CookieJar() {
  this.cookies = [];
};

/**
* Add the given `cookie` to the jar.
*
* @param {Cookie} cookie
* @api private
*/

CookieJar.prototype.add = function(cookie){
  this.cookies = this.cookies.filter(function(c){
    // Avoid duplication (same path, same name)
    return !(c.name == cookie.name && c.path == cookie.path);
  });
  this.cookies.push(cookie);
};

/**
* Get cookies for the given `req`.
*
* @param {IncomingRequest} req
* @return {Array}
* @api private
*/

CookieJar.prototype.get = function(req){
  var path = url.parse(req.url).pathname
    , now = new Date
    , specificity = {};
  return this.cookies.filter(function(cookie){
    if (0 == path.indexOf(cookie.path) && now < cookie.expires
      && cookie.path.length > (specificity[cookie.name] || 0))
      return specificity[cookie.name] = cookie.path.length;
  });
};

/**
* Return Cookie string for the given `req`.
*
* @param {IncomingRequest} req
* @return {String}
* @api private
*/

CookieJar.prototype.cookieString = function(req){
  var cookies = this.get(req);
  if (cookies.length) {
    return cookies.map(function(cookie){
      return cookie.name + '=' + cookie.value;
    }).join('; ');
  }
};

},{"url":1}],39:[function(require,module,exports){
/* Cause browserify to bundle SAX parsers: */
//require('./sax_easysax');
//require('./sax_saxjs');
require('./sax_ltx');

/* SHIM */
module.exports = require('./index');
},{"./sax_ltx":50,"./index":51}],52:[function(require,module,exports){
var util = require('util');
var EventEmitter = require('events').EventEmitter;
var Connection = require('./connection');
var BOSH = require('./bosh');
var WebSockets = require('./websockets');
var JID = require('./jid').JID;
var tls = require('tls');
var crypto = require('crypto');
var SRV = require('./srv');

function Session(opts) {
    var self = this;
    EventEmitter.call(this);

    if (typeof opts.jid == 'string')
        this.jid = new JID(opts.jid);
    else
        this.jid = opts.jid;
    this.password = opts.password;
    this.preferredSaslMechanism = opts.preferredSaslMechanism;
    this.availableSaslMechanisms = [];
    this.api_key = opts.api_key;
    this.access_token = opts.access_token;
    this.oauth2_token = opts.oauth2_token;
    this.oauth2_auth = opts.oauth2_auth;
    this.register = opts.register;
    if (typeof opts.actAs == 'string') 
    	this.actAs = new JID(opts.actAs);
    else
        this.actAs = opts.actAs;
    delete this.did_bind;
    delete this.did_session;

    if (opts.websocketsURL) {
	this.connection = new WebSockets.WSConnection(opts.websocketsURL);
	this.connection.on('connected', function() {
	    if (self.connection.startStream)
		self.connection.startStream();
	});
    } else if (opts.boshURL) {
	this.connection = new BOSH.BOSHConnection({
	    jid: this.jid,
	    boshURL: opts.boshURL
	});
    } else {
	this.connection = new Connection.Connection({
	    xmlns: { '': opts.xmlns },
	    streamAttrs: {
		version: "1.0",
		to: this.jid.domain
	    }
	});
	var connect = function() {
	    if (opts.host) {
    	    self.connection.on('connect', function() {
    	        if (self.connection.startStream)
    		        self.connection.startStream();
    	    });

	        if (opts.legacySSL) {
	            self.connection.allowTLS = false;
	            self.connection.socket = tls.connect(opts.port || 5223, opts.host, opts.credentials || {}, function() {
	                self.connection.setupStream();
	                self.connection.startParser();
            	    self.connection.emit('connect');
	            });
	        } else {
	            if (opts.credentials) {
	                self.connection.credentials = crypto.createCredentials(opts.credentials);
	            }
	            self.connection.socket.on("connect", function() {
                        self.connection.emit('connect')
                    })
                    self.connection.socket.connect(opts.port || 5222, opts.host);
    		}
	    } else if (!SRV) {
		    throw "Cannot load SRV";
	    } else {
	        if (opts.legacySSL) {
	            throw "LegacySSL mode does not support DNS lookups";
	        }

            if (opts.credentials) {
                self.connection.credentials = crypto.createCredentials(opts.credentials);
            }
	        
		    var attempt = SRV.connect(self.connection.socket,
		        ['_xmpp-client._tcp'], self.jid.domain, 5222);
		    attempt.addListener('connect', function() {
		    if (self.connection.startStream)
			    self.connection.startStream();
		});
		attempt.addListener('error', function(e) {
		    self.emit('error', e);
		});
	    }
	};
	if (opts.reconnect)
	    self.reconnect = connect;
	connect();
    }
    this.connection.addListener('stanza', this.onStanza.bind(this));
    this.connection.addListener('drain', this.emit.bind(this, 'drain'));

    this.connection.addListener('end', function() {
        self.emit('end');
    });
    this.connection.addListener('close', function() {
        self.emit('close');
    });
}

util.inherits(Session, EventEmitter);
exports.Session = Session;


Session.prototype.pause = function() {
    if (this.connection && this.connection.pause)
	this.connection.pause();
};

Session.prototype.resume = function() {
    if (this.connection && this.connection.resume)
	this.connection.resume();
};

Session.prototype.send = function(stanza) {
    if (this.connection)
	this.connection.send(stanza.root());
};

Session.prototype.end = function() {
    if (this.connection)
	this.connection.end();
};

Session.prototype.onStanza = function(stanza) {
};

},{"util":5,"events":4,"tls":8,"crypto":11,"./srv":17,"./connection":36,"./bosh":53,"./websockets":54,"./jid":16}],50:[function(require,module,exports){
var util = require('util');
var events = require('events');

const STATE_TEXT = 0,
    STATE_IGNORE_TAG = 1,
    STATE_TAG_NAME = 2,
    STATE_TAG = 3,
    STATE_ATTR_NAME = 4,
    STATE_ATTR_EQ = 5,
    STATE_ATTR_QUOT = 6,
    STATE_ATTR_VALUE = 7;

var RE_TAG_NAME = /^[^\s\/>]+$/,
    RE_ATTR_NAME = /^[^\s=]+$/;

var SaxLtx = module.exports = function SaxLtx() {
    events.EventEmitter.call(this);

    var state = STATE_TEXT, remainder;
    var tagName, attrs, endTag, selfClosing, attrQuote;
    var recordStart = 0;

    this.write = function(data) {
	if (typeof data !== 'string')
	    data = data.toString();
        var pos = 0
        var attrName

	/* Anything from previous write()? */
	if (remainder) {
	    data = remainder + data;
	    pos += remainder.length;
	    delete remainder;
	}

	function endRecording() {
	    if (typeof recordStart === 'number') {
		var recorded = data.slice(recordStart, pos);
		recordStart = undefined;
		return recorded;
	    }
	}

	for(; pos < data.length; pos++) {
	    var c = data.charCodeAt(pos);
	    //console.log("state", state, "c", c, data[pos]);
	    switch(state) {
	    case STATE_TEXT:
		if (c === 60 /* < */) {
		    var text = endRecording();
		    if (text)
			this.emit('text', unescapeXml(text));
		    state = STATE_TAG_NAME;
		    recordStart = pos + 1;
		    attrs = {};
		}
		break;
	    case STATE_TAG_NAME:
		if (c === 47 /* / */ && recordStart === pos) {
		    recordStart = pos + 1;
		    endTag = true;
		} else if (c === 33 /* ! */ || c === 63 /* ? */) {
		    recordStart = undefined;
		    state = STATE_IGNORE_TAG;
		} else if (c <= 32 || c === 47 /* / */ || c === 62 /* > */) {
		    tagName = endRecording();
		    pos--;
		    state = STATE_TAG;
		}
		break;
	    case STATE_IGNORE_TAG:
		if (c === 62 /* > */) {
		    state = STATE_TEXT;
		}
		break;
	    case STATE_TAG:
		if (c === 62 /* > */) {
		    if (!endTag) {
			this.emit('startElement', tagName, attrs);
			if (selfClosing)
			    this.emit('endElement', tagName);
		    } else
			this.emit('endElement', tagName);
		    tagName = undefined;
		    attrs = undefined;
		    endTag = undefined;
		    selfClosing = undefined;
		    state = STATE_TEXT;
		    recordStart = pos + 1;
		} else if (c === 47 /* / */) {
		    selfClosing = true;
		} else if (c > 32) {
		    recordStart = pos;
		    state = STATE_ATTR_NAME;
		}
		break;
	    case STATE_ATTR_NAME:
		if (c <= 32 || c === 61 /* = */) {
		    attrName = endRecording();
		    pos--;
		    state = STATE_ATTR_EQ;
		}
		break;
	    case STATE_ATTR_EQ:
		if (c === 61 /* = */) {
		    state = STATE_ATTR_QUOT;
		}
		break;
	    case STATE_ATTR_QUOT:
		if (c === 34 /* " */ || c === 39 /* ' */) {
		    attrQuote = c;
		    state = STATE_ATTR_VALUE;
		    recordStart = pos + 1;
		}
		break;
	    case STATE_ATTR_VALUE:
		if (c === attrQuote) {
		    var value = unescapeXml(endRecording());
		    attrs[attrName] = value;
		    attrName = undefined;
		    state = STATE_TAG;
		}
		break;
	    }
	}

	if (typeof recordStart === 'number' &&
	    recordStart <= data.length) {

	    remainder = data.slice(recordStart);
	    recordStart = 0;
	}
    };

    /*var origEmit = this.emit;
    this.emit = function() {
	console.log('ltx', arguments);
	origEmit.apply(this, arguments);
    };*/
};
util.inherits(SaxLtx, events.EventEmitter);


SaxLtx.prototype.end = function(data) {
    if (data)
	this.write(data);

    /* Uh, yeah */
    this.write = function() {
    };
};

function unescapeXml(s) {
    return s.
        replace(/\&amp;/g, '&').
        replace(/\&lt;/g, '<').
        replace(/\&gt;/g, '>').
        replace(/\&quot;/g, '"').
        replace(/\&apos;/g, '\'');
}

},{"util":5,"events":4}],10:[function(require,module,exports){
(function(){var Stream = require('stream');
var Response = require('./response');
var concatStream = require('concat-stream')
var Buffer = require('buffer')

var Request = module.exports = function (xhr, params) {
    var self = this;
    self.writable = true;
    self.xhr = xhr;
    self.body = concatStream()
    
    var uri = params.host
        + (params.port ? ':' + params.port : '')
        + (params.path || '/')
    ;
    
    xhr.open(
        params.method || 'GET',
        (params.scheme || 'http') + '://' + uri,
        true
    );
    
    if (params.headers) {
        var keys = objectKeys(params.headers);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!self.isSafeRequestHeader(key)) continue;
            var value = params.headers[key];
            if (isArray(value)) {
                for (var j = 0; j < value.length; j++) {
                    xhr.setRequestHeader(key, value[j]);
                }
            }
            else xhr.setRequestHeader(key, value)
        }
    }
    
    if (params.auth) {
        //basic auth
        this.setHeader('Authorization', 'Basic ' + new Buffer(params.auth).toString('base64'));
    }

    var res = new Response;
    res.on('close', function () {
        self.emit('close');
    });
    
    res.on('ready', function () {
        self.emit('response', res);
    });
    
    xhr.onreadystatechange = function () {
        res.handle(xhr);
    };
};

Request.prototype = new Stream;

Request.prototype.setHeader = function (key, value) {
    if (isArray(value)) {
        for (var i = 0; i < value.length; i++) {
            this.xhr.setRequestHeader(key, value[i]);
        }
    }
    else {
        this.xhr.setRequestHeader(key, value);
    }
};

Request.prototype.write = function (s) {
    this.body.write(s);
};

Request.prototype.destroy = function (s) {
    this.xhr.abort();
    this.emit('close');
};

Request.prototype.end = function (s) {
    if (s !== undefined) this.body.write(s);
    this.body.end()
    this.xhr.send(this.body.getBody());
};

// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
Request.unsafeHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "content-transfer-encoding",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "user-agent",
    "via"
];

Request.prototype.isSafeRequestHeader = function (headerName) {
    if (!headerName) return false;
    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
};

var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var indexOf = function (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
};

})()
},{"stream":3,"buffer":12,"./response":48,"concat-stream":55}],36:[function(require,module,exports){
var net = require('net');
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var ltx = require('ltx');
var StreamParser = require('./stream_parser');
var starttls = require('../starttls');

var NS_XMPP_TLS = exports.NS_XMPP_TLS = 'urn:ietf:params:xml:ns:xmpp-tls';
var NS_STREAM = exports.NS_STREAM = 'http://etherx.jabber.org/streams';
var NS_XMPP_STREAMS = 'urn:ietf:params:xml:ns:xmpp-streams';

/**
 Base class for connection-based streams (TCP).

 The socket parameter is optional for incoming connections.
*/

var MAX_RECONNECT_DELAY = 30 * 1000;


function Connection(opts) {
    EventEmitter.call(this);

    this.streamAttrs = (opts && opts.streamAttrs) || {};
    this.xmlns = (opts && opts.xmlns) || {};
    this.xmlns.stream = NS_STREAM;

    this.socket = (opts && opts.socket) || new net.Socket();
    this.reconnectDelay = 0;

    this.setupStream();
    if (this.socket.readable)
	this.startParser();
    else {
	var that = this;
	this.socket.on('connect', function() {
	    that.startParser();
	    that.emit('connect');
	});
    }

    this.mixins = [];
}

util.inherits(Connection, EventEmitter);
exports.Connection = Connection;

// Defaults
Connection.prototype.allowTLS = true;

/**
 Used by both the constructor and by reinitialization in setSecure().
*/
Connection.prototype.setupStream = function() {
    var self = this;

    this.socket.addListener('data', function(data) {
        self.onData(data);
    });
    this.socket.addListener('end', function() {
        self.onEnd();
    });
    this.socket.addListener('error', function() {
	/* unhandled errors may throw up in node, preventing a reconnect */
        self.onEnd();
    });
    this.socket.addListener('close', function() {
	self.onClose();
    });
    var proxyEvent = function(event) {
        self.socket.addListener(event, function() {
	    var args = Array.prototype.slice.call(arguments);
	    args.unshift(event);
	    self.emit.apply(self, args);
        });
    };
    proxyEvent('data');  // let them sniff unparsed XML
    proxyEvent('drain');
    //proxyEvent('close');

    /**
     * This is optimized for continuous TCP streams. If your "socket"
     * actually transports frames (WebSockets) and you can't have
     * stanzas split across those, use:
     *     cb(el.toString());
     */
    if (!this.socket.serializeStanza) {
        this.socket.serializeStanza = function(el, cb) {
            // Continuously write out
            el.write(function(s) {
                cb(s);
            });
        };
    }
};


Connection.prototype.pause = function() {
    if (this.socket.pause)
	this.socket.pause();
};

Connection.prototype.resume = function() {
    if (this.socket.resume)
	this.socket.resume();
};

/** Climbs the stanza up if a child was passed,
    but you can send strings and buffers too.

    Returns whether the socket flushed data.
*/
Connection.prototype.send = function(stanza) {
    var self = this;
    var flushed = true;
    if (!this.socket) {
        return; // Doh!
    }
    if (!this.socket.writable) {
        this.socket.end();
        return;
    }

    if (stanza.root) {
        var el = this.rmXmlns(stanza.root());
        this.socket.serializeStanza(el, function(s) {
            flushed = self.socket.write(s);
        });
    } else {
        flushed = this.socket.write(stanza);
    }
    return flushed;
};

Connection.prototype.startParser = function() {
    var self = this;
    this.parser = new StreamParser.StreamParser(this.maxStanzaSize);

    this.parser.addListener('streamStart', function(attrs) {
        /* We need those xmlns often, store them extra */
        self.streamNsAttrs = {};
        for(var k in attrs) {
        if (k == 'xmlns' ||
            k.substr(0, 6) == 'xmlns:')
                self.streamNsAttrs[k] = attrs[k];
        }

        /* Notify in case we don't wait for <stream:features/>
           (Component or non-1.0 streams)
         */
        self.emit('streamStart', attrs);
    });
    this.parser.addListener('stanza', function(stanza) {
        self.onStanza(self.addStreamNs(stanza));
    });
    this.parser.addListener('error', function(e) {
        self.error(e.condition || 'internal-server-error', e.message);
    });
    this.parser.addListener('end', function() {
        self.stopParser();
        self.end();
    });
};

Connection.prototype.stopParser = function() {
    /* No more events, please (may happen however) */
    if(this.parser) {
        /* Get GC'ed */
        delete this.parser;
    }
};

Connection.prototype.startStream = function() {
    /* reset reconnect delay */
    this.reconnectDelay = 0;
    
    var attrs = {};
    for(var k in this.xmlns) {
        if (this.xmlns.hasOwnProperty(k)) {
            if (!k)
                attrs.xmlns = this.xmlns[k];
            else
                attrs['xmlns:' + k] = this.xmlns[k];
        }
    }
    for(k in this.streamAttrs) {
	if (this.streamAttrs.hasOwnProperty(k))
	    attrs[k] = this.streamAttrs[k];
    }

    if (this.streamTo) { // in case of a component connecting
        attrs.to = this.streamTo;
    }

    var el = new ltx.Element('stream:stream', attrs);
    // make it non-empty to cut the closing tag
    el.t(' ');
    var s = el.toString();
    this.send(s.substr(0, s.indexOf(' </stream:stream>')));

    this.streamOpened = true;
};

Connection.prototype.onData = function(data) {
    if (this.parser)
        this.parser.write(data);
};

Connection.prototype.setSecure = function(credentials, isServer) {
    var self = this;

    // Remove old event listeners
    this.socket.removeAllListeners('data');
    // retain socket 'end' listeners because ssl layer doesn't support it
    this.socket.removeAllListeners('drain');
    this.socket.removeAllListeners('close');
    // remove idle_timeout
    if (this.socket.clearTimer)
	this.socket.clearTimer();

    this.stopParser();
    var ct = starttls(this.socket, credentials || this.credentials, isServer, function() {
	self.isSecure = true;
	self.startParser();
	if (!isServer)
	    // Clients start <stream:stream>, servers reply
	    self.startStream();
    });
    ct.on('close', function() {
	self.onClose();
	self.isSecure = false;
    });

    // The socket is now the cleartext stream
    this.socket = ct;

    // Attach new listeners on the cleartext stream
    this.setupStream();
};

/**
 * This is not an event listener, but takes care of the TLS handshake
 * before 'stanza' events are emitted to the derived classes.
 */
Connection.prototype.onStanza = function(stanza) {
    if (stanza.is('error', NS_STREAM)) {
        /* TODO: extract error text */
        this.emit('error', stanza);
    } else if (stanza.is('features', NS_STREAM) &&
               this.allowTLS &&
	       !this.isSecure &&
               stanza.getChild('starttls', NS_XMPP_TLS)) {
        /* Signal willingness to perform TLS handshake */
        this.send(new ltx.Element('starttls', { xmlns: NS_XMPP_TLS }));
    } else if (this.allowTLS &&
               stanza.is('proceed', NS_XMPP_TLS)) {
        /* Server is waiting for TLS handshake */
        this.setSecure();
    } else {
        this.emit('stanza', stanza);
    }
};

/**
 * Add stream xmlns to a stanza
 *
 * Does not add our default xmlns as it is different for
 * C2S/S2S/Component connections.
 */
Connection.prototype.addStreamNs = function(stanza) {
    for(var attr in this.streamNsAttrs) {
        if (!stanza.attrs[attr] &&
	    !(attr === 'xmlns' &&
	      this.streamNsAttrs[attr] === this.xmlns['']))
            stanza.attrs[attr] = this.streamNsAttrs[attr];
    }
    return stanza;
};

/**
 * Remove superfluous xmlns that were aleady declared in
 * our <stream:stream>
 */
Connection.prototype.rmXmlns = function(stanza) {
    for(var prefix in this.xmlns) {
        var attr = prefix ? 'xmlns:'+prefix : 'xmlns';
        if (stanza.attrs[attr] == this.xmlns[prefix])
            delete stanza.attrs[attr];
    }
    return stanza;
};


/**
 * Connection has been ended by remote, we will not get any incoming
 * 'data' events. Alternatively, used for 'error' event.
 */
Connection.prototype.onEnd = function() {
    this.stopParser();
    if (this.socket)
        this.socket.end();
};

/**
 * XMPP-style end connection for user
 */
Connection.prototype.end = function() {
    if (this.socket.writable) {
        if (this.streamOpened) {
            this.socket.write('</stream:stream>');
            delete this.streamOpened;
	    /* wait for being called again upon 'end' from other side */
        } else {
            this.socket.end();
        }
    }
};

Connection.prototype.onClose = function() {
    if (!this.socket)
	/* A reconnect may have already been scheduled */
	return;

    delete this.socket;
    if (this.reconnect) {
	var self = this;
	setTimeout(function() {
	    self.socket = new net.Stream();
	    self.setupStream();
	    self.reconnect();
	}, this.reconnectDelay);
	console.log("Reconnect in", this.reconnectDelay);
	this.reconnectDelay += Math.ceil(Math.random() * 2000);
	if (this.reconnectDelay > MAX_RECONNECT_DELAY)
	    this.reconnectDelay = MAX_RECONNECT_DELAY;
    } else {
	this.emit('close');
    }
};

/**
 * End connection with stream error.
 * Emits 'error' event too.
 *
 * @param {String} condition XMPP error condition, see RFC3920 4.7.3. Defined Conditions
 * @param {String} text Optional error message
 */
Connection.prototype.error = function(condition, message) {
    this.emit('error', new Error(message));

    if (!this.socket || !this.socket.writable)
        return;

    if(!this.streamOpened)
        this.startStream(); /* RFC 3920, 4.7.1 stream-level errors rules */

    var e = new ltx.Element('stream:error');
    e.c(condition, { xmlns: NS_XMPP_STREAMS });
    if (message)
        e.c('text', { xmlns: NS_XMPP_STREAMS,
                      'xml:lang': 'en' }).
        t(message);

    this.send(e);
    this.end();
};

},{"net":32,"events":4,"util":5,"./stream_parser":56,"../starttls":43,"ltx":39}],37:[function(require,module,exports){
(function(){var EventEmitter = require('events').EventEmitter;
var Session = require('./session').Session;
var Connection = require('./connection');
var JID = require('./jid').JID;
var ltx = require('ltx');
var sasl = require('./sasl');
var util = require('util');
try {
    var SRV = require('./srv');
} catch (e) { }

var NS_CLIENT = 'jabber:client';
var NS_REGISTER = 'jabber:iq:register';
var NS_XMPP_SASL = 'urn:ietf:params:xml:ns:xmpp-sasl';
var NS_XMPP_BIND = 'urn:ietf:params:xml:ns:xmpp-bind';
var NS_XMPP_SESSION = 'urn:ietf:params:xml:ns:xmpp-session';

var STATE_PREAUTH = 0,
    STATE_AUTH = 1,
    STATE_AUTHED = 2,
    STATE_BIND = 3,
    STATE_SESSION = 4,
    STATE_ONLINE = 5;
var IQID_SESSION = 'sess',
    IQID_BIND = 'bind';

/**
 * params object:
 *   jid: String (required)
 *   password: String (required)
 *   host: String (optional)
 *   port: Number (optional)
 *   reconnect: Boolean (optional)
 *   register: Boolean (option) - register account before authentication
 *   legacySSL: Boolean (optional) - connect to the legacy SSL port, requires at least the host to be specified
 *   credentials: Dictionary (optional) - TLS or SSL key and certificate credentials
 *   actAs: String (optional) - if admin user act on behalf of another user (just user)
 *
 * Examples:
 *   var cl = new xmpp.Client({
 *       jid: "me@example.com",
 *       password: "secret"
 *   });
 *   var aceboo = new xmpp.Client({
 *       jid: '-' + fbUID + '@chat.facebook.com',
 *       api_key: '54321', // api key of your facebook app
 *       access_token: 'abcdefg', // user access token
 *       host: 'chat.facebook.com'
 *   });
 *   var gtalk = new xmpp.Client({
 *       jid: 'me@gmail.com',
 *       oauth2_token: 'xxxx.xxxxxxxxxxx', // from OAuth2
 *       oauth2_auth: 'http://www.google.com/talk/protocol/auth',
 *       host: 'talk.google.com'
 *   });
 *
 * Example SASL EXTERNAL:
 * 
 * var myCredentials = { 
 *   // These are necessary only if using the client certificate authentication
 *   key: fs.readFileSync('key.pem'),
 *   cert: fs.readFileSync('cert.pem'),
 *   // passphrase: 'optional'
 * };
 * var cl = new xmppClient({jid: "me@example.com", credentials: myCredentials }); 
 
 */
function Client(opts) {
    var self = this;

    opts.xmlns = NS_CLIENT;
    self.state = STATE_PREAUTH;
    delete self.did_bind;
    delete self.did_session;

    Session.call(this, opts);

    if (opts.credentials) {
        this.preferredSaslMechanism = 'EXTERNAL';
        this.availableSaslMechanisms = [ sasl.External ];
    }

    this.state = STATE_PREAUTH;
    this.addListener('end', function() {
        self.state = STATE_PREAUTH;
        self.emit('offline');
    });
    this.on('close', function() {
        self.state = STATE_PREAUTH;
    });
}

util.inherits(Client, Session);
exports.Client = Client;

Client.prototype.onStanza = function(stanza) {
    /* Actually, we shouldn't wait for <stream:features/> if
       this.streamAttrs.version is missing, but who uses pre-XMPP-1.0
       these days anyway? */
    if (this.state != STATE_ONLINE &&
        stanza.is('features', Connection.NS_STREAM)) {
        this.streamFeatures = stanza;
        this.useFeatures();
    } else if (this.state == STATE_AUTH) {
        if (stanza.is('challenge', NS_XMPP_SASL)) {
            var challengeMsg = decode64(stanza.getText());
            var responseMsg = encode64(this.mech.challenge(challengeMsg));
            this.send(new ltx.Element('response',
                                      { xmlns: NS_XMPP_SASL
                                      }).t(responseMsg));
        } else if (stanza.is('success', NS_XMPP_SASL)) {
            this.mech = null;
            this.state = STATE_AUTHED;
	    if (this.connection.startParser)
		this.connection.startParser();
	    if (this.connection.startStream)
		this.connection.startStream();
        } else {
            this.emit('error', 'XMPP authentication failure');
        }
    } else if (this.state == STATE_BIND &&
               stanza.is('iq') &&
               stanza.attrs.id == IQID_BIND) {
        if (stanza.attrs.type == 'result') {
            this.state = STATE_AUTHED;
            this.did_bind = true;

            var bindEl = stanza.getChild('bind', NS_XMPP_BIND);
            if (bindEl && bindEl.getChild('jid')) {
                this.jid = new JID(bindEl.getChild('jid').getText());
            }

            /* no stream restart, but next feature */
            this.useFeatures();
        } else {
            this.emit('error', 'Cannot bind resource');
        }
    } else if (this.state == STATE_SESSION &&
               stanza.is('iq') &&
               stanza.attrs.id == IQID_SESSION) {
        if (stanza.attrs.type == 'result') {
            this.state = STATE_AUTHED;
            this.did_session = true;

            /* no stream restart, but next feature (most probably
               we'll go online next) */
            this.useFeatures();
        } else {
            this.emit('error', 'Cannot bind resource');
        }
    } else if (stanza.name == 'stream:error') {
        this.emit('error', stanza);
    } else if (this.state == STATE_ONLINE) {
        this.emit('stanza', stanza);
    }
};

/**
 * Either we just received <stream:features/>, or we just enabled a
 * feature and are looking for the next.
 */
Client.prototype.useFeatures = function() {
    if (this.state == STATE_PREAUTH &&
        this.register) {
	delete this.register;
	this.doRegister();
    } else if (this.state == STATE_PREAUTH &&
        this.streamFeatures.getChild('mechanisms', NS_XMPP_SASL)) {
        this.state = STATE_AUTH;
	var offeredMechs = this.streamFeatures.
            getChild('mechanisms', NS_XMPP_SASL).
            getChildren('mechanism', NS_XMPP_SASL).
            map(function(el) { return el.getText(); });
        this.mech = sasl.selectMechanism(
            offeredMechs,
            this.preferredSaslMechanism,
            this.availableSaslMechanisms);
        if (this.mech) {
            this.mech.authzid = this.jid.bare().toString();
            this.mech.authcid = this.jid.user;
            this.mech.password = this.password;
            this.mech.api_key = this.api_key;
            this.mech.access_token = this.access_token;
            this.mech.oauth2_token = this.oauth2_token;
            this.mech.oauth2_auth = this.oauth2_auth;
            this.mech.realm = this.jid.domain;  // anything?
            if (this.actAs) this.mech.actAs = this.actAs.user;
            this.mech.digest_uri = "xmpp/" + this.jid.domain;
            var authMsg = encode64(this.mech.auth());
            var attrs = this.mech.authAttrs();
            attrs.xmlns = NS_XMPP_SASL;
            attrs.mechanism = this.mech.name;
            this.send(new ltx.Element('auth', attrs).
		      t(authMsg));
        } else {
            this.emit('error', 'No usable SASL mechanism');
        }
    } else if (this.state == STATE_AUTHED &&
               !this.did_bind &&
               this.streamFeatures.getChild('bind', NS_XMPP_BIND)) {
        this.state = STATE_BIND;
        var bindEl = new ltx.Element('iq',
                                     { type: 'set',
                                       id: IQID_BIND
                                     }).c('bind',
                                          { xmlns: NS_XMPP_BIND
                                          });
        if (this.jid.resource)
            bindEl.c('resource').t(this.jid.resource);
        this.send(bindEl);
    } else if (this.state == STATE_AUTHED &&
               !this.did_session &&
               this.streamFeatures.getChild('session', NS_XMPP_SESSION)) {
        this.state = STATE_SESSION;
        this.send(new ltx.Element('iq',
                                  { type: 'set',
                                    to: this.jid.domain,
                                    id: IQID_SESSION
                                  }).c('session',
                                       { xmlns: NS_XMPP_SESSION
                                       }));
    } else if (this.state == STATE_AUTHED) {
        /* Ok, we're authenticated and all features have been
           processed */
        this.state = STATE_ONLINE;
        this.emit('online');
    }
};

Client.prototype.doRegister = function() {
    var id = "register" + Math.ceil(Math.random() * 99999);
    var iq = new ltx.Element('iq', { type: 'set',
				     id: id,
				     to: this.jid.domain
				   }).
	c('query', { xmlns: NS_REGISTER }).
	c('username').t(this.jid.user).up().
	c('password').t(this.password);
    this.send(iq);

    var that = this;
    var onReply = function(reply) {
	if (reply.is('iq') && reply.attrs.id === id) {
	    that.removeListener('stanza', onReply);

	    if (reply.attrs.type === 'result') {
		/* Registration successful, proceed to auth */
		that.useFeatures();
	    } else {
		that.emit('error', new Error("Registration error"));
	    }
	}
    };
    this.on('stanza', onReply);
};

Client.prototype.registerSaslMechanism = function () {
    var args = arguments.length > 0 ? Array.prototype.slice.call(arguments) : [];
    this.availableSaslMechanisms = this.availableSaslMechanisms.concat(args);
};

var decode64, encode64, Buffer;
if (typeof btoa === 'function') {
    decode64 = function(encoded) {
	return atob(encoded);
    };
} else {
    Buffer = require('buffer').Buffer;
    decode64 = function(encoded) {
	return (new Buffer(encoded, 'base64')).toString('utf8');
    };
}
if (typeof atob === 'function') {
    encode64 = function(decoded) {
	return btoa(decoded);
    };
} else {
    Buffer = require('buffer').Buffer;
    encode64 = function(decoded) {
	return (new Buffer(decoded, 'utf8')).toString('base64');
    };
}

})()
},{"events":4,"util":5,"./srv":17,"buffer":12,"./session":52,"./connection":36,"./jid":16,"./sasl":57,"ltx":39}],38:[function(require,module,exports){
var util = require('util');
var ltx = require('ltx');

function Stanza(name, attrs) {
    ltx.Element.call(this, name, attrs);
}
util.inherits(Stanza, ltx.Element);

/**
 * Common attribute getters/setters for all stanzas
 */

Stanza.prototype.__defineGetter__('from', function() {
    return this.attrs.from;
});
Stanza.prototype.__defineSetter__('from', function(from) {
    this.attrs.from = from;
});

Stanza.prototype.__defineGetter__('to', function() {
    return this.attrs.to;
});
Stanza.prototype.__defineSetter__('to', function(to) {
    this.attrs.to = to;
});

Stanza.prototype.__defineGetter__('id', function() {
    return this.attrs.id;
});
Stanza.prototype.__defineSetter__('id', function(id) {
    this.attrs.id = id;
});

Stanza.prototype.__defineGetter__('type', function() {
    return this.attrs.type;
});
Stanza.prototype.__defineSetter__('type', function(type) {
    this.attrs.type = type;
});


/**
 * Stanza kinds
 */

function Message(attrs) {
    Stanza.call(this, 'message', attrs);
}
util.inherits(Message, Stanza);

function Presence(attrs) {
    Stanza.call(this, 'presence', attrs);
}
util.inherits(Presence, Stanza);

function Iq(attrs) {
    Stanza.call(this, 'iq', attrs);
}
util.inherits(Iq, Stanza);

exports.Stanza = Stanza;
exports.Message = Message;
exports.Presence = Presence;
exports.Iq = Iq;

},{"util":5,"ltx":39}],55:[function(require,module,exports){
(function(Buffer){var stream = require('stream')
var util = require('util')

function ConcatStream(cb) {
  stream.Stream.call(this)
  this.writable = true
  if (cb) this.cb = cb
  this.body = []
  if (this.cb) this.on('error', cb)
}

util.inherits(ConcatStream, stream.Stream)

ConcatStream.prototype.write = function(chunk) {
  this.body.push(chunk)
}

ConcatStream.prototype.arrayConcat = function(arrs) {
  if (arrs.length === 0) return []
  if (arrs.length === 1) return arrs[0]
  return arrs.reduce(function (a, b) { return a.concat(b) })
}

ConcatStream.prototype.isArray = function(arr) {
  var isArray = Array.isArray(arr)
  var isTypedArray = arr.toString().match(/Array/)
  return isArray || isTypedArray
}

ConcatStream.prototype.getBody = function () {
  if (this.body.length === 0) return
  if (typeof(this.body[0]) === "string") return this.body.join('')
  if (this.isArray(this.body[0])) return this.arrayConcat(this.body)
  if (typeof(Buffer) !== "undefined" && Buffer.isBuffer(this.body[0])) {
    return Buffer.concat(this.body)
  }
  return this.body
}

ConcatStream.prototype.end = function() {
  if (this.cb) this.cb(false, this.getBody())
}

module.exports = function(cb) {
  return new ConcatStream(cb)
}

module.exports.ConcatStream = ConcatStream

})(require("__browserify_buffer").Buffer)
},{"stream":3,"util":5,"__browserify_buffer":19}],51:[function(require,module,exports){
var element = require('./element');
var parse = require('./parse');

/**
 * The only (relevant) data structure
 */
exports.Element = element.Element;
/**
 * Helper
 */
exports.escapeXml = element.escapeXml;

/**
 * DOM parser interface
 */
exports.parse = parse.parse;
exports.Parser = parse.Parser;
/**
 * SAX parser interface
 */
exports.availableSaxParsers = parse.availableSaxParsers;
exports.bestSaxParser = parse.bestSaxParser;

},{"./element":58,"./parse":59}],60:[function(require,module,exports){
(function(process){/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = setImmediate;
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                }
            }));
        });
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _each(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor !== Array) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (test()) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (!test()) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if(data.constructor !== Array) {
              data = [data];
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain) cargo.drain();
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.compose = function (/* functions... */) {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // Node.js
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

})(require("__browserify_process"))
},{"__browserify_process":9}],31:[function(require,module,exports){
(function(process,Buffer){var CombinedStream = require('combined-stream');
var util = require('util');
var path = require('path');
var http = require('http');
var https = require('https');
var parseUrl = require('url').parse;
var fs = require('fs');
var mime = require('mime');
var async = require('async');

module.exports = FormData;
function FormData() {
  this._overheadLength = 0;
  this._valueLength = 0;
  this._lengthRetrievers = [];

  CombinedStream.call(this);
}
util.inherits(FormData, CombinedStream);

FormData.LINE_BREAK = '\r\n';

FormData.prototype.append = function(field, value, options) {
  options = options || {};

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value == 'number') value = ''+value;

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter(field, value, options);

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;

  // used w/ trackLengthSync(), when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header) +
    + FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response
  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {
    return;
  }

  this._lengthRetrievers.push(function(next) {

    // do we already know the size?
    // 0 additional leaves value from getSyncLength()
    if (options.knownLength != null) {
      next(null, 0);

    // check if it's local file
    } else if (value.hasOwnProperty('fd')) {
      fs.stat(value.path, function(err, stat) {
        if (err) {
          next(err);
          return;
        }

        next(null, stat.size);
      });

    // or http response
    } else if (value.hasOwnProperty('httpVersion')) {
      next(null, +value.headers['content-length']);

    // or request stream http://github.com/mikeal/request
    } else if (value.hasOwnProperty('httpModule')) {
      // wait till response come back
      value.on('response', function(response) {
        value.pause();
        next(null, +response.headers['content-length']);
      });
      value.resume();

    // something else
    } else {
      next('Unknown stream');
    }
  });
};

FormData.prototype._multiPartHeader = function(field, value, options) {
  var boundary = this.getBoundary();
  var header = '';

  // custom header specified (as string)?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers)
  if (options.header != null) {
    header = options.header;
  } else {
    header += '--' + boundary + FormData.LINE_BREAK +
      'Content-Disposition: form-data; name="' + field + '"';

    // fs- and request- streams have path property
    // or use custom filename and/or contentType
    // TODO: Use request's response mime-type
    if (options.filename || value.path) {
      header +=
        '; filename="' + path.basename(options.filename || value.path) + '"' + FormData.LINE_BREAK +
        'Content-Type: ' +  (options.contentType || mime.lookup(options.filename || value.path));

    // http response has not
    } else if (value.readable && value.hasOwnProperty('httpVersion')) {
      header +=
        '; filename="' + path.basename(value.client._httpMessage.path) + '"' + FormData.LINE_BREAK +
        'Content-Type: ' + value.headers['content-type'];
    }

    header += FormData.LINE_BREAK + FormData.LINE_BREAK;
  }

  return header;
};

FormData.prototype._multiPartFooter = function(field, value, options) {
  return function(next) {
    var footer = FormData.LINE_BREAK;

    var lastPart = (this._streams.length === 0);
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function() {
  return '--' + this.getBoundary() + '--';
};

FormData.prototype.getHeaders = function(userHeaders) {
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (var header in userHeaders) {
    formHeaders[header.toLowerCase()] = userHeaders[header];
  }

  return formHeaders;
}

FormData.prototype.getCustomHeaders = function(contentType) {
    contentType = contentType ? contentType : 'multipart/form-data';

    var formHeaders = {
        'content-type': contentType + '; boundary=' + this.getBoundary(),
        'content-length': this.getLengthSync()
    };

    return formHeaders;
}

FormData.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData.prototype._generateBoundary = function() {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

FormData.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;

    if (this._streams.length) {
        knownLength += this._lastBoundary().length;
    }

    return knownLength;
};

FormData.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._lengthRetrievers.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  async.parallel(this._lengthRetrievers, function(err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function(length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData.prototype.submit = function(params, cb) {
  this.getLength(function(err, length) {

    var request
      , options
      , defaults = {
          method : 'post',
          port   : 80,
          headers: this.getHeaders({'Content-Length': length})
      };

    // parse provided url if it's string
    // or treat it as options object
    if (typeof params == 'string') {
      params = parseUrl(params);

      options = populate({
        port: params.port,
        path: params.pathname,
        host: params.hostname
      }, defaults);
    }
    else // use custom params
    {
      options = populate(params, defaults);
    }

    // https if specified, fallback to http in any other case
    if (params.protocol == 'https:') {
      // override default port
      if (!params.port) options.port = 443;
      request = https.request(options);
    } else {
      request = http.request(options);
    }

    this.pipe(request);
    if (cb) {
      request.on('error', cb);
      request.on('response', cb.bind(this, null));
    }

    return request;
  }.bind(this));
};

/*
 * Santa's little helpers
 */

// populates missing values
function populate(dst, src) {
  for (var prop in src) {
    if (!dst[prop]) dst[prop] = src[prop];
  }
  return dst;
}

})(require("__browserify_process"),require("__browserify_buffer").Buffer)
},{"util":5,"path":33,"http":7,"https":6,"url":1,"fs":34,"combined-stream":61,"async":60,"mime":23,"__browserify_process":9,"__browserify_buffer":19}],58:[function(require,module,exports){
/**
 * This cheap replica of DOM/Builder puts me to shame :-)
 *
 * Attributes are in the element.attrs object. Children is a list of
 * either other Elements or Strings for text content.
 **/
function Element(name, attrs) {
    this.name = name;
    this.parent = null;
    this.attrs = attrs || {};
    this.children = [];
}

/*** Accessors ***/

/**
 * if (element.is('message', 'jabber:client')) ...
 **/
Element.prototype.is = function(name, xmlns) {
    return this.getName() == name &&
        (!xmlns || this.getNS() == xmlns);
};

/* without prefix */
Element.prototype.getName = function() {
    if (this.name.indexOf(":") >= 0)
        return this.name.substr(this.name.indexOf(":") + 1);
    else
        return this.name;
};

/**
 * retrieves the namespace of the current element, upwards recursively
 **/
Element.prototype.getNS = function() {
    if (this.name.indexOf(":") >= 0) {
        var prefix = this.name.substr(0, this.name.indexOf(":"));
        return this.findNS(prefix);
    } else {
        return this.findNS();
    }
};

/**
 * find the namespace to the given prefix, upwards recursively
 **/
Element.prototype.findNS = function(prefix) {
    if (!prefix) {
        /* default namespace */
        if (this.attrs.xmlns)
            return this.attrs.xmlns;
        else if (this.parent)
            return this.parent.findNS();
    } else {
        /* prefixed namespace */
        var attr = 'xmlns:' + prefix;
        if (this.attrs[attr])
            return this.attrs[attr];
        else if (this.parent)
            return this.parent.findNS(prefix);
    }
};

/**
 * xmlns can be null
 **/
Element.prototype.getChild = function(name, xmlns) {
    return this.getChildren(name, xmlns)[0];
};

/**
 * xmlns can be null
 **/
Element.prototype.getChildren = function(name, xmlns) {
    var result = [];
    for(var i = 0; i < this.children.length; i++) {
	      var child = this.children[i];
        if (child.getName &&
            child.getName() == name &&
            (!xmlns || child.getNS() == xmlns))
            result.push(child);
    }
    return result;
};

/**
 * xmlns and recursive can be null
 **/
Element.prototype.getChildByAttr = function(attr, val, xmlns, recursive) {
    return this.getChildrenByAttr(attr, val, xmlns, recursive)[0];
};

/**
 * xmlns and recursive can be null
 **/
Element.prototype.getChildrenByAttr = function(attr, val, xmlns, recursive) {
    var result = [];
    for(var i = 0; i < this.children.length; i++) {
	      var child = this.children[i];
        if (child.attrs &&
            child.attrs[attr] == val &&
            (!xmlns || child.getNS() == xmlns))
            result.push(child);
        if (recursive && child.getChildrenByAttr)
            result.push(child.getChildrenByAttr(attr, val, xmlns, true));
    }
    if (recursive) result = [].concat.apply([], result);
    return result;
};

Element.prototype.getChildrenByFilter = function(filter, recursive) {
    var result = [];
    for(var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        if (filter(child))
            result.push(child);
        if (recursive && child.getChildrenByFilter){
            result.push(child.getChildrenByFilter(filter, true));
        }
    }
    if (recursive){
      result = [].concat.apply([], result);
    }
    return result;
};

Element.prototype.getText = function() {
    var text = "";
    for(var i = 0; i < this.children.length; i++) {
	var child = this.children[i]
        if (typeof child == 'string' || typeof child == 'number')
            text += child;
    }
    return text;
};

Element.prototype.getChildText = function(name, xmlns) {
    var child = this.getChild(name, xmlns);
    return child ? child.getText() : null;
};

/*** Builder ***/

/** returns uppermost parent */
Element.prototype.root = function() {
    if (this.parent)
        return this.parent.root();
    else
        return this;
};
Element.prototype.tree = Element.prototype.root;

/** just parent or itself */
Element.prototype.up = function() {
    if (this.parent)
        return this.parent;
    else
        return this;
};

/** create child node and return it */
Element.prototype.c = function(name, attrs) {
    return this.cnode(new Element(name, attrs));
};

Element.prototype.cnode = function(child) {
    this.children.push(child);
    child.parent = this;
    return child;
};

/** add text node and return element */
Element.prototype.t = function(text) {
    this.children.push(text);
    return this;
};

/*** Manipulation ***/

/**
 * Either:
 *   el.remove(childEl);
 *   el.remove('author', 'urn:...');
 */
Element.prototype.remove = function(el, xmlns) {
    var filter;
    if (typeof el === 'string') {
	/* 1st parameter is tag name */
	filter = function(child) {
	    return !(child.is &&
		     child.is(el, xmlns));
	};
    } else {
	/* 1st parameter is element */
	filter = function(child) {
	    return child !== el;
	};
    }

    this.children = this.children.filter(filter);

    return this;
};

/**
 * To use in case you want the same XML data for separate uses.
 * Please refrain from this practise unless you know what you are
 * doing. Building XML with ltx is easy!
 */
Element.prototype.clone = function() {
    var clone = new Element(this.name, {});
    for(var k in this.attrs) {
	if (this.attrs.hasOwnProperty(k))
	    clone.attrs[k] = this.attrs[k];
    }
    for(var i = 0; i < this.children.length; i++) {
	var child = this.children[i];
	clone.cnode(child.clone ? child.clone() : child);
    }
    return clone;
};

Element.prototype.text = function(val) {
    if(val && this.children.length == 1){
        this.children[0] = val;
        return this;
    }
    return this.getText();
};

Element.prototype.attr = function(attr, val) {
    if (!(typeof val === 'undefined' || val === null)) {
        if(!this.attrs){
          this.attrs = {};
        }
        this.attrs[attr] = val;
        return this;
    }
    return this.attrs[attr];
};

/*** Serialization ***/

Element.prototype.toString = function() {
    var s = "";
    this.write(function(c) {
        s += c;
    });
    return s;
};

Element.prototype.write = function(writer) {
    writer("<");
    writer(this.name);
    for(var k in this.attrs) {
        var v = this.attrs[k];
	if (v || v === '' || v === 0) {
	    writer(" ");
            writer(k);
            writer("=\"");
            if (typeof v != 'string')
		v = v.toString();
            writer(escapeXml(v));
            writer("\"");
	}
    }
    if (this.children.length == 0) {
        writer("/>");
    } else {
        writer(">");
	for(var i = 0; i < this.children.length; i++) {
	    var child = this.children[i];
	    /* Skip null/undefined */
	    if (child || child === 0) {
		if (child.write)
		    child.write(writer);
		else if (typeof child === 'string')
			writer(escapeXmlText(child));
		else if (child.toString)
			writer(escapeXmlText(child.toString()));
	    }
        }
        writer("</");
        writer(this.name);
        writer(">");
    }
};

function escapeXml(s) {
    return s.
        replace(/\&/g, '&amp;').
        replace(/</g, '&lt;').
        replace(/>/g, '&gt;').
        replace(/"/g, '&quot;').
        replace(/'/g, '&apos;');
}

function escapeXmlText(s) {
    return s.
        replace(/\&/g, '&amp;').
        replace(/</g, '&lt;').
        replace(/>/g, '&gt;');
}

exports.Element = Element;
exports.escapeXml = escapeXml;

},{}],44:[function(require,module,exports){
// Copyright 2012 Joyent, Inc.  All rights reserved.

var assert = require('assert-plus');
var util = require('util');



///--- Globals

var Algorithms = {
  'rsa-sha1': true,
  'rsa-sha256': true,
  'rsa-sha512': true,
  'dsa-sha1': true,
  'hmac-sha1': true,
  'hmac-sha256': true,
  'hmac-sha512': true
};

var State = {
  New: 0,
  Params: 1
};

var ParamsState = {
  Name: 0,
  Quote: 1,
  Value: 2,
  Comma: 3
};



///--- Specific Errors

function HttpSignatureError(message, caller) {
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, caller || HttpSignatureError);

  this.message = message;
  this.name = caller.name;
}
util.inherits(HttpSignatureError, Error);

function ExpiredRequestError(message) {
  HttpSignatureError.call(this, message, ExpiredRequestError);
}
util.inherits(ExpiredRequestError, HttpSignatureError);


function InvalidHeaderError(message) {
  HttpSignatureError.call(this, message, InvalidHeaderError);
}
util.inherits(InvalidHeaderError, HttpSignatureError);


function InvalidParamsError(message) {
  HttpSignatureError.call(this, message, InvalidParamsError);
}
util.inherits(InvalidParamsError, HttpSignatureError);


function MissingHeaderError(message) {
  HttpSignatureError.call(this, message, MissingHeaderError);
}
util.inherits(MissingHeaderError, HttpSignatureError);



///--- Exported API

module.exports = {

  /**
   * Parses the 'Authorization' header out of an http.ServerRequest object.
   *
   * Note that this API will fully validate the Authorization header, and throw
   * on any error.  It will not however check the signature, or the keyId format
   * as those are specific to your environment.  You can use the options object
   * to pass in extra constraints.
   *
   * As a response object you can expect this:
   *
   *     {
   *       "scheme": "Signature",
   *       "params": {
   *         "keyId": "foo",
   *         "algorithm": "rsa-sha256",
   *         "headers": [
   *           "date" or "x-date",
   *           "content-md5"
   *         ],
   *         "signature": "base64"
   *       },
   *       "signingString": "ready to be passed to crypto.verify()"
   *     }
   *
   * @param {Object} request an http.ServerRequest.
   * @param {Object} options an optional options object with:
   *                   - clockSkew: allowed clock skew in seconds (default 300).
   *                   - headers: required header names (def: date or x-date)
   *                   - algorithms: algorithms to support (default: all).
   * @return {Object} parsed out object (see above).
   * @throws {TypeError} on invalid input.
   * @throws {InvalidHeaderError} on an invalid Authorization header error.
   * @throws {InvalidParamsError} if the params in the scheme are invalid.
   * @throws {MissingHeaderError} if the params indicate a header not present,
   *                              either in the request headers from the params,
   *                              or not in the params from a required header
   *                              in options.
   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.
   */
  parseRequest: function parseRequest(request, options) {
    assert.object(request, 'request');
    assert.object(request.headers, 'request.headers');
    if (options === undefined) {
      options = {};
    }
    if (options.headers === undefined) {
      options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];
    }
    assert.object(options, 'options');
    assert.arrayOfString(options.headers, 'options.headers');
    assert.optionalNumber(options.clockSkew, 'options.clockSkew');

    if (!request.headers.authorization)
      throw new MissingHeaderError('no authorization header present in ' +
                                   'the request');

    options.clockSkew = options.clockSkew || 300;


    var i = 0;
    var state = State.New;
    var substate = ParamsState.Name;
    var tmpName = '';
    var tmpValue = '';

    var parsed = {
      scheme: '',
      params: {},
      signingString: '',

      get algorithm() {
        return this.params.algorithm.toUpperCase();
      },

      get keyId() {
        return this.params.keyId;
      }

    };

    var authz = request.headers.authorization;
    for (i = 0; i < authz.length; i++) {
      var c = authz.charAt(i);

      switch (Number(state)) {

      case State.New:
        if (c !== ' ') parsed.scheme += c;
        else state = State.Params;
        break;

      case State.Params:
        switch (Number(substate)) {

        case ParamsState.Name:
          var code = c.charCodeAt(0);
          // restricted name of A-Z / a-z
          if ((code >= 0x41 && code <= 0x5a) || // A-Z
              (code >= 0x61 && code <= 0x7a)) { // a-z
            tmpName += c;
          } else if (c === '=') {
            if (tmpName.length === 0)
              throw new InvalidHeaderError('bad param format');
            substate = ParamsState.Quote;
          } else {
            throw new InvalidHeaderError('bad param format');
          }
          break;

        case ParamsState.Quote:
          if (c === '"') {
            tmpValue = '';
            substate = ParamsState.Value;
          } else {
            throw new InvalidHeaderError('bad param format');
          }
          break;

        case ParamsState.Value:
          if (c === '"') {
            parsed.params[tmpName] = tmpValue;
            substate = ParamsState.Comma;
          } else {
            tmpValue += c;
          }
          break;

        case ParamsState.Comma:
          if (c === ',') {
            tmpName = '';
            substate = ParamsState.Name;
          } else {
            throw new InvalidHeaderError('bad param format');
          }
          break;

        default:
          throw new Error('Invalid substate');
        }
        break;

      default:
        throw new Error('Invalid substate');
      }

    }

    if (!parsed.params.headers || parsed.params.headers === '') {
      if (request.headers['x-date']) {
        parsed.params.headers = ['x-date'];
      } else {
        parsed.params.headers = ['date'];
      }
    } else {
      parsed.params.headers = parsed.params.headers.split(' ');
    }

    // Minimally validate the parsed object
    if (!parsed.scheme || parsed.scheme !== 'Signature')
      throw new InvalidHeaderError('scheme was not "Signature"');

    if (!parsed.params.keyId)
      throw new InvalidHeaderError('keyId was not specified');

    if (!parsed.params.algorithm)
      throw new InvalidHeaderError('algorithm was not specified');

    if (!parsed.params.signature)
      throw new InvalidHeaderError('signature was not specified');

    // Check the algorithm against the official list
    parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
    if (!Algorithms[parsed.params.algorithm])
      throw new InvalidParamsError(parsed.params.algorithm +
                                   ' is not supported');

    // Build the signingString
    for (i = 0; i < parsed.params.headers.length; i++) {
      var h = parsed.params.headers[i].toLowerCase();
      parsed.params.headers[i] = h;

      if (h !== 'request-line') {
        var value = request.headers[h];
        if (!value)
          throw new MissingHeaderError(h + ' was not in the request');
        parsed.signingString += h + ': ' + value;
      } else {
        parsed.signingString +=
          request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;
      }

      if ((i + 1) < parsed.params.headers.length)
        parsed.signingString += '\n';
    }

    // Check against the constraints
    var date;
    if (request.headers.date || request.headers['x-date']) {
        if (request.headers['x-date']) {
          date = new Date(request.headers['x-date']);
        } else {
          date = new Date(request.headers.date);
        }
      var now = new Date();
      var skew = Math.abs(now.getTime() - date.getTime());

      if (skew > options.clockSkew * 1000) {
        throw new ExpiredRequestError('clock skew of ' +
                                      (skew / 1000) +
                                      's was greater than ' +
                                      options.clockSkew + 's');
      }
    }

    options.headers.forEach(function (hdr) {
      // Remember that we already checked any headers in the params
      // were in the request, so if this passes we're good.
      if (parsed.params.headers.indexOf(hdr) < 0)
        throw new MissingHeaderError(hdr + ' was not a signed header');
    });

    if (options.algorithms) {
      if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
        throw new InvalidParamsError(parsed.params.algorithm +
                                     ' is not a supported algorithm');
    }

    return parsed;
  }

};

},{"util":5,"assert-plus":62}],45:[function(require,module,exports){
// Copyright 2012 Joyent, Inc.  All rights reserved.

var assert = require('assert-plus');
var crypto = require('crypto');
var http = require('http');

var sprintf = require('util').format;



///--- Globals

var Algorithms = {
  'rsa-sha1': true,
  'rsa-sha256': true,
  'rsa-sha512': true,
  'dsa-sha1': true,
  'hmac-sha1': true,
  'hmac-sha256': true,
  'hmac-sha512': true
};

var Authorization =
  'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';



///--- Specific Errors

function MissingHeaderError(message) {
    this.name = 'MissingHeaderError';
    this.message = message;
    this.stack = (new Error()).stack;
}
MissingHeaderError.prototype = new Error();


function InvalidAlgorithmError(message) {
    this.name = 'InvalidAlgorithmError';
    this.message = message;
    this.stack = (new Error()).stack;
}
InvalidAlgorithmError.prototype = new Error();



///--- Internal Functions

function _pad(val) {
  if (parseInt(val, 10) < 10) {
    val = '0' + val;
  }
  return val;
}


function _rfc1123() {
  var date = new Date();

  var months = ['Jan',
                'Feb',
                'Mar',
                'Apr',
                'May',
                'Jun',
                'Jul',
                'Aug',
                'Sep',
                'Oct',
                'Nov',
                'Dec'];
  var days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  return days[date.getUTCDay()] + ', ' +
    _pad(date.getUTCDate()) + ' ' +
    months[date.getUTCMonth()] + ' ' +
    date.getUTCFullYear() + ' ' +
    _pad(date.getUTCHours()) + ':' +
    _pad(date.getUTCMinutes()) + ':' +
    _pad(date.getUTCSeconds()) +
    ' GMT';
}



///--- Exported API

module.exports = {

  /**
   * Adds an 'Authorization' header to an http.ClientRequest object.
   *
   * Note that this API will add a Date header if it's not already set. Any
   * other headers in the options.headers array MUST be present, or this
   * will throw.
   *
   * You shouldn't need to check the return type; it's just there if you want
   * to be pedantic.
   *
   * @param {Object} request an instance of http.ClientRequest.
   * @param {Object} options signing parameters object:
   *                   - {String} keyId required.
   *                   - {String} key required (either a PEM or HMAC key).
   *                   - {Array} headers optional; defaults to ['date'].
   *                   - {String} algorithm optional; defaults to 'rsa-sha256'.
   *                   - {String} httpVersion optional; defaults to '1.1'.
   * @return {Boolean} true if Authorization (and optionally Date) were added.
   * @throws {TypeError} on bad parameter types (input).
   * @throws {InvalidAlgorithmError} if algorithm was bad.
   * @throws {MissingHeaderError} if a header to be signed was specified but
   *                              was not present.
   */
  signRequest: function signRequest(request, options) {
    assert.object(request, 'request');
    assert.object(options, 'options');
    assert.optionalString(options.algorithm, 'options.algorithm');
    assert.string(options.keyId, 'options.keyId');
    assert.optionalArrayOfString(options.headers, 'options.headers');
    assert.optionalString(options.httpVersion, 'options.httpVersion');

    if (!request.getHeader('Date'))
      request.setHeader('Date', _rfc1123());
    if (!options.headers)
      options.headers = ['date'];
    if (!options.algorithm)
      options.algorithm = 'rsa-sha256';
    if (!options.httpVersion)
      options.httpVersion = '1.1';

    options.algorithm = options.algorithm.toLowerCase();

    if (!Algorithms[options.algorithm])
      throw new InvalidAlgorithmError(options.algorithm + ' is not supported');

    var i;
    var stringToSign = '';
    for (i = 0; i < options.headers.length; i++) {
      if (typeof (options.headers[i]) !== 'string')
        throw new TypeError('options.headers must be an array of Strings');

      var h = options.headers[i].toLowerCase();

      if (h !== 'request-line') {
        var value = request.getHeader(h);
        if (!value) {
          throw new MissingHeaderError(h + ' was not in the request');
        }
        stringToSign += h + ': ' + value;
      } else {
        value =
        stringToSign +=
          request.method + ' ' + request.path + ' HTTP/' + options.httpVersion;
      }

      if ((i + 1) < options.headers.length)
        stringToSign += '\n';
    }

    var alg = options.algorithm.match(/(hmac|rsa)-(\w+)/);
    var signature;
    if (alg[1] === 'hmac') {
      var hmac = crypto.createHmac(alg[2].toUpperCase(), options.key);
      hmac.update(stringToSign);
      signature = hmac.digest('base64');
    } else {
      var signer = crypto.createSign(options.algorithm.toUpperCase());
      signer.update(stringToSign);
      signature = signer.sign(options.key, 'base64');
    }

    request.setHeader('Authorization', sprintf(Authorization,
                                               options.keyId,
                                               options.algorithm,
                                               options.headers.join(' '),
                                               signature));

    return true;
  }

};

},{"crypto":11,"http":7,"util":5,"assert-plus":62}],46:[function(require,module,exports){
(function(Buffer){// Copyright 2012 Joyent, Inc.  All rights reserved.

var assert = require('assert-plus');
var crypto = require('crypto');

var asn1 = require('asn1');
var ctype = require('ctype');



///--- Helpers

function readNext(buffer, offset) {
  var len = ctype.ruint32(buffer, 'big', offset);
  offset += 4;

  var newOffset = offset + len;

  return {
    data: buffer.slice(offset, newOffset),
    offset: newOffset
  };
}


function writeInt(writer, buffer) {
  writer.writeByte(0x02); // ASN1.Integer
  writer.writeLength(buffer.length);

  for (var i = 0; i < buffer.length; i++)
    writer.writeByte(buffer[i]);

  return writer;
}


function rsaToPEM(key) {
  var buffer;
  var der;
  var exponent;
  var i;
  var modulus;
  var newKey = '';
  var offset = 0;
  var type;
  var tmp;

  try {
    buffer = new Buffer(key.split(' ')[1], 'base64');

    tmp = readNext(buffer, offset);
    type = tmp.data.toString();
    offset = tmp.offset;

    if (type !== 'ssh-rsa')
      throw new Error('Invalid ssh key type: ' + type);

    tmp = readNext(buffer, offset);
    exponent = tmp.data;
    offset = tmp.offset;

    tmp = readNext(buffer, offset);
    modulus = tmp.data;
  } catch (e) {
    throw new Error('Invalid ssh key: ' + key);
  }

  // DER is a subset of BER
  der = new asn1.BerWriter();

  der.startSequence();

  der.startSequence();
  der.writeOID('1.2.840.113549.1.1.1');
  der.writeNull();
  der.endSequence();

  der.startSequence(0x03); // bit string
  der.writeByte(0x00);

  // Actual key
  der.startSequence();
  writeInt(der, modulus);
  writeInt(der, exponent);
  der.endSequence();

  // bit string
  der.endSequence();

  der.endSequence();

  tmp = der.buffer.toString('base64');
  for (i = 0; i < tmp.length; i++) {
    if ((i % 64) === 0)
      newKey += '\n';
    newKey += tmp.charAt(i);
  }

  if (!/\\n$/.test(newKey))
    newKey += '\n';

  return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\n';
}


function dsaToPEM(key) {
  var buffer;
  var offset = 0;
  var tmp;
  var der;
  var newKey = '';

  var type;
  var p;
  var q;
  var g;
  var y;

  try {
    buffer = new Buffer(key.split(' ')[1], 'base64');

    tmp = readNext(buffer, offset);
    type = tmp.data.toString();
    offset = tmp.offset;

    /* JSSTYLED */
    if (!/^ssh-ds[as].*/.test(type))
      throw new Error('Invalid ssh key type: ' + type);

    tmp = readNext(buffer, offset);
    p = tmp.data;
    offset = tmp.offset;

    tmp = readNext(buffer, offset);
    q = tmp.data;
    offset = tmp.offset;

    tmp = readNext(buffer, offset);
    g = tmp.data;
    offset = tmp.offset;

    tmp = readNext(buffer, offset);
    y = tmp.data;
  } catch (e) {
    console.log(e.stack);
    throw new Error('Invalid ssh key: ' + key);
  }

  // DER is a subset of BER
  der = new asn1.BerWriter();

  der.startSequence();

  der.startSequence();
  der.writeOID('1.2.840.10040.4.1');

  der.startSequence();
  writeInt(der, p);
  writeInt(der, q);
  writeInt(der, g);
  der.endSequence();

  der.endSequence();

  der.startSequence(0x03); // bit string
  der.writeByte(0x00);
  writeInt(der, y);
  der.endSequence();

  der.endSequence();

  tmp = der.buffer.toString('base64');
  for (var i = 0; i < tmp.length; i++) {
    if ((i % 64) === 0)
      newKey += '\n';
    newKey += tmp.charAt(i);
  }

  if (!/\\n$/.test(newKey))
    newKey += '\n';

  return '-----BEGIN PUBLIC KEY-----' + newKey + '-----END PUBLIC KEY-----\n';
}


///--- API

module.exports = {

  /**
   * Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.
   *
   * The intent of this module is to interoperate with OpenSSL only,
   * specifically the node crypto module's `verify` method.
   *
   * @param {String} key an OpenSSH public key.
   * @return {String} PEM encoded form of the RSA public key.
   * @throws {TypeError} on bad input.
   * @throws {Error} on invalid ssh key formatted data.
   */
  sshKeyToPEM: function sshKeyToPEM(key) {
    assert.string(key, 'ssh_key');

    /* JSSTYLED */
    if (/^ssh-rsa.*/.test(key))
      return rsaToPEM(key);

    /* JSSTYLED */
    if (/^ssh-ds[as].*/.test(key))
      return dsaToPEM(key);

    throw new Error('Only RSA and DSA public keys are allowed');
  },


  /**
   * Generates an OpenSSH fingerprint from an ssh public key.
   *
   * @param {String} key an OpenSSH public key.
   * @return {String} key fingerprint.
   * @throws {TypeError} on bad input.
   * @throws {Error} if what you passed doesn't look like an ssh public key.
   */
  fingerprint: function fingerprint(key) {
    assert.string(key, 'ssh_key');

    var pieces = key.split(' ');
    if (!pieces || !pieces.length || pieces.length < 2)
      throw new Error('invalid ssh key');

    var data = new Buffer(pieces[1], 'base64');

    var hash = crypto.createHash('md5');
    hash.update(data);
    var digest = hash.digest('hex');

    var fp = '';
    for (var i = 0; i < digest.length; i++) {
      if (i && i % 2 === 0)
        fp += ':';

      fp += digest[i];
    }

    return fp;
  }


};

})(require("__browserify_buffer").Buffer)
},{"crypto":11,"assert-plus":62,"asn1":63,"ctype":64,"__browserify_buffer":19}],47:[function(require,module,exports){
// Copyright 2011 Joyent, Inc.  All rights reserved.

var assert = require('assert-plus');
var crypto = require('crypto');



///--- Exported API

module.exports = {

  /**
   * Simply wraps up the node crypto operations for you, and returns
   * true or false.  You are expected to pass in an object that was
   * returned from `parse()`.
   *
   * @param {Object} parsedSignature the object you got from `parse`.
   * @param {String} key either an RSA private key PEM or HMAC secret.
   * @return {Boolean} true if valid, false otherwise.
   * @throws {TypeError} if you pass in bad arguments.
   */
  verifySignature: function verifySignature(parsedSignature, key) {
    assert.object(parsedSignature, 'parsedSignature');
    assert.string(key, 'key');

    var alg = parsedSignature.algorithm.match(/(HMAC|RSA|DSA)-(\w+)/);
    if (!alg || alg.length !== 3)
      throw new TypeError('parsedSignature: unsupported algorithm ' +
                          parsedSignature.algorithm);

    if (alg[1] === 'HMAC') {
      var hmac = crypto.createHmac(alg[2].toUpperCase(), key);
      hmac.update(parsedSignature.signingString);
      return (hmac.digest('base64') === parsedSignature.params.signature);
    } else {
      var verify = crypto.createVerify(alg[0]);
      verify.update(parsedSignature.signingString);
      return verify.verify(key, parsedSignature.params.signature, 'base64');
    }
  }

};

},{"crypto":11,"assert-plus":62}],56:[function(require,module,exports){
var util = require('util');
var EventEmitter = require('events').EventEmitter;
var ltx = require('ltx');
var Stanza = require('./stanza').Stanza;

/**
 * Recognizes <stream:stream> and collects stanzas; used for ordinary
 * TCP streams and Websockets.
 *
 * API: write(data) & end(data)
 * Events: streamStart, stanza, end, error
 */
function StreamParser(maxStanzaSize) {
    EventEmitter.call(this);

    var self = this;
    this.parser = new ltx.bestSaxParser();

    /* Count traffic for entire life-time */
    this.bytesParsed = 0;
    this.maxStanzaSize = maxStanzaSize;
    /* Will be reset upon first stanza, but enforce maxStanzaSize until it is parsed */
    this.bytesParsedOnStanzaBegin = 0;

    this.parser.addListener('startElement', function(name, attrs) {
        // TODO: refuse anything but <stream:stream>
        if (!self.element && name == 'stream:stream') {
            self.emit('streamStart', attrs);
        } else {
	    var child;
            if (!self.element) {
                /* A new stanza */
		child = new Stanza(name, attrs);
                self.element = child;
		/* For maxStanzaSize enforcement */
                self.bytesParsedOnStanzaBegin = self.bytesParsed;
            } else {
                /* A child element of a stanza */
		child = new ltx.Element(name, attrs);
                self.element = self.element.cnode(child);
            }
        }
    });

    this.parser.addListener('endElement', function(name) {
        if (!self.element && name == 'stream:stream') {
            self.end();
        } else if (self.element && name == self.element.name) {
            if (self.element.parent)
                self.element = self.element.parent;
            else {
                /* Stanza complete */
                self.emit('stanza', self.element);
                delete self.element;
		/* maxStanzaSize doesn't apply until next startElement */
                delete self.bytesParsedOnStanzaBegin;
            }
        } else {
            self.error('xml-not-well-formed', 'XML parse error');
        }
    });
    
    this.parser.addListener('text', function(str) {
        if (self.element)
            self.element.t(str);
    });
    
    this.parser.addListener('entityDecl', function() {
	/* Entity declarations are forbidden in XMPP. We must abort to
	 * avoid a billion laughs.
	 */
	self.error('xml-not-well-formed', 'No entity declarations allowed');
	self.end();
    });

    this.parser.addListener('error', function(error) {
	self.emit('error', error);
    });
}
util.inherits(StreamParser, EventEmitter);
exports.StreamParser = StreamParser;

StreamParser.prototype.write = function(data) {
    /*if (/^<stream:stream [^>]+\/>$/.test(data)) {
	data = data.replace(/\/>$/, ">");
    }*/
    if (this.parser) {
	/* If a maxStanzaSize is configured, the current stanza must consist only of this many bytes */
        if (this.bytesParsedOnStanzaBegin && this.maxStanzaSize &&
            this.bytesParsed > this.bytesParsedOnStanzaBegin + this.maxStanzaSize) {

            this.error('policy-violation', 'Maximum stanza size exceeded');
            return;
        }
        this.bytesParsed += data.length;

        this.parser.write(data);
    }
};

StreamParser.prototype.end = function(data) {
    if (data) {
        this.write(data);
    }

    delete this.parser;
    this.emit('end');
};

StreamParser.prototype.error = function(condition, message) {
    var e = new Error(message);
    e.condition = condition;
    this.emit('error', e);
};

},{"util":5,"events":4,"./stanza":38,"ltx":39}],57:[function(require,module,exports){
(function(process){var querystring = require('querystring');
var util = require('util');
var EventEmitter = require('events').EventEmitter;

/**
 * What's available for client-side authentication (Client)
 *
 * @param {Array} mechs Server-offered SASL mechanism names
 */
function selectMechanism(offeredMechs, preferredMech, availableMech) {
    var mechClasses = [XOAuth2, XFacebookPlatform, DigestMD5,
		       Plain, Anonymous];
    var byName = {};
    var mech;
    if (Array.isArray(availableMech)) {
        mechClasses = mechClasses.concat(availableMech);
    }
    mechClasses.forEach(function(mechClass) {
	byName[mechClass.prototype.name] = mechClass;
    });
    /* Any preferred? */
    if (byName[preferredMech]) {
	mech = byName[preferredMech];
    }
    /* By priority */
    mechClasses.forEach(function(mechClass) {
	if (!mech &&
	    offeredMechs.indexOf(mechClass.prototype.name) >= 0)
	    mech = mechClass;
    });

    return mech ? new mech() : null;
}

exports.selectMechanism = selectMechanism;

/**
 * What's available for server-side authentication (C2S)
 */
function availableMechanisms(availableMech) {
    var mechanisms = [new Plain()];
    if (availableMech) {
        mechanisms = mechanisms.concat(availableMech);
    }
    return mechanisms;
}
exports.availableMechanisms = availableMechanisms;

// Mechanisms
function Mechanism() {
}
util.inherits(Mechanism, EventEmitter);
Mechanism.prototype.authAttrs = function() {
    return {};
};

function Plain() {
}
util.inherits(Plain, Mechanism);
Plain.prototype.name = "PLAIN";
Plain.prototype.auth = function() {
    return this.authzid + "\0" +
        this.authcid + "\0" +
        this.password;
};
Plain.prototype.authServer = function(auth, client) {
    var params = auth.split("\x00");
    this.username = params[1];
    client.authenticate(this.username, params[2]);
};

function XOAuth2() {
}
util.inherits(XOAuth2, Mechanism);
XOAuth2.prototype.name = "X-OAUTH2";
XOAuth2.prototype.auth = function() {
    return "\0" + this.authzid + "\0" + this.oauth2_token;
};
XOAuth2.prototype.authServer = function(auth, client) {
    var params = auth.split("\x00");
    this.username = params[1];
    client.authenticate(this.username, params[2]);
};
XOAuth2.prototype.authAttrs = function() {
    return { "auth:service": "oauth2",
	     "xmlns:auth": this.oauth2_auth
    };
};

function XFacebookPlatform() {
}
util.inherits(XFacebookPlatform, Mechanism);
XFacebookPlatform.prototype.name = "X-FACEBOOK-PLATFORM";
XFacebookPlatform.prototype.auth = function() {
    return "";
};
XFacebookPlatform.prototype.challenge = function(s) {
    var dict = querystring.parse(s);

    var response = {
        api_key: this.api_key,
        call_id: new Date().getTime(),
        method: dict.method,
        nonce: dict.nonce,
        access_token: this.access_token,
        v: "1.0"
    };

    return querystring.stringify(response);
};

function Anonymous() {
}
util.inherits(Anonymous, Mechanism);
Anonymous.prototype.name = "ANONYMOUS";
Anonymous.prototype.auth = function() {
    return this.authzid;
};

function External() {
}
util.inherits(External, Mechanism);
External.prototype.name = "EXTERNAL";
External.prototype.auth = function() {
    return(this.authzid);
};

exports.External = External;

function DigestMD5() {
    this.nonce_count = 0;
    this.cnonce = generateNonce();
}
util.inherits(DigestMD5, Mechanism);
DigestMD5.prototype.name = "DIGEST-MD5";
DigestMD5.prototype.auth = function() {
    return "";
};
DigestMD5.prototype.getNC = function() {
    return rjust(this.nonce_count.toString(), 8, '0');
};
DigestMD5.prototype.responseValue = function(s) {
    var dict = parseDict(s);
    if (dict.realm)
        this.realm = dict.realm;

    var value;
    if (dict.nonce && dict.qop) {
        this.nonce_count++;
        var a1 = md5(this.authcid + ':' +
                     this.realm + ':' +
                     this.password) + ':' +
                     dict.nonce + ':' +
                     this.cnonce;
        if (this.actAs) a1 += ":" + this.actAs

        var a2 = "AUTHENTICATE:" + this.digest_uri;
        if (dict.qop == 'auth-int' || dict.qop == 'auth-conf')
            a2 += ":00000000000000000000000000000000";

        value = md5_hex(md5_hex(a1) + ':' +
                        dict.nonce + ':' +
                        this.getNC() + ':' +
                        this.cnonce + ':' +
                        dict.qop + ':' +
                        md5_hex(a2));
    }
    return value;
};

DigestMD5.prototype.challenge = function(s) {
    var dict = parseDict(s);
    if (dict.realm)
        this.realm = dict.realm;

    var response;
    if (dict.nonce && dict.qop) {
        var responseValue = this.responseValue(s);
        response = {
            username: this.authcid,
            realm: this.realm,
            nonce: dict.nonce,
            cnonce: this.cnonce,
            nc: this.getNC(),
            qop: dict.qop,
            'digest-uri': this.digest_uri,
            response: responseValue,
            charset: 'utf-8'
        };
        if (this.actAs) response['authzid'] = this.actAs
    } else if (dict.rspauth) {
        return "";
    }
    return encodeDict(response);
};
DigestMD5.prototype.serverChallenge = function() {
    var dict = {};
    dict.realm = "";
    this.nonce = dict.nonce = generateNonce();
    dict.qop = "auth";
    this.charset = dict.charset = "utf-8";
    dict.algorithm = "md5-sess";
    return encodeDict(dict);
};

// Used on the server to check for auth!
DigestMD5.prototype.response = function(s) {
    var dict = parseDict(s);
    this.authcid = dict.username;
    if(dict.nonce != this.nonce) {
        return false;
    }
    if(!dict.cnonce) {
        return false;
    }
    this.cnonce = dict.cnonce;
    if(this.charset != dict.charset) {
        return false;
    }
    this.response = dict.response;
    return true;
};

/**
 * Parse SASL serialization
 */
function parseDict(s) {
    var result = {};
    while (s) {
        var m;
        if((m = /^(.+?)=(.*?[^\\]),(.*)/.exec(s))) {
            result[m[1]] = m[2].replace(/\"/g, '');
            s = m[3];
        } else if ((m = /^(.+?)=(.+?),(.*)/.exec(s))) {
            result[m[1]] = m[2];
            s = m[3];
        } else if ((m = /^(.+?)="(.*?[^\\])"$/.exec(s))) {
            result[m[1]] = m[2];
            s = m[3];
        } else if ((m = /^(.+?)=(.+?)$/.exec(s))) {
            result[m[1]] = m[2];
            s = m[3];
        } else {
            s = null;
        }
    }
    return result;
}

/**
 * SASL serialization
 */
function encodeDict(dict) {
    var s = "";
    for(k in dict) {
        var v = dict[k];
        if (v)
            s += ',' + k + '="' + v + '"';
    }
    return s.substr(1);  // without first ','
}

/**
 * Right-justify a string,
 * eg. pad with 0s
 */
function rjust(s, targetLen, padding) {
    while(s.length < targetLen)
        s = padding + s;
    return s;
}

/**
 * Hash a string
 */
var md5, md5_hex;
if (process.title !== 'browser') {
    var crypto = require('crypto');
    md5 = function(s, encoding) {
	var hash = crypto.createHash('md5');
	hash.update(s);
	return hash.digest(encoding || 'binary');
    };
    md5_hex = function(s) {
	return md5(s, 'hex');
    };
} else {
    var md5lib = require('blueimp-md5').md5;
    console.log("md5lib",md5lib);
    md5 = function(s) {
	console.log("md5", s, md5lib(s, null, true));
	return md5lib(s, null, true);
    };
    md5_hex = function(s) {
	console.log("md5_hex", s, md5lib(s));
	return md5lib(s);
    };
}

/**
 * Generate a string of 8 digits
 * (number used once)
 */
function generateNonce() {
    var result = "";
    for(var i = 0; i < 8; i++)
        result += String.fromCharCode(48 +
                                      Math.ceil(Math.random() * 10));
    return result;
}

})(require("__browserify_process"))
},{"querystring":2,"util":5,"events":4,"crypto":11,"blueimp-md5":65,"__browserify_process":9}],66:[function(require,module,exports){
// Load modules

var Crypto = require('crypto');
var Url = require('url');
var Utils = require('./utils');


// Declare internals

var internals = {};


// MAC normalization format version

exports.headerVersion = '1';                        // Prevent comparison of mac values generated with different normalized string formats


// Supported HMAC algorithms

exports.algorithms = ['sha1', 'sha256'];


// Calculate the request MAC

/*
    type: 'header',                                 // 'header', 'bewit', 'response'
    credentials: {
        key: 'aoijedoaijsdlaksjdl',
        algorithm: 'sha256'                         // 'sha1', 'sha256'
    },
    options: {
        method: 'GET',
        resource: '/resource?a=1&b=2',
        host: 'example.com',
        port: 8080,
        ts: 1357718381034,
        nonce: 'd3d345f',
        hash: 'U4MKKSmiVxk37JCCrAVIjV/OhB3y+NdwoCr6RShbVkE=',
        ext: 'app-specific-data',
        app: 'hf48hd83qwkj',                        // Application id (Oz)
        dlg: 'd8djwekds9cj'                         // Delegated by application id (Oz), requires options.app
    }
*/

exports.calculateMac = function (type, credentials, options) {

    var normalized = exports.generateNormalizedString(type, options);

    var hmac = Crypto.createHmac(credentials.algorithm, credentials.key).update(normalized);
    var digest = hmac.digest('base64');
    return digest;
};


exports.generateNormalizedString = function (type, options) {

    var normalized = 'hawk.' + exports.headerVersion + '.' + type + '\n' +
                     options.ts + '\n' +
                     options.nonce + '\n' +
                     options.method.toUpperCase() + '\n' +
                     options.resource + '\n' +
                     options.host.toLowerCase() + '\n' +
                     options.port + '\n' +
                     (options.hash || '') + '\n';

    if (options.ext) {
        normalized += options.ext.replace('\\', '\\\\').replace('\n', '\\n');
    }

    normalized += '\n';

    if (options.app) {
        normalized += options.app + '\n' +
                      (options.dlg || '') + '\n';
    }

    return normalized;
};


exports.calculatePayloadHash = function (payload, algorithm, contentType) {

    var hash = exports.initializePayloadHash(algorithm, contentType);
    hash.update(payload || '');
    return exports.finalizePayloadHash(hash);
};


exports.initializePayloadHash = function (algorithm, contentType) {

    var hash = Crypto.createHash(algorithm);
    hash.update('hawk.' + exports.headerVersion + '.payload\n');
    hash.update(Utils.parseContentType(contentType) + '\n');
    return hash;
};


exports.finalizePayloadHash = function (hash) {

    hash.update('\n');
    return hash.digest('base64');
};


exports.calculateTsMac = function (ts, credentials) {

    var hmac = Crypto.createHmac(credentials.algorithm, credentials.key);
    hmac.update('hawk.' + exports.headerVersion + '.ts\n' + ts + '\n');
    return hmac.digest('base64');
};


},{"crypto":11,"url":1,"./utils":67}],62:[function(require,module,exports){
(function(process,Buffer){// Copyright (c) 2012, Mark Cavage. All rights reserved.

var assert = require('assert');
var Stream = require('stream').Stream;
var util = require('util');



///--- Globals

var NDEBUG = process.env.NODE_NDEBUG || false;



///--- Messages

var ARRAY_TYPE_REQUIRED = '%s ([%s]) required';
var TYPE_REQUIRED = '%s (%s) is required';



///--- Internal

function capitalize(str) {
        return (str.charAt(0).toUpperCase() + str.slice(1));
}

function uncapitalize(str) {
        return (str.charAt(0).toLowerCase() + str.slice(1));
}

function _() {
        return (util.format.apply(util, arguments));
}


function _assert(arg, type, name, stackFunc) {
        if (!NDEBUG) {
                name = name || type;
                stackFunc = stackFunc || _assert.caller;
                var t = typeof (arg);

                if (t !== type) {
                        throw new assert.AssertionError({
                                message: _(TYPE_REQUIRED, name, type),
                                actual: t,
                                expected: type,
                                operator: '===',
                                stackStartFunction: stackFunc
                        });
                }
        }
}



///--- API

function array(arr, type, name) {
        if (!NDEBUG) {
                name = name || type;

                if (!Array.isArray(arr)) {
                        throw new assert.AssertionError({
                                message: _(ARRAY_TYPE_REQUIRED, name, type),
                                actual: typeof (arr),
                                expected: 'array',
                                operator: 'Array.isArray',
                                stackStartFunction: array.caller
                        });
                }

                for (var i = 0; i < arr.length; i++) {
                        _assert(arr[i], type, name, array);
                }
        }
}


function bool(arg, name) {
        _assert(arg, 'boolean', name, bool);
}


function buffer(arg, name) {
        if (!Buffer.isBuffer(arg)) {
                throw new assert.AssertionError({
                        message: _(TYPE_REQUIRED, name, type),
                        actual: typeof (arg),
                        expected: 'buffer',
                        operator: 'Buffer.isBuffer',
                        stackStartFunction: buffer
                });
        }
}


function func(arg, name) {
        _assert(arg, 'function', name);
}


function number(arg, name) {
        _assert(arg, 'number', name);
}


function object(arg, name) {
        _assert(arg, 'object', name);
}


function stream(arg, name) {
        if (!(arg instanceof Stream)) {
                throw new assert.AssertionError({
                        message: _(TYPE_REQUIRED, name, type),
                        actual: typeof (arg),
                        expected: 'Stream',
                        operator: 'instanceof',
                        stackStartFunction: buffer
                });
        }
}


function string(arg, name) {
        _assert(arg, 'string', name);
}



///--- Exports

module.exports = {
        bool: bool,
        buffer: buffer,
        func: func,
        number: number,
        object: object,
        stream: stream,
        string: string
};


Object.keys(module.exports).forEach(function (k) {
        if (k === 'buffer')
                return;

        var name = 'arrayOf' + capitalize(k);

        if (k === 'bool')
                k = 'boolean';
        if (k === 'func')
                k = 'function';
        module.exports[name] = function (arg, name) {
                array(arg, k, name);
        };
});

Object.keys(module.exports).forEach(function (k) {
        var _name = 'optional' + capitalize(k);
        var s = uncapitalize(k.replace('arrayOf', ''));
        if (s === 'bool')
                s = 'boolean';
        if (s === 'func')
                s = 'function';

        if (k.indexOf('arrayOf') !== -1) {
          module.exports[_name] = function (arg, name) {
                  if (!NDEBUG && arg !== undefined) {
                          array(arg, s, name);
                  }
          };
        } else {
          module.exports[_name] = function (arg, name) {
                  if (!NDEBUG && arg !== undefined) {
                          _assert(arg, s, name);
                  }
          };
        }
});


// Reexport built-in assertions
Object.keys(assert).forEach(function (k) {
        if (k === 'AssertionError') {
                module.exports[k] = assert[k];
                return;
        }

        module.exports[k] = function () {
                if (!NDEBUG) {
                        assert[k].apply(assert[k], arguments);
                }
        };
});

})(require("__browserify_process"),require("__browserify_buffer").Buffer)
},{"assert":18,"stream":3,"util":5,"__browserify_process":9,"__browserify_buffer":19}],49:[function(require,module,exports){
// Export sub-modules

exports.error = exports.Error = require('boom');
exports.sntp = require('sntp');
exports.server = require('./server');
exports.client = require('./client');
exports.crypto = require('./crypto');
exports.utils = require('./utils');

exports.uri = {
    authenticate: exports.server.authenticateBewit,
    getBewit: exports.client.getBewit
};



},{"./server":68,"./client":69,"./crypto":66,"./utils":67,"sntp":70,"boom":71}],65:[function(require,module,exports){
(function(){/*
 * JavaScript MD5 1.0.1
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 * 
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*jslint bitwise: true */
/*global unescape, define */

(function ($) {
    'use strict';

    /*
    * Add integers, wrapping at 2^32. This uses 16-bit operations internally
    * to work around bugs in some JS interpreters.
    */
    function safe_add(x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF),
            msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    }

    /*
    * Bitwise rotate a 32-bit number to the left.
    */
    function bit_rol(num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    }

    /*
    * These functions implement the four basic operations the algorithm uses.
    */
    function md5_cmn(q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
    }
    function md5_ff(a, b, c, d, x, s, t) {
        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
    }
    function md5_gg(a, b, c, d, x, s, t) {
        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
    }
    function md5_hh(a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5_ii(a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
    }

    /*
    * Calculate the MD5 of an array of little-endian words, and a bit length.
    */
    function binl_md5(x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << (len % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;

        var i, olda, oldb, oldc, oldd,
            a =  1732584193,
            b = -271733879,
            c = -1732584194,
            d =  271733878;

        for (i = 0; i < x.length; i += 16) {
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;

            a = md5_ff(a, b, c, d, x[i],       7, -680876936);
            d = md5_ff(d, a, b, c, x[i +  1], 12, -389564586);
            c = md5_ff(c, d, a, b, x[i +  2], 17,  606105819);
            b = md5_ff(b, c, d, a, x[i +  3], 22, -1044525330);
            a = md5_ff(a, b, c, d, x[i +  4],  7, -176418897);
            d = md5_ff(d, a, b, c, x[i +  5], 12,  1200080426);
            c = md5_ff(c, d, a, b, x[i +  6], 17, -1473231341);
            b = md5_ff(b, c, d, a, x[i +  7], 22, -45705983);
            a = md5_ff(a, b, c, d, x[i +  8],  7,  1770035416);
            d = md5_ff(d, a, b, c, x[i +  9], 12, -1958414417);
            c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
            b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
            a = md5_ff(a, b, c, d, x[i + 12],  7,  1804603682);
            d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
            c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
            b = md5_ff(b, c, d, a, x[i + 15], 22,  1236535329);

            a = md5_gg(a, b, c, d, x[i +  1],  5, -165796510);
            d = md5_gg(d, a, b, c, x[i +  6],  9, -1069501632);
            c = md5_gg(c, d, a, b, x[i + 11], 14,  643717713);
            b = md5_gg(b, c, d, a, x[i],      20, -373897302);
            a = md5_gg(a, b, c, d, x[i +  5],  5, -701558691);
            d = md5_gg(d, a, b, c, x[i + 10],  9,  38016083);
            c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
            b = md5_gg(b, c, d, a, x[i +  4], 20, -405537848);
            a = md5_gg(a, b, c, d, x[i +  9],  5,  568446438);
            d = md5_gg(d, a, b, c, x[i + 14],  9, -1019803690);
            c = md5_gg(c, d, a, b, x[i +  3], 14, -187363961);
            b = md5_gg(b, c, d, a, x[i +  8], 20,  1163531501);
            a = md5_gg(a, b, c, d, x[i + 13],  5, -1444681467);
            d = md5_gg(d, a, b, c, x[i +  2],  9, -51403784);
            c = md5_gg(c, d, a, b, x[i +  7], 14,  1735328473);
            b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);

            a = md5_hh(a, b, c, d, x[i +  5],  4, -378558);
            d = md5_hh(d, a, b, c, x[i +  8], 11, -2022574463);
            c = md5_hh(c, d, a, b, x[i + 11], 16,  1839030562);
            b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
            a = md5_hh(a, b, c, d, x[i +  1],  4, -1530992060);
            d = md5_hh(d, a, b, c, x[i +  4], 11,  1272893353);
            c = md5_hh(c, d, a, b, x[i +  7], 16, -155497632);
            b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
            a = md5_hh(a, b, c, d, x[i + 13],  4,  681279174);
            d = md5_hh(d, a, b, c, x[i],      11, -358537222);
            c = md5_hh(c, d, a, b, x[i +  3], 16, -722521979);
            b = md5_hh(b, c, d, a, x[i +  6], 23,  76029189);
            a = md5_hh(a, b, c, d, x[i +  9],  4, -640364487);
            d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
            c = md5_hh(c, d, a, b, x[i + 15], 16,  530742520);
            b = md5_hh(b, c, d, a, x[i +  2], 23, -995338651);

            a = md5_ii(a, b, c, d, x[i],       6, -198630844);
            d = md5_ii(d, a, b, c, x[i +  7], 10,  1126891415);
            c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
            b = md5_ii(b, c, d, a, x[i +  5], 21, -57434055);
            a = md5_ii(a, b, c, d, x[i + 12],  6,  1700485571);
            d = md5_ii(d, a, b, c, x[i +  3], 10, -1894986606);
            c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
            b = md5_ii(b, c, d, a, x[i +  1], 21, -2054922799);
            a = md5_ii(a, b, c, d, x[i +  8],  6,  1873313359);
            d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
            c = md5_ii(c, d, a, b, x[i +  6], 15, -1560198380);
            b = md5_ii(b, c, d, a, x[i + 13], 21,  1309151649);
            a = md5_ii(a, b, c, d, x[i +  4],  6, -145523070);
            d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
            c = md5_ii(c, d, a, b, x[i +  2], 15,  718787259);
            b = md5_ii(b, c, d, a, x[i +  9], 21, -343485551);

            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
        }
        return [a, b, c, d];
    }

    /*
    * Convert an array of little-endian words to a string
    */
    function binl2rstr(input) {
        var i,
            output = '';
        for (i = 0; i < input.length * 32; i += 8) {
            output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF);
        }
        return output;
    }

    /*
    * Convert a raw string to an array of little-endian words
    * Characters >255 have their high-byte silently ignored.
    */
    function rstr2binl(input) {
        var i,
            output = [];
        output[(input.length >> 2) - 1] = undefined;
        for (i = 0; i < output.length; i += 1) {
            output[i] = 0;
        }
        for (i = 0; i < input.length * 8; i += 8) {
            output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32);
        }
        return output;
    }

    /*
    * Calculate the MD5 of a raw string
    */
    function rstr_md5(s) {
        return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
    }

    /*
    * Calculate the HMAC-MD5, of a key and some data (raw strings)
    */
    function rstr_hmac_md5(key, data) {
        var i,
            bkey = rstr2binl(key),
            ipad = [],
            opad = [],
            hash;
        ipad[15] = opad[15] = undefined;
        if (bkey.length > 16) {
            bkey = binl_md5(bkey, key.length * 8);
        }
        for (i = 0; i < 16; i += 1) {
            ipad[i] = bkey[i] ^ 0x36363636;
            opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }
        hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
        return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
    }

    /*
    * Convert a raw string to a hex string
    */
    function rstr2hex(input) {
        var hex_tab = '0123456789abcdef',
            output = '',
            x,
            i;
        for (i = 0; i < input.length; i += 1) {
            x = input.charCodeAt(i);
            output += hex_tab.charAt((x >>> 4) & 0x0F) +
                hex_tab.charAt(x & 0x0F);
        }
        return output;
    }

    /*
    * Encode a string as utf-8
    */
    function str2rstr_utf8(input) {
        return unescape(encodeURIComponent(input));
    }

    /*
    * Take string arguments and return either raw or hex encoded strings
    */
    function raw_md5(s) {
        return rstr_md5(str2rstr_utf8(s));
    }
    function hex_md5(s) {
        return rstr2hex(raw_md5(s));
    }
    function raw_hmac_md5(k, d) {
        return rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d));
    }
    function hex_hmac_md5(k, d) {
        return rstr2hex(raw_hmac_md5(k, d));
    }

    function md5(string, key, raw) {
        if (!key) {
            if (!raw) {
                return hex_md5(string);
            }
            return raw_md5(string);
        }
        if (!raw) {
            return hex_hmac_md5(key, string);
        }
        return raw_hmac_md5(key, string);
    }

    if (typeof define === 'function' && define.amd) {
        define(function () {
            return md5;
        });
    } else {
        $.md5 = md5;
    }
}(this));

})()
},{}],59:[function(require,module,exports){
var events = require('events');
var util = require('util');

exports.availableSaxParsers = [];
exports.bestSaxParser = null;
['./sax_expat.js', './sax_ltx.js', /*'./sax_easysax.js', './sax_node-xml.js',*/ './sax_saxjs.js'].forEach(function(modName) {
    var mod;
    try {
	mod = require(modName);
    } catch (e) {
	/* Silently missing libraries drop; for debug:
	console.error(e.stack || e);
	 */
    }
    if (mod) {
	exports.availableSaxParsers.push(mod);
	if (!exports.bestSaxParser)
	    exports.bestSaxParser = mod;
    }
});
var element = require('./element');

exports.Parser = function(saxParser) {
    events.EventEmitter.call(this);
    var that = this;

    var parserMod = saxParser || exports.bestSaxParser;
    if (!parserMod)
	throw new Error("No SAX parser available");
    this.parser = new parserMod();

    var el;
    this.parser.addListener('startElement', function(name, attrs) {
        var child = new element.Element(name, attrs);
        if (!el) {
            el = child;
        } else {
            el = el.cnode(child);
        }
    });
    this.parser.addListener('endElement', function(name) {
        if (!el) {
            /* Err */
        } else if (el && name == el.name) {
            if (el.parent)
                el = el.parent;
            else if (!that.tree) {
                that.tree = el;
                el = undefined;
            }
        }
    });
    this.parser.addListener('text', function(str) {
        if (el)
            el.t(str);
    });
    this.parser.addListener('error', function(e) {
	that.error = e;
	that.emit('error', e);
    });
};
util.inherits(exports.Parser, events.EventEmitter);

exports.Parser.prototype.write = function(data) {
    this.parser.write(data);
};

exports.Parser.prototype.end = function(data) {
    this.parser.end(data);

    if (!this.error) {
	if (this.tree)
	    this.emit('tree', this.tree);
	else
	    this.emit('error', new Error('Incomplete document'));
    }
};

exports.parse = function(data, saxParser) {
    var p = new exports.Parser(saxParser);
    var result = null, error = null;

    p.on('tree', function(tree) {
        result = tree;
    });
    p.on('error', function(e) {
        error = e;
    });

    p.write(data);
    p.end();

    if (error)
        throw error;
    else
        return result;
};

},{"events":4,"util":5,"./element":58}],64:[function(require,module,exports){
(function(Buffer){/*
 * rm - Feb 2011
 * ctype.js
 *
 * This module provides a simple abstraction towards reading and writing
 * different types of binary data. It is designed to use ctio.js and provide a
 * richer and more expressive API on top of it.
 *
 * By default we support the following as built in basic types:
 *	int8_t
 *	int16_t
 *	int32_t
 *	uint8_t
 *	uint16_t
 *	uint32_t
 *	uint64_t
 *	float
 *	double
 *	char
 *	char[]
 *
 * Each type is returned as a Number, with the exception of char and char[]
 * which are returned as Node Buffers. A char is considered a uint8_t.
 *
 * Requests to read and write data are specified as an array of JSON objects.
 * This is also the same way that one declares structs. Even if just a single
 * value is requested, it must be done as a struct. The array order determines
 * the order that we try and read values. Each entry has the following format
 * with values marked with a * being optional.
 *
 * { key: { type: /type/, value*: /value/, offset*: /offset/ }
 *
 * If offset is defined, we lseek(offset, SEEK_SET) before reading the next
 * value. Value is defined when we're writing out data, otherwise it's ignored.
 *
 */

var mod_ctf = require('./ctf.js');
var mod_ctio = require('./ctio.js');
var mod_assert = require('assert');

/*
 * This is the set of basic types that we support.
 *
 *	read		The function to call to read in a value from a buffer
 *
 *	write		The function to call to write a value to a buffer
 *
 */
var deftypes = {
    'uint8_t':  { read: ctReadUint8, write: ctWriteUint8 },
    'uint16_t': { read: ctReadUint16, write: ctWriteUint16 },
    'uint32_t': { read: ctReadUint32, write: ctWriteUint32 },
    'uint64_t': { read: ctReadUint64, write: ctWriteUint64 },
    'int8_t': { read: ctReadSint8, write: ctWriteSint8 },
    'int16_t': { read: ctReadSint16, write: ctWriteSint16 },
    'int32_t': { read: ctReadSint32, write: ctWriteSint32 },
    'int64_t': { read: ctReadSint64, write: ctWriteSint64 },
    'float': { read: ctReadFloat, write: ctWriteFloat },
    'double': { read: ctReadDouble, write: ctWriteDouble },
    'char': { read: ctReadChar, write: ctWriteChar },
    'char[]': { read: ctReadCharArray, write: ctWriteCharArray }
};

/*
 * The following are wrappers around the CType IO low level API. They encode
 * knowledge about the size and return something in the expected format.
 */
function ctReadUint8(endian, buffer, offset)
{
	var val = mod_ctio.ruint8(buffer, endian, offset);
	return ({ value: val, size: 1 });
}

function ctReadUint16(endian, buffer, offset)
{
	var val = mod_ctio.ruint16(buffer, endian, offset);
	return ({ value: val, size: 2 });
}

function ctReadUint32(endian, buffer, offset)
{
	var val = mod_ctio.ruint32(buffer, endian, offset);
	return ({ value: val, size: 4 });
}

function ctReadUint64(endian, buffer, offset)
{
	var val = mod_ctio.ruint64(buffer, endian, offset);
	return ({ value: val, size: 8 });
}

function ctReadSint8(endian, buffer, offset)
{
	var val = mod_ctio.rsint8(buffer, endian, offset);
	return ({ value: val, size: 1 });
}

function ctReadSint16(endian, buffer, offset)
{
	var val = mod_ctio.rsint16(buffer, endian, offset);
	return ({ value: val, size: 2 });
}

function ctReadSint32(endian, buffer, offset)
{
	var val = mod_ctio.rsint32(buffer, endian, offset);
	return ({ value: val, size: 4 });
}

function ctReadSint64(endian, buffer, offset)
{
	var val = mod_ctio.rsint64(buffer, endian, offset);
	return ({ value: val, size: 8 });
}

function ctReadFloat(endian, buffer, offset)
{
	var val = mod_ctio.rfloat(buffer, endian, offset);
	return ({ value: val, size: 4 });
}

function ctReadDouble(endian, buffer, offset)
{
	var val = mod_ctio.rdouble(buffer, endian, offset);
	return ({ value: val, size: 8 });
}

/*
 * Reads a single character into a node buffer
 */
function ctReadChar(endian, buffer, offset)
{
	var res = new Buffer(1);
	res[0] = mod_ctio.ruint8(buffer, endian, offset);
	return ({ value: res, size: 1 });
}

function ctReadCharArray(length, endian, buffer, offset)
{
	var ii;
	var res = new Buffer(length);

	for (ii = 0; ii < length; ii++)
		res[ii] = mod_ctio.ruint8(buffer, endian, offset + ii);

	return ({ value: res, size: length });
}

function ctWriteUint8(value, endian, buffer, offset)
{
	mod_ctio.wuint8(value, endian, buffer, offset);
	return (1);
}

function ctWriteUint16(value, endian, buffer, offset)
{
	mod_ctio.wuint16(value, endian, buffer, offset);
	return (2);
}

function ctWriteUint32(value, endian, buffer, offset)
{
	mod_ctio.wuint32(value, endian, buffer, offset);
	return (4);
}

function ctWriteUint64(value, endian, buffer, offset)
{
	mod_ctio.wuint64(value, endian, buffer, offset);
	return (8);
}

function ctWriteSint8(value, endian, buffer, offset)
{
	mod_ctio.wsint8(value, endian, buffer, offset);
	return (1);
}

function ctWriteSint16(value, endian, buffer, offset)
{
	mod_ctio.wsint16(value, endian, buffer, offset);
	return (2);
}

function ctWriteSint32(value, endian, buffer, offset)
{
	mod_ctio.wsint32(value, endian, buffer, offset);
	return (4);
}

function ctWriteSint64(value, endian, buffer, offset)
{
	mod_ctio.wsint64(value, endian, buffer, offset);
	return (8);
}

function ctWriteFloat(value, endian, buffer, offset)
{
	mod_ctio.wfloat(value, endian, buffer, offset);
	return (4);
}

function ctWriteDouble(value, endian, buffer, offset)
{
	mod_ctio.wdouble(value, endian, buffer, offset);
	return (8);
}

/*
 * Writes a single character into a node buffer
 */
function ctWriteChar(value, endian, buffer, offset)
{
	if (!(value instanceof Buffer))
		throw (new Error('Input must be a buffer'));

	mod_ctio.ruint8(value[0], endian, buffer, offset);
	return (1);
}

/*
 * We're going to write 0s into the buffer if the string is shorter than the
 * length of the array.
 */
function ctWriteCharArray(value, length, endian, buffer, offset)
{
	var ii;

	if (!(value instanceof Buffer))
		throw (new Error('Input must be a buffer'));

	if (value.length > length)
		throw (new Error('value length greater than array length'));

	for (ii = 0; ii < value.length && ii < length; ii++)
		mod_ctio.wuint8(value[ii], endian, buffer, offset + ii);

	for (; ii < length; ii++)
		mod_ctio.wuint8(0, endian, offset + ii);


	return (length);
}

/*
 * Each parser has their own set of types. We want to make sure that they each
 * get their own copy as they may need to modify it.
 */
function ctGetBasicTypes()
{
	var ret = {};
	var key;
	for (key in deftypes)
		ret[key] = deftypes[key];

	return (ret);
}

/*
 * Given a string in the form of type[length] we want to split this into an
 * object that extracts that information. We want to note that we could possibly
 * have nested arrays so this should only check the furthest one. It may also be
 * the case that we have no [] pieces, in which case we just return the current
 * type.
 */
function ctParseType(str)
{
	var begInd, endInd;
	var type, len;
	if (typeof (str) != 'string')
		throw (new Error('type must be a Javascript string'));

	endInd = str.lastIndexOf(']');
	if (endInd == -1) {
		if (str.lastIndexOf('[') != -1)
			throw (new Error('found invalid type with \'[\' but ' +
			    'no corresponding \']\''));

		return ({ type: str });
	}

	begInd = str.lastIndexOf('[');
	if (begInd == -1)
		throw (new Error('found invalid type with \']\' but ' +
		    'no corresponding \'[\''));

	if (begInd >= endInd)
		throw (new Error('malformed type, \']\' appears before \'[\''));

	type = str.substring(0, begInd);
	len = str.substring(begInd + 1, endInd);

	return ({ type: type, len: len });
}

/*
 * Given a request validate that all of the fields for it are valid and make
 * sense. This includes verifying the following notions:
 *  - Each type requested is present in types
 *  - Only allow a name for a field to be specified once
 *  - If an array is specified, validate that the requested field exists and
 *    comes before it.
 *  - If fields is defined, check that each entry has the occurrence of field
 */
function ctCheckReq(def, types, fields)
{
	var ii, jj;
	var req, keys, key;
	var found = {};

	if (!(def instanceof Array))
		throw (new Error('definition is not an array'));

	if (def.length === 0)
		throw (new Error('definition must have at least one element'));

	for (ii = 0; ii < def.length; ii++) {
		req = def[ii];
		if (!(req instanceof Object))
			throw (new Error('definition must be an array of' +
			    'objects'));

		keys = Object.keys(req);
		if (keys.length != 1)
			throw (new Error('definition entry must only have ' +
			    'one key'));

		if (keys[0] in found)
			throw (new Error('Specified name already ' +
			    'specified: ' + keys[0]));

		if (!('type' in req[keys[0]]))
			throw (new Error('missing required type definition'));

		key = ctParseType(req[keys[0]]['type']);

		/*
		 * We may have nested arrays, we need to check the validity of
		 * the types until the len field is undefined in key. However,
		 * each time len is defined we need to verify it is either an
		 * integer or corresponds to an already seen key.
		 */
		while (key['len'] !== undefined) {
			if (isNaN(parseInt(key['len'], 10))) {
				if (!(key['len'] in found))
					throw (new Error('Given an array ' +
					    'length without a matching type'));

			}

			key = ctParseType(key['type']);
		}

		/* Now we can validate if the type is valid */
		if (!(key['type'] in types))
			throw (new Error('type not found or typdefed: ' +
			    key['type']));

		/* Check for any required fields */
		if (fields !== undefined) {
			for (jj = 0; jj < fields.length; jj++) {
				if (!(fields[jj] in req[keys[0]]))
					throw (new Error('Missing required ' +
					    'field: ' + fields[jj]));
			}
		}

		found[keys[0]] = true;
	}
}


/*
 * Create a new instance of the parser. Each parser has its own store of
 * typedefs and endianness. Conf is an object with the following required
 * values:
 *
 *	endian		Either 'big' or 'little' do determine the endianness we
 *			want to read from or write to.
 *
 * And the following optional values:
 *
 * 	char-type	Valid options here are uint8 and int8. If uint8 is
 * 			specified this changes the default behavior of a single
 * 			char from being a buffer of a single character to being
 * 			a uint8_t. If int8, it becomes an int8_t instead.
 */
function CTypeParser(conf)
{
	if (!conf) throw (new Error('missing required argument'));

	if (!('endian' in conf))
		throw (new Error('missing required endian value'));

	if (conf['endian'] != 'big' && conf['endian'] != 'little')
		throw (new Error('Invalid endian type'));

	if ('char-type' in conf && (conf['char-type'] != 'uint8' &&
	    conf['char-type'] != 'int8'))
		throw (new Error('invalid option for char-type: ' +
		    conf['char-type']));

	this.endian = conf['endian'];
	this.types = ctGetBasicTypes();

	/*
	 * There may be a more graceful way to do this, but this will have to
	 * serve.
	 */
	if ('char-type' in conf && conf['char-type'] == 'uint8')
		this.types['char'] = this.types['uint8_t'];

	if ('char-type' in conf && conf['char-type'] == 'int8')
		this.types['char'] = this.types['int8_t'];
}

/*
 * Sets the current endian value for the Parser. If the value is not valid,
 * throws an Error.
 *
 *	endian		Either 'big' or 'little' do determine the endianness we
 *			want to read from or write to.
 *
 */
CTypeParser.prototype.setEndian = function (endian)
{
	if (endian != 'big' && endian != 'little')
		throw (new Error('invalid endian type, must be big or ' +
		    'little'));

	this.endian = endian;
};

/*
 * Returns the current value of the endian value for the parser.
 */
CTypeParser.prototype.getEndian = function ()
{
	return (this.endian);
};

/*
 * A user has requested to add a type, let us honor their request. Yet, if their
 * request doth spurn us, send them unto the Hells which Dante describes.
 *
 * 	name		The string for the type definition we're adding
 *
 *	value		Either a string that is a type/array name or an object
 *			that describes a struct.
 */
CTypeParser.prototype.typedef = function (name, value)
{
	var type;

	if (name === undefined)
		throw (new (Error('missing required typedef argument: name')));

	if (value === undefined)
		throw (new (Error('missing required typedef argument: value')));

	if (typeof (name) != 'string')
		throw (new (Error('the name of a type must be a string')));

	type = ctParseType(name);

	if (type['len'] !== undefined)
		throw (new Error('Cannot have an array in the typedef name'));

	if (name in this.types)
		throw (new Error('typedef name already present: ' + name));

	if (typeof (value) != 'string' && !(value instanceof Array))
		throw (new Error('typedef value must either be a string or ' +
		    'struct'));

	if (typeof (value) == 'string') {
		type = ctParseType(value);
		if (type['len'] !== undefined) {
			if (isNaN(parseInt(type['len'], 10)))
				throw (new (Error('typedef value must use ' +
				    'fixed size array when outside of a ' +
				    'struct')));
		}

		this.types[name] = value;
	} else {
		/* We have a struct, validate it */
		ctCheckReq(value, this.types);
		this.types[name] = value;
	}
};

/*
 * Include all of the typedefs, but none of the built in types. This should be
 * treated as read-only.
 */
CTypeParser.prototype.lstypes = function ()
{
	var key;
	var ret = {};

	for (key in this.types) {
		if (key in deftypes)
			continue;
		ret[key] = this.types[key];
	}

	return (ret);
};

/*
 * Given a type string that may have array types that aren't numbers, try and
 * fill them in from the values object. The object should be of the format where
 * indexing into it should return a number for that type.
 *
 *	str		The type string
 *
 *	values		An object that can be used to fulfill type information
 */
function ctResolveArray(str, values)
{
	var ret = '';
	var type = ctParseType(str);

	while (type['len'] !== undefined) {
		if (isNaN(parseInt(type['len'], 10))) {
			if (typeof (values[type['len']]) != 'number')
				throw (new Error('cannot sawp in non-number ' +
				    'for array value'));
			ret = '[' + values[type['len']] + ']' + ret;
		} else {
			ret = '[' + type['len'] + ']' + ret;
		}
		type = ctParseType(type['type']);
	}

	ret = type['type'] + ret;

	return (ret);
}

/*
 * [private] Either the typedef resolves to another type string or to a struct.
 * If it resolves to a struct, we just pass it off to read struct. If not, we
 * can just pass it off to read entry.
 */
CTypeParser.prototype.resolveTypedef = function (type, dispatch, buffer,
    offset, value)
{
	var pt;

	mod_assert.ok(type in this.types);
	if (typeof (this.types[type]) == 'string') {
		pt = ctParseType(this.types[type]);
		if (dispatch == 'read')
			return (this.readEntry(pt, buffer, offset));
		else if (dispatch == 'write')
			return (this.writeEntry(value, pt, buffer, offset));
		else
			throw (new Error('invalid dispatch type to ' +
			    'resolveTypedef'));
	} else {
		if (dispatch == 'read')
			return (this.readStruct(this.types[type], buffer,
			    offset));
		else if (dispatch == 'write')
			return (this.writeStruct(value, this.types[type],
			    buffer, offset));
		else
			throw (new Error('invalid dispatch type to ' +
			    'resolveTypedef'));
	}

};

/*
 * [private] Try and read in the specific entry.
 */
CTypeParser.prototype.readEntry = function (type, buffer, offset)
{
	var parse, len;

	/*
	 * Because we want to special case char[]s this is unfortunately
	 * a bit uglier than it really should be. We want to special
	 * case char[]s so that we return a node buffer, thus they are a
	 * first class type where as all other arrays just call into a
	 * generic array routine which calls their data-specific routine
	 * the specified number of times.
	 *
	 * The valid dispatch options we have are:
	 *  - Array and char => char[] handler
	 *  - Generic array handler
	 *  - Generic typedef handler
	 *  - Basic type handler
	 */
	if (type['len'] !== undefined) {
		len = parseInt(type['len'], 10);
		if (isNaN(len))
			throw (new Error('somehow got a non-numeric length'));

		if (type['type'] == 'char')
			parse = this.types['char[]']['read'](len,
			    this.endian, buffer, offset);
		else
			parse = this.readArray(type['type'],
			    len, buffer, offset);
	} else {
		if (type['type'] in deftypes)
			parse = this.types[type['type']]['read'](this.endian,
			    buffer, offset);
		else
			parse = this.resolveTypedef(type['type'], 'read',
			    buffer, offset);
	}

	return (parse);
};

/*
 * [private] Read an array of data
 */
CTypeParser.prototype.readArray = function (type, length, buffer, offset)
{
	var ii, ent, pt;
	var baseOffset = offset;
	var ret = new Array(length);
	pt = ctParseType(type);

	for (ii = 0; ii < length; ii++) {
		ent = this.readEntry(pt, buffer, offset);
		offset += ent['size'];
		ret[ii] = ent['value'];
	}

	return ({ value: ret, size: offset - baseOffset });
};

/*
 * [private] Read a single struct in.
 */
CTypeParser.prototype.readStruct = function (def, buffer, offset)
{
	var parse, ii, type, entry, key;
	var baseOffset = offset;
	var ret = {};

	/* Walk it and handle doing what's necessary */
	for (ii = 0; ii < def.length; ii++) {
		key = Object.keys(def[ii])[0];
		entry = def[ii][key];

		/* Resolve all array values */
		type = ctParseType(ctResolveArray(entry['type'], ret));

		if ('offset' in entry)
			offset = baseOffset + entry['offset'];

		parse = this.readEntry(type, buffer, offset);

		offset += parse['size'];
		ret[key] = parse['value'];
	}

	return ({ value: ret, size: (offset-baseOffset)});
};

/*
 * This is what we were born to do. We read the data from a buffer and return it
 * in an object whose keys match the values from the object.
 *
 *	def		The array definition of the data to read in
 *
 *	buffer		The buffer to read data from
 *
 *	offset		The offset to start writing to
 *
 * Returns an object where each key corresponds to an entry in def and the value
 * is the read value.
 */
CTypeParser.prototype.readData = function (def, buffer, offset)
{
	/* Sanity check for arguments */
	if (def === undefined)
		throw (new Error('missing definition for what we should be' +
		    'parsing'));

	if (buffer === undefined)
		throw (new Error('missing buffer for what we should be ' +
		    'parsing'));

	if (offset === undefined)
		throw (new Error('missing offset for what we should be ' +
		    'parsing'));

	/* Sanity check the object definition */
	ctCheckReq(def, this.types);

	return (this.readStruct(def, buffer, offset)['value']);
};

/*
 * [private] Write out an array of data
 */
CTypeParser.prototype.writeArray = function (value, type, length, buffer,
    offset)
{
	var ii, pt;
	var baseOffset = offset;
	if (!(value instanceof Array))
		throw (new Error('asked to write an array, but value is not ' +
		    'an array'));

	if (value.length != length)
		throw (new Error('asked to write array of length ' + length +
		    ' but that does not match value length: ' + value.length));

	pt = ctParseType(type);
	for (ii = 0; ii < length; ii++)
		offset += this.writeEntry(value[ii], pt, buffer, offset);

	return (offset - baseOffset);
};

/*
 * [private] Write the specific entry
 */
CTypeParser.prototype.writeEntry = function (value, type, buffer, offset)
{
	var len, ret;

	if (type['len'] !== undefined) {
		len = parseInt(type['len'], 10);
		if (isNaN(len))
			throw (new Error('somehow got a non-numeric length'));

		if (type['type'] == 'char')
			ret = this.types['char[]']['write'](value, len,
			    this.endian, buffer, offset);
		else
			ret = this.writeArray(value, type['type'],
			    len, buffer, offset);
	} else {
		if (type['type'] in deftypes)
			ret = this.types[type['type']]['write'](value,
			    this.endian, buffer, offset);
		else
			ret = this.resolveTypedef(type['type'], 'write',
			    buffer, offset, value);
	}

	return (ret);
};

/*
 * [private] Write a single struct out.
 */
CTypeParser.prototype.writeStruct = function (value, def, buffer, offset)
{
	var ii, entry, type, key;
	var baseOffset = offset;
	var vals = {};

	for (ii = 0; ii < def.length; ii++) {
		key = Object.keys(def[ii])[0];
		entry = def[ii][key];

		type = ctParseType(ctResolveArray(entry['type'], vals));

		if ('offset' in entry)
			offset = baseOffset + entry['offset'];

		offset += this.writeEntry(value[ii], type, buffer, offset);
		/* Now that we've written it out, we can use it for arrays */
		vals[key] = value[ii];
	}

	return (offset);
};

/*
 * Unfortunately, we're stuck with the sins of an initial poor design. Because
 * of that, we are going to have to support the old way of writing data via
 * writeData. There we insert the values that you want to write into the
 * definition. A little baroque. Internally, we use the new model. So we need to
 * just get those values out of there. But to maintain the principle of least
 * surprise, we're not going to modify the input data.
 */
function getValues(def)
{
	var ii, out, key;
	out = [];
	for (ii = 0; ii < def.length; ii++) {
		key = Object.keys(def[ii])[0];
		mod_assert.ok('value' in def[ii][key]);
		out.push(def[ii][key]['value']);
	}

	return (out);
}

/*
 * This is the second half of what we were born to do, write out the data
 * itself. Historically this function required you to put your values in the
 * definition section. This was not the smartest thing to do and a bit of an
 * oversight to be honest. As such, this function now takes a values argument.
 * If values is non-null and non-undefined, it will be used to determine the
 * values. This means that the old method is still supported, but is no longer
 * acceptable.
 *
 *	def		The array definition of the data to write out with
 *			values
 *
 *	buffer		The buffer to write to
 *
 *	offset		The offset in the buffer to write to
 *
 *	values		An array of values to write.
 */
CTypeParser.prototype.writeData = function (def, buffer, offset, values)
{
	var hv;

	if (def === undefined)
		throw (new Error('missing definition for what we should be' +
		    'parsing'));

	if (buffer === undefined)
		throw (new Error('missing buffer for what we should be ' +
		    'parsing'));

	if (offset === undefined)
		throw (new Error('missing offset for what we should be ' +
		    'parsing'));

	hv = (values != null && values != undefined);
	if (hv) {
		if (!Array.isArray(values))
			throw (new Error('missing values for writing'));
		ctCheckReq(def, this.types);
	} else {
		ctCheckReq(def, this.types, [ 'value' ]);
	}

	this.writeStruct(hv ? values : getValues(def), def, buffer, offset);
};

/*
 * Functions to go to and from 64 bit numbers in a way that is compatible with
 * Javascript limitations. There are two sets. One where the user is okay with
 * an approximation and one where they are definitely not okay with an
 * approximation.
 */

/*
 * Attempts to convert an array of two integers returned from rsint64 / ruint64
 * into an absolute 64 bit number. If however the value would exceed 2^52 this
 * will instead throw an error. The mantissa in a double is a 52 bit number and
 * rather than potentially give you a value that is an approximation this will
 * error. If you would rather an approximation, please see toApprox64.
 *
 *	val		An array of two 32-bit integers
 */
function toAbs64(val)
{
	if (val === undefined)
		throw (new Error('missing required arg: value'));

	if (!Array.isArray(val))
		throw (new Error('value must be an array'));

	if (val.length != 2)
		throw (new Error('value must be an array of length 2'));

	/* We have 20 bits worth of precision in this range */
	if (val[0] >= 0x100000)
		throw (new Error('value would become approximated'));

	return (val[0] * Math.pow(2, 32) + val[1]);
}

/*
 * Will return the 64 bit value as returned in an array from rsint64 / ruint64
 * to a value as close as it can. Note that Javascript stores all numbers as a
 * double and the mantissa only has 52 bits. Thus this version may approximate
 * the value.
 *
 *	val		An array of two 32-bit integers
 */
function toApprox64(val)
{
	if (val === undefined)
		throw (new Error('missing required arg: value'));

	if (!Array.isArray(val))
		throw (new Error('value must be an array'));

	if (val.length != 2)
		throw (new Error('value must be an array of length 2'));

	return (Math.pow(2, 32) * val[0] + val[1]);
}

function parseCTF(json, conf)
{
	var ctype = new CTypeParser(conf);
	mod_ctf.ctfParseJson(json, ctype);

	return (ctype);
}

/*
 * Export the few things we actually want to. Currently this is just the CType
 * Parser and ctio.
 */
exports.Parser = CTypeParser;
exports.toAbs64 = toAbs64;
exports.toApprox64 = toApprox64;

exports.parseCTF = parseCTF;

exports.ruint8 = mod_ctio.ruint8;
exports.ruint16 = mod_ctio.ruint16;
exports.ruint32 = mod_ctio.ruint32;
exports.ruint64 = mod_ctio.ruint64;
exports.wuint8 = mod_ctio.wuint8;
exports.wuint16 = mod_ctio.wuint16;
exports.wuint32 = mod_ctio.wuint32;
exports.wuint64 = mod_ctio.wuint64;

exports.rsint8 = mod_ctio.rsint8;
exports.rsint16 = mod_ctio.rsint16;
exports.rsint32 = mod_ctio.rsint32;
exports.rsint64 = mod_ctio.rsint64;
exports.wsint8 = mod_ctio.wsint8;
exports.wsint16 = mod_ctio.wsint16;
exports.wsint32 = mod_ctio.wsint32;
exports.wsint64 = mod_ctio.wsint64;

exports.rfloat = mod_ctio.rfloat;
exports.rdouble = mod_ctio.rdouble;
exports.wfloat = mod_ctio.wfloat;
exports.wdouble = mod_ctio.wdouble;

})(require("__browserify_buffer").Buffer)
},{"assert":18,"./ctf.js":72,"./ctio.js":73,"__browserify_buffer":19}],63:[function(require,module,exports){
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

// If you have no idea what ASN.1 or BER is, see this:
// ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc

var Ber = require('./ber/index');



///--- Exported API

module.exports = {

  Ber: Ber,

  BerReader: Ber.Reader,

  BerWriter: Ber.Writer

};

},{"./ber/index":74}],72:[function(require,module,exports){
/*
 * ctf.js
 *
 * Understand and parse all of the different JSON formats of CTF data and
 * translate that into a series of node-ctype friendly pieces. The reason for
 * the abstraction is to handle different changes in the file format.
 *
 * We have to be careful here that we don't end up using a name that is already
 * a built in type.
 */
var mod_assert = require('assert');
var ASSERT = mod_assert.ok;

var ctf_versions = [ '1.0' ];
var ctf_entries = [ 'integer', 'float', 'typedef', 'struct' ];
var ctf_deftypes = [ 'int8_t', 'uint8_t', 'int16_t', 'uint16_t', 'int32_t',
    'uint32_t', 'float', 'double' ];

function ctfParseInteger(entry, ctype)
{
	var name, sign, len, type;

	name = entry['name'];
	if (!('signed' in entry['integer']))
		throw (new Error('Malformed CTF JSON: integer missing ' +
		    'signed value'));


	if (!('length' in entry['integer']))
		throw (new Error('Malformed CTF JSON: integer missing ' +
		    'length value'));

	sign = entry['integer']['signed'];
	len = entry['integer']['length'];
	type = null;

	if (sign && len == 1)
		type = 'int8_t';
	else if (len == 1)
		type = 'uint8_t';
	else if (sign && len == 2)
		type = 'int16_t';
	else if (len == 2)
		type = 'uint16_t';
	else if (sign && len == 4)
		type = 'int32_t';
	else if (len == 4)
		type = 'uint32_t';
	else if (sign && len == 8)
		type = 'int64_t';
	else if (len == 8)
		type = 'uint64_t';

	if (type === null)
		throw (new Error('Malformed CTF JSON: integer has ' +
		    'unsupported length and sign - ' + len + '/' + sign));

	/*
	 * This means that this is the same as one of our built in types. If
	 * that's the case defining it would be an error. So instead of trying
	 * to typedef it, we'll return here.
	 */
	if (name == type)
		return;

	if (name == 'char') {
		ASSERT(type == 'int8_t');
		return;
	}

	ctype.typedef(name, type);
}

function ctfParseFloat(entry, ctype)
{
	var name, len;

	name = entry['name'];
	if (!('length' in entry['float']))
		throw (new Error('Malformed CTF JSON: float missing ' +
		    'length value'));

	len = entry['float']['length'];
	if (len != 4 && len != 8)
		throw (new Error('Malformed CTF JSON: float has invalid ' +
		    'length value'));

	if (len == 4) {
		if (name == 'float')
			return;
		ctype.typedef(name, 'float');
	} else if (len == 8) {
		if (name == 'double')
			return;
		ctype.typedef(name, 'double');
	}
}

function ctfParseTypedef(entry, ctype)
{
	var name, type, ii;

	name = entry['name'];
	if (typeof (entry['typedef']) != 'string')
		throw (new Error('Malformed CTF JSON: typedef value in not ' +
		    'a string'));

	type = entry['typedef'];

	/*
	 * We need to ensure that we're not looking at type that's one of our
	 * built in types. Traditionally in C a uint32_t would be a typedef to
	 * some kind of integer. However, those size types are built ins.
	 */
	for (ii = 0; ii < ctf_deftypes.length; ii++) {
		if (name == ctf_deftypes[ii])
			return;
	}

	ctype.typedef(name, type);
}

function ctfParseStruct(entry, ctype)
{
	var name, type, ii, val, index, member, push;

	member = [];
	if (!Array.isArray(entry['struct']))
		throw (new Error('Malformed CTF JSON: struct value is not ' +
		    'an array'));

	for (ii = 0; ii < entry['struct'].length; ii++) {
		val = entry['struct'][ii];
		if (!('name' in val))
			throw (new Error('Malformed CTF JSON: struct member ' +
			    'missing name'));

		if (!('type' in val))
			throw (new Error('Malformed CTF JSON: struct member ' +
			    'missing type'));

		if (typeof (val['name']) != 'string')
			throw (new Error('Malformed CTF JSON: struct member ' +
			    'name isn\'t a string'));

		if (typeof (val['type']) != 'string')
			throw (new Error('Malformed CTF JSON: struct member ' +
			    'type isn\'t a string'));

		/*
		 * CTF version 2 specifies array names as <type> [<num>] where
		 * as node-ctype does this as <type>[<num>].
		 */
		name = val['name'];
		type = val['type'];
		index = type.indexOf(' [');
		if (index != -1) {
			type = type.substring(0, index) +
			    type.substring(index + 1, type.length);
		}
		push = {};
		push[name] = { 'type': type };
		member.push(push);
	}

	name = entry['name'];
	ctype.typedef(name, member);
}

function ctfParseEntry(entry, ctype)
{
	var ii, found;

	if (!('name' in entry))
		throw (new Error('Malformed CTF JSON: entry missing "name" ' +
		    'section'));

	for (ii = 0; ii < ctf_entries.length; ii++) {
		if (ctf_entries[ii] in entry)
			found++;
	}

	if (found === 0)
		throw (new Error('Malformed CTF JSON: found no entries'));

	if (found >= 2)
		throw (new Error('Malformed CTF JSON: found more than one ' +
		    'entry'));

	if ('integer' in entry) {
		ctfParseInteger(entry, ctype);
		return;
	}

	if ('float' in entry) {
		ctfParseFloat(entry, ctype);
		return;
	}

	if ('typedef' in entry) {
		ctfParseTypedef(entry, ctype);
		return;
	}

	if ('struct' in entry) {
		ctfParseStruct(entry, ctype);
		return;
	}

	ASSERT(false, 'shouldn\'t reach here');
}

function ctfParseJson(json, ctype)
{
	var version, ii;

	ASSERT(json);
	ASSERT(ctype);
	if (!('metadata' in json))
		throw (new Error('Invalid CTF JSON: missing metadata section'));

	if (!('ctf2json_version' in json['metadata']))
		throw (new Error('Invalid CTF JSON: missing ctf2json_version'));

	version = json['metadata']['ctf2json_version'];
	for (ii = 0; ii < ctf_versions.length; ii++) {
		if (ctf_versions[ii] == version)
			break;
	}

	if (ii == ctf_versions.length)
		throw (new Error('Unsuported ctf2json_version: ' + version));

	if (!('data' in json))
		throw (new Error('Invalid CTF JSON: missing data section'));

	if (!Array.isArray(json['data']))
		throw (new Error('Malformed CTF JSON: data section is not ' +
		    'an array'));

	for (ii = 0; ii < json['data'].length; ii++)
		ctfParseEntry(json['data'][ii], ctype);
}

exports.ctfParseJson = ctfParseJson;

},{"assert":18}],73:[function(require,module,exports){
/*
 * rm - Feb 2011
 * ctio.js:
 *
 * A simple way to read and write simple ctypes. Of course, as you'll find the
 * code isn't as simple as it might appear. The following types are currently
 * supported in big and little endian formats:
 *
 * 	uint8_t			int8_t
 * 	uint16_t		int16_t
 * 	uint32_t		int32_t
 *	float (single precision IEEE 754)
 *	double (double precision IEEE 754)
 *
 * This is designed to work in Node and v8. It may in fact work in other
 * Javascript interpreters (that'd be pretty neat), but it hasn't been tested.
 * If you find that it does in fact work, that's pretty cool. Try and pass word
 * back to the original author.
 *
 * Note to the reader: If you're tabstop isn't set to 8, parts of this may look
 * weird.
 */

/*
 * Numbers in Javascript have a secret: all numbers must be represented with an
 * IEEE-754 double. The double has a mantissa with a length of 52 bits with an
 * implicit one. Thus the range of integers that can be represented is limited
 * to the size of the mantissa, this makes reading and writing 64-bit integers
 * difficult, but far from impossible.
 *
 * Another side effect of this representation is what happens when you use the
 * bitwise operators, i.e. shift left, shift right, and, or, etc. In Javascript,
 * each operand and the result is cast to a signed 32-bit number. However, in
 * the case of >>> the values are cast to an unsigned number.
 */

/*
 * A reminder on endian related issues:
 *
 * Big Endian: MSB -> First byte
 * Little Endian: MSB->Last byte
 */
var mod_assert = require('assert');

/*
 * An 8 bit unsigned integer involves doing no significant work.
 */
function ruint8(buffer, endian, offset)
{
	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	return (buffer[offset]);
}

/*
 * For 16 bit unsigned numbers we can do all the casting that we want to do.
 */
function rgint16(buffer, endian, offset)
{
	var val = 0;

	if (endian == 'big') {
		val = buffer[offset] << 8;
		val |=  buffer[offset+1];
	} else {
		val = buffer[offset];
		val |= buffer[offset+1] << 8;
	}

	return (val);

}

function ruint16(buffer, endian, offset)
{
	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 1 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	return (rgint16(buffer, endian, offset));
}

/*
 * Because most bitshifting is done using signed numbers, if we would go into
 * the realm where we use that 32nd bit, we'll end up going into the negative
 * range. i.e.:
 * > 200 << 24
 * -939524096
 *
 * Not the value you'd expect. To work around this, we end up having to do some
 * abuse of the JavaScript standard. in this case, we know that a >>> shift is
 * defined to cast our value to an *unsigned* 32-bit number. Because of that, we
 * use that instead to save us some additional math, though it does feel a
 * little weird and it isn't obvious as to why you woul dwant to do this at
 * first.
 */
function rgint32(buffer, endian, offset)
{
	var val = 0;

	if (endian == 'big') {
		val = buffer[offset+1] << 16;
		val |= buffer[offset+2] << 8;
		val |= buffer[offset+3];
		val = val + (buffer[offset] << 24 >>> 0);
	} else {
		val = buffer[offset+2] << 16;
		val |= buffer[offset+1] << 8;
		val |= buffer[offset];
		val = val + (buffer[offset + 3] << 24 >>> 0);
	}

	return (val);
}

function ruint32(buffer, endian, offset)
{
	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	return (rgint32(buffer, endian, offset));
}

/*
 * Reads a 64-bit unsigned number. The astue observer will note that this
 * doesn't quite work. Javascript has chosen to only have numbers that can be
 * represented by a double. A double only has 52 bits of mantissa with an
 * implicit 1, thus we have up to 53 bits to represent an integer. However, 2^53
 * doesn't quite give us what we want. Isn't 53 bits enough for anyone? What
 * could you have possibly wanted to represent that was larger than that? Oh,
 * maybe a size? You mean we bypassed the 4 GB limit on file sizes, when did
 * that happen?
 *
 * To get around this egregious language issue, we're going to instead construct
 * an array of two 32 bit unsigned integers. Where arr[0] << 32 + arr[1] would
 * give the actual number. However, note that the above code probably won't
 * produce the desired results because of the way Javascript numbers are
 * doubles.
 */
function rgint64(buffer, endian, offset)
{
	var val = new Array(2);

	if (endian == 'big') {
		val[0] = ruint32(buffer, endian, offset);
		val[1] = ruint32(buffer, endian, offset+4);
	} else {
		val[0] = ruint32(buffer, endian, offset+4);
		val[1] = ruint32(buffer, endian, offset);
	}

	return (val);
}

function ruint64(buffer, endian, offset)
{
	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 7 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	return (rgint64(buffer, endian, offset));
}


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 *
 * Doing it this way ends up allowing us to treat it appropriately in
 * Javascript. Sigh, that's really quite ugly for what should just be a few bit
 * shifts, ~ and &.
 */

/*
 * Endianness doesn't matter for 8-bit signed values. We could in fact optimize
 * this case because the more traditional methods work, but for consistency,
 * we'll keep doing this the same way.
 */
function rsint8(buffer, endian, offset)
{
	var neg;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	neg = buffer[offset] & 0x80;
	if (!neg)
		return (buffer[offset]);

	return ((0xff - buffer[offset] + 1) * -1);
}

/*
 * The 16-bit version requires a bit more effort. In this case, we can leverage
 * our unsigned code to generate the value we want to return.
 */
function rsint16(buffer, endian, offset)
{
	var neg, val;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 1 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = rgint16(buffer, endian, offset);
	neg = val & 0x8000;
	if (!neg)
		return (val);

	return ((0xffff - val + 1) * -1);
}

/*
 * We really shouldn't leverage our 32-bit code here and instead utilize the
 * fact that we know that since these are signed numbers, we can do all the
 * shifting and binary anding to generate the 32-bit number. But, for
 * consistency we'll do the same. If we want to do otherwise, we should instead
 * make the 32 bit unsigned code do the optimization. But as long as there
 * aren't floats secretly under the hood for that, we /should/ be okay.
 */
function rsint32(buffer, endian, offset)
{
	var neg, val;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = rgint32(buffer, endian, offset);
	neg = val & 0x80000000;
	if (!neg)
		return (val);

	return ((0xffffffff - val + 1) * -1);
}

/*
 * The signed version of this code suffers from all of the same problems of the
 * other 64 bit version.
 */
function rsint64(buffer, endian, offset)
{
	var neg, val;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = rgint64(buffer, endian, offset);
	neg = val[0] & 0x80000000;

	if (!neg)
		return (val);

	val[0] = (0xffffffff - val[0]) * -1;
	val[1] = (0xffffffff - val[1] + 1) * -1;

	/*
	 * If we had the key 0x8000000000000000, that would leave the lower 32
	 * bits as 0xffffffff, however, since we're goint to add one, that would
	 * actually leave the lower 32-bits as 0x100000000, which would break
	 * our ability to write back a value that we received. To work around
	 * this, if we actually get that value, we're going to bump the upper
	 * portion by 1 and set this to zero.
	 */
	mod_assert.ok(val[1] <= 0x100000000);
	if (val[1] == -0x100000000) {
		val[1] = 0;
		val[0]--;
	}

	return (val);
}

/*
 * We now move onto IEEE 754: The traditional form for floating point numbers
 * and what is secretly hiding at the heart of everything in this. I really hope
 * that someone is actually using this, as otherwise, this effort is probably
 * going to be more wasted.
 *
 * One might be tempted to use parseFloat here, but that wouldn't work at all
 * for several reasons. Mostly due to the way floats actually work, and
 * parseFloat only actually works in base 10. I don't see base 10 anywhere near
 * this file.
 *
 * In this case we'll implement the single and double precision versions. The
 * quadruple precision, while probably useful, wouldn't really be accepted by
 * Javascript, so let's not even waste our time.
 *
 * So let's review how this format looks like. A single precision value is 32
 * bits and has three parts:
 *   -  Sign bit
 *   -  Exponent (Using bias notation)
 *   -  Mantissa
 *
 * |s|eeeeeeee|mmmmmmmmmmmmmmmmmmmmmmmmm|
 * 31| 30-23  |  22    	-       0       |
 *
 * The exponent is stored in a biased input. The bias in this case 127.
 * Therefore, our exponent is equal to the 8-bit value - 127.
 *
 * By default, a number is normalized in IEEE, that means that the mantissa has
 * an implicit one that we don't see. So really the value stored is 1.m.
 * However, if the exponent is all zeros, then instead we have to shift
 * everything to the right one and there is no more implicit one.
 *
 * Special values:
 *  - Positive Infinity:
 *	Sign:		0
 *	Exponent: 	All 1s
 *	Mantissa:	0
 *  - Negative Infinity:
 *	Sign:		1
 *	Exponent: 	All 1s
 *	Mantissa:	0
 *  - NaN:
 *	Sign:		*
 *	Exponent: 	All 1s
 *	Mantissa:	non-zero
 *  - Zero:
 *	Sign:		*
 *	Exponent:	All 0s
 *	Mantissa:	0
 *
 * In the case of zero, the sign bit determines whether we get a positive or
 * negative zero. However, since Javascript cannot determine the difference
 * between the two: i.e. -0 == 0, we just always return 0.
 *
 */
function rfloat(buffer, endian, offset)
{
	var bytes = [];
	var sign, exponent, mantissa, val;
	var bias = 127;
	var maxexp = 0xff;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	/* Normalize the bytes to be in endian order */
	if (endian == 'big') {
		bytes[0] = buffer[offset];
		bytes[1] = buffer[offset+1];
		bytes[2] = buffer[offset+2];
		bytes[3] = buffer[offset+3];
	} else {
		bytes[3] = buffer[offset];
		bytes[2] = buffer[offset+1];
		bytes[1] = buffer[offset+2];
		bytes[0] = buffer[offset+3];
	}

	sign = bytes[0] & 0x80;
	exponent = (bytes[0] & 0x7f) << 1;
	exponent |= (bytes[1] & 0x80) >>> 7;
	mantissa = (bytes[1] & 0x7f) << 16;
	mantissa |= bytes[2] << 8;
	mantissa |= bytes[3];

	/* Check for special cases before we do general parsing */
	if (!sign && exponent == maxexp && mantissa === 0)
		return (Number.POSITIVE_INFINITY);

	if (sign && exponent == maxexp && mantissa === 0)
		return (Number.NEGATIVE_INFINITY);

	if (exponent == maxexp && mantissa !== 0)
		return (Number.NaN);

	/*
	 * Javascript really doesn't have support for positive or negative zero.
	 * So we're not going to try and give it to you. That would be just
	 * plain weird. Besides -0 == 0.
	 */
	if (exponent === 0 && mantissa === 0)
		return (0);

	/*
	 * Now we can deal with the bias and the determine whether the mantissa
	 * has the implicit one or not.
	 */
	exponent -= bias;
	if (exponent == -bias) {
		exponent++;
		val = 0;
	} else {
		val = 1;
	}

	val = (val + mantissa * Math.pow(2, -23)) * Math.pow(2, exponent);

	if (sign)
		val *= -1;

	return (val);
}

/*
 * Doubles in IEEE 754 are like their brothers except for a few changes and
 * increases in size:
 *   - The exponent is now 11 bits
 *   - The mantissa is now 52 bits
 *   - The bias is now 1023
 *
 * |s|eeeeeeeeeee|mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm|
 * 63| 62 - 52   | 	51		-			0     |
 * 63| 62 - 52   |      51              -                       0     |
 *
 * While the size has increased a fair amount, we're going to end up keeping the
 * same general formula for calculating the final value. As a reminder, this
 * formula is:
 *
 * (-1)^s * (n + m) * 2^(e-b)
 *
 * Where:
 *	s	is the sign bit
 *	n	is (exponent > 0) ? 1 : 0 -- Determines whether we're normalized
 *					     or not
 *	m	is the mantissa
 *	e	is the exponent specified
 *	b	is the bias for the exponent
 *
 */
function rdouble(buffer, endian, offset)
{
	var bytes = [];
	var sign, exponent, mantissa, val, lowmant;
	var bias = 1023;
	var maxexp = 0x7ff;

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 7 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	/* Normalize the bytes to be in endian order */
	if (endian == 'big') {
		bytes[0] = buffer[offset];
		bytes[1] = buffer[offset+1];
		bytes[2] = buffer[offset+2];
		bytes[3] = buffer[offset+3];
		bytes[4] = buffer[offset+4];
		bytes[5] = buffer[offset+5];
		bytes[6] = buffer[offset+6];
		bytes[7] = buffer[offset+7];
	} else {
		bytes[7] = buffer[offset];
		bytes[6] = buffer[offset+1];
		bytes[5] = buffer[offset+2];
		bytes[4] = buffer[offset+3];
		bytes[3] = buffer[offset+4];
		bytes[2] = buffer[offset+5];
		bytes[1] = buffer[offset+6];
		bytes[0] = buffer[offset+7];
	}

	/*
	 * We can construct the exponent and mantissa the same way as we did in
	 * the case of a float, just increase the range of the exponent.
	 */
	sign = bytes[0] & 0x80;
	exponent = (bytes[0] & 0x7f) << 4;
	exponent |= (bytes[1] & 0xf0) >>> 4;

	/*
	 * This is going to be ugly but then again, we're dealing with IEEE 754.
	 * This could probably be done as a node add on in a few lines of C++,
	 * but oh we'll, we've made it this far so let's be native the rest of
	 * the way...
	 *
	 * What we're going to do is break the mantissa into two parts, the
	 * lower 24 bits and the upper 28 bits. We'll multiply the upper 28 bits
	 * by the appropriate power and then add in the lower 24-bits. Not
	 * really that great. It's pretty much a giant kludge to deal with
	 * Javascript eccentricities around numbers.
	 */
	lowmant = bytes[7];
	lowmant |= bytes[6] << 8;
	lowmant |= bytes[5] << 16;
	mantissa = bytes[4];
	mantissa |= bytes[3] << 8;
	mantissa |= bytes[2] << 16;
	mantissa |= (bytes[1] & 0x0f) << 24;
	mantissa *= Math.pow(2, 24); /* Equivalent to << 24, but JS compat */
	mantissa += lowmant;

	/* Check for special cases before we do general parsing */
	if (!sign && exponent == maxexp && mantissa === 0)
		return (Number.POSITIVE_INFINITY);

	if (sign && exponent == maxexp && mantissa === 0)
		return (Number.NEGATIVE_INFINITY);

	if (exponent == maxexp && mantissa !== 0)
		return (Number.NaN);

	/*
	 * Javascript really doesn't have support for positive or negative zero.
	 * So we're not going to try and give it to you. That would be just
	 * plain weird. Besides -0 == 0.
	 */
	if (exponent === 0 && mantissa === 0)
		return (0);

	/*
	 * Now we can deal with the bias and the determine whether the mantissa
	 * has the implicit one or not.
	 */
	exponent -= bias;
	if (exponent == -bias) {
		exponent++;
		val = 0;
	} else {
		val = 1;
	}

	val = (val + mantissa * Math.pow(2, -52)) * Math.pow(2, exponent);

	if (sign)
		val *= -1;

	return (val);
}

/*
 * Now that we have gone through the pain of reading the individual types, we're
 * probably going to want some way to write these back. None of this is going to
 * be good. But since we have Javascript numbers this should certainly be more
 * interesting. Though we can constrain this end a little bit more in what is
 * valid. For now, let's go back to our friends the unsigned value.
 */

/*
 * Unsigned numbers seem deceptively easy. Here are the general steps and rules
 * that we are going to take:
 *   -  If the number is negative, throw an Error
 *   -  Truncate any floating point portion
 *   -  Take the modulus of the number in our base
 *   -  Write it out to the buffer in the endian format requested at the offset
 */

/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *	value		The number to check for validity
 *
 *	max		The maximum value
 */
function prepuint(value, max)
{
	if (typeof (value) != 'number')
		throw (new (Error('cannot write a non-number as a number')));

	if (value < 0)
		throw (new Error('specified a negative value for writing an ' +
		    'unsigned value'));

	if (value > max)
		throw (new Error('value is larger than maximum value for ' +
		    'type'));

	if (Math.floor(value) !== value)
		throw (new Error('value has a fractional component'));

	return (value);
}

/*
 * 8-bit version, classy. We can ignore endianness which is good.
 */
function wuint8(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepuint(value, 0xff);
	buffer[offset] = val;
}

/*
 * Pretty much the same as the 8-bit version, just this time we need to worry
 * about endian related issues.
 */
function wgint16(val, endian, buffer, offset)
{
	if (endian == 'big') {
		buffer[offset] = (val & 0xff00) >>> 8;
		buffer[offset+1] = val & 0x00ff;
	} else {
		buffer[offset+1] = (val & 0xff00) >>> 8;
		buffer[offset] = val & 0x00ff;
	}
}

function wuint16(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 1 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepuint(value, 0xffff);
	wgint16(val, endian, buffer, offset);
}

/*
 * The 32-bit version is going to have to be a little different unfortunately.
 * We can't quite bitshift to get the largest byte, because that would end up
 * getting us caught by the signed values.
 *
 * And yes, we do want to subtract out the lower part by default. This means
 * that when we do the division, it will be treated as a bit shift and we won't
 * end up generating a floating point value. If we did generate a floating point
 * value we'd have to truncate it intelligently, this saves us that problem and
 * may even be somewhat faster under the hood.
 */
function wgint32(val, endian, buffer, offset)
{
	if (endian == 'big') {
		buffer[offset] = (val - (val & 0x00ffffff)) / Math.pow(2, 24);
		buffer[offset+1] = (val >>> 16) & 0xff;
		buffer[offset+2] = (val >>> 8) & 0xff;
		buffer[offset+3] = val & 0xff;
	} else {
		buffer[offset+3] = (val - (val & 0x00ffffff)) /
		    Math.pow(2, 24);
		buffer[offset+2] = (val >>> 16) & 0xff;
		buffer[offset+1] = (val >>> 8) & 0xff;
		buffer[offset] = val & 0xff;
	}
}

function wuint32(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepuint(value, 0xffffffff);
	wgint32(val, endian, buffer, offset);
}

/*
 * Unlike the other versions, we expect the value to be in the form of two
 * arrays where value[0] << 32 + value[1] would result in the value that we
 * want.
 */
function wgint64(value, endian, buffer, offset)
{
	if (endian == 'big') {
		wgint32(value[0], endian, buffer, offset);
		wgint32(value[1], endian, buffer, offset+4);
	} else {
		wgint32(value[0], endian, buffer, offset+4);
		wgint32(value[1], endian, buffer, offset);
	}
}

function wuint64(value, endian, buffer, offset)
{
	if (value === undefined)
		throw (new Error('missing value'));

	if (!(value instanceof Array))
		throw (new Error('value must be an array'));

	if (value.length != 2)
		throw (new Error('value must be an array of length 2'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 7 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	prepuint(value[0], 0xffffffff);
	prepuint(value[1], 0xffffffff);
	wgint64(value, endian, buffer, offset);
}

/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *	we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *	we do the following computation:
 *	mb + val + 1, where
 *	mb	is the maximum unsigned value in that byte size
 *	val	is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 *
 * Thus the overall flow is:
 *   -  Truncate the floating point part of the number
 *   -  We don't have to take the modulus, because the unsigned versions will
 *   	take care of that for us. And we don't have to worry about that
 *   	potentially causing bad things to happen because of sign extension
 *   -  Pass it off to the appropriate unsigned version, potentially modifying
 *	the negative portions as necessary.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function prepsint(value, max, min)
{
	if (typeof (value) != 'number')
		throw (new (Error('cannot write a non-number as a number')));

	if (value > max)
		throw (new Error('value larger than maximum allowed value'));

	if (value < min)
		throw (new Error('value smaller than minimum allowed value'));

	if (Math.floor(value) !== value)
		throw (new Error('value has a fractional component'));

	return (value);
}

/*
 * The 8-bit version of the signed value. Overall, fairly straightforward.
 */
function wsint8(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepsint(value, 0x7f, -0x80);
	if (val >= 0)
		wuint8(val, endian, buffer, offset);
	else
		wuint8(0xff + val + 1, endian, buffer, offset);
}

/*
 * The 16-bit version of the signed value. Also, fairly straightforward.
 */
function wsint16(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 1 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepsint(value, 0x7fff, -0x8000);
	if (val >= 0)
		wgint16(val, endian, buffer, offset);
	else
		wgint16(0xffff + val + 1, endian, buffer, offset);

}

/*
 * We can do this relatively easily by leveraging the code used for 32-bit
 * unsigned code.
 */
function wsint32(value, endian, buffer, offset)
{
	var val;

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	val = prepsint(value, 0x7fffffff, -0x80000000);
	if (val >= 0)
		wgint32(val, endian, buffer, offset);
	else
		wgint32(0xffffffff + val + 1, endian, buffer, offset);
}

/*
 * The signed 64 bit integer should by in the same format as when received.
 * Mainly it should ensure that the value is an array of two integers where
 * value[0] << 32 + value[1] is the desired number. Furthermore, the two values
 * need to be equal.
 */
function wsint64(value, endian, buffer, offset)
{
	var vzpos, vopos;
	var vals = new Array(2);

	if (value === undefined)
		throw (new Error('missing value'));

	if (!(value instanceof Array))
		throw (new Error('value must be an array'));

	if (value.length != 2)
		throw (new Error('value must be an array of length 2'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));

	if (offset + 7 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	/*
	 * We need to make sure that we have the same sign on both values. The
	 * hokiest way to to do this is to multiply the number by +inf. If we do
	 * this, we'll get either +/-inf depending on the sign of the value.
	 * Once we have this, we can compare it to +inf to see if the number is
	 * positive or not.
	 */
	vzpos = (value[0] * Number.POSITIVE_INFINITY) ==
	    Number.POSITIVE_INFINITY;
	vopos = (value[1] * Number.POSITIVE_INFINITY) ==
	    Number.POSITIVE_INFINITY;

	/*
	 * If either of these is zero, then we don't actually need this check.
	 */
	if (value[0] != 0 && value[1] != 0 && vzpos != vopos)
		throw (new Error('Both entries in the array must have ' +
		    'the same sign'));

	/*
	 * Doing verification for a signed 64-bit integer is actually a big
	 * trickier than it appears. We can't quite use our standard techniques
	 * because we need to compare both sets of values. The first value is
	 * pretty straightforward. If the first value is beond the extremes than
	 * we error out. However, the valid range of the second value varies
	 * based on the first one. If the first value is negative, and *not* the
	 * largest negative value, than it can be any integer within the range [
	 * 0, 0xffffffff ]. If it is the largest negative number, it must be
	 * zero.
	 *
	 * If the first number is positive, than it doesn't matter what the
	 * value is. We just simply have to make sure we have a valid positive
	 * integer.
	 */
	if (vzpos) {
		prepuint(value[0], 0x7fffffff);
		prepuint(value[1], 0xffffffff);
	} else {
		prepsint(value[0], 0, -0x80000000);
		prepsint(value[1], 0, -0xffffffff);
		if (value[0] == -0x80000000 && value[1] != 0)
			throw (new Error('value smaller than minimum ' +
			    'allowed value'));
	}

	/* Fix negative numbers */
	if (value[0] < 0 || value[1] < 0) {
		vals[0] = 0xffffffff - Math.abs(value[0]);
		vals[1] = 0x100000000 - Math.abs(value[1]);
		if (vals[1] == 0x100000000) {
			vals[1] = 0;
			vals[0]++;
		}
	} else {
		vals[0] = value[0];
		vals[1] = value[1];
	}
	wgint64(vals, endian, buffer, offset);
}

/*
 * Now we are moving onto the weirder of these, the float and double. For this
 * we're going to just have to do something that's pretty weird. First off, we
 * have no way to get at the underlying float representation, at least not
 * easily. But that doesn't mean we can't figure it out, we just have to use our
 * heads.
 *
 * One might propose to use Number.toString(2). Of course, this is not really
 * that good, because the ECMAScript 262 v3 Standard says the following Section
 * 15.7.4.2-Number.prototype.toString (radix):
 *
 * If radix is an integer from 2 to 36, but not 10, the result is a string, the
 * choice of which is implementation-dependent.
 *
 * Well that doesn't really help us one bit now does it? We could use the
 * standard base 10 version of the string, but that's just going to create more
 * errors as we end up trying to convert it back to a binary value. So, really
 * this just means we have to be non-lazy and parse the structure intelligently.
 *
 * First off, we can do the basic checks: NaN, positive and negative infinity.
 *
 * Now that those are done we can work backwards to generate the mantissa and
 * exponent.
 *
 * The first thing we need to do is determine the sign bit, easy to do, check
 * whether the value is less than 0. And convert the number to its absolute
 * value representation. Next, we need to determine if the value is less than
 * one or greater than or equal to one and from there determine what power was
 * used to get there. What follows is now specific to floats, though the general
 * ideas behind this will hold for doubles as well, but the exact numbers
 * involved will change.
 *
 * Once we have that power we can determine the exponent and the mantissa. Call
 * the value that has the number of bits to reach the power ebits. In the
 * general case they have the following values:
 *
 *	exponent	127 + ebits
 *	mantissa	value * 2^(23 - ebits) & 0x7fffff
 *
 * In the case where the value of ebits is <= -127 we are now in the case where
 * we no longer have normalized numbers. In this case the values take on the
 * following values:
 *
 * 	exponent	0
 *	mantissa	value * 2^149 & 0x7fffff
 *
 * Once we have the values for the sign, mantissa, and exponent. We reconstruct
 * the four bytes as follows:
 *
 *	byte0		sign bit and seven most significant bits from the exp
 *			sign << 7 | (exponent & 0xfe) >>> 1
 *
 *	byte1		lsb from the exponent and 7 top bits from the mantissa
 *			(exponent & 0x01) << 7 | (mantissa & 0x7f0000) >>> 16
 *
 *	byte2		bits 8-15 (zero indexing) from mantissa
 *			mantissa & 0xff00 >> 8
 *
 *	byte3		bits 0-7 from mantissa
 *			mantissa & 0xff
 *
 * Once we have this we have to assign them into the buffer in proper endian
 * order.
 */

/*
 * Compute the log base 2 of the value. Now, someone who remembers basic
 * properties of logarithms will point out that we could use the change of base
 * formula for logs, and in fact that would be astute, because that's what we'll
 * do for now. It feels cleaner, albeit it may be less efficient than just
 * iterating and dividing by 2. We may want to come back and revisit that some
 * day.
 */
function log2(value)
{
	return (Math.log(value) / Math.log(2));
}

/*
 * Helper to determine the exponent of the number we're looking at.
 */
function intexp(value)
{
	return (Math.floor(log2(value)));
}

/*
 * Helper to determine the exponent of the fractional part of the value.
 */
function fracexp(value)
{
	return (Math.floor(log2(value)));
}

function wfloat(value, endian, buffer, offset)
{
	var sign, exponent, mantissa, ebits;
	var bytes = [];

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));


	if (offset + 3 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	if (isNaN(value)) {
		sign = 0;
		exponent = 0xff;
		mantissa = 23;
	} else if (value == Number.POSITIVE_INFINITY) {
		sign = 0;
		exponent = 0xff;
		mantissa = 0;
	} else if (value == Number.NEGATIVE_INFINITY) {
		sign = 1;
		exponent = 0xff;
		mantissa = 0;
	} else {
		/* Well we have some work to do */

		/* Thankfully the sign bit is trivial */
		if (value < 0) {
			sign = 1;
			value = Math.abs(value);
		} else {
			sign = 0;
		}

		/* Use the correct function to determine number of bits */
		if (value < 1)
			ebits = fracexp(value);
		else
			ebits = intexp(value);

		/* Time to deal with the issues surrounding normalization */
		if (ebits <= -127) {
			exponent = 0;
			mantissa = (value * Math.pow(2, 149)) & 0x7fffff;
		} else {
			exponent = 127 + ebits;
			mantissa = value * Math.pow(2, 23 - ebits);
			mantissa &= 0x7fffff;
		}
	}

	bytes[0] = sign << 7 | (exponent & 0xfe) >>> 1;
	bytes[1] = (exponent & 0x01) << 7 | (mantissa & 0x7f0000) >>> 16;
	bytes[2] = (mantissa & 0x00ff00) >>> 8;
	bytes[3] = mantissa & 0x0000ff;

	if (endian == 'big') {
		buffer[offset] = bytes[0];
		buffer[offset+1] = bytes[1];
		buffer[offset+2] = bytes[2];
		buffer[offset+3] = bytes[3];
	} else {
		buffer[offset] = bytes[3];
		buffer[offset+1] = bytes[2];
		buffer[offset+2] = bytes[1];
		buffer[offset+3] = bytes[0];
	}
}

/*
 * Now we move onto doubles. Doubles are similar to floats in pretty much all
 * ways except that the processing isn't quite as straightforward because we
 * can't always use shifting, i.e. we have > 32 bit values.
 *
 * We're going to proceed in an identical fashion to floats and utilize the same
 * helper functions. All that really is changing are the specific values that we
 * use to do the calculations. Thus, to review we have to do the following.
 *
 * First get the sign bit and convert the value to its absolute value
 * representation. Next, we determine the number of bits that we used to get to
 * the value, branching whether the value is greater than or less than 1. Once
 * we have that value which we will again call ebits, we have to do the
 * following in the general case:
 *
 *	exponent	1023 + ebits
 *	mantissa	[value * 2^(52 - ebits)] % 2^52
 *
 * In the case where the value of ebits <= -1023 we no longer use normalized
 * numbers, thus like with floats we have to do slightly different processing:
 *
 *	exponent	0
 *	mantissa	[value * 2^1074] % 2^52
 *
 * Once we have determined the sign, exponent and mantissa we can construct the
 * bytes as follows:
 *
 *	byte0		sign bit and seven most significant bits form the exp
 *			sign << 7 | (exponent & 0x7f0) >>> 4
 *
 *	byte1		Remaining 4 bits from the exponent and the four most
 *			significant bits from the mantissa 48-51
 *			(exponent & 0x00f) << 4 | mantissa >>> 48
 *
 *	byte2		Bits 40-47 from the mantissa
 *			(mantissa >>> 40) & 0xff
 *
 *	byte3		Bits 32-39 from the mantissa
 *			(mantissa >>> 32) & 0xff
 *
 *	byte4		Bits 24-31 from the mantissa
 *			(mantissa >>> 24) & 0xff
 *
 *	byte5		Bits 16-23 from the Mantissa
 *			(mantissa >>> 16) & 0xff
 *
 *	byte6		Bits 8-15 from the mantissa
 *			(mantissa >>> 8) & 0xff
 *
 *	byte7		Bits 0-7 from the mantissa
 *			mantissa & 0xff
 *
 * Now we can't quite do the right shifting that we want in bytes 1 - 3, because
 * we'll have extended too far and we'll lose those values when we try and do
 * the shift. Instead we have to use an alternate approach. To try and stay out
 * of floating point, what we'll do is say that mantissa -= bytes[4-7] and then
 * divide by 2^32. Once we've done that we can use binary arithmetic. Oof,
 * that's ugly, but it seems to avoid using floating point (just based on how v8
 * seems to be optimizing for base 2 arithmetic).
 */
function wdouble(value, endian, buffer, offset)
{
	var sign, exponent, mantissa, ebits;
	var bytes = [];

	if (value === undefined)
		throw (new Error('missing value'));

	if (endian === undefined)
		throw (new Error('missing endian'));

	if (buffer === undefined)
		throw (new Error('missing buffer'));

	if (offset === undefined)
		throw (new Error('missing offset'));


	if (offset + 7 >= buffer.length)
		throw (new Error('Trying to read beyond buffer length'));

	if (isNaN(value)) {
		sign = 0;
		exponent = 0x7ff;
		mantissa = 23;
	} else if (value == Number.POSITIVE_INFINITY) {
		sign = 0;
		exponent = 0x7ff;
		mantissa = 0;
	} else if (value == Number.NEGATIVE_INFINITY) {
		sign = 1;
		exponent = 0x7ff;
		mantissa = 0;
	} else {
		/* Well we have some work to do */

		/* Thankfully the sign bit is trivial */
		if (value < 0) {
			sign = 1;
			value = Math.abs(value);
		} else {
			sign = 0;
		}

		/* Use the correct function to determine number of bits */
		if (value < 1)
			ebits = fracexp(value);
		else
			ebits = intexp(value);

		/*
		 * This is a total hack to determine a denormalized value.
		 * Unfortunately, we sometimes do not get a proper value for
		 * ebits, i.e. we lose the values that would get rounded off.
		 *
		 *
		 * The astute observer may wonder why we would be
		 * multiplying by two Math.pows rather than just summing
		 * them. Well, that's to get around a small bug in the
		 * way v8 seems to implement the function. On occasion
		 * doing:
		 *
		 * foo * Math.pow(2, 1023 + 51)
		 *
		 * Causes us to overflow to infinity, where as doing:
		 *
		 * foo * Math.pow(2, 1023) * Math.pow(2, 51)
		 *
		 * Does not cause us to overflow. Go figure.
		 *
		 */
		if (value <= 2.225073858507201e-308 || ebits <= -1023) {
			exponent = 0;
			mantissa = value * Math.pow(2, 1023) * Math.pow(2, 51);
			mantissa %= Math.pow(2, 52);
		} else {
			/*
			 * We might have gotten fucked by our floating point
			 * logarithm magic. This is rather crappy, but that's
			 * our luck. If we just had a log base 2 or access to
			 * the stupid underlying representation this would have
			 * been much easier and we wouldn't have such stupid
			 * kludges or hacks.
			 */
			if (ebits > 1023)
				ebits = 1023;
			exponent = 1023 + ebits;
			mantissa = value * Math.pow(2, -ebits);
			mantissa *= Math.pow(2, 52);
			mantissa %= Math.pow(2, 52);
		}
	}

	/* Fill the bytes in backwards to deal with the size issues */
	bytes[7] = mantissa & 0xff;
	bytes[6] = (mantissa >>> 8) & 0xff;
	bytes[5] = (mantissa >>> 16) & 0xff;
	mantissa = (mantissa - (mantissa & 0xffffff)) / Math.pow(2, 24);
	bytes[4] = mantissa & 0xff;
	bytes[3] = (mantissa >>> 8) & 0xff;
	bytes[2] = (mantissa >>> 16) & 0xff;
	bytes[1] = (exponent & 0x00f) << 4 | mantissa >>> 24;
	bytes[0] = (sign << 7) | (exponent & 0x7f0) >>> 4;

	if (endian == 'big') {
		buffer[offset] = bytes[0];
		buffer[offset+1] = bytes[1];
		buffer[offset+2] = bytes[2];
		buffer[offset+3] = bytes[3];
		buffer[offset+4] = bytes[4];
		buffer[offset+5] = bytes[5];
		buffer[offset+6] = bytes[6];
		buffer[offset+7] = bytes[7];
	} else {
		buffer[offset+7] = bytes[0];
		buffer[offset+6] = bytes[1];
		buffer[offset+5] = bytes[2];
		buffer[offset+4] = bytes[3];
		buffer[offset+3] = bytes[4];
		buffer[offset+2] = bytes[5];
		buffer[offset+1] = bytes[6];
		buffer[offset] = bytes[7];
	}
}

/*
 * Actually export our work above. One might argue that we shouldn't expose
 * these interfaces and just force people to use the higher level abstractions
 * around this work. However, unlike say other libraries we've come across, this
 * interface has several properties: it makes sense, it's simple, and it's
 * useful.
 */
exports.ruint8 = ruint8;
exports.ruint16 = ruint16;
exports.ruint32 = ruint32;
exports.ruint64 = ruint64;
exports.wuint8 = wuint8;
exports.wuint16 = wuint16;
exports.wuint32 = wuint32;
exports.wuint64 = wuint64;

exports.rsint8 = rsint8;
exports.rsint16 = rsint16;
exports.rsint32 = rsint32;
exports.rsint64 = rsint64;
exports.wsint8 = wsint8;
exports.wsint16 = wsint16;
exports.wsint32 = wsint32;
exports.wsint64 = wsint64;

exports.rfloat = rfloat;
exports.rdouble = rdouble;
exports.wfloat = wfloat;
exports.wdouble = wdouble;

},{"assert":18}],54:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var ltx = require('ltx');
var StreamParser = require('./stream_parser');
var WebSocket = require('faye-websocket') ?
                require('faye-websocket').Client :
                window.WebSocket;


var NS_STREAM = exports.NS_STREAM = 'http://etherx.jabber.org/streams';
var NS_XMPP_STREAMS = 'urn:ietf:params:xml:ns:xmpp-streams';

function WSConnection(url) {
    EventEmitter.call(this);

    this.url = url;
    this.xmlns = {};
    this.websocket = new WebSocket(this.url, ['xmpp']);
    this.websocket.onopen = this.onopen.bind(this);
    this.websocket.onmessage = this.onmessage.bind(this);
    this.websocket.onclose = this.onclose.bind(this);
    this.websocket.onerror = this.onerror.bind(this);
}
util.inherits(WSConnection, EventEmitter);
exports.WSConnection = WSConnection;

WSConnection.prototype.maxStanzaSize = 65535;

WSConnection.prototype.onopen = function() {
    this.emit('connected');
    this.startParser();
};

WSConnection.prototype.startParser = function() {
    var self = this;
    this.parser = new StreamParser.StreamParser(this.maxStanzaSize);

    this.parser.addListener('start', function(attrs) {
        self.streamAttrs = attrs;
        /* We need those xmlns often, store them extra */
        self.streamNsAttrs = {};
        for(var k in attrs) {
        if (k == 'xmlns' ||
            k.substr(0, 6) == 'xmlns:')
                self.streamNsAttrs[k] = attrs[k];
        }

        /* Notify in case we don't wait for <stream:features/>
           (Component or non-1.0 streams)
         */
        self.emit('streamStart', attrs);
    });
    this.parser.addListener('stanza', function(stanza) {
        //self.onStanza(self.addStreamNs(stanza));
        self.onStanza(stanza);
    });
    this.parser.addListener('error', this.onerror.bind(this));
    this.parser.addListener('end', function() {
        self.stopParser();
        self.end();
    });
};

WSConnection.prototype.stopParser = function() {
    /* No more events, please (may happen however) */
    if(this.parser) {
        /* Get GC'ed */
        delete this.parser;
    }
};

WSConnection.prototype.onmessage = function(msg) {
    console.log("ws msg", msg.data);
    if (msg && msg.data && this.parser)
	this.parser.write(msg.data);
};

WSConnection.prototype.onStanza = function(stanza) {
    if (stanza.is('error', NS_STREAM)) {
        /* TODO: extract error text */
        this.emit('error', stanza);
    } else {
        this.emit('stanza', stanza);
    }
};

WSConnection.prototype.startStream = function() {
    var attrs = {};
    for(var k in this.xmlns) {
        if (this.xmlns.hasOwnProperty(k)) {
            if (!k)
                attrs.xmlns = this.xmlns[k];
            else
                attrs['xmlns:' + k] = this.xmlns[k];
        }
    }
    if (this.xmppVersion)
        attrs.version = this.xmppVersion;
    if (this.streamTo)
        attrs.to = this.streamTo;
    if (this.streamId)
        attrs.id = this.streamId;

    var el = new ltx.Element('stream:stream', attrs);
    // make it non-empty to cut the closing tag
    el.t(' ');
    var s = el.toString();
    this.send(s.substr(0, s.indexOf(' </stream:stream>')));

    this.streamOpened = true;
};

WSConnection.prototype.send = function(stanza) {
    if (stanza.root)
	stanza = stanza.root();
    stanza = stanza.toString();
    console.log("ws send", stanza);
    this.websocket.send(stanza);
};

WSConnection.prototype.onclose = function() {
};

WSConnection.prototype.end = function() {
    this.send("</stream:stream>");
    if (this.websocket)
	this.websocket.close();
};

WSConnection.prototype.onerror = function(e) {
    this.emit('error', e);
};

},{"events":4,"util":5,"faye-websocket":17,"./stream_parser":56,"ltx":39}],61:[function(require,module,exports){
(function(Buffer){var util = require('util');
var Stream = require('stream').Stream;
var DelayedStream = require('delayed-stream');

module.exports = CombinedStream;
function CombinedStream() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;

  this._released = false;
  this._streams = [];
  this._currentStream = null;
}
util.inherits(CombinedStream, Stream);

CombinedStream.create = function(options) {
  var combinedStream = new this();

  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }

  return combinedStream;
};

CombinedStream.isStreamLike = function(stream) {
  return (typeof stream !== 'function')
    && (typeof stream !== 'string')
    && (typeof stream !== 'boolean')    
    && (typeof stream !== 'number')
    && (!Buffer.isBuffer(stream));
};

CombinedStream.prototype.append = function(stream) {
  var isStreamLike = CombinedStream.isStreamLike(stream);

  if (isStreamLike) {
    if (!(stream instanceof DelayedStream)) {
      stream.on('data', this._checkDataSize.bind(this));

      stream = DelayedStream.create(stream, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams,
      });
    }

    this._handleErrors(stream);

    if (this.pauseStreams) {
      stream.pause();
    }
  }

  this._streams.push(stream);
  return this;
};

CombinedStream.prototype.pipe = function(dest, options) {
  Stream.prototype.pipe.call(this, dest, options);
  this.resume();
};

CombinedStream.prototype._getNext = function() {
  this._currentStream = null;
  var stream = this._streams.shift();


  if (typeof stream == 'undefined') {
    this.end();
    return;
  }

  if (typeof stream !== 'function') {
    this._pipeNext(stream);
    return;
  }

  var getStream = stream;
  getStream(function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on('data', this._checkDataSize.bind(this));
      this._handleErrors(stream);
    }

    this._pipeNext(stream);
  }.bind(this));
};

CombinedStream.prototype._pipeNext = function(stream) {
  this._currentStream = stream;

  var isStreamLike = CombinedStream.isStreamLike(stream);
  if (isStreamLike) {
    stream.on('end', this._getNext.bind(this))
    stream.pipe(this, {end: false});
    return;
  }

  var value = stream;
  this.write(value);
  this._getNext();
};

CombinedStream.prototype._handleErrors = function(stream) {
  var self = this;
  stream.on('error', function(err) {
    self._emitError(err);
  });
};

CombinedStream.prototype.write = function(data) {
  this.emit('data', data);
};

CombinedStream.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }

  this.emit('pause');
};

CombinedStream.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }

  this.emit('resume');
};

CombinedStream.prototype.end = function() {
  this._reset();
  this.emit('end');
};

CombinedStream.prototype.destroy = function() {
  this._reset();
  this.emit('close');
};

CombinedStream.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};

CombinedStream.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this._emitError(new Error(message));
};

CombinedStream.prototype._updateDataSize = function() {
  this.dataSize = 0;

  var self = this;
  this._streams.forEach(function(stream) {
    if (!stream.dataSize) {
      return;
    }

    self.dataSize += stream.dataSize;
  });

  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};

CombinedStream.prototype._emitError = function(err) {
  this._reset();
  this.emit('error', err);
};

})(require("__browserify_buffer").Buffer)
},{"util":5,"stream":3,"delayed-stream":75,"__browserify_buffer":19}],68:[function(require,module,exports){
// Load modules

var Boom = require('boom');
var Hoek = require('hoek');
var Cryptiles = require('cryptiles');
var Crypto = require('./crypto');
var Utils = require('./utils');


// Declare internals

var internals = {};


// Hawk authentication

/*
   req:                 node's HTTP request object or an object as follows:
  
                        var request = {
                            method: 'GET',
                            url: '/resource/4?a=1&b=2',
                            host: 'example.com',
                            port: 8080,
                            authorization: 'Hawk id="dh37fgj492je", ts="1353832234", nonce="j4h3g2", ext="some-app-ext-data", mac="6R4rV5iE+NPoym+WwjeHzjAGXUtLNIxmo1vpMofpLAE="'
                        };
  
   credentialsFunc:     required function to lookup the set of Hawk credentials based on the provided credentials id.
                        The credentials include the MAC key, MAC algorithm, and other attributes (such as username)
                        needed by the application. This function is the equivalent of verifying the username and
                        password in Basic authentication.
  
                        var credentialsFunc = function (id, callback) {
    
                            // Lookup credentials in database
                            db.lookup(id, function (err, item) {
    
                                if (err || !item) {
                                    return callback(err);
                                }
    
                                var credentials = {
                                    // Required
                                    key: item.key,
                                    algorithm: item.algorithm,
                                    // Application specific
                                    user: item.user
                                };
    
                                return callback(null, credentials);
                            });
                        };
  
   options: {

        hostHeaderName:        optional header field name, used to override the default 'Host' header when used
                               behind a cache of a proxy. Apache2 changes the value of the 'Host' header while preserving
                               the original (which is what the module must verify) in the 'x-forwarded-host' header field.
                               Only used when passed a node Http.ServerRequest object.
  
        nonceFunc:             optional nonce validation function. The function signature is function(nonce, ts, callback)
                               where 'callback' must be called using the signature function(err).
  
        timestampSkewSec:      optional number of seconds of permitted clock skew for incoming timestamps. Defaults to 60 seconds.
                               Provides a +/- skew which means actual allowed window is double the number of seconds.
  
        localtimeOffsetMsec:   optional local clock time offset express in a number of milliseconds (positive or negative).
                               Defaults to 0.
  
        payload:               optional payload for validation. The client calculates the hash value and includes it via the 'hash'
                               header attribute. The server always ensures the value provided has been included in the request
                               MAC. When this option is provided, it validates the hash value itself. Validation is done by calculating
                               a hash value over the entire payload (assuming it has already be normalized to the same format and
                               encoding used by the client to calculate the hash on request). If the payload is not available at the time
                               of authentication, the authenticatePayload() method can be used by passing it the credentials and
                               attributes.hash returned in the authenticate callback.
    }

    callback: function (err, credentials, artifacts) { }
 */

exports.authenticate = function (req, credentialsFunc, options, callback) {

    callback = Utils.nextTick(callback);
    
    // Default options

    options.nonceFunc = options.nonceFunc || function (nonce, ts, nonceCallback) { return nonceCallback(); };   // No validation
    options.timestampSkewSec = options.timestampSkewSec || 60;                                                  // 60 seconds

    // Application time

    var now = Utils.now() + (options.localtimeOffsetMsec || 0);                 // Measure now before any other processing

    // Convert node Http request object to a request configuration object

    var request = Utils.parseRequest(req, options);
    if (request instanceof Error) {
        return callback(Boom.badRequest(request.message));
    }

    // Parse HTTP Authorization header

    var attributes = Utils.parseAuthorizationHeader(request.authorization);
    if (attributes instanceof Error) {
        return callback(attributes);
    }

    // Construct artifacts container

    var artifacts = {
        method: request.method,
        host: request.host,
        port: request.port,
        resource: request.url,
        ts: attributes.ts,
        nonce: attributes.nonce,
        hash: attributes.hash,
        ext: attributes.ext,
        app: attributes.app,
        dlg: attributes.dlg,
        mac: attributes.mac,
        id: attributes.id
    };

    // Verify required header attributes

    if (!attributes.id ||
        !attributes.ts ||
        !attributes.nonce ||
        !attributes.mac) {

        return callback(Boom.badRequest('Missing attributes'), null, artifacts);
    }

    // Fetch Hawk credentials

    credentialsFunc(attributes.id, function (err, credentials) {

        if (err) {
            return callback(err, credentials || null, artifacts);
        }

        if (!credentials) {
            return callback(Boom.unauthorized('Unknown credentials', 'Hawk'), null, artifacts);
        }

        if (!credentials.key ||
            !credentials.algorithm) {

            return callback(Boom.internal('Invalid credentials'), credentials, artifacts);
        }

        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            return callback(Boom.internal('Unknown algorithm'), credentials, artifacts);
        }

        // Calculate MAC

        var mac = Crypto.calculateMac('header', credentials, artifacts);
        if (!Cryptiles.fixedTimeComparison(mac, attributes.mac)) {
            return callback(Boom.unauthorized('Bad mac', 'Hawk'), credentials, artifacts);
        }

        // Check payload hash

        if (options.payload !== null &&
            options.payload !== undefined) {       // '' is valid

            if (!attributes.hash) {
                return callback(Boom.unauthorized('Missing required payload hash', 'Hawk'), credentials, artifacts);
            }

            var hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, request.contentType);
            if (!Cryptiles.fixedTimeComparison(hash, attributes.hash)) {
                return callback(Boom.unauthorized('Bad payload hash', 'Hawk'), credentials, artifacts);
            }
        }

        // Check nonce

        options.nonceFunc(attributes.nonce, attributes.ts, function (err) {

            if (err) {
                return callback(Boom.unauthorized('Invalid nonce', 'Hawk'), credentials, artifacts);
            }

            // Check timestamp staleness

            if (Math.abs((attributes.ts * 1000) - now) > (options.timestampSkewSec * 1000)) {
                var fresh = Math.floor((Utils.now() + (options.localtimeOffsetMsec || 0)) / 1000);            // Get fresh now
                var tsm = Crypto.calculateTsMac(fresh, credentials);
                return callback(Boom.unauthorized('Stale timestamp', 'Hawk', { ts: fresh, tsm: tsm }), credentials, artifacts);
            }

            // Successful authentication

            return callback(null, credentials, artifacts);
        });
    });
};


// Authenticate payload hash - used when payload cannot be provided during authenticate()

/*
    payload:        raw request payload
    credentials:    from authenticate callback
    artifacts:      from authenticate callback
    contentType:    req.headers['content-type']
*/

exports.authenticatePayload = function (payload, credentials, artifacts, contentType) {

    var calculatedHash = Crypto.calculatePayloadHash(payload, credentials.algorithm, contentType);
    return Cryptiles.fixedTimeComparison(calculatedHash, artifacts.hash);
};


// Generate a Server-Authorization header for a given response

/*
    credentials: {},                                        // Object received from authenticate()
    artifacts: {}                                           // Object received from authenticate(); 'mac', 'hash', and 'ext' - ignored
    options: {
        ext: 'application-specific',                        // Application specific data sent via the ext attribute
        payload: '{"some":"payload"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
        contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
        hash: 'U4MKKSmiVxk37JCCrAVIjV='                     // Pre-calculated payload hash
    }
*/

exports.header = function (credentials, artifacts, options) {

    // Prepare inputs

    options = options || {};

    if (!artifacts ||
        typeof artifacts !== 'object' ||
        typeof options !== 'object') {

        return '';
    }

    artifacts = Hoek.clone(artifacts);
    delete artifacts.mac;
    artifacts.hash = options.hash;
    artifacts.ext = options.ext;

    // Validate credentials

    if (!credentials ||
        !credentials.key ||
        !credentials.algorithm) {

        // Invalid credential object
        return '';
    }

    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
        return '';
    }

    // Calculate payload hash

    if (!artifacts.hash &&
        options.hasOwnProperty('payload')) {

        artifacts.hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);
    }

    var mac = Crypto.calculateMac('response', credentials, artifacts);

    // Construct header

    var header = 'Hawk mac="' + mac + '"' +
                 (artifacts.hash ? ', hash="' + artifacts.hash + '"' : '');

    if (artifacts.ext !== null &&
        artifacts.ext !== undefined &&
        artifacts.ext !== '') {                       // Other falsey values allowed

        header += ', ext="' + Utils.escapeHeaderAttribute(artifacts.ext) + '"';
    }

    return header;
};


/*
 * Arguments and options are the same as index.js with the exception that the only supported options are:
 * 'hostHeaderName', 'localtimeOffsetMsec'
 */

exports.authenticateBewit = function (req, credentialsFunc, options, callback) {

    callback = Utils.nextTick(callback);

    // Application time

    var now = Utils.now() + (options.localtimeOffsetMsec || 0);

    // Convert node Http request object to a request configuration object

    var request = Utils.parseRequest(req, options);
    if (request instanceof Error) {
        return callback(Boom.badRequest(request.message));
    }

    // Extract bewit

    //                                 1     2             3           4     
    var resource = request.url.match(/^(\/.*)([\?&])bewit\=([^&$]*)(?:&(.+))?$/);
    if (!resource) {
        return callback(Boom.unauthorized(null, 'Hawk'));
    }

    // Bewit not empty

    if (!resource[3]) {
        return callback(Boom.unauthorized('Empty bewit', 'Hawk'));
    }

    // Verify method is GET

    if (request.method !== 'GET' &&
        request.method !== 'HEAD') {

        return callback(Boom.unauthorized('Invalid method', 'Hawk'));
    }

    // No other authentication

    if (request.authorization) {
        return callback(Boom.badRequest('Multiple authentications', 'Hawk'));
    }

    // Parse bewit

    var bewitString = Utils.base64urlDecode(resource[3]);
    if (bewitString instanceof Error) {
        return callback(Boom.badRequest('Invalid bewit encoding'));
    }

    // Bewit format: id\exp\mac\ext ('\' is used because it is a reserved header attribute character)

    var bewitParts = bewitString.split('\\');
    if (!bewitParts ||
        bewitParts.length !== 4) {

        return callback(Boom.badRequest('Invalid bewit structure'));
    }

    var bewit = {
        id: bewitParts[0],
        exp: parseInt(bewitParts[1], 10),
        mac: bewitParts[2],
        ext: bewitParts[3] || ''
    };

    if (!bewit.id ||
        !bewit.exp ||
        !bewit.mac) {

        return callback(Boom.badRequest('Missing bewit attributes'));
    }

    // Construct URL without bewit

    var url = resource[1];
    if (resource[4]) {
        url += resource[2] + resource[4];
    }

    // Check expiration

    if (bewit.exp * 1000 <= now) {
        return callback(Boom.unauthorized('Access expired', 'Hawk'), null, bewit);
    }

    // Fetch Hawk credentials

    credentialsFunc(bewit.id, function (err, credentials) {

        if (err) {
            return callback(err, credentials || null, bewit.ext);
        }

        if (!credentials) {
            return callback(Boom.unauthorized('Unknown credentials', 'Hawk'), null, bewit);
        }

        if (!credentials.key ||
            !credentials.algorithm) {

            return callback(Boom.internal('Invalid credentials'), credentials, bewit);
        }

        if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
            return callback(Boom.internal('Unknown algorithm'), credentials, bewit);
        }

        // Calculate MAC

        var mac = Crypto.calculateMac('bewit', credentials, {
            ts: bewit.exp,
            nonce: '',
            method: 'GET',
            resource: url,
            host: request.host,
            port: request.port,
            ext: bewit.ext
        });

        if (!Cryptiles.fixedTimeComparison(mac, bewit.mac)) {
            return callback(Boom.unauthorized('Bad mac', 'Hawk'), credentials, bewit);
        }

        // Successful authentication

        return callback(null, credentials, bewit);
    });
};

},{"./crypto":66,"./utils":67,"boom":71,"hoek":76,"cryptiles":77}],69:[function(require,module,exports){
// Load modules

var Url = require('url');
var Hoek = require('hoek');
var Cryptiles = require('cryptiles');
var Crypto = require('./crypto');
var Utils = require('./utils');


// Declare internals

var internals = {};


// Generate an Authorization header for a given request

/*
    uri: 'http://example.com/resource?a=b' or object from Url.parse()
    method: HTTP verb (e.g. 'GET', 'POST')
    options: {

        // Required

        credentials: {
            id: 'dh37fgj492je',
            key: 'aoijedoaijsdlaksjdl',
            algorithm: 'sha256'                                 // 'sha1', 'sha256'
        },

        // Optional

        ext: 'application-specific',                        // Application specific data sent via the ext attribute
        timestamp: Date.now(),                              // A pre-calculated timestamp
        nonce: '2334f34f',                                  // A pre-generated nonce
        localtimeOffsetMsec: 400,                           // Time offset to sync with server time (ignored if timestamp provided)
        payload: '{"some":"payload"}',                      // UTF-8 encoded string for body hash generation (ignored if hash provided)
        contentType: 'application/json',                    // Payload content-type (ignored if hash provided)
        hash: 'U4MKKSmiVxk37JCCrAVIjV=',                    // Pre-calculated payload hash
        app: '24s23423f34dx',                               // Oz application id
        dlg: '234sz34tww3sd'                                // Oz delegated-by application id
    }
*/

exports.header = function (uri, method, options) {

    var result = {
        field: '',
        artifacts: {}
    };

    // Validate inputs

    if (!uri || (typeof uri !== 'string' && typeof uri !== 'object') ||
        !method || typeof method !== 'string' ||
        !options || typeof options !== 'object') {

        return result;
    }

    // Application time

    var timestamp = options.timestamp || Math.floor((Utils.now() + (options.localtimeOffsetMsec || 0)) / 1000)

    // Validate credentials

    var credentials = options.credentials;
    if (!credentials ||
        !credentials.id ||
        !credentials.key ||
        !credentials.algorithm) {

        // Invalid credential object
        return result;
    }

    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
        return result;
    }

    // Parse URI

    if (typeof uri === 'string') {
        uri = Url.parse(uri);
    }

    // Calculate signature

    var artifacts = {
        ts: timestamp,
        nonce: options.nonce || Cryptiles.randomString(6),
        method: method,
        resource: uri.pathname + (uri.search || ''),                            // Maintain trailing '?'
        host: uri.hostname,
        port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
        hash: options.hash,
        ext: options.ext,
        app: options.app,
        dlg: options.dlg
    };

    result.artifacts = artifacts;

    // Calculate payload hash

    if (!artifacts.hash &&
        options.hasOwnProperty('payload')) {

        artifacts.hash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, options.contentType);
    }

    var mac = Crypto.calculateMac('header', credentials, artifacts);

    // Construct header

    var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== '';       // Other falsey values allowed
    var header = 'Hawk id="' + credentials.id +
                 '", ts="' + artifacts.ts +
                 '", nonce="' + artifacts.nonce +
                 (artifacts.hash ? '", hash="' + artifacts.hash : '') +
                 (hasExt ? '", ext="' + Utils.escapeHeaderAttribute(artifacts.ext) : '') +
                 '", mac="' + mac + '"';

    if (artifacts.app) {
        header += ', app="' + artifacts.app +
                  (artifacts.dlg ? '", dlg="' + artifacts.dlg : '') + '"';
    }

    result.field = header;

    return result;
};


// Validate server response

/*
    res:        node's response object
    artifacts:  object recieved from header().artifacts
    options: {
        payload:    optional payload received
        required:   specifies if a Server-Authorization header is required. Defaults to 'false'
    }
*/

exports.authenticate = function (res, credentials, artifacts, options) {

    artifacts = Hoek.clone(artifacts);
    options = options || {};

    if (res.headers['www-authenticate']) {

        // Parse HTTP WWW-Authenticate header

        var attributes = Utils.parseAuthorizationHeader(res.headers['www-authenticate'], ['ts', 'tsm', 'error']);
        if (attributes instanceof Error) {
            return false;
        }

        if (attributes.ts) {
            var tsm = Crypto.calculateTsMac(attributes.ts, credentials);
            if (tsm !== attributes.tsm) {
                return false;
            }
        }
    }

    // Parse HTTP Server-Authorization header

    if (!res.headers['server-authorization'] &&
        !options.required) {

        return true;
    }

    var attributes = Utils.parseAuthorizationHeader(res.headers['server-authorization'], ['mac', 'ext', 'hash']);
    if (attributes instanceof Error) {
        return false;
    }

    artifacts.ext = attributes.ext;
    artifacts.hash = attributes.hash;

    var mac = Crypto.calculateMac('response', credentials, artifacts);
    if (mac !== attributes.mac) {
        return false;
    }

    if (!options.hasOwnProperty('payload')) {
        return true;
    }

    if (!attributes.hash) {
        return false;
    }

    var calculatedHash = Crypto.calculatePayloadHash(options.payload, credentials.algorithm, res.headers['content-type']);
    return (calculatedHash === attributes.hash);
};


// Generate a bewit value for a given URI

/*
 * credentials is an object with the following keys: 'id, 'key', 'algorithm'.
 * options is an object with the following optional keys: 'ext', 'localtimeOffsetMsec'
 */
/*
    uri: 'http://example.com/resource?a=b' or object from Url.parse()
    options: {

        // Required

        credentials: {
            id: 'dh37fgj492je',
            key: 'aoijedoaijsdlaksjdl',
            algorithm: 'sha256'                             // 'sha1', 'sha256'
        },
        ttlSec: 60 * 60,                                    // TTL in seconds

        // Optional

        ext: 'application-specific',                        // Application specific data sent via the ext attribute
        localtimeOffsetMsec: 400                            // Time offset to sync with server time
    };
*/

exports.getBewit = function (uri, options) {

    // Validate inputs

    if (!uri ||
        (typeof uri !== 'string' && typeof uri !== 'object') ||
        !options ||
        typeof options !== 'object' ||
        !options.ttlSec) {

        return '';
    }

    options.ext = (options.ext === null || options.ext === undefined ? '' : options.ext);       // Zero is valid value

    // Application time

    var now = Utils.now() + (options.localtimeOffsetMsec || 0);

    // Validate credentials

    var credentials = options.credentials;
    if (!credentials ||
        !credentials.id ||
        !credentials.key ||
        !credentials.algorithm) {

        return '';
    }

    if (Crypto.algorithms.indexOf(credentials.algorithm) === -1) {
        return '';
    }

    // Parse URI

    if (typeof uri === 'string') {
        uri = Url.parse(uri);
    }

    // Calculate signature

    var exp = Math.floor(now / 1000) + options.ttlSec;
    var mac = Crypto.calculateMac('bewit', credentials, {
        ts: exp,
        nonce: '',
        method: 'GET',
        resource: uri.pathname + (uri.search || ''),                            // Maintain trailing '?'
        host: uri.hostname,
        port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
        ext: options.ext
    });

    // Construct bewit: id\exp\mac\ext

    var bewit = credentials.id + '\\' + exp + '\\' + mac + '\\' + options.ext;
    return Utils.base64urlEncode(bewit);
};


},{"url":1,"./crypto":66,"./utils":67,"hoek":76,"cryptiles":77}],67:[function(require,module,exports){
(function(__dirname){// Load modules

var Hoek = require('hoek');
var Sntp = require('sntp');
var Boom = require('boom');


// Declare internals

var internals = {};


// Import Hoek Utilities

internals.import = function () {

    for (var i in Hoek) {
        if (Hoek.hasOwnProperty(i)) {
            exports[i] = Hoek[i];
        }
    }
};

internals.import();


// Hawk version

exports.version = function () {

    return exports.loadPackage(__dirname + '/..').version;
};


// Extract host and port from request

exports.parseHost = function (req, hostHeaderName) {

    hostHeaderName = (hostHeaderName ? hostHeaderName.toLowerCase() : 'host');
    var hostHeader = req.headers[hostHeaderName];
    if (!hostHeader) {
        return null;
    }

    var hostHeaderRegex = /^(?:(?:\r\n)?[\t ])*([^:]+)(?::(\d+))?(?:(?:\r\n)?[\t ])*$/;     // Does not support IPv6
    var hostParts = hostHeader.match(hostHeaderRegex);

    if (!hostParts ||
        hostParts.length !== 3 ||
        !hostParts[1]) {

        return null;
    }

    return {
        name: hostParts[1],
        port: (hostParts[2] ? hostParts[2] : (req.connection && req.connection.encrypted ? 443 : 80))
    };
};


// Parse Content-Type header content

exports.parseContentType = function (header) {

    if (!header) {
        return '';
    }

    return header.split(';')[0].trim().toLowerCase();
};


// Convert node's  to request configuration object

exports.parseRequest = function (req, options) {

    if (!req.headers) {
        return req;
    }

    // Obtain host and port information

    var host = exports.parseHost(req, options.hostHeaderName);
    if (!host) {
        return new Error('Invalid Host header');
    }

    var request = {
        method: req.method,
        url: req.url,
        host: host.name,
        port: host.port,
        authorization: req.headers.authorization,
        contentType: req.headers['content-type'] || ''
    };

    return request;
};


exports.now = function () {

    return Sntp.now();
};


// Parse Hawk HTTP Authorization header

exports.parseAuthorizationHeader = function (header, keys) {

    keys = keys || ['id', 'ts', 'nonce', 'hash', 'ext', 'mac', 'app', 'dlg'];

    if (!header) {
        return Boom.unauthorized(null, 'Hawk');
    }

    var headerParts = header.match(/^(\w+)(?:\s+(.*))?$/);       // Header: scheme[ something]
    if (!headerParts) {
        return Boom.badRequest('Invalid header syntax');
    }

    var scheme = headerParts[1];
    if (scheme.toLowerCase() !== 'hawk') {
        return Boom.unauthorized(null, 'Hawk');
    }

    var attributesString = headerParts[2];
    if (!attributesString) {
        return Boom.badRequest('Invalid header syntax');
    }

    var attributes = {};
    var errorMessage = '';
    var verify = attributesString.replace(/(\w+)="([^"\\]*)"\s*(?:,\s*|$)/g, function ($0, $1, $2) {

        // Check valid attribute names

        if (keys.indexOf($1) === -1) {
            errorMessage = 'Unknown attribute: ' + $1;
            return;
        }

        // Allowed attribute value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9

        if ($2.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~]+$/) === null) {
            errorMessage = 'Bad attribute value: ' + $1;
            return;
        }

        // Check for duplicates

        if (attributes.hasOwnProperty($1)) {
            errorMessage = 'Duplicate attribute: ' + $1;
            return;
        }

        attributes[$1] = $2;
        return '';
    });

    if (verify !== '') {
        return Boom.badRequest(errorMessage || 'Bad header format');
    }

    return attributes;
};


exports.unauthorized = function (message) {

    return Boom.unauthorized(message, 'Hawk');
};


})("/request/node_modules/hawk/lib")
},{"hoek":76,"sntp":70,"boom":71}],70:[function(require,module,exports){
module.exports = require('./lib');
},{"./lib":78}],71:[function(require,module,exports){
module.exports = require('./lib');
},{"./lib":79}],53:[function(require,module,exports){
(function(process){var EventEmitter = require('events').EventEmitter;
var util = require('util');
var request = require('request');
var ltx = require('ltx');


function BOSHConnection(opts) {
    var that = this;
    EventEmitter.call(this);

    this.boshURL = opts.boshURL;
    this.jid = opts.jid;
    this.xmlnsAttrs = {
	xmlns: "http://jabber.org/protocol/httpbind",
	'xmlns:xmpp': "urn:xmpp:xbosh",
	'xmlns:stream': "http://etherx.jabber.org/streams"
    };
    if (opts.xmlns)
	for(var prefix in opts.xmlns)
	    if (prefix)
		this.xmlnsAttrs["xmlns:" + prefix] = opts.xmlns[prefix];
	    else
		this.xmlnsAttrs["xmlns"] = opts.xmlns[prefix];
    this.currentRequests = 0;
    this.queue = [];
    this.rid = Math.ceil(Math.random() * 9999999999);

    this.request({
	to: this.jid.domain,
	ver: "1.6",
	wait: "10",
	hold: "1",
	content: this.contentType
    }, [], function(err, bodyEl) {
	if (err) {
	    that.emit('error', err);
	} else if (bodyEl && bodyEl.attrs) {
	    that.sid = bodyEl.attrs.sid;
	    that.maxRequests = parseInt(bodyEl.attrs.requests, 10) || 2;
	    if (that.sid && that.maxRequests > 0) {
		that.emit('connect');
		that.processResponse(bodyEl);
		process.nextTick(that.mayRequest.bind(that));
	    } else
		that.emit('error', "Invalid parameters");
	}
    });
}
util.inherits(BOSHConnection, EventEmitter);
exports.BOSHConnection = BOSHConnection;

BOSHConnection.prototype.contentType = "text/xml; charset=utf-8";

BOSHConnection.prototype.send = function(stanza) {
    this.queue.push(stanza.root());
    process.nextTick(this.mayRequest.bind(this));
};

BOSHConnection.prototype.processResponse = function(bodyEl) {
    if (bodyEl && bodyEl.children) {
	for(var i = 0; i < bodyEl.children.length; i++) {
	    var child = bodyEl.children[i];
	    if (child.name && child.attrs && child.children)
		this.emit('stanza', child);
	}
    }
    if (bodyEl && bodyEl.attrs.type === 'terminate') {
	this.emit('error', new Error(bodyEl.attrs.condition || "Session terminated"));
	this.emit('close');
    }
};

BOSHConnection.prototype.mayRequest = function() {
    var that = this;
    var canRequest =
	/* Must have a session already */
	this.sid &&
	/* We can only receive when one request is in flight */
	(this.currentRequests === 0 ||
	 /* Is there something to send, and are we allowed? */
	 ((this.queue.length > 0 && this.currentRequests < this.maxRequests))
	);
    if (!canRequest)
	return;

    var stanzas = this.queue;
    this.queue = [];
    this.rid++;
    this.request({}, stanzas, function(err, bodyEl) {
	if (err) {
	    that.emit('error', err);
	    that.emit('close');
	    delete that.sid;
	} else {
	    if (bodyEl)
		that.processResponse(bodyEl);

	    process.nextTick(that.mayRequest.bind(that));
	}
    });
};

BOSHConnection.prototype.end = function(stanzas) {
    var that = this;

    stanzas = stanzas || [];
    if (typeof stanzas !== 'array')
	stanzas = [stanzas];

    stanzas = this.queue.concat(stanzas);
    this.queue = [];
    this.rid++;
    this.request({ type: 'terminate' }, stanzas, function(err, bodyEl) {
	if (bodyEl)
	    that.processResponse(bodyEl);

	that.emit('end');
	that.emit('close');
	delete that.sid;
    });
};

BOSHConnection.prototype.maxHTTPRetries = 5;

BOSHConnection.prototype.request = function(attrs, children, cb, retry) {
    var that = this;
    retry = retry || 0;

    attrs.rid = this.rid.toString();
    if (this.sid)
	attrs.sid = this.sid;

    for(var k in this.xmlnsAttrs)
	attrs[k] = this.xmlnsAttrs[k];
    var boshEl = new ltx.Element('body', attrs);
    for(var i = 0; i < children.length; i++)
	boshEl.cnode(children[i]);

    request({
	uri: this.boshURL,
	method: 'POST',
	headers: {
	    "Content-Type": this.contentType
	},
	body: boshEl.toString()
    }, function(err, res, body) {
	that.currentRequests--;

	if (err) {
	    if (retry < that.maxHTTPRetries)
		return that.request(attrs, children, cb, retry + 1);
	    else
		return cb(err);
	}
	if (res.statusCode < 200 || res.statusCode >= 400)
	    return cb(new Error("HTTP status " + res.statusCode));

	var bodyEl;
	try {
	    bodyEl = ltx.parse(body);
	} catch(e) {
	    return cb(e);
	}

	if (bodyEl && bodyEl.attrs.type === 'terminate')
	    cb(new Error(bodyEl.attrs.condition));
	else if (bodyEl)
	    cb(null, bodyEl);
	else
	    cb(new Error('no <body/>'));
    });
    this.currentRequests++;
};

})(require("__browserify_process"))
},{"events":4,"util":5,"ltx":39,"request":"Rqhtau","__browserify_process":9}],75:[function(require,module,exports){
var Stream = require('stream').Stream;
var util = require('util');

module.exports = DelayedStream;
function DelayedStream() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;

  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);

DelayedStream.create = function(source, options) {
  var delayedStream = new this();

  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }

  delayedStream.source = source;

  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };

  source.on('error', function() {});
  if (delayedStream.pauseStream) {
    source.pause();
  }

  return delayedStream;
};

DelayedStream.prototype.__defineGetter__('readable', function() {
  return this.source.readable;
});

DelayedStream.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }

  this.source.resume();
};

DelayedStream.prototype.pause = function() {
  this.source.pause();
};

DelayedStream.prototype.release = function() {
  this._released = true;

  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};

DelayedStream.prototype.pipe = function() {
  var r = Stream.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};

DelayedStream.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }

  if (args[0] === 'data') {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }

  this._bufferedEvents.push(args);
};

DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }

  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  this._maxDataSizeExceeded = true;
  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this.emit('error', new Error(message));
};

},{"stream":3,"util":5}],74:[function(require,module,exports){
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var errors = require('./errors');
var types = require('./types');

var Reader = require('./reader');
var Writer = require('./writer');


///--- Exports

module.exports = {

  Reader: Reader,

  Writer: Writer

};

for (var t in types) {
  if (types.hasOwnProperty(t))
    module.exports[t] = types[t];
}
for (var e in errors) {
  if (errors.hasOwnProperty(e))
    module.exports[e] = errors[e];
}

},{"./errors":80,"./types":81,"./reader":82,"./writer":83}],84:[function(require,module,exports){

},{}],80:[function(require,module,exports){
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


module.exports = {

  newInvalidAsn1Error: function(msg) {
    var e = new Error();
    e.name = 'InvalidAsn1Error';
    e.message = msg || '';
    return e;
  }

};

},{}],81:[function(require,module,exports){
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


module.exports = {
  EOC: 0,
  Boolean: 1,
  Integer: 2,
  BitString: 3,
  OctetString: 4,
  Null: 5,
  OID: 6,
  ObjectDescriptor: 7,
  External: 8,
  Real: 9, // float
  Enumeration: 10,
  PDV: 11,
  Utf8String: 12,
  RelativeOID: 13,
  Sequence: 16,
  Set: 17,
  NumericString: 18,
  PrintableString: 19,
  T61String: 20,
  VideotexString: 21,
  IA5String: 22,
  UTCTime: 23,
  GeneralizedTime: 24,
  GraphicString: 25,
  VisibleString: 26,
  GeneralString: 28,
  UniversalString: 29,
  CharacterString: 30,
  BMPString: 31,
  Constructor: 32,
  Context: 128
};

},{}],76:[function(require,module,exports){
module.exports = require('./lib');
},{"./lib":85}],77:[function(require,module,exports){
module.exports = require('./lib');
},{"./lib":86}],83:[function(require,module,exports){
(function(Buffer){// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var assert = require('assert');
var ASN1 = require('./types');
var errors = require('./errors');


///--- Globals

var newInvalidAsn1Error = errors.newInvalidAsn1Error;

var DEFAULT_OPTS = {
  size: 1024,
  growthFactor: 8
};


///--- Helpers

function merge(from, to) {
  assert.ok(from);
  assert.equal(typeof(from), 'object');
  assert.ok(to);
  assert.equal(typeof(to), 'object');

  var keys = Object.getOwnPropertyNames(from);
  keys.forEach(function(key) {
    if (to[key])
      return;

    var value = Object.getOwnPropertyDescriptor(from, key);
    Object.defineProperty(to, key, value);
  });

  return to;
}



///--- API

function Writer(options) {
  options = merge(DEFAULT_OPTS, options || {});

  this._buf = new Buffer(options.size || 1024);
  this._size = this._buf.length;
  this._offset = 0;
  this._options = options;

  // A list of offsets in the buffer where we need to insert
  // sequence tag/len pairs.
  this._seq = [];

  var self = this;
  this.__defineGetter__('buffer', function() {
    if (self._seq.length)
      throw new InvalidAsn1Error(self._seq.length + ' unended sequence(s)');

    return self._buf.slice(0, self._offset);
  });
}


Writer.prototype.writeByte = function(b) {
  if (typeof(b) !== 'number')
    throw new TypeError('argument must be a Number');

  this._ensure(1);
  this._buf[this._offset++] = b;
};


Writer.prototype.writeInt = function(i, tag) {
  if (typeof(i) !== 'number')
    throw new TypeError('argument must be a Number');
  if (typeof(tag) !== 'number')
    tag = ASN1.Integer;

  var sz = 4;

  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000)) &&
         (sz > 1)) {
    sz--;
    i <<= 8;
  }

  if (sz > 4)
    throw new InvalidAsn1Error('BER ints cannot be > 0xffffffff');

  this._ensure(2 + sz);
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = sz;

  while (sz-- > 0) {
    this._buf[this._offset++] = ((i & 0xff000000) >> 24);
    i <<= 8;
  }

};


Writer.prototype.writeNull = function() {
  this.writeByte(ASN1.Null);
  this.writeByte(0x00);
};


Writer.prototype.writeEnumeration = function(i, tag) {
  if (typeof(i) !== 'number')
    throw new TypeError('argument must be a Number');
  if (typeof(tag) !== 'number')
    tag = ASN1.Enumeration;

  return this.writeInt(i, tag);
};


Writer.prototype.writeBoolean = function(b, tag) {
  if (typeof(b) !== 'boolean')
    throw new TypeError('argument must be a Boolean');
  if (typeof(tag) !== 'number')
    tag = ASN1.Boolean;

  this._ensure(3);
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = 0x01;
  this._buf[this._offset++] = b ? 0xff : 0x00;
};


Writer.prototype.writeString = function(s, tag) {
  if (typeof(s) !== 'string')
    throw new TypeError('argument must be a string (was: ' + typeof(s) + ')');
  if (typeof(tag) !== 'number')
    tag = ASN1.OctetString;

  var len = Buffer.byteLength(s);
  this.writeByte(tag);
  this.writeLength(len);
  if (len) {
    this._ensure(len);
    this._buf.write(s, this._offset);
    this._offset += len;
  }
};


Writer.prototype.writeBuffer = function(buf, tag) {
  if (typeof(tag) !== 'number')
    throw new TypeError('tag must be a number');
  if (!Buffer.isBuffer(buf))
    throw new TypeError('argument must be a buffer');

  this.writeByte(tag);
  this.writeLength(buf.length);
  this._ensure(buf.length);
  buf.copy(this._buf, this._offset, 0, buf.length);
  this._offset += buf.length;
};


Writer.prototype.writeStringArray = function(strings) {
  if ((!strings instanceof Array))
    throw new TypeError('argument must be an Array[String]');

  var self = this;
  strings.forEach(function(s) {
    self.writeString(s);
  });
};

// This is really to solve DER cases, but whatever for now
Writer.prototype.writeOID = function(s, tag) {
  if (typeof(s) !== 'string')
    throw new TypeError('argument must be a string');
  if (typeof(tag) !== 'number')
    tag = ASN1.OID;

  if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
    throw new Error('argument is not a valid OID string');

  function encodeOctet(bytes, octet) {
    if (octet < 128) {
        bytes.push(octet);
    } else if (octet < 16384) {
        bytes.push((octet >>> 7) | 0x80);
        bytes.push(octet & 0x7F);
    } else if (octet < 2097152) {
      bytes.push((octet >>> 14) | 0x80);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    } else if (octet < 268435456) {
      bytes.push((octet >>> 21) | 0x80);
      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    } else {
      bytes.push(((octet >>> 28) | 0x80) & 0xFF);
      bytes.push(((octet >>> 21) | 0x80) & 0xFF);
      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    }
  }

  var tmp = s.split('.');
  var bytes = [];
  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
  tmp.slice(2).forEach(function(b) {
    encodeOctet(bytes, parseInt(b, 10));
  });

  var self = this;
  this._ensure(2 + bytes.length);
  this.writeByte(tag);
  this.writeLength(bytes.length);
  bytes.forEach(function(b) {
    self.writeByte(b);
  });
};


Writer.prototype.writeLength = function(len) {
  if (typeof(len) !== 'number')
    throw new TypeError('argument must be a Number');

  this._ensure(4);

  if (len <= 0x7f) {
    this._buf[this._offset++] = len;
  } else if (len <= 0xff) {
    this._buf[this._offset++] = 0x81;
    this._buf[this._offset++] = len;
  } else if (len <= 0xffff) {
    this._buf[this._offset++] = 0x82;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
  } else if (len <= 0xffffff) {
    this._shift(start, len, 1);
    this._buf[this._offset++] = 0x83;
    this._buf[this._offset++] = len >> 16;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
  } else {
    throw new InvalidAsn1ERror('Length too long (> 4 bytes)');
  }
};

Writer.prototype.startSequence = function(tag) {
  if (typeof(tag) !== 'number')
    tag = ASN1.Sequence | ASN1.Constructor;

  this.writeByte(tag);
  this._seq.push(this._offset);
  this._ensure(3);
  this._offset += 3;
};


Writer.prototype.endSequence = function() {
  var seq = this._seq.pop();
  var start = seq + 3;
  var len = this._offset - start;

  if (len <= 0x7f) {
    this._shift(start, len, -2);
    this._buf[seq] = len;
  } else if (len <= 0xff) {
    this._shift(start, len, -1);
    this._buf[seq] = 0x81;
    this._buf[seq + 1] = len;
  } else if (len <= 0xffff) {
    this._buf[seq] = 0x82;
    this._buf[seq + 1] = len >> 8;
    this._buf[seq + 2] = len;
  } else if (len <= 0xffffff) {
    this._shift(start, len, 1);
    this._buf[seq] = 0x83;
    this._buf[seq + 1] = len >> 16;
    this._buf[seq + 2] = len >> 8;
    this._buf[seq + 3] = len;
  } else {
    throw new InvalidAsn1Error('Sequence too long');
  }
};


Writer.prototype._shift = function(start, len, shift) {
  assert.ok(start !== undefined);
  assert.ok(len !== undefined);
  assert.ok(shift);

  this._buf.copy(this._buf, start + shift, start, start + len);
  this._offset += shift;
};

Writer.prototype._ensure = function(len) {
  assert.ok(len);

  if (this._size - this._offset < len) {
    var sz = this._size * this._options.growthFactor;
    if (sz - this._offset < len)
      sz += len;

    var buf = new Buffer(sz);

    this._buf.copy(buf, 0, 0, this._offset);
    this._buf = buf;
    this._size = sz;
  }
};



///--- Exported API

module.exports = Writer;

})(require("__browserify_buffer").Buffer)
},{"assert":18,"./types":81,"./errors":80,"__browserify_buffer":19}],82:[function(require,module,exports){
(function(Buffer){// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

var assert = require('assert');

var ASN1 = require('./types');
var errors = require('./errors');


///--- Globals

var newInvalidAsn1Error = errors.newInvalidAsn1Error;



///--- API

function Reader(data) {
  if (!data || !Buffer.isBuffer(data))
    throw new TypeError('data must be a node Buffer');

  this._buf = data;
  this._size = data.length;

  // These hold the "current" state
  this._len = 0;
  this._offset = 0;

  var self = this;
  this.__defineGetter__('length', function() { return self._len; });
  this.__defineGetter__('offset', function() { return self._offset; });
  this.__defineGetter__('remain', function() {
    return self._size - self._offset;
  });
  this.__defineGetter__('buffer', function() {
    return self._buf.slice(self._offset);
  });
}


/**
 * Reads a single byte and advances offset; you can pass in `true` to make this
 * a "peek" operation (i.e., get the byte, but don't advance the offset).
 *
 * @param {Boolean} peek true means don't move offset.
 * @return {Number} the next byte, null if not enough data.
 */
Reader.prototype.readByte = function(peek) {
  if (this._size - this._offset < 1)
    return null;

  var b = this._buf[this._offset] & 0xff;

  if (!peek)
    this._offset += 1;

  return b;
};


Reader.prototype.peek = function() {
  return this.readByte(true);
};


/**
 * Reads a (potentially) variable length off the BER buffer.  This call is
 * not really meant to be called directly, as callers have to manipulate
 * the internal buffer afterwards.
 *
 * As a result of this call, you can call `Reader.length`, until the
 * next thing called that does a readLength.
 *
 * @return {Number} the amount of offset to advance the buffer.
 * @throws {InvalidAsn1Error} on bad ASN.1
 */
Reader.prototype.readLength = function(offset) {
  if (offset === undefined)
    offset = this._offset;

  if (offset >= this._size)
    return null;

  var lenB = this._buf[offset++] & 0xff;
  if (lenB === null)
    return null;

  if ((lenB & 0x80) == 0x80) {
    lenB &= 0x7f;

    if (lenB == 0)
      throw newInvalidAsn1Error('Indefinite length not supported');

    if (lenB > 4)
      throw newInvalidAsn1Error('encoding too long');

    if (this._size - offset < lenB)
      return null;

    this._len = 0;
    for (var i = 0; i < lenB; i++)
      this._len = (this._len << 8) + (this._buf[offset++] & 0xff);

  } else {
    // Wasn't a variable length
    this._len = lenB;
  }

  return offset;
};


/**
 * Parses the next sequence in this BER buffer.
 *
 * To get the length of the sequence, call `Reader.length`.
 *
 * @return {Number} the sequence's tag.
 */
Reader.prototype.readSequence = function(tag) {
  var seq = this.peek();
  if (seq === null)
    return null;
  if (tag !== undefined && tag !== seq)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + seq.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`
  if (o === null)
    return null;

  this._offset = o;
  return seq;
};


Reader.prototype.readInt = function() {
  return this._readTag(ASN1.Integer);
};


Reader.prototype.readBoolean = function() {
  return (this._readTag(ASN1.Boolean) === 0 ? false : true);
};


Reader.prototype.readEnumeration = function() {
  return this._readTag(ASN1.Enumeration);
};


Reader.prototype.readString = function(tag, retbuf) {
  if (!tag)
    tag = ASN1.OctetString;

  var b = this.peek();
  if (b === null)
    return null;

  if (b !== tag)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + b.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`

  if (o === null)
    return null;

  if (this.length > this._size - o)
    return null;

  this._offset = o;

  if (this.length === 0)
    return '';

  var str = this._buf.slice(this._offset, this._offset + this.length);
  this._offset += this.length;

  return retbuf ? str : str.toString('utf8');
};

Reader.prototype.readOID = function(tag) {
  if (!tag)
    tag = ASN1.OID;

  var b = this.peek();
  if (b === null)
    return null;

  if (b !== tag)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + b.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`
  if (o === null)
    return null;

  if (this.length > this._size - o)
    return null;

  this._offset = o;

  var values = [];
  var value = 0;

  for (var i = 0; i < this.length; i++) {
    var byte = this._buf[this._offset++] & 0xff;

    value <<= 7;
    value += byte & 0x7f;
    if ((byte & 0x80) == 0) {
      values.push(value);
      value = 0;
    }
  }

  value = values.shift();
  values.unshift(value % 40);
  values.unshift((value / 40) >> 0);

  return values.join('.');
};


Reader.prototype._readTag = function(tag) {
  assert.ok(tag !== undefined);

  var b = this.peek();

  if (b === null)
    return null;

  if (b !== tag)
    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +
                              ': got 0x' + b.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`
  if (o === null)
    return null;

  if (this.length > 4)
    throw newInvalidAsn1Error('Integer too long: ' + this.length);

  if (this.length > this._size - o)
    return null;
  this._offset = o;

  var fb = this._buf[this._offset++];
  var value = 0;

  value = fb & 0x7F;
  for (var i = 1; i < this.length; i++) {
    value <<= 8;
    value |= (this._buf[this._offset++] & 0xff);
  }

  if ((fb & 0x80) == 0x80)
    value = -value;

  return value;
};



///--- Exported API

module.exports = Reader;

})(require("__browserify_buffer").Buffer)
},{"assert":18,"./types":81,"./errors":80,"__browserify_buffer":19}],85:[function(require,module,exports){
(function(process,Buffer){// Load modules

var Fs = require('fs');
var Escape = require('./escape');


// Declare internals

var internals = {};


// Clone object or array

exports.clone = function (obj, seen) {

    if (typeof obj !== 'object' ||
        obj === null) {

        return obj;
    }

    seen = seen || { orig: [], copy: [] };

    var lookup = seen.orig.indexOf(obj);
    if (lookup !== -1) {
        return seen.copy[lookup];
    }

    var newObj = (obj instanceof Array) ? [] : {};

    seen.orig.push(obj);
    seen.copy.push(newObj);

    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (obj[i] instanceof Buffer) {
                newObj[i] = new Buffer(obj[i]);
            }
            else if (obj[i] instanceof Date) {
                newObj[i] = new Date(obj[i].getTime());
            }
            else if (obj[i] instanceof RegExp) {
                var flags = '' + (obj[i].global ? 'g' : '') + (obj[i].ignoreCase ? 'i' : '') + (obj[i].multiline ? 'm' : '');
                newObj[i] = new RegExp(obj[i].source, flags);
            }
            else {
                newObj[i] = exports.clone(obj[i], seen);
            }
        }
    }

    return newObj;
};


// Merge all the properties of source into target, source wins in conflic, and by default null and undefined from source are applied

exports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {

    exports.assert(target && typeof target == 'object', 'Invalid target value: must be an object');
    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');

    if (!source) {
        return target;
    }

    if (source instanceof Array) {
        exports.assert(target instanceof Array, 'Cannot merge array onto an object');
        if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true
            target.length = 0;                                                          // Must not change target assignment
        }

        source.forEach(function (item) {

            target.push(item);
        });

        return target;
    }

    Object.keys(source).forEach(function (key) {

        var value = source[key];
        if (value &&
            typeof value === 'object') {

            if (!target[key] ||
                typeof target[key] !== 'object') {

                target[key] = exports.clone(value);
            }
            else {
                exports.merge(target[key], source[key], isNullOverride, isMergeArrays);
            }
        }
        else {
            if (value !== null && value !== undefined) {            // Explicit to preserve empty strings
                target[key] = value;
            }
            else if (isNullOverride !== false) {                    // Defaults to true
                target[key] = value;
            }
        }
    });

    return target;
};


// Apply options to a copy of the defaults

exports.applyToDefaults = function (defaults, options) {

    exports.assert(defaults && typeof defaults == 'object', 'Invalid defaults value: must be an object');
    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');

    if (!options) {                                                 // If no options, return null
        return null;
    }

    var copy = exports.clone(defaults);

    if (options === true) {                                         // If options is set to true, use defaults
        return copy;
    }

    return exports.merge(copy, options, false, false);
};


// Remove duplicate items from array

exports.unique = function (array, key) {

    var index = {};
    var result = [];

    for (var i = 0, il = array.length; i < il; ++i) {
        var id = (key ? array[i][key] : array[i]);
        if (index[id] !== true) {

            result.push(array[i]);
            index[id] = true;
        }
    }

    return result;
};


// Convert array into object

exports.mapToObject = function (array, key) {

    if (!array) {
        return null;
    }

    var obj = {};
    for (var i = 0, il = array.length; i < il; ++i) {
        if (key) {
            if (array[i][key]) {
                obj[array[i][key]] = true;
            }
        }
        else {
            obj[array[i]] = true;
        }
    }

    return obj;
};


// Find the common unique items in two arrays

exports.intersect = function (array1, array2) {

    if (!array1 || !array2) {
        return [];
    }

    var common = [];
    var hash = (array1 instanceof Array ? exports.mapToObject(array1) : array1);
    var found = {};
    for (var i = 0, il = array2.length; i < il; ++i) {
        if (hash[array2[i]] && !found[array2[i]]) {
            common.push(array2[i]);
            found[array2[i]] = true;
        }
    }

    return common;
};


// Find which keys are present

exports.matchKeys = function (obj, keys) {

    var matched = [];
    for (var i = 0, il = keys.length; i < il; ++i) {
        if (obj.hasOwnProperty(keys[i])) {
            matched.push(keys[i]);
        }
    }
    return matched;
};


// Flatten array

exports.flatten = function (array, target) {

    var result = target || [];

    for (var i = 0, il = array.length; i < il; ++i) {
        if (Array.isArray(array[i])) {
            exports.flatten(array[i], result);
        }
        else {
            result.push(array[i]);
        }
    }

    return result;
};


// Remove keys

exports.removeKeys = function (object, keys) {

    for (var i = 0, il = keys.length; i < il; i++) {
        delete object[keys[i]];
    }
};


// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])

exports.reach = function (obj, chain) {

    var path = chain.split('.');
    var ref = obj;
    path.forEach(function (level) {

        if (ref) {
            ref = ref[level];
        }
    });

    return ref;
};


// Inherits a selected set of methods from an object, wrapping functions in asynchronous syntax and catching errors

exports.inheritAsync = function (self, obj, keys) {

    keys = keys || null;

    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (keys instanceof Array &&
                keys.indexOf(i) < 0) {

                continue;
            }

            self.prototype[i] = (function (fn) {

                return function (next) {

                    var result = null;
                    try {
                        result = fn();
                    }
                    catch (err) {
                        return next(err);
                    }

                    return next(null, result);
                };
            })(obj[i]);
        }
    }
};


exports.formatStack = function (stack) {

    var trace = [];
    stack.forEach(function (item) {

        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
    });

    return trace;
};


exports.formatTrace = function (trace) {

    var display = [];
    trace.forEach(function (row) {

        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');
    });

    return display;
};


exports.callStack = function (slice) {

    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi

    var v8 = Error.prepareStackTrace;
    Error.prepareStackTrace = function (err, stack) {

        return stack;
    };

    var capture = {};
    Error.captureStackTrace(capture, arguments.callee);
    var stack = capture.stack;

    Error.prepareStackTrace = v8;

    var trace = exports.formatStack(stack);

    if (slice) {
        return trace.slice(slice);
    }

    return trace;
};


exports.displayStack = function (slice) {

    var trace = exports.callStack(slice === undefined ? 1 : slice + 1);

    return exports.formatTrace(trace);
};


exports.abortThrow = false;


exports.abort = function (message, hideStack) {

    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {
        throw new Error(message || 'Unknown error');
    }

    var stack = '';
    if (!hideStack) {
        stack = exports.displayStack(1).join('\n\t');
    }
    console.log('ABORT: ' + message + '\n\t' + stack);
    process.exit(1);
};


exports.assert = function (condition /*, msg1, msg2, msg3 */) {

    if (condition) {
        return;
    }

    var msgs = Array.prototype.slice.call(arguments, 1);
    msgs = msgs.map(function (msg) {

        return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : JSON.stringify(msg);
    });
    throw new Error(msgs.join(' ') || 'Unknown error');
};


exports.loadDirModules = function (path, excludeFiles, target) {      // target(filename, name, capName)

    var exclude = {};
    for (var i = 0, il = excludeFiles.length; i < il; ++i) {
        exclude[excludeFiles[i] + '.js'] = true;
    }

    Fs.readdirSync(path).forEach(function (filename) {

        if (/\.js$/.test(filename) &&
            !exclude[filename]) {

            var name = filename.substr(0, filename.lastIndexOf('.'));
            var capName = name.charAt(0).toUpperCase() + name.substr(1).toLowerCase();

            if (typeof target !== 'function') {
                target[capName] = require(path + '/' + name);
            }
            else {
                target(path + '/' + name, name, capName);
            }
        }
    });
};


exports.rename = function (obj, from, to) {

    obj[to] = obj[from];
    delete obj[from];
};


exports.Timer = function () {

    this.reset();
};


exports.Timer.prototype.reset = function () {

    this.ts = Date.now();
};


exports.Timer.prototype.elapsed = function () {

    return Date.now() - this.ts;
};


// Load and parse package.json process root or given directory

exports.loadPackage = function (dir) {

    var result = {};
    var filepath = (dir || process.env.PWD) + '/package.json';
    if (Fs.existsSync(filepath)) {
        try {
            result = JSON.parse(Fs.readFileSync(filepath));
        }
        catch (e) { }
    }

    return result;
};


// Escape string for Regex construction

exports.escapeRegex = function (string) {

    // Escape ^$.*+-?=!:|\/()[]{},
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
};


// Return an error as first argument of a callback

exports.toss = function (condition /*, [message], next */) {

    var message = (arguments.length === 3 ? arguments[1] : '');
    var next = (arguments.length === 3 ? arguments[2] : arguments[1]);

    var err = (message instanceof Error ? message : (message ? new Error(message) : (condition instanceof Error ? condition : new Error())));

    if (condition instanceof Error ||
        !condition) {

        return next(err);
    }
};


// Base64url (RFC 4648) encode

exports.base64urlEncode = function (value) {

    return (new Buffer(value, 'binary')).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
};


// Base64url (RFC 4648) decode

exports.base64urlDecode = function (encoded) {

    if (encoded &&
        !encoded.match(/^[\w\-]*$/)) {

        return new Error('Invalid character');
    }

    try {
        return (new Buffer(encoded.replace(/-/g, '+').replace(/:/g, '/'), 'base64')).toString('binary');
    }
    catch (err) {
        return err;
    }
};


// Escape attribute value for use in HTTP header

exports.escapeHeaderAttribute = function (attribute) {

    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

    exports.assert(attribute.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/), 'Bad attribute value (' + attribute + ')');

    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
};


exports.escapeHtml = function (string) {

    return Escape.escapeHtml(string);
};


exports.escapeJavaScript = function (string) {

    return Escape.escapeJavaScript(string);
};


/*
var event = {
    timestamp: now.getTime(),
    tags: ['tag'],
    data: { some: 'data' }
};
*/

exports.consoleFunc = console.log;

exports.printEvent = function (event) {

    var pad = function (value) {

        return (value < 10 ? '0' : '') + value;
    };

    var now = new Date(event.timestamp);
    var timestring = (now.getYear() - 100).toString() +
        pad(now.getMonth() + 1) +
        pad(now.getDate()) +
        '/' +
        pad(now.getHours()) +
        pad(now.getMinutes()) +
        pad(now.getSeconds()) +
        '.' +
        now.getMilliseconds();

    var data = event.data;
    if (typeof event.data !== 'string') {
        try {
            data = JSON.stringify(event.data);
        }
        catch (e) {
            data = 'JSON Error: ' + e.message;
        }
    }

    var output = timestring + ', ' + event.tags[0] + ', ' + data;
    exports.consoleFunc(output);
};


exports.nextTick = function (callback) {

    return function () {

        var args = arguments;
        process.nextTick(function () {

            callback.apply(null, args);
        });
    };
};

})(require("__browserify_process"),require("__browserify_buffer").Buffer)
},{"fs":34,"./escape":87,"__browserify_process":9,"__browserify_buffer":19}],78:[function(require,module,exports){
(function(process,Buffer){// Load modules

var Dgram = require('dgram');
var Dns = require('dns');
var Hoek = require('hoek');


// Declare internals

var internals = {};


exports.time = function (options, callback) {

    if (arguments.length !== 2) {
        callback = arguments[0];
        options = {};
    }

    var settings = Hoek.clone(options);
    settings.host = settings.host || 'pool.ntp.org';
    settings.port = settings.port || 123;
    settings.resolveReference = settings.resolveReference || false;

    // Declare variables used by callback

    var timeoutId = 0;
    var sent = 0;

    // Ensure callback is only called once

    var isFinished = false;
    var finish = function (err, result) {

        if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = 0;
        }

        if (!isFinished) {
            isFinished = true;
            socket.removeAllListeners();
            socket.close();
            return callback(err, result);
        }
    };

    // Create UDP socket

    var socket = Dgram.createSocket('udp4');

    socket.once('error', function (err) {

        return finish(err);
    });

    // Listen to incoming messages

    socket.on('message', function (buffer, rinfo) {

        var received = Date.now();

        var message = new internals.NtpMessage(buffer);
        if (!message.isValid) {
            return finish(new Error('Invalid server response'), message);
        }

        if (message.originateTimestamp !== sent) {
            return finish(new Error('Wrong originate timestamp'), message);
        }

        // Timestamp Name          ID   When Generated
        // ------------------------------------------------------------
        // Originate Timestamp     T1   time request sent by client
        // Receive Timestamp       T2   time request received by server
        // Transmit Timestamp      T3   time reply sent by server
        // Destination Timestamp   T4   time reply received by client
        //
        // The roundtrip delay d and system clock offset t are defined as:
        //
        // d = (T4 - T1) - (T3 - T2)     t = ((T2 - T1) + (T3 - T4)) / 2

        var T1 = message.originateTimestamp;
        var T2 = message.receiveTimestamp;
        var T3 = message.transmitTimestamp;
        var T4 = received;

        message.d = (T4 - T1) - (T3 - T2);
        message.t = ((T2 - T1) + (T3 - T4)) / 2;
        message.receivedLocally = received;

        if (!settings.resolveReference ||
            message.stratum !== 'secondary') {

            return finish(null, message);
        }

        // Resolve reference IP address

        Dns.reverse(message.referenceId, function (err, domains) {

            if (!err) {
                message.referenceHost = domains[0];
            }

            return finish(null, message);
        });
    });

    // Set timeout

    if (settings.timeout) {
        timeoutId = setTimeout(function () {

            timeoutId = 0;
            return finish(new Error('Timeout'));
        }, settings.timeout);
    }

    // Construct NTP message

    var message = new Buffer(48);
    for (var i = 0; i < 48; i++) {                      // Zero message
        message[i] = 0;
    }

    message[0] = (0 << 6) + (4 << 3) + (3 << 0)         // Set version number to 4 and Mode to 3 (client)
    sent = Date.now();
    internals.fromMsecs(sent, message, 40);               // Set transmit timestamp (returns as originate)

    // Send NTP request

    socket.send(message, 0, message.length, settings.port, settings.host, function (err, bytes) {

        if (err ||
            bytes !== 48) {

            return finish(err || new Error('Could not send entire message'));
        }
    });
};


internals.NtpMessage = function (buffer) {

    this.isValid = false;

    // Validate

    if (buffer.length !== 48) {
        return;
    }

    // Leap indicator

    var li = (buffer[0] >> 6);
    switch (li) {
        case 0: this.leapIndicator = 'no-warning'; break;
        case 1: this.leapIndicator = 'last-minute-61'; break;
        case 2: this.leapIndicator = 'last-minute-59'; break;
        case 3: this.leapIndicator = 'alarm'; break;
    }

    // Version

    var vn = ((buffer[0] & 0x38) >> 3);
    this.version = vn;

    // Mode

    var mode = (buffer[0] & 0x7);
    switch (mode) {
        case 1: this.mode = 'symmetric-active'; break;
        case 2: this.mode = 'symmetric-passive'; break;
        case 3: this.mode = 'client'; break;
        case 4: this.mode = 'server'; break;
        case 5: this.mode = 'broadcast'; break;
        case 0:
        case 6:
        case 7: this.mode = 'reserved'; break;
    }

    // Stratum

    var stratum = buffer[1];
    if (stratum === 0) {
        this.stratum = 'death';
    }
    else if (stratum === 1) {
        this.stratum = 'primary';
    }
    else if (stratum <= 15) {
        this.stratum = 'secondary';
    }
    else {
        this.stratum = 'reserved';
    }

    // Poll interval (msec)

    this.pollInterval = Math.round(Math.pow(2, buffer[2])) * 1000;

    // Precision (msecs)

    this.precision = Math.pow(2, buffer[3]) * 1000;

    // Root delay (msecs)

    var rootDelay = 256 * (256 * (256 * buffer[4] + buffer[5]) + buffer[6]) + buffer[7];
    this.rootDelay = 1000 * (rootDelay / 0x10000);

    // Root dispersion (msecs)

    this.rootDispersion = ((buffer[8] << 8) + buffer[9] + ((buffer[10] << 8) + buffer[11]) / Math.pow(2, 16)) * 1000;

    // Reference identifier

    this.referenceId = '';
    switch (this.stratum) {
        case 'death':
        case 'primary':
            this.referenceId = String.fromCharCode(buffer[12]) + String.fromCharCode(buffer[13]) + String.fromCharCode(buffer[14]) + String.fromCharCode(buffer[15]);
            break;
        case 'secondary':
            this.referenceId = '' + buffer[12] + '.' + buffer[13] + '.' + buffer[14] + '.' + buffer[15];
            break;
    }

    // Reference timestamp

    this.referenceTimestamp = internals.toMsecs(buffer, 16);

    // Originate timestamp

    this.originateTimestamp = internals.toMsecs(buffer, 24);

    // Receive timestamp

    this.receiveTimestamp = internals.toMsecs(buffer, 32);

    // Transmit timestamp

    this.transmitTimestamp = internals.toMsecs(buffer, 40);

    // Validate

    if (this.version === 4 &&
        this.stratum !== 'reserved' &&
        this.mode === 'server' &&
        this.originateTimestamp &&
        this.receiveTimestamp &&
        this.transmitTimestamp) {

        this.isValid = true;
    }

    return this;
};


internals.toMsecs = function (buffer, offset) {

    var seconds = 0;
    var fraction = 0;

    for (var i = 0; i < 4; ++i) {
        seconds = (seconds * 256) + buffer[offset + i];
    }

    for (i = 4; i < 8; ++i) {
        fraction = (fraction * 256) + buffer[offset + i];
    }

    return ((seconds - 2208988800 + (fraction / Math.pow(2, 32))) * 1000);
};


internals.fromMsecs = function (ts, buffer, offset) {

    var seconds = Math.floor(ts / 1000) + 2208988800;
    var fraction = Math.round((ts % 1000) / 1000 * Math.pow(2, 32));

    buffer[offset + 0] = (seconds & 0xFF000000) >> 24;
    buffer[offset + 1] = (seconds & 0x00FF0000) >> 16;
    buffer[offset + 2] = (seconds & 0x0000FF00) >> 8;
    buffer[offset + 3] = (seconds & 0x000000FF);

    buffer[offset + 4] = (fraction & 0xFF000000) >> 24;
    buffer[offset + 5] = (fraction & 0x00FF0000) >> 16;
    buffer[offset + 6] = (fraction & 0x0000FF00) >> 8;
    buffer[offset + 7] = (fraction & 0x000000FF);
};


// Offset singleton

internals.last = {
    offset: 0,
    expires: 0,
    host: '',
    port: 0
};


exports.offset = function (options, callback) {

    if (arguments.length !== 2) {
        callback = arguments[0];
        options = {};
    }

    var now = Date.now();
    var clockSyncRefresh = options.clockSyncRefresh || 24 * 60 * 60 * 1000;                    // Daily

    if (internals.last.offset &&
        internals.last.host === options.host &&
        internals.last.port === options.port &&
        now < internals.last.expires) {

        process.nextTick(function () {
                
            callback(null, internals.last.offset);
        });

        return;
    }

    exports.time(options, function (err, time) {

        if (err) {
            return callback(err, 0);
        }

        internals.last = {
            offset: Math.round(time.t),
            expires: now + clockSyncRefresh,
            host: options.host,
            port: options.port
        };

        return callback(null, internals.last.offset);
    });
};


// Now singleton

internals.now = {
    intervalId: 0
};


exports.start = function (options, callback) {

    if (arguments.length !== 2) {
        callback = arguments[0];
        options = {};
    }

    if (internals.now.intervalId) {
        process.nextTick(function () {
            
            callback();
        });
        
        return;
    }

    exports.offset(options, function (err, offset) {

        internals.now.intervalId = setInterval(function () {

            exports.offset(options, function () { });
        }, options.clockSyncRefresh || 24 * 60 * 60 * 1000);                                // Daily

        return callback();
    });
};


exports.stop = function () {

    if (!internals.now.intervalId) {
        return;
    }

    clearInterval(internals.now.intervalId);
    internals.now.intervalId = 0;
};


exports.isLive = function () {

    return !!internals.now.intervalId;
};


exports.now = function () {

    var now = Date.now();
    if (!exports.isLive() ||
        now >= internals.last.expires) {

        return now;
    }

    return now + internals.last.offset;
};


})(require("__browserify_process"),require("__browserify_buffer").Buffer)
},{"dgram":84,"dns":17,"hoek":88,"__browserify_process":9,"__browserify_buffer":19}],79:[function(require,module,exports){
// Load modules

var Http = require('http');
var NodeUtil = require('util');
var Hoek = require('hoek');


// Declare internals

var internals = {};


exports = module.exports = internals.Boom = function (/* (new Error) or (code, message) */) {

    var self = this;

    Hoek.assert(this.constructor === internals.Boom, 'Error must be instantiated using new');

    Error.call(this);
    this.isBoom = true;

    this.response = {
        code: 0,
        payload: {},
        headers: {}
        // type: 'content-type'
    };

    if (arguments[0] instanceof Error) {

        // Error

        var error = arguments[0];

        this.data = error;
        this.response.code = error.code || 500;
        if (error.message) {
            this.message = error.message;
        }
    }
    else {

        // code, message

        var code = arguments[0];
        var message = arguments[1];

        Hoek.assert(!isNaN(parseFloat(code)) && isFinite(code) && code >= 400, 'First argument must be a number (400+)');

        this.response.code = code;
        if (message) {
            this.message = message;
        }
    }

    // Response format

    this.reformat();

    return this;
};

NodeUtil.inherits(internals.Boom, Error);


internals.Boom.prototype.reformat = function () {

    this.response.payload.code = this.response.code;
    this.response.payload.error = Http.STATUS_CODES[this.response.code] || 'Unknown';
    if (this.message) {
        this.response.payload.message = Hoek.escapeHtml(this.message);         // Prevent XSS from error message
    }
};


// Utilities

internals.Boom.badRequest = function (message) {

    return new internals.Boom(400, message);
};


internals.Boom.unauthorized = function (message, scheme, attributes) {          // Or function (message, wwwAuthenticate[])

    var err = new internals.Boom(401, message);

    if (!scheme) {
        return err;
    }

    var wwwAuthenticate = '';

    if (typeof scheme === 'string') {

        // function (message, scheme, attributes)

        wwwAuthenticate = scheme;
        if (attributes) {
            var names = Object.keys(attributes);
            for (var i = 0, il = names.length; i < il; ++i) {
                if (i) {
                    wwwAuthenticate += ',';
                }

                var value = attributes[names[i]];
                if (value === null ||
                    value === undefined) {              // Value can be zero

                    value = '';
                }
                wwwAuthenticate += ' ' + names[i] + '="' + Hoek.escapeHeaderAttribute(value.toString()) + '"';
            }
        }

        if (message) {
            if (attributes) {
                wwwAuthenticate += ',';
            }
            wwwAuthenticate += ' error="' + Hoek.escapeHeaderAttribute(message) + '"';
        }
        else {
            err.isMissing = true;
        }
    }
    else {

        // function (message, wwwAuthenticate[])

        var wwwArray = scheme;
        for (var i = 0, il = wwwArray.length; i < il; ++i) {
            if (i) {
                wwwAuthenticate += ', ';
            }

            wwwAuthenticate += wwwArray[i];
        }
    }

    err.response.headers['WWW-Authenticate'] = wwwAuthenticate;

    return err;
};


internals.Boom.clientTimeout = function (message) {

    return new internals.Boom(408, message);
};


internals.Boom.serverTimeout = function (message) {

    return new internals.Boom(503, message);
};


internals.Boom.forbidden = function (message) {

    return new internals.Boom(403, message);
};


internals.Boom.notFound = function (message) {

    return new internals.Boom(404, message);
};


internals.Boom.internal = function (message, data) {

    var err = new internals.Boom(500, message);

    if (data && data.stack) {
        err.trace = data.stack.split('\n');
        err.outterTrace = Hoek.displayStack(1);
    }
    else {
        err.trace = Hoek.displayStack(1);
    }

    err.data = data;
    err.response.payload.message = 'An internal server error occurred';                     // Hide actual error from user

    return err;
};


internals.Boom.passThrough = function (code, payload, contentType, headers) {

    var err = new internals.Boom(500, 'Pass-through');                                      // 500 code is only used to initialize

    err.data = {
        code: code,
        payload: payload,
        type: contentType
    };

    err.response.code = code;
    err.response.type = contentType;
    err.response.headers = headers;
    err.response.payload = payload;

    return err;
};



},{"http":7,"util":5,"hoek":89}],87:[function(require,module,exports){
(function(Buffer){// Declare internals

var internals = {};


exports.escapeJavaScript = function (input) {

    if (!input) {
        return '';
    }

    var escaped = '';

    for (var i = 0, il = input.length; i < il; ++i) {

        var charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeJavaScriptChar(charCode);
        }
    }

    return escaped;
};


exports.escapeHtml = function (input) {

    if (!input) {
        return '';
    }

    var escaped = '';

    for (var i = 0, il = input.length; i < il; ++i) {

        var charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeHtmlChar(charCode);
        }
    }

    return escaped;
};


internals.escapeJavaScriptChar = function (charCode) {

    if (charCode >= 256) {
        return '\\u' + internals.padLeft('' + charCode, 4);
    }

    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '\\x' + internals.padLeft(hexValue, 2);
};


internals.escapeHtmlChar = function (charCode) {

    var namedEscape = internals.namedHtml[charCode];
    if (typeof namedEscape !== 'undefined') {
        return namedEscape;
    }

    if (charCode >= 256) {
        return '&#' + charCode + ';';
    }

    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '&#x' + internals.padLeft(hexValue, 2) + ';';
};


internals.padLeft = function (str, len) {

    while (str.length < len) {
        str = '0' + str;
    }

    return str;
};


internals.isSafe = function (charCode) {

    return (typeof internals.safeCharCodes[charCode] !== 'undefined');
};


internals.namedHtml = {
    '38': '&amp;',
    '60': '&lt;',
    '62': '&gt;',
    '34': '&quot;',
    '160': '&nbsp;',
    '162': '&cent;',
    '163': '&pound;',
    '164': '&curren;',
    '169': '&copy;',
    '174': '&reg;'
};


internals.safeCharCodes = (function () {

    var safe = {};

    for (var i = 32; i < 123; ++i) {

        if ((i >= 97 && i <= 122) ||         // a-z
            (i >= 65 && i <= 90) ||          // A-Z
            (i >= 48 && i <= 57) ||          // 0-9
            i === 32 ||                      // space
            i === 46 ||                      // .
            i === 44 ||                      // ,
            i === 45 ||                      // -
            i === 58 ||                      // :
            i === 95) {                      // _

            safe[i] = null;
        }
    }

    return safe;
}());
})(require("__browserify_buffer").Buffer)
},{"__browserify_buffer":19}],88:[function(require,module,exports){
module.exports = require('./lib');
},{"./lib":90}],89:[function(require,module,exports){
module.exports = require('./lib');
},{"./lib":91}],86:[function(require,module,exports){
// Load modules

var Crypto = require('crypto');
var Boom = require('boom');


// Declare internals

var internals = {};


// Generate a cryptographically strong pseudo-random data

exports.randomString = function (size) {

    var buffer = exports.randomBits((size + 1) * 6);
    if (buffer instanceof Error) {
        return buffer;
    }

    var string = buffer.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
    return string.slice(0, size);
};


exports.randomBits = function (bits) {

    if (!bits ||
        bits < 0) {

        return Boom.internal('Invalid random bits count');
    }

    var bytes = Math.ceil(bits / 8);
    try {
        return Crypto.randomBytes(bytes);
    }
    catch (err) {
        return Boom.internal('Failed generating random bits: ' + err.message);
    }
};


// Compare two strings using fixed time algorithm (to prevent time-based analysis of MAC digest match)

exports.fixedTimeComparison = function (a, b) {

    if (typeof a !== 'string' ||
        typeof b !== 'string') {

        return false;
    }

    var mismatch = (a.length === b.length ? 0 : 1);
    if (mismatch) {
        b = a;
    }

    for (var i = 0, il = a.length; i < il; ++i) {
        var ac = a.charCodeAt(i);
        var bc = b.charCodeAt(i);
        mismatch += (ac === bc ? 0 : 1);
    }

    return (mismatch === 0);
};



},{"crypto":11,"boom":71}],90:[function(require,module,exports){
(function(process,Buffer){// Load modules

var Fs = require('fs');
var Escape = require('./escape');


// Declare internals

var internals = {};


// Clone object or array

exports.clone = function (obj, seen) {

    if (typeof obj !== 'object' ||
        obj === null) {

        return obj;
    }

    seen = seen || { orig: [], copy: [] };

    var lookup = seen.orig.indexOf(obj);
    if (lookup !== -1) {
        return seen.copy[lookup];
    }

    var newObj = (obj instanceof Array) ? [] : {};

    seen.orig.push(obj);
    seen.copy.push(newObj);

    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (obj[i] instanceof Buffer) {
                newObj[i] = new Buffer(obj[i]);
            }
            else if (obj[i] instanceof Date) {
                newObj[i] = new Date(obj[i].getTime());
            }
            else if (obj[i] instanceof RegExp) {
                var flags = '' + (obj[i].global ? 'g' : '') + (obj[i].ignoreCase ? 'i' : '') + (obj[i].multiline ? 'm' : '');
                newObj[i] = new RegExp(obj[i].source, flags);
            }
            else {
                newObj[i] = exports.clone(obj[i], seen);
            }
        }
    }

    return newObj;
};


// Merge all the properties of source into target, source wins in conflic, and by default null and undefined from source are applied

exports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {

    exports.assert(target && typeof target == 'object', 'Invalid target value: must be an object');
    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');

    if (!source) {
        return target;
    }

    if (source instanceof Array) {
        exports.assert(target instanceof Array, 'Cannot merge array onto an object');
        if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true
            target.length = 0;                                                          // Must not change target assignment
        }

        for (var i = 0, il = source.length; i < il; ++i) {
            target.push(source[i]);
        }

        return target;
    }

    var keys = Object.keys(source);
    for (var k = 0, kl = keys.length; k < kl; ++k) {
        var key = keys[k];
        var value = source[key];
        if (value &&
            typeof value === 'object') {

            if (!target[key] ||
                typeof target[key] !== 'object') {

                target[key] = exports.clone(value);
            }
            else {
                exports.merge(target[key], source[key], isNullOverride, isMergeArrays);
            }
        }
        else {
            if (value !== null && value !== undefined) {            // Explicit to preserve empty strings
                target[key] = value;
            }
            else if (isNullOverride !== false) {                    // Defaults to true
                target[key] = value;
            }
        }
    }

    return target;
};


// Apply options to a copy of the defaults

exports.applyToDefaults = function (defaults, options) {

    exports.assert(defaults && typeof defaults == 'object', 'Invalid defaults value: must be an object');
    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');

    if (!options) {                                                 // If no options, return null
        return null;
    }

    var copy = exports.clone(defaults);

    if (options === true) {                                         // If options is set to true, use defaults
        return copy;
    }

    return exports.merge(copy, options, false, false);
};


// Remove duplicate items from array

exports.unique = function (array, key) {

    var index = {};
    var result = [];

    for (var i = 0, il = array.length; i < il; ++i) {
        var id = (key ? array[i][key] : array[i]);
        if (index[id] !== true) {

            result.push(array[i]);
            index[id] = true;
        }
    }

    return result;
};


// Convert array into object

exports.mapToObject = function (array, key) {

    if (!array) {
        return null;
    }

    var obj = {};
    for (var i = 0, il = array.length; i < il; ++i) {
        if (key) {
            if (array[i][key]) {
                obj[array[i][key]] = true;
            }
        }
        else {
            obj[array[i]] = true;
        }
    }

    return obj;
};


// Find the common unique items in two arrays

exports.intersect = function (array1, array2, justFirst) {

    if (!array1 || !array2) {
        return [];
    }

    var common = [];
    var hash = (array1 instanceof Array ? exports.mapToObject(array1) : array1);
    var found = {};
    for (var i = 0, il = array2.length; i < il; ++i) {
        if (hash[array2[i]] && !found[array2[i]]) {
            if (justFirst) {
                return array2[i];
            }

            common.push(array2[i]);
            found[array2[i]] = true;
        }
    }

    return (justFirst ? null : common);
};


// Find which keys are present

exports.matchKeys = function (obj, keys) {

    var matched = [];
    for (var i = 0, il = keys.length; i < il; ++i) {
        if (obj.hasOwnProperty(keys[i])) {
            matched.push(keys[i]);
        }
    }
    return matched;
};


// Flatten array

exports.flatten = function (array, target) {

    var result = target || [];

    for (var i = 0, il = array.length; i < il; ++i) {
        if (Array.isArray(array[i])) {
            exports.flatten(array[i], result);
        }
        else {
            result.push(array[i]);
        }
    }

    return result;
};


// Remove keys

exports.removeKeys = function (object, keys) {

    for (var i = 0, il = keys.length; i < il; i++) {
        delete object[keys[i]];
    }
};


// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])

exports.reach = function (obj, chain) {

    var path = chain.split('.');
    var ref = obj;
    for (var i = 0, il = path.length; i < il; ++i) {
        if (ref) {
            ref = ref[path[i]];
        }
    }

    return ref;
};


// Inherits a selected set of methods from an object, wrapping functions in asynchronous syntax and catching errors

exports.inheritAsync = function (self, obj, keys) {

    keys = keys || null;

    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (keys instanceof Array &&
                keys.indexOf(i) < 0) {

                continue;
            }

            self.prototype[i] = (function (fn) {

                return function (next) {

                    var result = null;
                    try {
                        result = fn();
                    }
                    catch (err) {
                        return next(err);
                    }

                    return next(null, result);
                };
            })(obj[i]);
        }
    }
};


exports.formatStack = function (stack) {

    var trace = [];
    for (var i = 0, il = stack.length; i < il; ++i) {
        var item = stack[i];
        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
    }

    return trace;
};


exports.formatTrace = function (trace) {

    var display = [];

    for (var i = 0, il = trace.length; i < il; ++i) {
        var row = trace[i];
        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');
    }

    return display;
};


exports.callStack = function (slice) {

    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi

    var v8 = Error.prepareStackTrace;
    Error.prepareStackTrace = function (err, stack) {

        return stack;
    };

    var capture = {};
    Error.captureStackTrace(capture, arguments.callee);
    var stack = capture.stack;

    Error.prepareStackTrace = v8;

    var trace = exports.formatStack(stack);

    if (slice) {
        return trace.slice(slice);
    }

    return trace;
};


exports.displayStack = function (slice) {

    var trace = exports.callStack(slice === undefined ? 1 : slice + 1);

    return exports.formatTrace(trace);
};


exports.abortThrow = false;


exports.abort = function (message, hideStack) {

    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {
        throw new Error(message || 'Unknown error');
    }

    var stack = '';
    if (!hideStack) {
        stack = exports.displayStack(1).join('\n\t');
    }
    console.log('ABORT: ' + message + '\n\t' + stack);
    process.exit(1);
};


exports.assert = function (condition /*, msg1, msg2, msg3 */) {

    if (condition) {
        return;
    }

    var msgs = Array.prototype.slice.call(arguments, 1);
    msgs = msgs.map(function (msg) {

        return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : JSON.stringify(msg);
    });
    throw new Error(msgs.join(' ') || 'Unknown error');
};


exports.loadDirModules = function (path, excludeFiles, target) {      // target(filename, name, capName)

    var exclude = {};
    for (var i = 0, il = excludeFiles.length; i < il; ++i) {
        exclude[excludeFiles[i] + '.js'] = true;
    }

    var files = Fs.readdirSync(path);
    for (i = 0, il = files.length; i < il; ++i) {
        var filename = files[i];
        if (/\.js$/.test(filename) &&
            !exclude[filename]) {

            var name = filename.substr(0, filename.lastIndexOf('.'));
            var capName = name.charAt(0).toUpperCase() + name.substr(1).toLowerCase();

            if (typeof target !== 'function') {
                target[capName] = require(path + '/' + name);
            }
            else {
                target(path + '/' + name, name, capName);
            }
        }
    }
};


exports.rename = function (obj, from, to) {

    obj[to] = obj[from];
    delete obj[from];
};


exports.Timer = function () {

    this.reset();
};


exports.Timer.prototype.reset = function () {

    this.ts = Date.now();
};


exports.Timer.prototype.elapsed = function () {

    return Date.now() - this.ts;
};


// Load and parse package.json process root or given directory

exports.loadPackage = function (dir) {

    var result = {};
    var filepath = (dir || process.env.PWD) + '/package.json';
    if (Fs.existsSync(filepath)) {
        try {
            result = JSON.parse(Fs.readFileSync(filepath));
        }
        catch (e) { }
    }

    return result;
};


// Escape string for Regex construction

exports.escapeRegex = function (string) {

    // Escape ^$.*+-?=!:|\/()[]{},
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
};


// Return an error as first argument of a callback

exports.toss = function (condition /*, [message], next */) {

    var message = (arguments.length === 3 ? arguments[1] : '');
    var next = (arguments.length === 3 ? arguments[2] : arguments[1]);

    var err = (message instanceof Error ? message : (message ? new Error(message) : (condition instanceof Error ? condition : new Error())));

    if (condition instanceof Error ||
        !condition) {

        return next(err);
    }
};


// Base64url (RFC 4648) encode

exports.base64urlEncode = function (value) {

    return (new Buffer(value, 'binary')).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
};


// Base64url (RFC 4648) decode

exports.base64urlDecode = function (encoded) {

    if (encoded &&
        !encoded.match(/^[\w\-]*$/)) {

        return new Error('Invalid character');
    }

    try {
        return (new Buffer(encoded.replace(/-/g, '+').replace(/:/g, '/'), 'base64')).toString('binary');
    }
    catch (err) {
        return err;
    }
};


// Escape attribute value for use in HTTP header

exports.escapeHeaderAttribute = function (attribute) {

    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

    exports.assert(attribute.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/), 'Bad attribute value (' + attribute + ')');

    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
};


exports.escapeHtml = function (string) {

    return Escape.escapeHtml(string);
};


exports.escapeJavaScript = function (string) {

    return Escape.escapeJavaScript(string);
};


/*
var event = {
    timestamp: now.getTime(),
    tags: ['tag'],
    data: { some: 'data' }
};
*/

exports.consoleFunc = console.log;

exports.printEvent = function (event) {

    var pad = function (value) {

        return (value < 10 ? '0' : '') + value;
    };

    var now = new Date(event.timestamp);
    var timestring = (now.getYear() - 100).toString() +
        pad(now.getMonth() + 1) +
        pad(now.getDate()) +
        '/' +
        pad(now.getHours()) +
        pad(now.getMinutes()) +
        pad(now.getSeconds()) +
        '.' +
        now.getMilliseconds();

    var data = event.data;
    if (typeof event.data !== 'string') {
        try {
            data = JSON.stringify(event.data);
        }
        catch (e) {
            data = 'JSON Error: ' + e.message;
        }
    }

    var output = timestring + ', ' + event.tags[0] + ', ' + data;
    exports.consoleFunc(output);
};


exports.nextTick = function (callback) {

    return function () {

        var args = arguments;
        process.nextTick(function () {

            callback.apply(null, args);
        });
    };
};

})(require("__browserify_process"),require("__browserify_buffer").Buffer)
},{"fs":34,"./escape":92,"__browserify_process":9,"__browserify_buffer":19}],91:[function(require,module,exports){
(function(process,Buffer){// Load modules

var Fs = require('fs');
var Escape = require('./escape');


// Declare internals

var internals = {};


// Clone object or array

exports.clone = function (obj, seen) {

    if (typeof obj !== 'object' ||
        obj === null) {

        return obj;
    }

    seen = seen || { orig: [], copy: [] };

    var lookup = seen.orig.indexOf(obj);
    if (lookup !== -1) {
        return seen.copy[lookup];
    }

    var newObj = (obj instanceof Array) ? [] : {};

    seen.orig.push(obj);
    seen.copy.push(newObj);

    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (obj[i] instanceof Buffer) {
                newObj[i] = new Buffer(obj[i]);
            }
            else if (obj[i] instanceof Date) {
                newObj[i] = new Date(obj[i].getTime());
            }
            else if (obj[i] instanceof RegExp) {
                var flags = '' + (obj[i].global ? 'g' : '') + (obj[i].ignoreCase ? 'i' : '') + (obj[i].multiline ? 'm' : '');
                newObj[i] = new RegExp(obj[i].source, flags);
            }
            else {
                newObj[i] = exports.clone(obj[i], seen);
            }
        }
    }

    return newObj;
};


// Merge all the properties of source into target, source wins in conflic, and by default null and undefined from source are applied

exports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {

    exports.assert(target && typeof target == 'object', 'Invalid target value: must be an object');
    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');

    if (!source) {
        return target;
    }

    if (source instanceof Array) {
        exports.assert(target instanceof Array, 'Cannot merge array onto an object');
        if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true
            target.length = 0;                                                          // Must not change target assignment
        }

        for (var i = 0, il = source.length; i < il; ++i) {
            target.push(source[i]);
        }

        return target;
    }

    var keys = Object.keys(source);
    for (var k = 0, kl = keys.length; k < kl; ++k) {
        var key = keys[k];
        var value = source[key];
        if (value &&
            typeof value === 'object') {

            if (!target[key] ||
                typeof target[key] !== 'object') {

                target[key] = exports.clone(value);
            }
            else {
                exports.merge(target[key], source[key], isNullOverride, isMergeArrays);
            }
        }
        else {
            if (value !== null && value !== undefined) {            // Explicit to preserve empty strings
                target[key] = value;
            }
            else if (isNullOverride !== false) {                    // Defaults to true
                target[key] = value;
            }
        }
    }

    return target;
};


// Apply options to a copy of the defaults

exports.applyToDefaults = function (defaults, options) {

    exports.assert(defaults && typeof defaults == 'object', 'Invalid defaults value: must be an object');
    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');

    if (!options) {                                                 // If no options, return null
        return null;
    }

    var copy = exports.clone(defaults);

    if (options === true) {                                         // If options is set to true, use defaults
        return copy;
    }

    return exports.merge(copy, options, false, false);
};


// Remove duplicate items from array

exports.unique = function (array, key) {

    var index = {};
    var result = [];

    for (var i = 0, il = array.length; i < il; ++i) {
        var id = (key ? array[i][key] : array[i]);
        if (index[id] !== true) {

            result.push(array[i]);
            index[id] = true;
        }
    }

    return result;
};


// Convert array into object

exports.mapToObject = function (array, key) {

    if (!array) {
        return null;
    }

    var obj = {};
    for (var i = 0, il = array.length; i < il; ++i) {
        if (key) {
            if (array[i][key]) {
                obj[array[i][key]] = true;
            }
        }
        else {
            obj[array[i]] = true;
        }
    }

    return obj;
};


// Find the common unique items in two arrays

exports.intersect = function (array1, array2, justFirst) {

    if (!array1 || !array2) {
        return [];
    }

    var common = [];
    var hash = (array1 instanceof Array ? exports.mapToObject(array1) : array1);
    var found = {};
    for (var i = 0, il = array2.length; i < il; ++i) {
        if (hash[array2[i]] && !found[array2[i]]) {
            if (justFirst) {
                return array2[i];
            }

            common.push(array2[i]);
            found[array2[i]] = true;
        }
    }

    return (justFirst ? null : common);
};


// Find which keys are present

exports.matchKeys = function (obj, keys) {

    var matched = [];
    for (var i = 0, il = keys.length; i < il; ++i) {
        if (obj.hasOwnProperty(keys[i])) {
            matched.push(keys[i]);
        }
    }
    return matched;
};


// Flatten array

exports.flatten = function (array, target) {

    var result = target || [];

    for (var i = 0, il = array.length; i < il; ++i) {
        if (Array.isArray(array[i])) {
            exports.flatten(array[i], result);
        }
        else {
            result.push(array[i]);
        }
    }

    return result;
};


// Remove keys

exports.removeKeys = function (object, keys) {

    for (var i = 0, il = keys.length; i < il; i++) {
        delete object[keys[i]];
    }
};


// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])

exports.reach = function (obj, chain) {

    var path = chain.split('.');
    var ref = obj;
    for (var i = 0, il = path.length; i < il; ++i) {
        if (ref) {
            ref = ref[path[i]];
        }
    }

    return ref;
};


// Inherits a selected set of methods from an object, wrapping functions in asynchronous syntax and catching errors

exports.inheritAsync = function (self, obj, keys) {

    keys = keys || null;

    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (keys instanceof Array &&
                keys.indexOf(i) < 0) {

                continue;
            }

            self.prototype[i] = (function (fn) {

                return function (next) {

                    var result = null;
                    try {
                        result = fn();
                    }
                    catch (err) {
                        return next(err);
                    }

                    return next(null, result);
                };
            })(obj[i]);
        }
    }
};


exports.formatStack = function (stack) {

    var trace = [];
    for (var i = 0, il = stack.length; i < il; ++i) {
        var item = stack[i];
        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);
    }

    return trace;
};


exports.formatTrace = function (trace) {

    var display = [];

    for (var i = 0, il = trace.length; i < il; ++i) {
        var row = trace[i];
        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');
    }

    return display;
};


exports.callStack = function (slice) {

    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi

    var v8 = Error.prepareStackTrace;
    Error.prepareStackTrace = function (err, stack) {

        return stack;
    };

    var capture = {};
    Error.captureStackTrace(capture, arguments.callee);
    var stack = capture.stack;

    Error.prepareStackTrace = v8;

    var trace = exports.formatStack(stack);

    if (slice) {
        return trace.slice(slice);
    }

    return trace;
};


exports.displayStack = function (slice) {

    var trace = exports.callStack(slice === undefined ? 1 : slice + 1);

    return exports.formatTrace(trace);
};


exports.abortThrow = false;


exports.abort = function (message, hideStack) {

    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {
        throw new Error(message || 'Unknown error');
    }

    var stack = '';
    if (!hideStack) {
        stack = exports.displayStack(1).join('\n\t');
    }
    console.log('ABORT: ' + message + '\n\t' + stack);
    process.exit(1);
};


exports.assert = function (condition /*, msg1, msg2, msg3 */) {

    if (condition) {
        return;
    }

    var msgs = Array.prototype.slice.call(arguments, 1);
    msgs = msgs.map(function (msg) {

        return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : JSON.stringify(msg);
    });
    throw new Error(msgs.join(' ') || 'Unknown error');
};


exports.loadDirModules = function (path, excludeFiles, target) {      // target(filename, name, capName)

    var exclude = {};
    for (var i = 0, il = excludeFiles.length; i < il; ++i) {
        exclude[excludeFiles[i] + '.js'] = true;
    }

    var files = Fs.readdirSync(path);
    for (i = 0, il = files.length; i < il; ++i) {
        var filename = files[i];
        if (/\.js$/.test(filename) &&
            !exclude[filename]) {

            var name = filename.substr(0, filename.lastIndexOf('.'));
            var capName = name.charAt(0).toUpperCase() + name.substr(1).toLowerCase();

            if (typeof target !== 'function') {
                target[capName] = require(path + '/' + name);
            }
            else {
                target(path + '/' + name, name, capName);
            }
        }
    }
};


exports.rename = function (obj, from, to) {

    obj[to] = obj[from];
    delete obj[from];
};


exports.Timer = function () {

    this.reset();
};


exports.Timer.prototype.reset = function () {

    this.ts = Date.now();
};


exports.Timer.prototype.elapsed = function () {

    return Date.now() - this.ts;
};


// Load and parse package.json process root or given directory

exports.loadPackage = function (dir) {

    var result = {};
    var filepath = (dir || process.env.PWD) + '/package.json';
    if (Fs.existsSync(filepath)) {
        try {
            result = JSON.parse(Fs.readFileSync(filepath));
        }
        catch (e) { }
    }

    return result;
};


// Escape string for Regex construction

exports.escapeRegex = function (string) {

    // Escape ^$.*+-?=!:|\/()[]{},
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
};


// Return an error as first argument of a callback

exports.toss = function (condition /*, [message], next */) {

    var message = (arguments.length === 3 ? arguments[1] : '');
    var next = (arguments.length === 3 ? arguments[2] : arguments[1]);

    var err = (message instanceof Error ? message : (message ? new Error(message) : (condition instanceof Error ? condition : new Error())));

    if (condition instanceof Error ||
        !condition) {

        return next(err);
    }
};


// Base64url (RFC 4648) encode

exports.base64urlEncode = function (value) {

    return (new Buffer(value, 'binary')).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
};


// Base64url (RFC 4648) decode

exports.base64urlDecode = function (encoded) {

    if (encoded &&
        !encoded.match(/^[\w\-]*$/)) {

        return new Error('Invalid character');
    }

    try {
        return (new Buffer(encoded.replace(/-/g, '+').replace(/:/g, '/'), 'base64')).toString('binary');
    }
    catch (err) {
        return err;
    }
};


// Escape attribute value for use in HTTP header

exports.escapeHeaderAttribute = function (attribute) {

    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

    exports.assert(attribute.match(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/), 'Bad attribute value (' + attribute + ')');

    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
};


exports.escapeHtml = function (string) {

    return Escape.escapeHtml(string);
};


exports.escapeJavaScript = function (string) {

    return Escape.escapeJavaScript(string);
};


/*
var event = {
    timestamp: now.getTime(),
    tags: ['tag'],
    data: { some: 'data' }
};
*/

exports.consoleFunc = console.log;

exports.printEvent = function (event) {

    var pad = function (value) {

        return (value < 10 ? '0' : '') + value;
    };

    var now = new Date(event.timestamp);
    var timestring = (now.getYear() - 100).toString() +
        pad(now.getMonth() + 1) +
        pad(now.getDate()) +
        '/' +
        pad(now.getHours()) +
        pad(now.getMinutes()) +
        pad(now.getSeconds()) +
        '.' +
        now.getMilliseconds();

    var data = event.data;
    if (typeof event.data !== 'string') {
        try {
            data = JSON.stringify(event.data);
        }
        catch (e) {
            data = 'JSON Error: ' + e.message;
        }
    }

    var output = timestring + ', ' + event.tags[0] + ', ' + data;
    exports.consoleFunc(output);
};


exports.nextTick = function (callback) {

    return function () {

        var args = arguments;
        process.nextTick(function () {

            callback.apply(null, args);
        });
    };
};

})(require("__browserify_process"),require("__browserify_buffer").Buffer)
},{"fs":34,"./escape":93,"__browserify_process":9,"__browserify_buffer":19}],92:[function(require,module,exports){
(function(Buffer){// Declare internals

var internals = {};


exports.escapeJavaScript = function (input) {

    if (!input) {
        return '';
    }

    var escaped = '';

    for (var i = 0, il = input.length; i < il; ++i) {

        var charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeJavaScriptChar(charCode);
        }
    }

    return escaped;
};


exports.escapeHtml = function (input) {

    if (!input) {
        return '';
    }

    var escaped = '';

    for (var i = 0, il = input.length; i < il; ++i) {

        var charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeHtmlChar(charCode);
        }
    }

    return escaped;
};


internals.escapeJavaScriptChar = function (charCode) {

    if (charCode >= 256) {
        return '\\u' + internals.padLeft('' + charCode, 4);
    }

    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '\\x' + internals.padLeft(hexValue, 2);
};


internals.escapeHtmlChar = function (charCode) {

    var namedEscape = internals.namedHtml[charCode];
    if (typeof namedEscape !== 'undefined') {
        return namedEscape;
    }

    if (charCode >= 256) {
        return '&#' + charCode + ';';
    }

    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '&#x' + internals.padLeft(hexValue, 2) + ';';
};


internals.padLeft = function (str, len) {

    while (str.length < len) {
        str = '0' + str;
    }

    return str;
};


internals.isSafe = function (charCode) {

    return (typeof internals.safeCharCodes[charCode] !== 'undefined');
};


internals.namedHtml = {
    '38': '&amp;',
    '60': '&lt;',
    '62': '&gt;',
    '34': '&quot;',
    '160': '&nbsp;',
    '162': '&cent;',
    '163': '&pound;',
    '164': '&curren;',
    '169': '&copy;',
    '174': '&reg;'
};


internals.safeCharCodes = (function () {

    var safe = {};

    for (var i = 32; i < 123; ++i) {

        if ((i >= 97 && i <= 122) ||         // a-z
            (i >= 65 && i <= 90) ||          // A-Z
            (i >= 48 && i <= 57) ||          // 0-9
            i === 32 ||                      // space
            i === 46 ||                      // .
            i === 44 ||                      // ,
            i === 45 ||                      // -
            i === 58 ||                      // :
            i === 95) {                      // _

            safe[i] = null;
        }
    }

    return safe;
}());
})(require("__browserify_buffer").Buffer)
},{"__browserify_buffer":19}],93:[function(require,module,exports){
(function(Buffer){// Declare internals

var internals = {};


exports.escapeJavaScript = function (input) {

    if (!input) {
        return '';
    }

    var escaped = '';

    for (var i = 0, il = input.length; i < il; ++i) {

        var charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeJavaScriptChar(charCode);
        }
    }

    return escaped;
};


exports.escapeHtml = function (input) {

    if (!input) {
        return '';
    }

    var escaped = '';

    for (var i = 0, il = input.length; i < il; ++i) {

        var charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeHtmlChar(charCode);
        }
    }

    return escaped;
};


internals.escapeJavaScriptChar = function (charCode) {

    if (charCode >= 256) {
        return '\\u' + internals.padLeft('' + charCode, 4);
    }

    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '\\x' + internals.padLeft(hexValue, 2);
};


internals.escapeHtmlChar = function (charCode) {

    var namedEscape = internals.namedHtml[charCode];
    if (typeof namedEscape !== 'undefined') {
        return namedEscape;
    }

    if (charCode >= 256) {
        return '&#' + charCode + ';';
    }

    var hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');
    return '&#x' + internals.padLeft(hexValue, 2) + ';';
};


internals.padLeft = function (str, len) {

    while (str.length < len) {
        str = '0' + str;
    }

    return str;
};


internals.isSafe = function (charCode) {

    return (typeof internals.safeCharCodes[charCode] !== 'undefined');
};


internals.namedHtml = {
    '38': '&amp;',
    '60': '&lt;',
    '62': '&gt;',
    '34': '&quot;',
    '160': '&nbsp;',
    '162': '&cent;',
    '163': '&pound;',
    '164': '&curren;',
    '169': '&copy;',
    '174': '&reg;'
};


internals.safeCharCodes = (function () {

    var safe = {};

    for (var i = 32; i < 123; ++i) {

        if ((i >= 97 && i <= 122) ||         // a-z
            (i >= 65 && i <= 90) ||          // A-Z
            (i >= 48 && i <= 57) ||          // 0-9
            i === 32 ||                      // space
            i === 46 ||                      // .
            i === 44 ||                      // ,
            i === 45 ||                      // -
            i === 58 ||                      // :
            i === 95) {                      // _

            safe[i] = null;
        }
    }

    return safe;
}());
})(require("__browserify_buffer").Buffer)
},{"__browserify_buffer":19}]},{},[35])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1idWlsdGlucy9idWlsdGluL3VybC5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL2J1aWx0aW4vc3RyZWFtLmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvYnVpbHRpbi91dGlsLmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvYnVpbHRpbi9xdWVyeXN0cmluZy5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL2J1aWx0aW4vaHR0cHMuanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1idWlsdGlucy9idWlsdGluL3Rscy5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL2J1aWx0aW4vZXZlbnRzLmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvbm9kZV9tb2R1bGVzL2h0dHAtYnJvd3NlcmlmeS9pbmRleC5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9pbmRleC5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvbm9kZS14bXBwL2xpYi94bXBwL2ppZC5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL2J1aWx0aW4vYXNzZXJ0LmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9idWZmZXIuanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL3JlcXVlc3QvaW5kZXguanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1idWlsdGlucy9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvcm5nLmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L3NoYS5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9tZDUuanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1idWlsdGlucy9idWlsdGluL25ldC5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L19lbXB0eS5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvb2F1dGgtc2lnbi9pbmRleC5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvYXdzLXNpZ24vaW5kZXguanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL21pbWUvbWltZS5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvbm9kZS11dWlkL3V1aWQuanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL3R1bm5lbC1hZ2VudC9pbmRleC5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvZm9yZXZlci1hZ2VudC9pbmRleC5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvanNvbi1zdHJpbmdpZnktc2FmZS9zdHJpbmdpZnkuanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL3FzL2luZGV4LmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbGliL25vZGUteG1wcC1icm93c2VyaWZ5LmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvbm9kZV9tb2R1bGVzL2J1ZmZlci1icm93c2VyaWZ5L2J1ZmZlcl9pZWVlNzU0LmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvbm9kZV9tb2R1bGVzL2J1ZmZlci1icm93c2VyaWZ5L2luZGV4LmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvYnVpbHRpbi9mcy5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL2J1aWx0aW4vcGF0aC5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvY29va2llLWphci9pbmRleC5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvbm9kZS14bXBwL2xpYi9zdGFydHRscy5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL2luZGV4LmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvbm9kZV9tb2R1bGVzL2J1ZmZlci1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL25vZGVfbW9kdWxlcy9odHRwLWJyb3dzZXJpZnkvbGliL3Jlc3BvbnNlLmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9oYXdrL2luZGV4LmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9jb29raWUtamFyL2phci5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9sdHgvbGliL2luZGV4LWJyb3dzZXJpZnkuanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9saWIveG1wcC9zZXNzaW9uLmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2x0eC9saWIvc2F4X2x0eC5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLWJ1aWx0aW5zL25vZGVfbW9kdWxlcy9odHRwLWJyb3dzZXJpZnkvbGliL3JlcXVlc3QuanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9saWIveG1wcC9jb25uZWN0aW9uLmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbGliL3htcHAvY2xpZW50LmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbGliL3htcHAvc3RhbnphLmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvbm9kZV9tb2R1bGVzL2h0dHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY29uY2F0LXN0cmVhbS9pbmRleC5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9sdHgvbGliL2luZGV4LmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9mb3JtLWRhdGEvbm9kZV9tb2R1bGVzL2FzeW5jL2xpYi9hc3luYy5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9mb3JtX2RhdGEuanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9ub2RlX21vZHVsZXMvbHR4L2xpYi9lbGVtZW50LmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9odHRwLXNpZ25hdHVyZS9saWIvcGFyc2VyLmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9odHRwLXNpZ25hdHVyZS9saWIvc2lnbmVyLmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9odHRwLXNpZ25hdHVyZS9saWIvdXRpbC5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL3ZlcmlmeS5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvbm9kZS14bXBwL2xpYi94bXBwL3N0cmVhbV9wYXJzZXIuanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9saWIveG1wcC9zYXNsLmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9oYXdrL2xpYi9jcnlwdG8uanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2h0dHAtc2lnbmF0dXJlL25vZGVfbW9kdWxlcy9hc3NlcnQtcGx1cy9hc3NlcnQuanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2hhd2svbGliL2luZGV4LmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2JsdWVpbXAtbWQ1L2pzL21kNS5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvbm9kZS14bXBwL25vZGVfbW9kdWxlcy9sdHgvbGliL3BhcnNlLmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9odHRwLXNpZ25hdHVyZS9ub2RlX21vZHVsZXMvY3R5cGUvY3R5cGUuanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2h0dHAtc2lnbmF0dXJlL25vZGVfbW9kdWxlcy9hc24xL2xpYi9pbmRleC5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL2N0eXBlL2N0Zi5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL2N0eXBlL2N0aW8uanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9saWIveG1wcC93ZWJzb2NrZXRzLmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9mb3JtLWRhdGEvbm9kZV9tb2R1bGVzL2NvbWJpbmVkLXN0cmVhbS9saWIvY29tYmluZWRfc3RyZWFtLmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9oYXdrL2xpYi9zZXJ2ZXIuanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2hhd2svbGliL2NsaWVudC5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaGF3ay9saWIvdXRpbHMuanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2hhd2svbm9kZV9tb2R1bGVzL3NudHAvaW5kZXguanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2hhd2svbm9kZV9tb2R1bGVzL2Jvb20vaW5kZXguanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL25vZGUteG1wcC9saWIveG1wcC9ib3NoLmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9mb3JtLWRhdGEvbm9kZV9tb2R1bGVzL2NvbWJpbmVkLXN0cmVhbS9ub2RlX21vZHVsZXMvZGVsYXllZC1zdHJlYW0vbGliL2RlbGF5ZWRfc3RyZWFtLmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9odHRwLXNpZ25hdHVyZS9ub2RlX21vZHVsZXMvYXNuMS9saWIvYmVyL2luZGV4LmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9ub2RlLXhtcHAvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItYnVpbHRpbnMvYnVpbHRpbi9kZ3JhbS5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL2FzbjEvbGliL2Jlci9lcnJvcnMuanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2h0dHAtc2lnbmF0dXJlL25vZGVfbW9kdWxlcy9hc24xL2xpYi9iZXIvdHlwZXMuanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2hhd2svbm9kZV9tb2R1bGVzL2hvZWsvaW5kZXguanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2hhd2svbm9kZV9tb2R1bGVzL2NyeXB0aWxlcy9pbmRleC5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbm9kZV9tb2R1bGVzL2FzbjEvbGliL2Jlci93cml0ZXIuanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2h0dHAtc2lnbmF0dXJlL25vZGVfbW9kdWxlcy9hc24xL2xpYi9iZXIvcmVhZGVyLmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9oYXdrL25vZGVfbW9kdWxlcy9ob2VrL2xpYi9pbmRleC5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaGF3ay9ub2RlX21vZHVsZXMvc250cC9saWIvaW5kZXguanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2hhd2svbm9kZV9tb2R1bGVzL2Jvb20vbGliL2luZGV4LmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9oYXdrL25vZGVfbW9kdWxlcy9ob2VrL2xpYi9lc2NhcGUuanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2hhd2svbm9kZV9tb2R1bGVzL3NudHAvbm9kZV9tb2R1bGVzL2hvZWsvaW5kZXguanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2hhd2svbm9kZV9tb2R1bGVzL2Jvb20vbm9kZV9tb2R1bGVzL2hvZWsvaW5kZXguanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2hhd2svbm9kZV9tb2R1bGVzL2NyeXB0aWxlcy9saWIvaW5kZXguanMiLCIvVXNlcnMvc3RhdWZmZXIvRGV2ZWxvcG1lbnQvZ2xhc3Mvbm9kZV9tb2R1bGVzL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL2hhd2svbm9kZV9tb2R1bGVzL3NudHAvbm9kZV9tb2R1bGVzL2hvZWsvbGliL2luZGV4LmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9oYXdrL25vZGVfbW9kdWxlcy9ib29tL25vZGVfbW9kdWxlcy9ob2VrL2xpYi9pbmRleC5qcyIsIi9Vc2Vycy9zdGF1ZmZlci9EZXZlbG9wbWVudC9nbGFzcy9ub2RlX21vZHVsZXMvcmVxdWVzdC9ub2RlX21vZHVsZXMvaGF3ay9ub2RlX21vZHVsZXMvc250cC9ub2RlX21vZHVsZXMvaG9lay9saWIvZXNjYXBlLmpzIiwiL1VzZXJzL3N0YXVmZmVyL0RldmVsb3BtZW50L2dsYXNzL25vZGVfbW9kdWxlcy9yZXF1ZXN0L25vZGVfbW9kdWxlcy9oYXdrL25vZGVfbW9kdWxlcy9ib29tL25vZGVfbW9kdWxlcy9ob2VrL2xpYi9lc2NhcGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9WQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdnhIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2wyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoWUE7QUFDQTs7QUNEQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFqQ0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNTdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2o3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzc4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvS0E7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNya0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTs7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHB1bnljb2RlID0geyBlbmNvZGUgOiBmdW5jdGlvbiAocykgeyByZXR1cm4gcyB9IH07XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZihhcnJheSwgc3ViamVjdCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXkubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIGlmKGFycmF5W2ldID09IHN1YmplY3QpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gb2JqZWN0S2V5cyhvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ICE9PSBPYmplY3Qob2JqZWN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBvYmplY3QnKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkga2V5c1trZXlzLmxlbmd0aF0gPSBrZXk7XG4gICAgcmV0dXJuIGtleXM7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0rJC8sXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ34nLCAnWycsICddJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10sXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddXG4gICAgICAuY29uY2F0KHVud2lzZSkuY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIG5vbkF1dGhDaGFycyA9IFsnLycsICdAJywgJz8nLCAnIyddLmNvbmNhdChkZWxpbXMpLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlthLXpBLVowLTldW2EtejAtOUEtWl8tXXswLDYyfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oW2EtekEtWjAtOV1bYS16MC05QS1aXy1dezAsNjJ9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGhhdmUgYSBwYXRoIGNvbXBvbmVudC5cbiAgICBwYXRoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdHlwZW9mKHVybCkgPT09ICdvYmplY3QnICYmIHVybC5ocmVmKSByZXR1cm4gdXJsO1xuXG4gIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICB2YXIgb3V0ID0ge30sXG4gICAgICByZXN0ID0gdXJsO1xuXG4gIC8vIGN1dCBvZmYgYW55IGRlbGltaXRlcnMuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiPGh0dHA6Ly9mb28uY29tPlwiXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcmVzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoYXJyYXlJbmRleE9mKGRlbGltcywgcmVzdC5jaGFyQXQoaSkpID09PSAtMSkgYnJlYWs7XG4gIH1cbiAgaWYgKGkgIT09IDApIHJlc3QgPSByZXN0LnN1YnN0cihpKTtcblxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICBvdXQucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICBvdXQuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvLyBkb24ndCBlbmZvcmNlIGZ1bGwgUkZDIGNvcnJlY3RuZXNzLCBqdXN0IGJlIHVuc3R1cGlkIGFib3V0IGl0LlxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBAIHNpZ24sIHVubGVzcyBzb21lIG5vbi1hdXRoIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIHZhciBhdFNpZ24gPSBhcnJheUluZGV4T2YocmVzdCwgJ0AnKTtcbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgLy8gdGhlcmUgKm1heSBiZSogYW4gYXV0aFxuICAgICAgdmFyIGhhc0F1dGggPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub25BdXRoQ2hhcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGFycmF5SW5kZXhPZihyZXN0LCBub25BdXRoQ2hhcnNbaV0pO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xICYmIGluZGV4IDwgYXRTaWduKSB7XG4gICAgICAgICAgLy8gbm90IGEgdmFsaWQgYXV0aC4gIFNvbWV0aGluZyBsaWtlIGh0dHA6Ly9mb28uY29tL2JhckBiYXovXG4gICAgICAgICAgaGFzQXV0aCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaGFzQXV0aCkge1xuICAgICAgICAvLyBwbHVjayBvZmYgdGhlIGF1dGggcG9ydGlvbi5cbiAgICAgICAgb3V0LmF1dGggPSByZXN0LnN1YnN0cigwLCBhdFNpZ24pO1xuICAgICAgICByZXN0ID0gcmVzdC5zdWJzdHIoYXRTaWduICsgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0Tm9uSG9zdCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9uSG9zdENoYXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGluZGV4ID0gYXJyYXlJbmRleE9mKHJlc3QsIG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xICYmXG4gICAgICAgICAgKGZpcnN0Tm9uSG9zdCA8IDAgfHwgaW5kZXggPCBmaXJzdE5vbkhvc3QpKSBmaXJzdE5vbkhvc3QgPSBpbmRleDtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3ROb25Ib3N0ICE9PSAtMSkge1xuICAgICAgb3V0Lmhvc3QgPSByZXN0LnN1YnN0cigwLCBmaXJzdE5vbkhvc3QpO1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKGZpcnN0Tm9uSG9zdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5ob3N0ID0gcmVzdDtcbiAgICAgIHJlc3QgPSAnJztcbiAgICB9XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHZhciBwID0gcGFyc2VIb3N0KG91dC5ob3N0KTtcbiAgICB2YXIga2V5cyA9IG9iamVjdEtleXMocCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBvdXRba2V5XSA9IHBba2V5XTtcbiAgICB9XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgb3V0Lmhvc3RuYW1lID0gb3V0Lmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKG91dC5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgb3V0Lmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSBvdXQuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0Lmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgIG91dC5ob3N0bmFtZSA9IG91dC5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueSBjb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgIC8vIEl0IG9ubHkgY29udmVydHMgdGhlIHBhcnQgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAvLyBoYXMgbm9uIEFTQ0lJIGNoYXJhY3RlcnMuIEkuZS4gaXQgZG9zZW50IG1hdHRlciBpZlxuICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIGluIEFTQ0lJLlxuICAgIHZhciBkb21haW5BcnJheSA9IG91dC5ob3N0bmFtZS5zcGxpdCgnLicpO1xuICAgIHZhciBuZXdPdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbWFpbkFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcyA9IGRvbWFpbkFycmF5W2ldO1xuICAgICAgbmV3T3V0LnB1c2gocy5tYXRjaCgvW15BLVphLXowLTlfLV0vKSA/XG4gICAgICAgICAgJ3huLS0nICsgcHVueWNvZGUuZW5jb2RlKHMpIDogcyk7XG4gICAgfVxuICAgIG91dC5ob3N0bmFtZSA9IG5ld091dC5qb2luKCcuJyk7XG5cbiAgICBvdXQuaG9zdCA9IChvdXQuaG9zdG5hbWUgfHwgJycpICtcbiAgICAgICAgKChvdXQucG9ydCkgPyAnOicgKyBvdXQucG9ydCA6ICcnKTtcbiAgICBvdXQuaHJlZiArPSBvdXQuaG9zdDtcbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cblxuICAgIC8vIE5vdyBtYWtlIHN1cmUgdGhhdCBkZWxpbXMgbmV2ZXIgYXBwZWFyIGluIGEgdXJsLlxuICAgIHZhciBjaG9wID0gcmVzdC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkZWxpbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGFycmF5SW5kZXhPZihyZXN0LCBkZWxpbXNbaV0pO1xuICAgICAgaWYgKGMgIT09IC0xKSB7XG4gICAgICAgIGNob3AgPSBNYXRoLm1pbihjLCBjaG9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKDAsIGNob3ApO1xuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IGFycmF5SW5kZXhPZihyZXN0LCAnIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgb3V0Lmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSBhcnJheUluZGV4T2YocmVzdCwgJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIG91dC5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgb3V0LnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgb3V0LnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2Uob3V0LnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIG91dC5zZWFyY2ggPSAnJztcbiAgICBvdXQucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgb3V0LnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIG91dC5ob3N0bmFtZSAmJiAhb3V0LnBhdGhuYW1lKSB7XG4gICAgb3V0LnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAob3V0LnBhdGhuYW1lIHx8IG91dC5zZWFyY2gpIHtcbiAgICBvdXQucGF0aCA9IChvdXQucGF0aG5hbWUgPyBvdXQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgKG91dC5zZWFyY2ggPyBvdXQuc2VhcmNoIDogJycpO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIG91dC5ocmVmID0gdXJsRm9ybWF0KG91dCk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodHlwZW9mKG9iaikgPT09ICdzdHJpbmcnKSBvYmogPSB1cmxQYXJzZShvYmopO1xuXG4gIHZhciBhdXRoID0gb2JqLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGF1dGguc3BsaXQoJ0AnKS5qb2luKCclNDAnKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vbkF1dGhDaGFycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBuQUMgPSBub25BdXRoQ2hhcnNbaV07XG4gICAgICBhdXRoID0gYXV0aC5zcGxpdChuQUMpLmpvaW4oZW5jb2RlVVJJQ29tcG9uZW50KG5BQykpO1xuICAgIH1cbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IG9iai5wcm90b2NvbCB8fCAnJyxcbiAgICAgIGhvc3QgPSAob2JqLmhvc3QgIT09IHVuZGVmaW5lZCkgPyBhdXRoICsgb2JqLmhvc3QgOlxuICAgICAgICAgIG9iai5ob3N0bmFtZSAhPT0gdW5kZWZpbmVkID8gKFxuICAgICAgICAgICAgICBhdXRoICsgb2JqLmhvc3RuYW1lICtcbiAgICAgICAgICAgICAgKG9iai5wb3J0ID8gJzonICsgb2JqLnBvcnQgOiAnJylcbiAgICAgICAgICApIDpcbiAgICAgICAgICBmYWxzZSxcbiAgICAgIHBhdGhuYW1lID0gb2JqLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgcXVlcnkgPSBvYmoucXVlcnkgJiZcbiAgICAgICAgICAgICAgKCh0eXBlb2Ygb2JqLnF1ZXJ5ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIG9iamVjdEtleXMob2JqLnF1ZXJ5KS5sZW5ndGgpID9cbiAgICAgICAgICAgICAgICAgcXVlcnlzdHJpbmcuc3RyaW5naWZ5KG9iai5xdWVyeSkgOlxuICAgICAgICAgICAgICAgICAnJykgfHwgJycsXG4gICAgICBzZWFyY2ggPSBvYmouc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJyxcbiAgICAgIGhhc2ggPSBvYmouaGFzaCB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmIChvYmouc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsRm9ybWF0KHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkpO1xufVxuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcblxuICBzb3VyY2UgPSB1cmxQYXJzZSh1cmxGb3JtYXQoc291cmNlKSwgZmFsc2UsIHRydWUpO1xuICByZWxhdGl2ZSA9IHVybFBhcnNlKHVybEZvcm1hdChyZWxhdGl2ZSksIGZhbHNlLCB0cnVlKTtcblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgc291cmNlLmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHNvdXJjZS5ocmVmID0gdXJsRm9ybWF0KHNvdXJjZSk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICByZWxhdGl2ZS5wcm90b2NvbCA9IHNvdXJjZS5wcm90b2NvbDtcbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdICYmXG4gICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lICYmICFyZWxhdGl2ZS5wYXRobmFtZSkge1xuICAgICAgcmVsYXRpdmUucGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lID0gJy8nO1xuICAgIH1cbiAgICByZWxhdGl2ZS5ocmVmID0gdXJsRm9ybWF0KHJlbGF0aXZlKTtcbiAgICByZXR1cm4gcmVsYXRpdmU7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHNvdXJjZS5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHJlbGF0aXZlLmhyZWYgPSB1cmxGb3JtYXQocmVsYXRpdmUpO1xuICAgICAgcmV0dXJuIHJlbGF0aXZlO1xuICAgIH1cbiAgICBzb3VyY2UucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZWxhdGl2ZS5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH1cbiAgICBzb3VyY2UucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICBzb3VyY2Uuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHNvdXJjZS5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNvdXJjZS5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICBzb3VyY2UuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgc291cmNlLmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICBzb3VyY2UucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChzb3VyY2UucGF0aG5hbWUgIT09IHVuZGVmaW5lZCB8fCBzb3VyY2Uuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNvdXJjZS5wYXRoID0gKHNvdXJjZS5wYXRobmFtZSA/IHNvdXJjZS5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChzb3VyY2Uuc2VhcmNoID8gc291cmNlLnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgc291cmNlLnNsYXNoZXMgPSBzb3VyY2Uuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHNvdXJjZS5ocmVmID0gdXJsRm9ybWF0KHNvdXJjZSk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChzb3VyY2UucGF0aG5hbWUgJiYgc291cmNlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAoc291cmNlLmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHNvdXJjZS5wYXRobmFtZSAmJiBzb3VyY2UucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gc291cmNlLnByb3RvY29sICYmXG4gICAgICAgICAgIXNsYXNoZWRQcm90b2NvbFtzb3VyY2UucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHNvdXJjZS5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG5cbiAgICBkZWxldGUgc291cmNlLmhvc3RuYW1lO1xuICAgIGRlbGV0ZSBzb3VyY2UucG9ydDtcbiAgICBpZiAoc291cmNlLmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHNvdXJjZS5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQoc291cmNlLmhvc3QpO1xuICAgIH1cbiAgICBkZWxldGUgc291cmNlLmhvc3Q7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICBkZWxldGUgcmVsYXRpdmUuaG9zdG5hbWU7XG4gICAgICBkZWxldGUgcmVsYXRpdmUucG9ydDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHJlbGF0aXZlLmhvc3Q7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHNvdXJjZS5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogc291cmNlLmhvc3Q7XG4gICAgc291cmNlLmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogc291cmNlLmhvc3RuYW1lO1xuICAgIHNvdXJjZS5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgc291cmNlLnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgc291cmNlLnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICBzb3VyY2UucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICgnc2VhcmNoJyBpbiByZWxhdGl2ZSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHNvdXJjZS5ob3N0bmFtZSA9IHNvdXJjZS5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHNvdXJjZS5ob3N0ICYmIGFycmF5SW5kZXhPZihzb3VyY2UuaG9zdCwgJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICBzb3VyY2UuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgc291cmNlLmhvc3QgPSBzb3VyY2UuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZS5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgc291cmNlLnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChzb3VyY2UucGF0aG5hbWUgIT09IHVuZGVmaW5lZCB8fCBzb3VyY2Uuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNvdXJjZS5wYXRoID0gKHNvdXJjZS5wYXRobmFtZSA/IHNvdXJjZS5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChzb3VyY2Uuc2VhcmNoID8gc291cmNlLnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgc291cmNlLmhyZWYgPSB1cmxGb3JtYXQoc291cmNlKTtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICBkZWxldGUgc291cmNlLnBhdGhuYW1lO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXNvdXJjZS5zZWFyY2gpIHtcbiAgICAgIHNvdXJjZS5wYXRoID0gJy8nICsgc291cmNlLnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHNvdXJjZS5wYXRoO1xuICAgIH1cbiAgICBzb3VyY2UuaHJlZiA9IHVybEZvcm1hdChzb3VyY2UpO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChzb3VyY2UuaG9zdCB8fCByZWxhdGl2ZS5ob3N0KSAmJiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8XG4gICAgICBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICBzb3VyY2UuaG9zdG5hbWUgPSBzb3VyY2UuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSBzb3VyY2UuaG9zdCAmJiBhcnJheUluZGV4T2Yoc291cmNlLmhvc3QsICdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgc291cmNlLmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICBzb3VyY2UuaG9zdCA9IHNvdXJjZS5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAoc291cmNlLmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIHNvdXJjZS5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmIChzb3VyY2UucGF0aG5hbWUgIT09IHVuZGVmaW5lZCB8fCBzb3VyY2Uuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2UucGF0aCA9IChzb3VyY2UucGF0aG5hbWUgPyBzb3VyY2UucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNvdXJjZS5zZWFyY2ggPyBzb3VyY2Uuc2VhcmNoIDogJycpO1xuICB9XG4gIHNvdXJjZS5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCBzb3VyY2UuYXV0aDtcbiAgc291cmNlLnNsYXNoZXMgPSBzb3VyY2Uuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICBzb3VyY2UuaHJlZiA9IHVybEZvcm1hdChzb3VyY2UpO1xuICByZXR1cm4gc291cmNlO1xufVxuXG5mdW5jdGlvbiBwYXJzZUhvc3QoaG9zdCkge1xuICB2YXIgb3V0ID0ge307XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBvdXQucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgb3V0Lmhvc3RuYW1lID0gaG9zdDtcbiAgcmV0dXJuIG91dDtcbn1cbiIsInZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIGV2ZW50cy5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbn1cbnV0aWwuaW5oZXJpdHMoU3RyZWFtLCBldmVudHMuRXZlbnRFbWl0dGVyKTtcbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UsIGFuZFxuICAvLyBvbmx5IHdoZW4gYWxsIHNvdXJjZXMgaGF2ZSBlbmRlZC5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgZGVzdC5fcGlwZUNvdW50ID0gZGVzdC5fcGlwZUNvdW50IHx8IDA7XG4gICAgZGVzdC5fcGlwZUNvdW50Kys7XG5cbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5fcGlwZUNvdW50LS07XG5cbiAgICAvLyByZW1vdmUgdGhlIGxpc3RlbmVyc1xuICAgIGNsZWFudXAoKTtcblxuICAgIGlmIChkZXN0Ll9waXBlQ291bnQgPiAwKSB7XG4gICAgICAvLyB3YWl0aW5nIGZvciBvdGhlciBpbmNvbWluZyBzdHJlYW1zIHRvIGVuZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuX3BpcGVDb3VudC0tO1xuXG4gICAgLy8gcmVtb3ZlIHRoZSBsaXN0ZW5lcnNcbiAgICBjbGVhbnVwKCk7XG5cbiAgICBpZiAoZGVzdC5fcGlwZUNvdW50ID4gMCkge1xuICAgICAgLy8gd2FpdGluZyBmb3Igb3RoZXIgaW5jb21pbmcgc3RyZWFtcyB0byBlbmQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsInZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcblxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcbmV4cG9ydHMuaXNEYXRlID0gZnVuY3Rpb24ob2JqKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJ307XG5leHBvcnRzLmlzUmVnRXhwID0gZnVuY3Rpb24ob2JqKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nfTtcblxuXG5leHBvcnRzLnByaW50ID0gZnVuY3Rpb24gKCkge307XG5leHBvcnRzLnB1dHMgPSBmdW5jdGlvbiAoKSB7fTtcbmV4cG9ydHMuZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuXG5leHBvcnRzLmluc3BlY3QgPSBmdW5jdGlvbihvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMpIHtcbiAgdmFyIHNlZW4gPSBbXTtcblxuICB2YXIgc3R5bGl6ZSA9IGZ1bmN0aW9uKHN0ciwgc3R5bGVUeXBlKSB7XG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG4gICAgdmFyIHN0eWxlcyA9XG4gICAgICAgIHsgJ2JvbGQnIDogWzEsIDIyXSxcbiAgICAgICAgICAnaXRhbGljJyA6IFszLCAyM10sXG4gICAgICAgICAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAgICAgICAgICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICAgICAgICAgJ3doaXRlJyA6IFszNywgMzldLFxuICAgICAgICAgICdncmV5JyA6IFs5MCwgMzldLFxuICAgICAgICAgICdibGFjaycgOiBbMzAsIDM5XSxcbiAgICAgICAgICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgICAgICAgICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgICAgICAgICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICAgICAgICAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICAgICAgICAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgICAgICAgICAneWVsbG93JyA6IFszMywgMzldIH07XG5cbiAgICB2YXIgc3R5bGUgPVxuICAgICAgICB7ICdzcGVjaWFsJzogJ2N5YW4nLFxuICAgICAgICAgICdudW1iZXInOiAnYmx1ZScsXG4gICAgICAgICAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgICAgICAgICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAgICAgICAgICdudWxsJzogJ2JvbGQnLFxuICAgICAgICAgICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAgICAgICAgICdkYXRlJzogJ21hZ2VudGEnLFxuICAgICAgICAgIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICAgICAgICAgJ3JlZ2V4cCc6ICdyZWQnIH1bc3R5bGVUeXBlXTtcblxuICAgIGlmIChzdHlsZSkge1xuICAgICAgcmV0dXJuICdcXDAzM1snICsgc3R5bGVzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICAgJ1xcMDMzWycgKyBzdHlsZXNbc3R5bGVdWzFdICsgJ20nO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfTtcbiAgaWYgKCEgY29sb3JzKSB7XG4gICAgc3R5bGl6ZSA9IGZ1bmN0aW9uKHN0ciwgc3R5bGVUeXBlKSB7IHJldHVybiBzdHI7IH07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXQodmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAgIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLmluc3BlY3QgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICAgIHZhbHVlICE9PSBleHBvcnRzICYmXG4gICAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMpO1xuICAgIH1cblxuICAgIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiBzdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgICAgIHJldHVybiBzdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuXG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG5cbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAgIH1cbiAgICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG4gICAgfVxuXG4gICAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICAgIHZhciB2aXNpYmxlX2tleXMgPSBPYmplY3Rfa2V5cyh2YWx1ZSk7XG4gICAgdmFyIGtleXMgPSBzaG93SGlkZGVuID8gT2JqZWN0X2dldE93blByb3BlcnR5TmFtZXModmFsdWUpIDogdmlzaWJsZV9rZXlzO1xuXG4gICAgLy8gRnVuY3Rpb25zIHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAncmVnZXhwJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGF0ZXMgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZFxuICAgIGlmIChpc0RhdGUodmFsdWUpICYmIGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gc3R5bGl6ZSh2YWx1ZS50b1VUQ1N0cmluZygpLCAnZGF0ZScpO1xuICAgIH1cblxuICAgIHZhciBiYXNlLCB0eXBlLCBicmFjZXM7XG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBvYmplY3QgdHlwZVxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdHlwZSA9ICdBcnJheSc7XG4gICAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gJ09iamVjdCc7XG4gICAgICBicmFjZXMgPSBbJ3snLCAnfSddO1xuICAgIH1cblxuICAgIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICBiYXNlID0gKGlzUmVnRXhwKHZhbHVlKSkgPyAnICcgKyB2YWx1ZSA6ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSAnJztcbiAgICB9XG5cbiAgICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgYmFzZSA9ICcgJyArIHZhbHVlLnRvVVRDU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgICB9XG5cbiAgICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnJyArIHZhbHVlLCAncmVnZXhwJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgICB2YXIgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgbmFtZSwgc3RyO1xuICAgICAgaWYgKHZhbHVlLl9fbG9va3VwR2V0dGVyX18pIHtcbiAgICAgICAgaWYgKHZhbHVlLl9fbG9va3VwR2V0dGVyX18oa2V5KSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cFNldHRlcl9fKGtleSkpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZhbHVlLl9fbG9va3VwU2V0dGVyX18oa2V5KSkge1xuICAgICAgICAgICAgc3RyID0gc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZpc2libGVfa2V5cy5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cikge1xuICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKHZhbHVlW2tleV0pIDwgMCkge1xuICAgICAgICAgIGlmIChyZWN1cnNlVGltZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciA9IGZvcm1hdCh2YWx1ZVtrZXldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyID0gZm9ybWF0KHZhbHVlW2tleV0sIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdBcnJheScgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICAgICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICAgICAgbmFtZSA9IHN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgICAgIG5hbWUgPSBzdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG4gICAgfSk7XG5cbiAgICBzZWVuLnBvcCgpO1xuXG4gICAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICAgIG51bUxpbmVzRXN0Kys7XG4gICAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgICByZXR1cm4gcHJldiArIGN1ci5sZW5ndGggKyAxO1xuICAgIH0sIDApO1xuXG4gICAgaWYgKGxlbmd0aCA+IDUwKSB7XG4gICAgICBvdXRwdXQgPSBicmFjZXNbMF0gK1xuICAgICAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICAgICBicmFjZXNbMV07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ID0gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdChvYmosICh0eXBlb2YgZGVwdGggPT09ICd1bmRlZmluZWQnID8gMiA6IGRlcHRoKSk7XG59O1xuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIGFyIGluc3RhbmNlb2YgQXJyYXkgfHxcbiAgICAgICAgIEFycmF5LmlzQXJyYXkoYXIpIHx8XG4gICAgICAgICAoYXIgJiYgYXIgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgaXNBcnJheShhci5fX3Byb3RvX18pKTtcbn1cblxuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gcmUgaW5zdGFuY2VvZiBSZWdFeHAgfHxcbiAgICAodHlwZW9mIHJlID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocmUpID09PSAnW29iamVjdCBSZWdFeHBdJyk7XG59XG5cblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgaWYgKGQgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHR5cGVvZiBkICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICB2YXIgcHJvcGVydGllcyA9IERhdGUucHJvdG90eXBlICYmIE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKERhdGUucHJvdG90eXBlKTtcbiAgdmFyIHByb3RvID0gZC5fX3Byb3RvX18gJiYgT2JqZWN0X2dldE93blByb3BlcnR5TmFtZXMoZC5fX3Byb3RvX18pO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocHJvdG8pID09PSBKU09OLnN0cmluZ2lmeShwcm9wZXJ0aWVzKTtcbn1cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cbmV4cG9ydHMubG9nID0gZnVuY3Rpb24gKG1zZykge307XG5cbmV4cG9ydHMucHVtcCA9IG51bGw7XG5cbnZhciBPYmplY3Rfa2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgcmVzLnB1c2goa2V5KTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxudmFyIE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuXG52YXIgT2JqZWN0X2NyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgIC8vIGZyb20gZXM1LXNoaW1cbiAgICB2YXIgb2JqZWN0O1xuICAgIGlmIChwcm90b3R5cGUgPT09IG51bGwpIHtcbiAgICAgICAgb2JqZWN0ID0geyAnX19wcm90b19fJyA6IG51bGwgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAndHlwZW9mIHByb3RvdHlwZVsnICsgKHR5cGVvZiBwcm90b3R5cGUpICsgJ10gIT0gXFwnb2JqZWN0XFwnJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgVHlwZSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBUeXBlLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICAgICAgb2JqZWN0ID0gbmV3IFR5cGUoKTtcbiAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QuZGVmaW5lUHJvcGVydGllcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmplY3QsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxuZXhwb3J0cy5pbmhlcml0cyA9IGZ1bmN0aW9uKGN0b3IsIHN1cGVyQ3Rvcikge1xuICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3RfY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICh0eXBlb2YgZiAhPT0gJ3N0cmluZycpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goZXhwb3J0cy5pbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzogcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKXtcbiAgICBpZiAoeCA9PT0gbnVsbCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgZXhwb3J0cy5pbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcbiIsIlxuLyoqXG4gKiBPYmplY3QjdG9TdHJpbmcoKSByZWYgZm9yIHN0cmluZ2lmeSgpLlxuICovXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogQXJyYXkjaW5kZXhPZiBzaGltLlxuICovXG5cbnZhciBpbmRleE9mID0gdHlwZW9mIEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nXG4gID8gZnVuY3Rpb24oYXJyLCBlbCkgeyByZXR1cm4gYXJyLmluZGV4T2YoZWwpOyB9XG4gIDogZnVuY3Rpb24oYXJyLCBlbCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycltpXSA9PT0gZWwpIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbi8qKlxuICogQXJyYXkuaXNBcnJheSBzaGltLlxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLyoqXG4gKiBPYmplY3Qua2V5cyBzaGltLlxuICovXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ob2JqKSB7XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikgcmV0LnB1c2goa2V5KTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogQXJyYXkjZm9yRWFjaCBzaGltLlxuICovXG5cbnZhciBmb3JFYWNoID0gdHlwZW9mIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID09PSAnZnVuY3Rpb24nXG4gID8gZnVuY3Rpb24oYXJyLCBmbikgeyByZXR1cm4gYXJyLmZvckVhY2goZm4pOyB9XG4gIDogZnVuY3Rpb24oYXJyLCBmbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGZuKGFycltpXSk7XG4gICAgfTtcblxuLyoqXG4gKiBBcnJheSNyZWR1Y2Ugc2hpbS5cbiAqL1xuXG52YXIgcmVkdWNlID0gZnVuY3Rpb24oYXJyLCBmbiwgaW5pdGlhbCkge1xuICBpZiAodHlwZW9mIGFyci5yZWR1Y2UgPT09ICdmdW5jdGlvbicpIHJldHVybiBhcnIucmVkdWNlKGZuLCBpbml0aWFsKTtcbiAgdmFyIHJlcyA9IGluaXRpYWw7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSByZXMgPSBmbihyZXMsIGFycltpXSk7XG4gIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIENhY2hlIG5vbi1pbnRlZ2VyIHRlc3QgcmVnZXhwLlxuICovXG5cbnZhciBpc2ludCA9IC9eWzAtOV0rJC87XG5cbmZ1bmN0aW9uIHByb21vdGUocGFyZW50LCBrZXkpIHtcbiAgaWYgKHBhcmVudFtrZXldLmxlbmd0aCA9PSAwKSByZXR1cm4gcGFyZW50W2tleV0gPSB7fTtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgaSBpbiBwYXJlbnRba2V5XSkgdFtpXSA9IHBhcmVudFtrZXldW2ldO1xuICBwYXJlbnRba2V5XSA9IHQ7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBwYXJzZShwYXJ0cywgcGFyZW50LCBrZXksIHZhbCkge1xuICB2YXIgcGFydCA9IHBhcnRzLnNoaWZ0KCk7XG4gIC8vIGVuZFxuICBpZiAoIXBhcnQpIHtcbiAgICBpZiAoaXNBcnJheShwYXJlbnRba2V5XSkpIHtcbiAgICAgIHBhcmVudFtrZXldLnB1c2godmFsKTtcbiAgICB9IGVsc2UgaWYgKCdvYmplY3QnID09IHR5cGVvZiBwYXJlbnRba2V5XSkge1xuICAgICAgcGFyZW50W2tleV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YgcGFyZW50W2tleV0pIHtcbiAgICAgIHBhcmVudFtrZXldID0gdmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRba2V5XSA9IFtwYXJlbnRba2V5XSwgdmFsXTtcbiAgICB9XG4gICAgLy8gYXJyYXlcbiAgfSBlbHNlIHtcbiAgICB2YXIgb2JqID0gcGFyZW50W2tleV0gPSBwYXJlbnRba2V5XSB8fCBbXTtcbiAgICBpZiAoJ10nID09IHBhcnQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgICAgaWYgKCcnICE9IHZhbCkgb2JqLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgICBvYmpbb2JqZWN0S2V5cyhvYmopLmxlbmd0aF0gPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmogPSBwYXJlbnRba2V5XSA9IFtwYXJlbnRba2V5XSwgdmFsXTtcbiAgICAgIH1cbiAgICAgIC8vIHByb3BcbiAgICB9IGVsc2UgaWYgKH5pbmRleE9mKHBhcnQsICddJykpIHtcbiAgICAgIHBhcnQgPSBwYXJ0LnN1YnN0cigwLCBwYXJ0Lmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKCFpc2ludC50ZXN0KHBhcnQpICYmIGlzQXJyYXkob2JqKSkgb2JqID0gcHJvbW90ZShwYXJlbnQsIGtleSk7XG4gICAgICBwYXJzZShwYXJ0cywgb2JqLCBwYXJ0LCB2YWwpO1xuICAgICAgLy8ga2V5XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghaXNpbnQudGVzdChwYXJ0KSAmJiBpc0FycmF5KG9iaikpIG9iaiA9IHByb21vdGUocGFyZW50LCBrZXkpO1xuICAgICAgcGFyc2UocGFydHMsIG9iaiwgcGFydCwgdmFsKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSBwYXJlbnQga2V5L3ZhbCBwYWlyLlxuICovXG5cbmZ1bmN0aW9uIG1lcmdlKHBhcmVudCwga2V5LCB2YWwpe1xuICBpZiAofmluZGV4T2Yoa2V5LCAnXScpKSB7XG4gICAgdmFyIHBhcnRzID0ga2V5LnNwbGl0KCdbJylcbiAgICAgICwgbGVuID0gcGFydHMubGVuZ3RoXG4gICAgICAsIGxhc3QgPSBsZW4gLSAxO1xuICAgIHBhcnNlKHBhcnRzLCBwYXJlbnQsICdiYXNlJywgdmFsKTtcbiAgICAvLyBvcHRpbWl6ZVxuICB9IGVsc2Uge1xuICAgIGlmICghaXNpbnQudGVzdChrZXkpICYmIGlzQXJyYXkocGFyZW50LmJhc2UpKSB7XG4gICAgICB2YXIgdCA9IHt9O1xuICAgICAgZm9yICh2YXIgayBpbiBwYXJlbnQuYmFzZSkgdFtrXSA9IHBhcmVudC5iYXNlW2tdO1xuICAgICAgcGFyZW50LmJhc2UgPSB0O1xuICAgIH1cbiAgICBzZXQocGFyZW50LmJhc2UsIGtleSwgdmFsKTtcbiAgfVxuXG4gIHJldHVybiBwYXJlbnQ7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIG9iai5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU9iamVjdChvYmope1xuICB2YXIgcmV0ID0geyBiYXNlOiB7fSB9O1xuICBmb3JFYWNoKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24obmFtZSl7XG4gICAgbWVyZ2UocmV0LCBuYW1lLCBvYmpbbmFtZV0pO1xuICB9KTtcbiAgcmV0dXJuIHJldC5iYXNlO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBzdHIuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyKXtcbiAgcmV0dXJuIHJlZHVjZShTdHJpbmcoc3RyKS5zcGxpdCgnJicpLCBmdW5jdGlvbihyZXQsIHBhaXIpe1xuICAgIHZhciBlcWwgPSBpbmRleE9mKHBhaXIsICc9JylcbiAgICAgICwgYnJhY2UgPSBsYXN0QnJhY2VJbktleShwYWlyKVxuICAgICAgLCBrZXkgPSBwYWlyLnN1YnN0cigwLCBicmFjZSB8fCBlcWwpXG4gICAgICAsIHZhbCA9IHBhaXIuc3Vic3RyKGJyYWNlIHx8IGVxbCwgcGFpci5sZW5ndGgpXG4gICAgICAsIHZhbCA9IHZhbC5zdWJzdHIoaW5kZXhPZih2YWwsICc9JykgKyAxLCB2YWwubGVuZ3RoKTtcblxuICAgIC8vID9mb29cbiAgICBpZiAoJycgPT0ga2V5KSBrZXkgPSBwYWlyLCB2YWwgPSAnJztcbiAgICBpZiAoJycgPT0ga2V5KSByZXR1cm4gcmV0O1xuXG4gICAgcmV0dXJuIG1lcmdlKHJldCwgZGVjb2RlKGtleSksIGRlY29kZSh2YWwpKTtcbiAgfSwgeyBiYXNlOiB7fSB9KS5iYXNlO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBxdWVyeSBgc3RyYCBvciBgb2JqYCwgcmV0dXJuaW5nIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHwge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbihzdHIpe1xuICBpZiAobnVsbCA9PSBzdHIgfHwgJycgPT0gc3RyKSByZXR1cm4ge307XG4gIHJldHVybiAnb2JqZWN0JyA9PSB0eXBlb2Ygc3RyXG4gICAgPyBwYXJzZU9iamVjdChzdHIpXG4gICAgOiBwYXJzZVN0cmluZyhzdHIpO1xufTtcblxuLyoqXG4gKiBUdXJuIHRoZSBnaXZlbiBgb2JqYCBpbnRvIGEgcXVlcnkgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG52YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbihvYmosIHByZWZpeCkge1xuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KG9iaiwgcHJlZml4KTtcbiAgfSBlbHNlIGlmICgnW29iamVjdCBPYmplY3RdJyA9PSB0b1N0cmluZy5jYWxsKG9iaikpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KG9iaiwgcHJlZml4KTtcbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVN0cmluZyhvYmosIHByZWZpeCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZWZpeCArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcob2JqKSk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHJpbmcoc3RyLCBwcmVmaXgpIHtcbiAgaWYgKCFwcmVmaXgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ2lmeSBleHBlY3RzIGFuIG9iamVjdCcpO1xuICByZXR1cm4gcHJlZml4ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cik7XG59XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBnaXZlbiBgYXJyYC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5KGFyciwgcHJlZml4KSB7XG4gIHZhciByZXQgPSBbXTtcbiAgaWYgKCFwcmVmaXgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ2lmeSBleHBlY3RzIGFuIG9iamVjdCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIHJldC5wdXNoKHN0cmluZ2lmeShhcnJbaV0sIHByZWZpeCArICdbJyArIGkgKyAnXScpKTtcbiAgfVxuICByZXR1cm4gcmV0LmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBTdHJpbmdpZnkgdGhlIGdpdmVuIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdChvYmosIHByZWZpeCkge1xuICB2YXIgcmV0ID0gW11cbiAgICAsIGtleXMgPSBvYmplY3RLZXlzKG9iailcbiAgICAsIGtleTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgaWYgKG51bGwgPT0gb2JqW2tleV0pIHtcbiAgICAgIHJldC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0LnB1c2goc3RyaW5naWZ5KG9ialtrZXldLCBwcmVmaXhcbiAgICAgICAgPyBwcmVmaXggKyAnWycgKyBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICddJ1xuICAgICAgICA6IGVuY29kZVVSSUNvbXBvbmVudChrZXkpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldC5qb2luKCcmJyk7XG59XG5cbi8qKlxuICogU2V0IGBvYmpgJ3MgYGtleWAgdG8gYHZhbGAgcmVzcGVjdGluZ1xuICogdGhlIHdlaXJkIGFuZCB3b25kZXJmdWwgc3ludGF4IG9mIGEgcXMsXG4gKiB3aGVyZSBcImZvbz1iYXImZm9vPWJhelwiIGJlY29tZXMgYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2V0KG9iaiwga2V5LCB2YWwpIHtcbiAgdmFyIHYgPSBvYmpba2V5XTtcbiAgaWYgKHVuZGVmaW5lZCA9PT0gdikge1xuICAgIG9ialtrZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodikpIHtcbiAgICB2LnB1c2godmFsKTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IFt2LCB2YWxdO1xuICB9XG59XG5cbi8qKlxuICogTG9jYXRlIGxhc3QgYnJhY2UgaW4gYHN0cmAgd2l0aGluIHRoZSBrZXkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbGFzdEJyYWNlSW5LZXkoc3RyKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoXG4gICAgLCBicmFjZVxuICAgICwgYztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGMgPSBzdHJbaV07XG4gICAgaWYgKCddJyA9PSBjKSBicmFjZSA9IGZhbHNlO1xuICAgIGlmICgnWycgPT0gYykgYnJhY2UgPSB0cnVlO1xuICAgIGlmICgnPScgPT0gYyAmJiAhYnJhY2UpIHJldHVybiBpO1xuICB9XG59XG5cbi8qKlxuICogRGVjb2RlIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0ci5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cbiIsInZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuXG52YXIgaHR0cHMgPSBtb2R1bGUuZXhwb3J0cztcblxuZm9yICh2YXIga2V5IGluIGh0dHApIHtcbiAgICBpZiAoaHR0cC5oYXNPd25Qcm9wZXJ0eShrZXkpKSBodHRwc1trZXldID0gaHR0cFtrZXldO1xufTtcblxuaHR0cHMucmVxdWVzdCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNiKSB7XG4gICAgaWYgKCFwYXJhbXMpIHBhcmFtcyA9IHt9O1xuICAgIHBhcmFtcy5zY2hlbWUgPSAnaHR0cHMnO1xuICAgIHJldHVybiBodHRwLnJlcXVlc3QuY2FsbCh0aGlzLCBwYXJhbXMsIGNiKTtcbn0iLCIvLyB0b2RvXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGV2LnNvdXJjZSA9PT0gd2luZG93ICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiIsIihmdW5jdGlvbihwcm9jZXNzKXtpZiAoIXByb2Nlc3MuRXZlbnRFbWl0dGVyKSBwcm9jZXNzLkV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgRXZlbnRFbWl0dGVyID0gZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBwcm9jZXNzLkV2ZW50RW1pdHRlcjtcbnZhciBpc0FycmF5ID0gdHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbidcbiAgICA/IEFycmF5LmlzQXJyYXlcbiAgICA6IGZ1bmN0aW9uICh4cykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIH1cbjtcbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHJldHVybiB4cy5pbmRleE9mKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHggPT09IHhzW2ldKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuXG4vLyAxMCBsaXN0ZW5lcnMgYXJlIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2hcbi8vIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuLy9cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcbiAgdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyA9IG47XG59O1xuXG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzQXJyYXkodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpXG4gICAge1xuICAgICAgaWYgKGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGFyZ3VtZW50c1sxXTsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuY2F1Z2h0LCB1bnNwZWNpZmllZCAnZXJyb3InIGV2ZW50LlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIGZhbHNlO1xuICB2YXIgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgaWYgKCFoYW5kbGVyKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09ICdmdW5jdGlvbicpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gRXZlbnRFbWl0dGVyIGlzIGRlZmluZWQgaW4gc3JjL25vZGVfZXZlbnRzLmNjXG4vLyBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQoKSBpcyBhbHNvIGRlZmluZWQgdGhlcmUuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBsaXN0ZW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcignYWRkTGlzdGVuZXIgb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09IFwibmV3TGlzdGVuZXJzXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyc1wiLlxuICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgICAgdmFyIG07XG4gICAgICBpZiAodGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG0gPSB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbSA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLm9uKHR5cGUsIGZ1bmN0aW9uIGcoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcbiAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGxpc3RlbmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pIHJldHVybiB0aGlzO1xuXG4gIHZhciBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0FycmF5KGxpc3QpKSB7XG4gICAgdmFyIGkgPSBpbmRleE9mKGxpc3QsIGxpc3RlbmVyKTtcbiAgICBpZiAoaSA8IDApIHJldHVybiB0aGlzO1xuICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PSAwKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfSBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0gPT09IGxpc3RlbmVyKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBkb2VzIG5vdCB1c2UgbGlzdGVuZXJzKCksIHNvIG5vIHNpZGUgZWZmZWN0IG9mIGNyZWF0aW5nIF9ldmVudHNbdHlwZV1cbiAgaWYgKHR5cGUgJiYgdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gbnVsbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gW107XG4gIGlmICghaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2V2ZW50c1t0eXBlXTtcbn07XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSkiLCJ2YXIgaHR0cCA9IG1vZHVsZS5leHBvcnRzO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBSZXF1ZXN0ID0gcmVxdWlyZSgnLi9saWIvcmVxdWVzdCcpO1xuXG5odHRwLnJlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgIGlmICghcGFyYW1zKSBwYXJhbXMgPSB7fTtcbiAgICBpZiAoIXBhcmFtcy5ob3N0KSBwYXJhbXMuaG9zdCA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0LnNwbGl0KCc6JylbMF07XG4gICAgaWYgKCFwYXJhbXMucG9ydCkgcGFyYW1zLnBvcnQgPSB3aW5kb3cubG9jYXRpb24ucG9ydDtcbiAgICBpZiAoIXBhcmFtcy5zY2hlbWUpIHBhcmFtcy5zY2hlbWUgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuc3BsaXQoJzonKVswXTtcbiAgICBcbiAgICB2YXIgcmVxID0gbmV3IFJlcXVlc3QobmV3IHhockh0dHAsIHBhcmFtcyk7XG4gICAgaWYgKGNiKSByZXEub24oJ3Jlc3BvbnNlJywgY2IpO1xuICAgIHJldHVybiByZXE7XG59O1xuXG5odHRwLmdldCA9IGZ1bmN0aW9uIChwYXJhbXMsIGNiKSB7XG4gICAgcGFyYW1zLm1ldGhvZCA9ICdHRVQnO1xuICAgIHZhciByZXEgPSBodHRwLnJlcXVlc3QocGFyYW1zLCBjYik7XG4gICAgcmVxLmVuZCgpO1xuICAgIHJldHVybiByZXE7XG59O1xuXG5odHRwLkFnZW50ID0gZnVuY3Rpb24gKCkge307XG5odHRwLkFnZW50LmRlZmF1bHRNYXhTb2NrZXRzID0gNDtcblxudmFyIHhockh0dHAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHdpbmRvdyBvYmplY3QgcHJlc2VudCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh3aW5kb3cuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5YTUxIdHRwUmVxdWVzdDtcbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93LkFjdGl2ZVhPYmplY3QpIHtcbiAgICAgICAgdmFyIGF4cyA9IFtcbiAgICAgICAgICAgICdNc3htbDIuWE1MSFRUUC42LjAnLFxuICAgICAgICAgICAgJ01zeG1sMi5YTUxIVFRQLjMuMCcsXG4gICAgICAgICAgICAnTWljcm9zb2Z0LlhNTEhUVFAnXG4gICAgICAgIF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBheCA9IG5ldyh3aW5kb3cuQWN0aXZlWE9iamVjdCkoYXhzW2ldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheF8gPSBheDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBheF87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3KHdpbmRvdy5BY3RpdmVYT2JqZWN0KShheHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWpheCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FqYXggbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICB9XG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7dmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxudmFyIHNoYSA9IHJlcXVpcmUoJy4vc2hhJylcbnZhciBybmcgPSByZXF1aXJlKCcuL3JuZycpXG52YXIgbWQ1ID0gcmVxdWlyZSgnLi9tZDUnKVxuXG52YXIgYWxnb3JpdGhtcyA9IHtcbiAgc2hhMToge1xuICAgIGhleDogc2hhLmhleF9zaGExLFxuICAgIGJpbmFyeTogc2hhLmI2NF9zaGExLFxuICAgIGFzY2lpOiBzaGEuc3RyX3NoYTFcbiAgfSxcbiAgbWQ1OiB7XG4gICAgaGV4OiBtZDUuaGV4X21kNSxcbiAgICBiaW5hcnk6IG1kNS5iNjRfbWQ1LFxuICAgIGFzY2lpOiBtZDUuYW55X21kNVxuICB9XG59XG5cbmZ1bmN0aW9uIGVycm9yICgpIHtcbiAgdmFyIG0gPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbignICcpXG4gIHRocm93IG5ldyBFcnJvcihbXG4gICAgbSxcbiAgICAnd2UgYWNjZXB0IHB1bGwgcmVxdWVzdHMnLFxuICAgICdodHRwOi8vZ2l0aHViLmNvbS9kb21pbmljdGFyci9jcnlwdG8tYnJvd3NlcmlmeSdcbiAgICBdLmpvaW4oJ1xcbicpKVxufVxuXG5leHBvcnRzLmNyZWF0ZUhhc2ggPSBmdW5jdGlvbiAoYWxnKSB7XG4gIGFsZyA9IGFsZyB8fCAnc2hhMSdcbiAgaWYoIWFsZ29yaXRobXNbYWxnXSlcbiAgICBlcnJvcignYWxnb3JpdGhtOicsIGFsZywgJ2lzIG5vdCB5ZXQgc3VwcG9ydGVkJylcbiAgdmFyIHMgPSAnJ1xuICB2YXIgX2FsZyA9IGFsZ29yaXRobXNbYWxnXVxuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHMgKz0gZGF0YVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIGRpZ2VzdDogZnVuY3Rpb24gKGVuYykge1xuICAgICAgZW5jID0gZW5jIHx8ICdiaW5hcnknXG4gICAgICB2YXIgZm5cbiAgICAgIGlmKCEoZm4gPSBfYWxnW2VuY10pKVxuICAgICAgICBlcnJvcignZW5jb2Rpbmc6JywgZW5jICwgJ2lzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBhbGdvcml0aG0nLCBhbGcpXG4gICAgICB2YXIgciA9IGZuKHMpXG4gICAgICBzID0gbnVsbCAvL25vdCBtZWFudCB0byB1c2UgdGhlIGhhc2ggYWZ0ZXIgeW91J3ZlIGNhbGxlZCBkaWdlc3QuXG4gICAgICByZXR1cm4gclxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24oc2l6ZSwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwpIHtcbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCB1bmRlZmluZWQsIG5ldyBCdWZmZXIocm5nKHNpemUpKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7IGNhbGxiYWNrKGVycik7IH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihybmcoc2l6ZSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVhY2goYSwgZikge1xuICBmb3IodmFyIGkgaW4gYSlcbiAgICBmKGFbaV0sIGkpXG59XG5cbi8vIHRoZSBsZWFzdCBJIGNhbiBkbyBpcyBtYWtlIGVycm9yIG1lc3NhZ2VzIGZvciB0aGUgcmVzdCBvZiB0aGUgbm9kZS5qcy9jcnlwdG8gYXBpLlxuZWFjaChbJ2NyZWF0ZUNyZWRlbnRpYWxzJ1xuLCAnY3JlYXRlSG1hYydcbiwgJ2NyZWF0ZUN5cGhlcidcbiwgJ2NyZWF0ZUN5cGhlcml2J1xuLCAnY3JlYXRlRGVjaXBoZXInXG4sICdjcmVhdGVEZWNpcGhlcml2J1xuLCAnY3JlYXRlU2lnbidcbiwgJ2NyZWF0ZVZlcmlmeSdcbiwgJ2NyZWF0ZURlZmZpZUhlbGxtYW4nXG4sICdwYmtkZjInXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgZXhwb3J0c1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBlcnJvcignc29ycnksJywgbmFtZSwgJ2lzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKVxuICB9XG59KVxuXG59KSgpIiwidHJ5IHtcbiAgICB2YXIgU3RyaW5nUHJlcCA9IHJlcXVpcmUoJ25vZGUtc3RyaW5ncHJlcCcpLlN0cmluZ1ByZXA7XG4gICAgdmFyIHRvVW5pY29kZSA9IHJlcXVpcmUoJ25vZGUtc3RyaW5ncHJlcCcpLnRvVW5pY29kZTtcbiAgICB2YXIgYyA9IGZ1bmN0aW9uKG4pIHtcblx0dmFyIHAgPSBuZXcgU3RyaW5nUHJlcChuKTtcblx0cmV0dXJuIGZ1bmN0aW9uKHMpIHtcblx0ICAgIHJldHVybiBwLnByZXBhcmUocyk7XG5cdH07XG4gICAgfTtcbiAgICB2YXIgbmFtZXByZXAgPSBjKCduYW1lcHJlcCcpO1xuICAgIHZhciBub2RlcHJlcCA9IGMoJ25vZGVwcmVwJyk7XG4gICAgdmFyIHJlc291cmNlcHJlcCA9IGMoJ3Jlc291cmNlcHJlcCcpO1xufSBjYXRjaChleCkge1xuICAgIGNvbnNvbGUud2FybihcIkNhbm5vdCBsb2FkIFN0cmluZ1ByZXAtMC4xLjAgYmluZGluZ3MuIFlvdSBtYXkgbmVlZCB0byBgbnBtIGluc3RhbGwgbm9kZS1zdHJpbmdwcmVwJ1wiKTtcbiAgICB2YXIgaWRlbnRpdHkgPSBmdW5jdGlvbihhKSB7IHJldHVybiBhOyB9O1xuICAgIHZhciB0b0xvd2VyID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gYS50b0xvd2VyQ2FzZSgpOyB9O1xuICAgIHZhciB0b1VuaWNvZGUgPSBpZGVudGl0eTtcbiAgICB2YXIgbmFtZXByZXAgPSB0b0xvd2VyO1xuICAgIHZhciBub2RlcHJlcCA9IHRvTG93ZXI7XG4gICAgdmFyIHJlc291cmNlcHJlcCA9IGlkZW50aXR5O1xufVxuXG5mdW5jdGlvbiBKSUQoYSwgYiwgYykge1xuICAgIGlmIChhICYmIGIgPT0gbnVsbCAmJiBjID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5wYXJzZUpJRChhKTtcbiAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgICAgdGhpcy5zZXRVc2VyKGEpO1xuICAgICAgICB0aGlzLnNldERvbWFpbihiKTtcbiAgICAgICAgdGhpcy5zZXRSZXNvdXJjZShjKTtcbiAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCBlcnJvcicpO1xufVxuXG5KSUQucHJvdG90eXBlLnBhcnNlSklEID0gZnVuY3Rpb24ocykge1xuICAgIGlmIChzLmluZGV4T2YoJ0AnKSA+PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0VXNlcihzLnN1YnN0cigwLCBzLmluZGV4T2YoJ0AnKSkpO1xuICAgICAgICBzID0gcy5zdWJzdHIocy5pbmRleE9mKCdAJykgKyAxKTtcbiAgICB9XG4gICAgaWYgKHMuaW5kZXhPZignLycpID49IDApIHtcbiAgICAgICAgdGhpcy5zZXRSZXNvdXJjZShzLnN1YnN0cihzLmluZGV4T2YoJy8nKSArIDEpKTtcbiAgICAgICAgcyA9IHMuc3Vic3RyKDAsIHMuaW5kZXhPZignLycpKTtcbiAgICB9XG4gICAgdGhpcy5zZXREb21haW4ocyk7XG59O1xuXG5KSUQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHMgPSB0aGlzLmRvbWFpbjtcbiAgICBpZiAodGhpcy51c2VyKVxuICAgICAgICBzID0gdGhpcy51c2VyICsgJ0AnICsgcztcbiAgICBpZiAodGhpcy5yZXNvdXJjZSlcbiAgICAgICAgcyA9IHMgKyAnLycgKyB0aGlzLnJlc291cmNlO1xuICAgIHJldHVybiBzO1xufTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gZGlzdGluZ3Vpc2ggdXNlcnNcbiAqKi9cbkpJRC5wcm90b3R5cGUuYmFyZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnJlc291cmNlKVxuICAgICAgICByZXR1cm4gbmV3IEpJRCh0aGlzLnVzZXIsIHRoaXMuZG9tYWluLCBudWxsKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb21wYXJpc29uIGZ1bmN0aW9uXG4gKiovXG5KSUQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlciA9PSBvdGhlci51c2VyICYmXG4gICAgICAgIHRoaXMuZG9tYWluID09IG90aGVyLmRvbWFpbiAmJlxuICAgICAgICB0aGlzLnJlc291cmNlID09IG90aGVyLnJlc291cmNlO1xufTtcblxuLyoqXG4gKiBTZXR0ZXJzIHRoYXQgZG8gc3RyaW5ncHJlcCBub3JtYWxpemF0aW9uLlxuICoqL1xuSklELnByb3RvdHlwZS5zZXRVc2VyID0gZnVuY3Rpb24odXNlcikge1xuICAgIHRoaXMudXNlciA9IHVzZXIgJiYgbm9kZXByZXAodXNlcik7XG59O1xuLyoqXG4gKiBodHRwOi8veG1wcC5vcmcvcmZjcy9yZmM2MTIyLmh0bWwjYWRkcmVzc2luZy1kb21haW5cbiAqL1xuSklELnByb3RvdHlwZS5zZXREb21haW4gPSBmdW5jdGlvbihkb21haW4pIHtcbiAgICB0aGlzLmRvbWFpbiA9IGRvbWFpbiAmJlxuICAgICAgICBuYW1lcHJlcChkb21haW4uc3BsaXQoXCIuXCIpLlxuICAgICAgICAgICAgICAgICBtYXAodG9Vbmljb2RlKS5cbiAgICAgICAgICAgICAgICAgam9pbihcIi5cIikpO1xufTtcbkpJRC5wcm90b3R5cGUuc2V0UmVzb3VyY2UgPSBmdW5jdGlvbihyZXNvdXJjZSkge1xuICAgIHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZSAmJiByZXNvdXJjZXByZXAocmVzb3VyY2UpO1xufTtcblxuaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiICYmIGV4cG9ydHMgIT09IG51bGwpIHtcbiAgZXhwb3J0cy5KSUQgPSBKSUQ7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9PSBudWxsKSB7XG4gIHdpbmRvdy5KSUQgPSBKSUQ7XG59XG4iLCIoZnVuY3Rpb24oKXsvLyBVVElMSVRZXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmZ1bmN0aW9uIG9iamVjdEtleXMob2JqZWN0KSB7XG4gIGlmIChPYmplY3Qua2V5cykgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgbmFtZSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5hbWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyAxLiBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG5cbi8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC5cbi8vIG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KVxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICB2YXIgc3RhY2tTdGFydEZ1bmN0aW9uID0gb3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb24gfHwgZmFpbDtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9XG59O1xudXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAnJyArIHZhbHVlO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh0eXBlb2YgcyA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm1lc3NhZ2UpIHtcbiAgICByZXR1cm4gW3RoaXMubmFtZSArICc6JywgdGhpcy5tZXNzYWdlXS5qb2luKCcgJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMubmFtZSArICc6JyxcbiAgICAgIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHRoaXMuYWN0dWFsLCByZXBsYWNlciksIDEyOCksXG4gICAgICB0aGlzLm9wZXJhdG9yLFxuICAgICAgdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkodGhpcy5leHBlY3RlZCwgcmVwbGFjZXIpLCAxMjgpXG4gICAgXS5qb2luKCcgJyk7XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG5cbmFzc2VydC5Bc3NlcnRpb25FcnJvci5fX3Byb3RvX18gPSBFcnJvci5wcm90b3R5cGU7XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCBndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCEhIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcEVxdWFsJywgYXNzZXJ0LmRlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihhY3R1YWwpICYmIEJ1ZmZlci5pc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICBpZiAoYWN0dWFsLmxlbmd0aCAhPSBleHBlY3RlZC5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0dWFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWN0dWFsW2ldICE9PSBleHBlY3RlZFtpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBEYXRlICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zLiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKHR5cGVvZiBhY3R1YWwgIT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkICE9ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyA3LjQuIEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIpIHtcbiAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsKGEpIHx8IGlzVW5kZWZpbmVkT3JOdWxsKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYik7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAgICBrYiA9IG9iamVjdEtleXMoYiksXG4gICAgICAgIGtleSwgaTtcbiAgfSBjYXRjaCAoZSkgey8vaGFwcGVucyB3aGVuIG9uZSBpcyBhIHN0cmluZyBsaXRlcmFsIGFuZCB0aGUgb3RoZXIgaXNuJ3RcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChleHBlY3RlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csIGJsb2NrLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsO1xuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGFjdHVhbCA9IGU7XG4gIH1cblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKCdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICghc2hvdWxkVGhyb3cgJiYgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKCdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW3RydWVdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cy5hcHBseSh0aGlzLCBbZmFsc2VdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB7dGhyb3cgZXJyO319O1xuXG59KSgpIiwicmVxdWlyZT0oZnVuY3Rpb24oZSx0LG4scil7ZnVuY3Rpb24gaShyKXtpZighbltyXSl7aWYoIXRbcl0pe2lmKGUpcmV0dXJuIGUocik7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIityK1wiJ1wiKX12YXIgcz1uW3JdPXtleHBvcnRzOnt9fTt0W3JdWzBdKGZ1bmN0aW9uKGUpe3ZhciBuPXRbcl1bMV1bZV07cmV0dXJuIGkobj9uOmUpfSxzLHMuZXhwb3J0cyl9cmV0dXJuIG5bcl0uZXhwb3J0c31mb3IodmFyIHM9MDtzPHIubGVuZ3RoO3MrKylpKHJbc10pO3JldHVybiBpfSkodHlwZW9mIHJlcXVpcmUhPT1cInVuZGVmaW5lZFwiJiZyZXF1aXJlLHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmV4cG9ydHMucmVhZElFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNCRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNCRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNCRSA/IDEgOiAtMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlSUVFRTc1NCA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0JFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0JFID8gLTEgOiAxLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG5cbn0se31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCl7Ly8gVVRJTElUWVxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5mdW5jdGlvbiBvYmplY3RLZXlzKG9iamVjdCkge1xuICBpZiAoT2JqZWN0LmtleXMpIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIG5hbWUpKSB7XG4gICAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfVxufTtcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodHlwZW9mIHMgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5tZXNzYWdlKSB7XG4gICAgcmV0dXJuIFt0aGlzLm5hbWUgKyAnOicsIHRoaXMubWVzc2FnZV0uam9pbignICcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXG4gICAgICB0aGlzLm5hbWUgKyAnOicsXG4gICAgICB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeSh0aGlzLmFjdHVhbCwgcmVwbGFjZXIpLCAxMjgpLFxuICAgICAgdGhpcy5vcGVyYXRvcixcbiAgICAgIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHRoaXMuZXhwZWN0ZWQsIHJlcGxhY2VyKSwgMTI4KVxuICAgIF0uam9pbignICcpO1xuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IuX19wcm90b19fID0gRXJyb3IucHJvdG90eXBlO1xuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghISF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYWN0dWFsKSAmJiBCdWZmZXIuaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgaWYgKGFjdHVhbC5sZW5ndGggIT0gZXhwZWN0ZWQubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdHVhbC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFjdHVhbFtpXSAhPT0gZXhwZWN0ZWRbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICh0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiKSB7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIpO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpLFxuICAgICAgICBrZXksIGk7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBhY3R1YWwgPSBlO1xuICB9XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbCgnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoIXNob3VsZFRocm93ICYmIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbCgnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFt0cnVlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW2ZhbHNlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikge3Rocm93IGVycjt9fTtcblxufSkoKVxufSx7XCJ1dGlsXCI6MyxcImJ1ZmZlclwiOjR9XSxcImJ1ZmZlci1icm93c2VyaWZ5XCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHM9cmVxdWlyZSgncTlUeENDJyk7XG59LHt9XSxcInE5VHhDQ1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpe2Z1bmN0aW9uIFNsb3dCdWZmZXIgKHNpemUpIHtcbiAgICB0aGlzLmxlbmd0aCA9IHNpemU7XG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MDtcblxuXG5mdW5jdGlvbiB0b0hleChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSkgPD0gMHg3RilcbiAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5jaGFyQXQoaSkpLnN1YnN0cigxKS5zcGxpdCgnJScpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKVxuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpO1xuICAgIH1cblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyApXG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goIHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRiApO1xuXG4gIHJldHVybiBieXRlQXJyYXk7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoc3RyKSB7XG4gIHJldHVybiByZXF1aXJlKFwiYmFzZTY0LWpzXCIpLnRvQnl0ZUFycmF5KHN0cik7XG59XG5cblNsb3dCdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgXCJ1dGY4XCIpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHN0ci5sZW5ndGggLyAyO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gc3RyLmxlbmd0aDtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYmxpdEJ1ZmZlcihzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIHBvcywgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaWYgKChpK29mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrO1xuXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldO1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gaTtcbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSAgYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSAgYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgdGhpcywgb2Zmc2V0LCBsZW5ndGgpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuYmluYXJ5V3JpdGUgPSBTbG93QnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlO1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5iYXNlNjRXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJhc2U2NFNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgcmV0dXJuIHJlcXVpcmUoXCJiYXNlNjQtanNcIikuZnJvbUJ5dGVBcnJheShieXRlcyk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKTsgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdmFyIHJlcyA9IFwiXCI7XG4gIHZhciB0bXAgPSBcIlwiO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVzW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgICB0bXAgPSBcIlwiO1xuICAgIH0gZWxzZVxuICAgICAgdG1wICs9IFwiJVwiICsgYnl0ZXNbaV0udG9TdHJpbmcoMTYpO1xuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcCk7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB2YXIgcmV0ID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gIHJldHVybiByZXQ7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJpbmFyeVNsaWNlID0gU2xvd0J1ZmZlci5wcm90b3R5cGUuYXNjaWlTbGljZTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW10sXG4gICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pO1xuICAgIGlmIChpID09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxTbG93QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nO1xufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5oZXhTbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW47XG5cbiAgdmFyIG91dCA9ICcnO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleCh0aGlzW2ldKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcbiAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgaWYgKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGVuZ3RoO1xuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKCtlbmQgPT0gc3RhcnQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiB0aGlzLmhleFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHRoaXMudXRmOFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0dXJuIHRoaXMuYXNjaWlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdGhpcy5iaW5hcnlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gdGhpcy5iYXNlNjRTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIHJldHVybiB0aGlzLnVjczJTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5oZXhXcml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuICBpZiAoc3RyTGVuICUgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgaWYgKGlzTmFOKGJ5dGUpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpO1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSBieXRlO1xuICB9XG4gIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGkgKiAyO1xuICByZXR1cm4gaTtcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSBzd2FwO1xuICB9XG5cbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gdGhpcy5oZXhXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnV0ZjhXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLmFzY2lpV3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy51Y3MyV3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcblNsb3dCdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIGVuZCA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIH1cbiAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQnVmZmVyKHRoaXMsIGVuZCAtIHN0YXJ0LCArc3RhcnQpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKHRhcmdldCwgdGFyZ2V0c3RhcnQsIHNvdXJjZXN0YXJ0LCBzb3VyY2VlbmQpIHtcbiAgdmFyIHRlbXAgPSBbXTtcbiAgZm9yICh2YXIgaT1zb3VyY2VzdGFydDsgaTxzb3VyY2VlbmQ7IGkrKykge1xuICAgIGFzc2VydC5vayh0eXBlb2YgdGhpc1tpXSAhPT0gJ3VuZGVmaW5lZCcsIFwiY29weWluZyB1bmRlZmluZWQgYnVmZmVyIGJ5dGVzIVwiKTtcbiAgICB0ZW1wLnB1c2godGhpc1tpXSk7XG4gIH1cblxuICBmb3IgKHZhciBpPXRhcmdldHN0YXJ0OyBpPHRhcmdldHN0YXJ0K3RlbXAubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRbaV0gPSB0ZW1wW2ktdGFyZ2V0c3RhcnRdO1xuICB9XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24odmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICB0aGlzW2ldID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29lcmNlKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpO1xuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGg7XG59XG5cblxuLy8gQnVmZmVyXG5cbmZ1bmN0aW9uIEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgb2Zmc2V0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG9mZnNldCk7XG4gIH1cblxuICB2YXIgdHlwZTtcblxuICAvLyBBcmUgd2Ugc2xpY2luZz9cbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5sZW5ndGggPSBjb2VyY2UoZW5jb2RpbmcpO1xuICAgIHRoaXMucGFyZW50ID0gc3ViamVjdDtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgICBzd2l0Y2ggKHR5cGUgPSB0eXBlb2Ygc3ViamVjdCkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB0aGlzLmxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6IC8vIEFzc3VtZSBvYmplY3QgaXMgYW4gYXJyYXlcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJyYXkgb3Igc3RyaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IEJ1ZmZlci5wb29sU2l6ZSkge1xuICAgICAgLy8gQmlnIGJ1ZmZlciwganVzdCBhbGxvYyBvbmUuXG4gICAgICB0aGlzLnBhcmVudCA9IG5ldyBTbG93QnVmZmVyKHRoaXMubGVuZ3RoKTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTbWFsbCBidWZmZXIuXG4gICAgICBpZiAoIXBvb2wgfHwgcG9vbC5sZW5ndGggLSBwb29sLnVzZWQgPCB0aGlzLmxlbmd0aCkgYWxsb2NQb29sKCk7XG4gICAgICB0aGlzLnBhcmVudCA9IHBvb2w7XG4gICAgICB0aGlzLm9mZnNldCA9IHBvb2wudXNlZDtcbiAgICAgIHBvb2wudXNlZCArPSB0aGlzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXkuXG4gICAgaWYgKGlzQXJyYXlJc2goc3ViamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3ViamVjdCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgIHRoaXMucGFyZW50W2kgKyB0aGlzLm9mZnNldF0gPSBzdWJqZWN0LnJlYWRVSW50OChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhcmVudFtpICsgdGhpcy5vZmZzZXRdID0gc3ViamVjdFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgLy8gV2UgYXJlIGEgc3RyaW5nXG4gICAgICB0aGlzLmxlbmd0aCA9IHRoaXMud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpO1xuICAgIH1cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlJc2goc3ViamVjdCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInO1xufVxuXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyO1xuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXI7XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDggKiAxMDI0O1xudmFyIHBvb2w7XG5cbmZ1bmN0aW9uIGFsbG9jUG9vbCgpIHtcbiAgcG9vbCA9IG5ldyBTbG93QnVmZmVyKEJ1ZmZlci5wb29sU2l6ZSk7XG4gIHBvb2wudXNlZCA9IDA7XG59XG5cblxuLy8gU3RhdGljIG1ldGhvZHNcbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyKGIpIHtcbiAgcmV0dXJuIGIgaW5zdGFuY2VvZiBCdWZmZXIgfHwgYiBpbnN0YW5jZW9mIFNsb3dCdWZmZXI7XG59O1xuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3QsIFt0b3RhbExlbmd0aF0pXFxuIFxcXG4gICAgICBsaXN0IHNob3VsZCBiZSBhbiBBcnJheS5cIik7XG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKTtcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0b3RhbExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICB0b3RhbExlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYnVmID0gbGlzdFtpXTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpO1xuICB2YXIgcG9zID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpO1xuICAgIHBvcyArPSBidWYubGVuZ3RoO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59O1xuXG4vLyBJbnNwZWN0XG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICB2YXIgb3V0ID0gW10sXG4gICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpcy5wYXJlbnRbaSArIHRoaXMub2Zmc2V0XSk7XG4gICAgaWYgKGkgPT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nO1xufTtcblxuXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICByZXR1cm4gdGhpcy5wYXJlbnRbdGhpcy5vZmZzZXQgKyBpXTtcbn07XG5cblxuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQoaSwgdikge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgcmV0dXJuIHRoaXMucGFyZW50W3RoaXMub2Zmc2V0ICsgaV0gPSB2O1xufTtcblxuXG4vLyB3cml0ZShzdHJpbmcsIG9mZnNldCA9IDAsIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgtb2Zmc2V0LCBlbmNvZGluZyA9ICd1dGY4JylcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSBzd2FwO1xuICB9XG5cbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgdmFyIHJldDtcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC5oZXhXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC51dGY4V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYXNjaWlXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYmluYXJ5V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICByZXQgPSB0aGlzLnBhcmVudC5iYXNlNjRXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC51Y3MyV3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG5cbiAgQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW47XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cblxuLy8gdG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcblxuICBpZiAodHlwZW9mIHN0YXJ0ID09ICd1bmRlZmluZWQnIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMDtcbiAgfSBlbHNlIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH0gZWxzZSBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCA9IDA7XG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ICsgdGhpcy5vZmZzZXQ7XG4gIGVuZCA9IGVuZCArIHRoaXMub2Zmc2V0O1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmhleFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnV0ZjhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5hc2NpaVNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5iaW5hcnlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYmFzZTY0U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQudWNzMlNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5cbi8vIGJ5dGVMZW5ndGhcbkJ1ZmZlci5ieXRlTGVuZ3RoID0gU2xvd0J1ZmZlci5ieXRlTGVuZ3RoO1xuXG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICB2YWx1ZSB8fCAodmFsdWUgPSAwKTtcbiAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gIGVuZCB8fCAoZW5kID0gdGhpcy5sZW5ndGgpO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICB9XG4gIGlmICghKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHx8IGlzTmFOKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgaXMgbm90IGEgbnVtYmVyJyk7XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBFcnJvcignZW5kIDwgc3RhcnQnKTtcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICBpZiAodGhpcy5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5wYXJlbnQuZmlsbCh2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKyB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpcztcbiAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gIGVuZCB8fCAoZW5kID0gdGhpcy5sZW5ndGgpO1xuICB0YXJnZXRfc3RhcnQgfHwgKHRhcmdldF9zdGFydCA9IDApO1xuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpO1xuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDA7XG4gIGlmICh0YXJnZXQubGVuZ3RoID09IDAgfHwgc291cmNlLmxlbmd0aCA9PSAwKSByZXR1cm4gMDtcblxuICBpZiAodGFyZ2V0X3N0YXJ0IDwgMCB8fCB0YXJnZXRfc3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMucGFyZW50LmNvcHkodGFyZ2V0LnBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X3N0YXJ0ICsgdGFyZ2V0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKyB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBzbGljZShzdGFydCwgZW5kKVxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICBpZiAoc3RhcnQgPiBlbmQpIHRocm93IG5ldyBFcnJvcignb29iJyk7XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIodGhpcy5wYXJlbnQsIGVuZCAtIHN0YXJ0LCArc3RhcnQgKyB0aGlzLm9mZnNldCk7XG59O1xuXG5cbi8vIExlZ2FjeSBtZXRob2RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblxuQnVmZmVyLnByb3RvdHlwZS51dGY4U2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCd1dGY4Jywgc3RhcnQsIGVuZCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmJpbmFyeVNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygnYmluYXJ5Jywgc3RhcnQsIGVuZCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCdhc2NpaScsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCkge1xuICByZXR1cm4gdGhpcy53cml0ZShzdHJpbmcsIG9mZnNldCwgJ3V0ZjgnKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuYmluYXJ5V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCkge1xuICByZXR1cm4gdGhpcy53cml0ZShzdHJpbmcsIG9mZnNldCwgJ2JpbmFyeScpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICdhc2NpaScpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhciBidWZmZXIgPSB0aGlzO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHJldHVybiBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdO1xufTtcblxuZnVuY3Rpb24gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciB2YWwgPSAwO1xuXG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm4gMDtcblxuICBpZiAoaXNCaWdFbmRpYW4pIHtcbiAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDg7XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF07XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZFVJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciB2YWwgPSAwO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuIDA7XG5cbiAgaWYgKGlzQmlnRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgMTY7XG4gICAgaWYgKG9mZnNldCArIDIgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDJdIDw8IDg7XG4gICAgaWYgKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDNdO1xuICAgIHZhbCA9IHZhbCArIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDI0ID4+PiAwKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA8PCAxNjtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbiAgICBpZiAob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgPSB2YWwgKyAoYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFNpZ25lZCBpbnRlZ2VyIHR5cGVzLCB5YXkgdGVhbSEgQSByZW1pbmRlciBvbiBob3cgdHdvJ3MgY29tcGxlbWVudCBhY3R1YWxseVxuICogd29ya3MuIFRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ25lZCBiaXQsIGkuZS4gdGVsbHMgdXMgd2hldGhlciBvciBub3QgdGhlXG4gKiBudW1iZXIgc2hvdWxkIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLiBJZiB0aGUgdHdvJ3MgY29tcGxlbWVudCB2YWx1ZSBpc1xuICogcG9zaXRpdmUsIHRoZW4gd2UncmUgZG9uZSwgYXMgaXQncyBlcXVpdmFsZW50IHRvIHRoZSB1bnNpZ25lZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBOb3cgaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgeW91J3JlIHByZXR0eSBtdWNoIGRvbmUsIHlvdSBjYW4ganVzdCBsZXZlcmFnZVxuICogdGhlIHVuc2lnbmVkIHRyYW5zbGF0aW9ucyBhbmQgcmV0dXJuIHRob3NlLiBVbmZvcnR1bmF0ZWx5LCBuZWdhdGl2ZSBudW1iZXJzXG4gKiBhcmVuJ3QgcXVpdGUgdGhhdCBzdHJhaWdodGZvcndhcmQuXG4gKlxuICogQXQgZmlyc3QgZ2xhbmNlLCBvbmUgbWlnaHQgYmUgaW5jbGluZWQgdG8gdXNlIHRoZSB0cmFkaXRpb25hbCBmb3JtdWxhIHRvXG4gKiB0cmFuc2xhdGUgYmluYXJ5IG51bWJlcnMgYmV0d2VlbiB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcyBpbiB0d28nc1xuICogY29tcGxlbWVudC4gKFRob3VnaCBpdCBkb2Vzbid0IHF1aXRlIHdvcmsgZm9yIHRoZSBtb3N0IG5lZ2F0aXZlIHZhbHVlKVxuICogTWFpbmx5OlxuICogIC0gaW52ZXJ0IGFsbCB0aGUgYml0c1xuICogIC0gYWRkIG9uZSB0byB0aGUgcmVzdWx0XG4gKlxuICogT2YgY291cnNlLCB0aGlzIGRvZXNuJ3QgcXVpdGUgd29yayBpbiBKYXZhc2NyaXB0LiBUYWtlIGZvciBleGFtcGxlIHRoZSB2YWx1ZVxuICogb2YgLTEyOC4gVGhpcyBjb3VsZCBiZSByZXByZXNlbnRlZCBpbiAxNiBiaXRzIChiaWctZW5kaWFuKSBhcyAweGZmODAuIEJ1dCBvZlxuICogY291cnNlLCBKYXZhc2NyaXB0IHdpbGwgZG8gdGhlIGZvbGxvd2luZzpcbiAqXG4gKiA+IH4weGZmODBcbiAqIC02NTQwOVxuICpcbiAqIFdob2ggdGhlcmUsIEphdmFzY3JpcHQsIHRoYXQncyBub3QgcXVpdGUgcmlnaHQuIEJ1dCB3YWl0LCBhY2NvcmRpbmcgdG9cbiAqIEphdmFzY3JpcHQgdGhhdCdzIHBlcmZlY3RseSBjb3JyZWN0LiBXaGVuIEphdmFzY3JpcHQgZW5kcyB1cCBzZWVpbmcgdGhlXG4gKiBjb25zdGFudCAweGZmODAsIGl0IGhhcyBubyBub3Rpb24gdGhhdCBpdCBpcyBhY3R1YWxseSBhIHNpZ25lZCBudW1iZXIuIEl0XG4gKiBhc3N1bWVzIHRoYXQgd2UndmUgaW5wdXQgdGhlIHVuc2lnbmVkIHZhbHVlIDB4ZmY4MC4gVGh1cywgd2hlbiBpdCBkb2VzIHRoZVxuICogYmluYXJ5IG5lZ2F0aW9uLCBpdCBjYXN0cyBpdCBpbnRvIGEgc2lnbmVkIHZhbHVlLCAocG9zaXRpdmUgMHhmZjgwKS4gVGhlblxuICogd2hlbiB5b3UgcGVyZm9ybSBiaW5hcnkgbmVnYXRpb24gb24gdGhhdCwgaXQgdHVybnMgaXQgaW50byBhIG5lZ2F0aXZlIG51bWJlci5cbiAqXG4gKiBJbnN0ZWFkLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHVzZSB0aGUgZm9sbG93aW5nIGdlbmVyYWwgZm9ybXVsYSwgdGhhdCB3b3Jrc1xuICogaW4gYSByYXRoZXIgSmF2YXNjcmlwdCBmcmllbmRseSB3YXkuIEknbSBnbGFkIHdlIGRvbid0IHN1cHBvcnQgdGhpcyBraW5kIG9mXG4gKiB3ZWlyZCBudW1iZXJpbmcgc2NoZW1lIGluIHRoZSBrZXJuZWwuXG4gKlxuICogKEJJVC1NQVggLSAodW5zaWduZWQpdmFsICsgMSkgKiAtMVxuICpcbiAqIFRoZSBhc3R1dGUgb2JzZXJ2ZXIsIG1heSB0aGluayB0aGF0IHRoaXMgZG9lc24ndCBtYWtlIHNlbnNlIGZvciA4LWJpdCBudW1iZXJzXG4gKiAocmVhbGx5IGl0IGlzbid0IG5lY2Vzc2FyeSBmb3IgdGhlbSkuIEhvd2V2ZXIsIHdoZW4geW91IGdldCAxNi1iaXQgbnVtYmVycyxcbiAqIHlvdSBkby4gTGV0J3MgZ28gYmFjayB0byBvdXIgcHJpb3IgZXhhbXBsZSBhbmQgc2VlIGhvdyB0aGlzIHdpbGwgbG9vazpcbiAqXG4gKiAoMHhmZmZmIC0gMHhmZjgwICsgMSkgKiAtMVxuICogKDB4MDA3ZiArIDEpICogLTFcbiAqICgweDAwODApICogLTFcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG4gIHZhciBuZWc7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm47XG5cbiAgbmVnID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSAmIDB4ODA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdKTtcbiAgfVxuXG4gIHJldHVybiAoKDB4ZmYgLSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdICsgMSkgKiAtMSk7XG59O1xuXG5mdW5jdGlvbiByZWFkSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgbmVnLCB2YWw7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFsID0gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgbmVnID0gdmFsICYgMHg4MDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciBuZWcsIHZhbDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICB2YWwgPSByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICBuZWcgPSB2YWwgJiAweDgwMDAwMDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiAodmFsKTtcbiAgfVxuXG4gIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGbG9hdChidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDIzLCA0KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZERvdWJsZShidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyA3IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDUyLCA4KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0IGlzXG4gKiBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdCBleGNlZWQgdGhlXG4gKiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKlxuICogICAgICB2YWx1ZSAgICAgICAgICAgVGhlIG51bWJlciB0byBjaGVjayBmb3IgdmFsaWRpdHlcbiAqXG4gKiAgICAgIG1heCAgICAgICAgICAgICBUaGUgbWF4aW11bSB2YWx1ZVxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQodmFsdWUsIG1heCkge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSAwLFxuICAgICAgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKTtcblxuICBhc3NlcnQub2soTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSA9IHZhbHVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZik7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWluKGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQsIDIpOyBpKyspIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGlzQmlnRW5kaWFuID8gMSAtIGkgOiBpKSkpKSA+Pj5cbiAgICAgICAgICAgIChpc0JpZ0VuZGlhbiA/IDEgLSBpIDogaSkgKiA4O1xuICB9XG5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVUludDMyKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmZmZmZik7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWluKGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQsIDQpOyBpKyspIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSA+Pj4gKGlzQmlnRW5kaWFuID8gMyAtIGkgOiBpKSAqIDgpICYgMHhmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuXG4vKlxuICogV2Ugbm93IG1vdmUgb250byBvdXIgZnJpZW5kcyBpbiB0aGUgc2lnbmVkIG51bWJlciBjYXRlZ29yeS4gVW5saWtlIHVuc2lnbmVkXG4gKiBudW1iZXJzLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHdvcnJ5IGEgYml0IG1vcmUgYWJvdXQgaG93IHdlIHB1dCB2YWx1ZXMgaW50b1xuICogYXJyYXlzLiBTaW5jZSB3ZSBhcmUgb25seSB3b3JyeWluZyBhYm91dCBzaWduZWQgMzItYml0IHZhbHVlcywgd2UncmUgaW5cbiAqIHNsaWdodGx5IGJldHRlciBzaGFwZS4gVW5mb3J0dW5hdGVseSwgd2UgcmVhbGx5IGNhbid0IGRvIG91ciBmYXZvcml0ZSBiaW5hcnlcbiAqICYgaW4gdGhpcyBzeXN0ZW0uIEl0IHJlYWxseSBzZWVtcyB0byBkbyB0aGUgd3JvbmcgdGhpbmcuIEZvciBleGFtcGxlOlxuICpcbiAqID4gLTMyICYgMHhmZlxuICogMjI0XG4gKlxuICogV2hhdCdzIGhhcHBlbmluZyBhYm92ZSBpcyByZWFsbHk6IDB4ZTAgJiAweGZmID0gMHhlMC4gSG93ZXZlciwgdGhlIHJlc3VsdHMgb2ZcbiAqIHRoaXMgYXJlbid0IHRyZWF0ZWQgYXMgYSBzaWduZWQgbnVtYmVyLiBVbHRpbWF0ZWx5IGEgYmFkIHRoaW5nLlxuICpcbiAqIFdoYXQgd2UncmUgZ29pbmcgdG8gd2FudCB0byBkbyBpcyBiYXNpY2FsbHkgY3JlYXRlIHRoZSB1bnNpZ25lZCBlcXVpdmFsZW50IG9mXG4gKiBvdXIgcmVwcmVzZW50YXRpb24gYW5kIHBhc3MgdGhhdCBvZmYgdG8gdGhlIHd1aW50KiBmdW5jdGlvbnMuIFRvIGRvIHRoYXRcbiAqIHdlJ3JlIGdvaW5nIHRvIGRvIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogIC0gaWYgdGhlIHZhbHVlIGlzIHBvc2l0aXZlXG4gKiAgICAgIHdlIGNhbiBwYXNzIGl0IGRpcmVjdGx5IG9mZiB0byB0aGUgZXF1aXZhbGVudCB3dWludFxuICogIC0gaWYgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlXG4gKiAgICAgIHdlIGRvIHRoZSBmb2xsb3dpbmcgY29tcHV0YXRpb246XG4gKiAgICAgICAgIG1iICsgdmFsICsgMSwgd2hlcmVcbiAqICAgICAgICAgbWIgICBpcyB0aGUgbWF4aW11bSB1bnNpZ25lZCB2YWx1ZSBpbiB0aGF0IGJ5dGUgc2l6ZVxuICogICAgICAgICB2YWwgIGlzIHRoZSBKYXZhc2NyaXB0IG5lZ2F0aXZlIGludGVnZXJcbiAqXG4gKlxuICogQXMgYSBjb25jcmV0ZSB2YWx1ZSwgdGFrZSAtMTI4LiBJbiBzaWduZWQgMTYgYml0cyB0aGlzIHdvdWxkIGJlIDB4ZmY4MC4gSWZcbiAqIHlvdSBkbyBvdXQgdGhlIGNvbXB1dGF0aW9uczpcbiAqXG4gKiAweGZmZmYgLSAxMjggKyAxXG4gKiAweGZmZmYgLSAxMjdcbiAqIDB4ZmY4MFxuICpcbiAqIFlvdSBjYW4gdGhlbiBlbmNvZGUgdGhpcyB2YWx1ZSBhcyB0aGUgc2lnbmVkIHZlcnNpb24uIFRoaXMgaXMgcmVhbGx5IHJhdGhlclxuICogaGFja3ksIGJ1dCBpdCBzaG91bGQgd29yayBhbmQgZ2V0IHRoZSBqb2IgZG9uZSB3aGljaCBpcyBvdXIgZ29hbCBoZXJlLlxuICovXG5cbi8qXG4gKiBBIHNlcmllcyBvZiBjaGVja3MgdG8gbWFrZSBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgYSBzaWduZWQgMzItYml0IG51bWJlclxuICovXG5mdW5jdGlvbiB2ZXJpZnNpbnQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydC5vayh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJyxcbiAgICAgICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jyk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0Lm9rKHR5cGVvZiAodmFsdWUpID09ICdudW1iZXInLFxuICAgICAgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKTtcblxuICBhc3NlcnQub2sodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDB4ZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgd3JpdGVVSW50MTYoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlVUludDE2KGJ1ZmZlciwgMHhmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVJbnQzMihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgd3JpdGVVSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlVUludDMyKGJ1ZmZlciwgMHhmZmZmZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOCk7XG4gIH1cblxuICByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0Jykud3JpdGVJRUVFNzU0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICAyMywgNCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgNyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCk7XG4gIH1cblxuICByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0Jykud3JpdGVJRUVFNzU0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICA1MiwgOCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50ODtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRTtcblxufSkoKVxufSx7XCJhc3NlcnRcIjoyLFwiLi9idWZmZXJfaWVlZTc1NFwiOjEsXCJiYXNlNjQtanNcIjo1fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5leHBvcnRzLmlzRGF0ZSA9IGZ1bmN0aW9uKG9iail7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBEYXRlXSd9O1xuZXhwb3J0cy5pc1JlZ0V4cCA9IGZ1bmN0aW9uKG9iail7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBSZWdFeHBdJ307XG5cblxuZXhwb3J0cy5wcmludCA9IGZ1bmN0aW9uICgpIHt9O1xuZXhwb3J0cy5wdXRzID0gZnVuY3Rpb24gKCkge307XG5leHBvcnRzLmRlYnVnID0gZnVuY3Rpb24oKSB7fTtcblxuZXhwb3J0cy5pbnNwZWN0ID0gZnVuY3Rpb24ob2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKSB7XG4gIHZhciBzZWVuID0gW107XG5cbiAgdmFyIHN0eWxpemUgPSBmdW5jdGlvbihzdHIsIHN0eWxlVHlwZSkge1xuICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuICAgIHZhciBzdHlsZXMgPVxuICAgICAgICB7ICdib2xkJyA6IFsxLCAyMl0sXG4gICAgICAgICAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAgICAgICAgICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgICAgICAgICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAgICAgICAgICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgICAgICAgICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgICAgICAgICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICAgICAgICAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICAgICAgICAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICAgICAgICAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAgICAgICAgICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAgICAgICAgICdyZWQnIDogWzMxLCAzOV0sXG4gICAgICAgICAgJ3llbGxvdycgOiBbMzMsIDM5XSB9O1xuXG4gICAgdmFyIHN0eWxlID1cbiAgICAgICAgeyAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgICAgICAgICAnbnVtYmVyJzogJ2JsdWUnLFxuICAgICAgICAgICdib29sZWFuJzogJ3llbGxvdycsXG4gICAgICAgICAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgICAgICAgICAnbnVsbCc6ICdib2xkJyxcbiAgICAgICAgICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgICAgICAgICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgICAgICAgICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAgICAgICAgICdyZWdleHAnOiAncmVkJyB9W3N0eWxlVHlwZV07XG5cbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHJldHVybiAnXFwwMzNbJyArIHN0eWxlc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAgICdcXDAzM1snICsgc3R5bGVzW3N0eWxlXVsxXSArICdtJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH07XG4gIGlmICghIGNvbG9ycykge1xuICAgIHN0eWxpemUgPSBmdW5jdGlvbihzdHIsIHN0eWxlVHlwZSkgeyByZXR1cm4gc3RyOyB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0KHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gICAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pbnNwZWN0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgICB2YWx1ZSAhPT0gZXhwb3J0cyAmJlxuICAgICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzKTtcbiAgICB9XG5cbiAgICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgICAgICByZXR1cm4gc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcblxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgICB9XG4gICAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xuICAgIH1cblxuICAgIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgICB2YXIgdmlzaWJsZV9rZXlzID0gT2JqZWN0X2tleXModmFsdWUpO1xuICAgIHZhciBrZXlzID0gc2hvd0hpZGRlbiA/IE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKSA6IHZpc2libGVfa2V5cztcblxuICAgIC8vIEZ1bmN0aW9ucyB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ3JlZ2V4cCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERhdGVzIHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWRcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSAmJiBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHN0eWxpemUodmFsdWUudG9VVENTdHJpbmcoKSwgJ2RhdGUnKTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZSwgdHlwZSwgYnJhY2VzO1xuICAgIC8vIERldGVybWluZSB0aGUgb2JqZWN0IHR5cGVcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHR5cGUgPSAnQXJyYXknO1xuICAgICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9ICdPYmplY3QnO1xuICAgICAgYnJhY2VzID0gWyd7JywgJ30nXTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgYmFzZSA9IChpc1JlZ0V4cCh2YWx1ZSkpID8gJyAnICsgdmFsdWUgOiAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlID0gJyc7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIGJhc2UgPSAnICcgKyB2YWx1ZS50b1VUQ1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gICAgfVxuXG4gICAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ3JlZ2V4cCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWVuLnB1c2godmFsdWUpO1xuXG4gICAgdmFyIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIG5hbWUsIHN0cjtcbiAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cEdldHRlcl9fKSB7XG4gICAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cEdldHRlcl9fKGtleSkpIHtcbiAgICAgICAgICBpZiAodmFsdWUuX19sb29rdXBTZXR0ZXJfXyhrZXkpKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSBzdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cFNldHRlcl9fKGtleSkpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh2aXNpYmxlX2tleXMuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgICAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgaWYgKHNlZW4uaW5kZXhPZih2YWx1ZVtrZXldKSA8IDApIHtcbiAgICAgICAgICBpZiAocmVjdXJzZVRpbWVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgPSBmb3JtYXQodmFsdWVba2V5XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9IGZvcm1hdCh2YWx1ZVtrZXldLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnQXJyYXknICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgICAgIG5hbWUgPSBzdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgICAgICBuYW1lID0gc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xuICAgIH0pO1xuXG4gICAgc2Vlbi5wb3AoKTtcblxuICAgIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgICBudW1MaW5lc0VzdCsrO1xuICAgICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgICAgcmV0dXJuIHByZXYgKyBjdXIubGVuZ3RoICsgMTtcbiAgICB9LCAwKTtcblxuICAgIGlmIChsZW5ndGggPiA1MCkge1xuICAgICAgb3V0cHV0ID0gYnJhY2VzWzBdICtcbiAgICAgICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgYnJhY2VzWzFdO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dCA9IGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHJldHVybiBmb3JtYXQob2JqLCAodHlwZW9mIGRlcHRoID09PSAndW5kZWZpbmVkJyA/IDIgOiBkZXB0aCkpO1xufTtcblxuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBhciBpbnN0YW5jZW9mIEFycmF5IHx8XG4gICAgICAgICBBcnJheS5pc0FycmF5KGFyKSB8fFxuICAgICAgICAgKGFyICYmIGFyICE9PSBPYmplY3QucHJvdG90eXBlICYmIGlzQXJyYXkoYXIuX19wcm90b19fKSk7XG59XG5cblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIHJlIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgKHR5cGVvZiByZSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScpO1xufVxuXG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIGlmIChkIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2YgZCAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHByb3BlcnRpZXMgPSBEYXRlLnByb3RvdHlwZSAmJiBPYmplY3RfZ2V0T3duUHJvcGVydHlOYW1lcyhEYXRlLnByb3RvdHlwZSk7XG4gIHZhciBwcm90byA9IGQuX19wcm90b19fICYmIE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKGQuX19wcm90b19fKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByb3RvKSA9PT0gSlNPTi5zdHJpbmdpZnkocHJvcGVydGllcyk7XG59XG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uIChtc2cpIHt9O1xuXG5leHBvcnRzLnB1bXAgPSBudWxsO1xuXG52YXIgT2JqZWN0X2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHJlcy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBPYmplY3RfZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxudmFyIE9iamVjdF9jcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAvLyBmcm9tIGVzNS1zaGltXG4gICAgdmFyIG9iamVjdDtcbiAgICBpZiAocHJvdG90eXBlID09PSBudWxsKSB7XG4gICAgICAgIG9iamVjdCA9IHsgJ19fcHJvdG9fXycgOiBudWxsIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIHByb3RvdHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgJ3R5cGVvZiBwcm90b3R5cGVbJyArICh0eXBlb2YgcHJvdG90eXBlKSArICddICE9IFxcJ29iamVjdFxcJydcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFR5cGUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgVHlwZS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgIG9iamVjdCA9IG5ldyBUeXBlKCk7XG4gICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcGVydGllcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmV4cG9ydHMuaW5oZXJpdHMgPSBmdW5jdGlvbihjdG9yLCBzdXBlckN0b3IpIHtcbiAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gIGN0b3IucHJvdG90eXBlID0gT2JqZWN0X2NyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAodHlwZW9mIGYgIT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGV4cG9ydHMuaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6IHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSl7XG4gICAgaWYgKHggPT09IG51bGwgfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGV4cG9ydHMuaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbn0se1wiZXZlbnRzXCI6Nn1dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5KGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuXHRcblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyAnSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCc7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHBsYWNlSG9sZGVycyA9IGI2NC5pbmRleE9mKCc9Jyk7XG5cdFx0cGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSBwbGFjZUhvbGRlcnMgOiAwO1xuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gW107Ly9uZXcgVWludDhBcnJheShiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMTgpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pIDw8IDEyKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA8PCA2KSB8IGxvb2t1cC5pbmRleE9mKGI2NFtpICsgM10pO1xuXHRcdFx0YXJyLnB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNik7XG5cdFx0XHRhcnIucHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDIpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pID4+IDQpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDEwKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDFdKSA8PCA0KSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA+PiAyKTtcblx0XHRcdGFyci5wdXNoKCh0bXAgPj4gOCkgJiAweEZGKTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0KHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGg7XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdO1xuXHRcdH07XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTtcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcCk7XG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbdGVtcCA+PiAyXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA8PCA0KSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gJz09Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwW3RlbXAgPj4gMTBdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wID4+IDQpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPDwgMikgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9ICc9Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXk7XG5cdG1vZHVsZS5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0O1xufSgpKTtcblxufSx7fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5leHBvcnRzLnJlYWRJRUVFNzU0ID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzQkUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzQkUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzQkUgPyAxIDogLTEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZUlFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQkUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNCRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNCRSA/IC0xIDogMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuXG59LHt9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoZXYuc291cmNlID09PSB3aW5kb3cgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbihwcm9jZXNzKXtpZiAoIXByb2Nlc3MuRXZlbnRFbWl0dGVyKSBwcm9jZXNzLkV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgRXZlbnRFbWl0dGVyID0gZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBwcm9jZXNzLkV2ZW50RW1pdHRlcjtcbnZhciBpc0FycmF5ID0gdHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbidcbiAgICA/IEFycmF5LmlzQXJyYXlcbiAgICA6IGZ1bmN0aW9uICh4cykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIH1cbjtcbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHJldHVybiB4cy5pbmRleE9mKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHggPT09IHhzW2ldKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuXG4vLyAxMCBsaXN0ZW5lcnMgYXJlIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2hcbi8vIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuLy9cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcbiAgdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyA9IG47XG59O1xuXG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzQXJyYXkodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpXG4gICAge1xuICAgICAgaWYgKGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGFyZ3VtZW50c1sxXTsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuY2F1Z2h0LCB1bnNwZWNpZmllZCAnZXJyb3InIGV2ZW50LlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIGZhbHNlO1xuICB2YXIgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgaWYgKCFoYW5kbGVyKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09ICdmdW5jdGlvbicpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gRXZlbnRFbWl0dGVyIGlzIGRlZmluZWQgaW4gc3JjL25vZGVfZXZlbnRzLmNjXG4vLyBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQoKSBpcyBhbHNvIGRlZmluZWQgdGhlcmUuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBsaXN0ZW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcignYWRkTGlzdGVuZXIgb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09IFwibmV3TGlzdGVuZXJzXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyc1wiLlxuICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgICAgdmFyIG07XG4gICAgICBpZiAodGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG0gPSB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbSA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLm9uKHR5cGUsIGZ1bmN0aW9uIGcoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcbiAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGxpc3RlbmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pIHJldHVybiB0aGlzO1xuXG4gIHZhciBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0FycmF5KGxpc3QpKSB7XG4gICAgdmFyIGkgPSBpbmRleE9mKGxpc3QsIGxpc3RlbmVyKTtcbiAgICBpZiAoaSA8IDApIHJldHVybiB0aGlzO1xuICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PSAwKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfSBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0gPT09IGxpc3RlbmVyKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBkb2VzIG5vdCB1c2UgbGlzdGVuZXJzKCksIHNvIG5vIHNpZGUgZWZmZWN0IG9mIGNyZWF0aW5nIF9ldmVudHNbdHlwZV1cbiAgaWYgKHR5cGUgJiYgdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gbnVsbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gW107XG4gIGlmICghaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2V2ZW50c1t0eXBlXTtcbn07XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSlcbn0se1wiX19icm93c2VyaWZ5X3Byb2Nlc3NcIjo4fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oKXtmdW5jdGlvbiBTbG93QnVmZmVyIChzaXplKSB7XG4gICAgdGhpcy5sZW5ndGggPSBzaXplO1xufTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5cblxuZnVuY3Rpb24gdG9IZXgobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNik7XG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspXG4gICAgaWYgKHN0ci5jaGFyQ29kZUF0KGkpIDw9IDB4N0YpXG4gICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuY2hhckF0KGkpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKylcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKTtcbiAgICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheTtcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKysgKVxuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKCBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYgKTtcblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKHN0cikge1xuICByZXR1cm4gcmVxdWlyZShcImJhc2U2NC1qc1wiKS50b0J5dGVBcnJheShzdHIpO1xufVxuXG5TbG93QnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8IFwidXRmOFwiKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoIC8gMjtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aDtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBibGl0QnVmZmVyKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgcG9zLCBpID0gMDtcbiAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICBpZiAoKGkrb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWs7XG5cbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBpO1xufVxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgYnl0ZXMsIHBvcztcbiAgcmV0dXJuIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9ICBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpV3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgYnl0ZXMsIHBvcztcbiAgcmV0dXJuIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9ICBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5iYXNlNjRXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJhc2U2NFNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgcmV0dXJuIHJlcXVpcmUoXCJiYXNlNjQtanNcIikuZnJvbUJ5dGVBcnJheShieXRlcyk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKTsgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdmFyIHJlcyA9IFwiXCI7XG4gIHZhciB0bXAgPSBcIlwiO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVzW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgICB0bXAgPSBcIlwiO1xuICAgIH0gZWxzZVxuICAgICAgdG1wICs9IFwiJVwiICsgYnl0ZXNbaV0udG9TdHJpbmcoMTYpO1xuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcCk7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB2YXIgcmV0ID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gIHJldHVybiByZXQ7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG91dCA9IFtdLFxuICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzW2ldKTtcbiAgICBpZiAoaSA9PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLic7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8U2xvd0J1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+Jztcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaGV4U2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgodGhpc1tpXSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG4gIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG4gIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxlbmd0aDtcblxuICAvLyBGYXN0cGF0aCBlbXB0eSBzdHJpbmdzXG4gIGlmICgrZW5kID09IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gdGhpcy5oZXhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnV0ZjhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLmFzY2lpU2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy51Y3MyU2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaGV4V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKHN0ckxlbiAlIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpO1xuICB9XG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xuICAgIGlmIChpc05hTihieXRlKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKTtcbiAgICB0aGlzW29mZnNldCArIGldID0gYnl0ZTtcbiAgfVxuICBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBpICogMjtcbiAgcmV0dXJuIGk7XG59O1xuXG5cblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgbGVuZ3RoID0gc3dhcDtcbiAgfVxuXG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHRoaXMuaGV4V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXR1cm4gdGhpcy51dGY4V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gdGhpcy5hc2NpaVdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiB0aGlzLmJpbmFyeVdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiB0aGlzLmJhc2U2NFdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0dXJuIHRoaXMudWNzMldyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5TbG93QnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSBlbmQgPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICB9XG4gIGlmIChzdGFydCA+IGVuZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIH1cblxuICByZXR1cm4gbmV3IEJ1ZmZlcih0aGlzLCBlbmQgLSBzdGFydCwgK3N0YXJ0KTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldHN0YXJ0LCBzb3VyY2VzdGFydCwgc291cmNlZW5kKSB7XG4gIHZhciB0ZW1wID0gW107XG4gIGZvciAodmFyIGk9c291cmNlc3RhcnQ7IGk8c291cmNlZW5kOyBpKyspIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIHRoaXNbaV0gIT09ICd1bmRlZmluZWQnLCBcImNvcHlpbmcgdW5kZWZpbmVkIGJ1ZmZlciBieXRlcyFcIik7XG4gICAgdGVtcC5wdXNoKHRoaXNbaV0pO1xuICB9XG5cbiAgZm9yICh2YXIgaT10YXJnZXRzdGFydDsgaTx0YXJnZXRzdGFydCt0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0W2ldID0gdGVtcFtpLXRhcmdldHN0YXJ0XTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY29lcmNlKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpO1xuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGg7XG59XG5cblxuLy8gQnVmZmVyXG5cbmZ1bmN0aW9uIEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgb2Zmc2V0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG9mZnNldCk7XG4gIH1cblxuICB2YXIgdHlwZTtcblxuICAvLyBBcmUgd2Ugc2xpY2luZz9cbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5sZW5ndGggPSBjb2VyY2UoZW5jb2RpbmcpO1xuICAgIHRoaXMucGFyZW50ID0gc3ViamVjdDtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgICBzd2l0Y2ggKHR5cGUgPSB0eXBlb2Ygc3ViamVjdCkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB0aGlzLmxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6IC8vIEFzc3VtZSBvYmplY3QgaXMgYW4gYXJyYXlcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJyYXkgb3Igc3RyaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IEJ1ZmZlci5wb29sU2l6ZSkge1xuICAgICAgLy8gQmlnIGJ1ZmZlciwganVzdCBhbGxvYyBvbmUuXG4gICAgICB0aGlzLnBhcmVudCA9IG5ldyBTbG93QnVmZmVyKHRoaXMubGVuZ3RoKTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTbWFsbCBidWZmZXIuXG4gICAgICBpZiAoIXBvb2wgfHwgcG9vbC5sZW5ndGggLSBwb29sLnVzZWQgPCB0aGlzLmxlbmd0aCkgYWxsb2NQb29sKCk7XG4gICAgICB0aGlzLnBhcmVudCA9IHBvb2w7XG4gICAgICB0aGlzLm9mZnNldCA9IHBvb2wudXNlZDtcbiAgICAgIHBvb2wudXNlZCArPSB0aGlzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXkuXG4gICAgaWYgKGlzQXJyYXlJc2goc3ViamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnBhcmVudFtpICsgdGhpcy5vZmZzZXRdID0gc3ViamVjdFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFdlIGFyZSBhIHN0cmluZ1xuICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKTtcbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBpc0FycmF5SXNoKHN1YmplY3QpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJztcbn1cblxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlcjtcbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyO1xuXG5CdWZmZXIucG9vbFNpemUgPSA4ICogMTAyNDtcbnZhciBwb29sO1xuXG5mdW5jdGlvbiBhbGxvY1Bvb2woKSB7XG4gIHBvb2wgPSBuZXcgU2xvd0J1ZmZlcihCdWZmZXIucG9vbFNpemUpO1xuICBwb29sLnVzZWQgPSAwO1xufVxuXG5cbi8vIFN0YXRpYyBtZXRob2RzXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIHJldHVybiBiIGluc3RhbmNlb2YgQnVmZmVyIHx8IGIgaW5zdGFuY2VvZiBTbG93QnVmZmVyO1xufTtcblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0LCBbdG90YWxMZW5ndGhdKVxcbiBcXFxuICAgICAgbGlzdCBzaG91bGQgYmUgYW4gQXJyYXkuXCIpO1xuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMCk7XG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdG90YWxMZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgICB0b3RhbExlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKTtcbiAgdmFyIHBvcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBidWYgPSBsaXN0W2ldO1xuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcbiAgICBwb3MgKz0gYnVmLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuLy8gSW5zcGVjdFxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgdmFyIG91dCA9IFtdLFxuICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXMucGFyZW50W2kgKyB0aGlzLm9mZnNldF0pO1xuICAgIGlmIChpID09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+Jztcbn07XG5cblxuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgcmV0dXJuIHRoaXMucGFyZW50W3RoaXMub2Zmc2V0ICsgaV07XG59O1xuXG5cbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KGksIHYpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIHJldHVybiB0aGlzLnBhcmVudFt0aGlzLm9mZnNldCArIGldID0gdjtcbn07XG5cblxuLy8gd3JpdGUoc3RyaW5nLCBvZmZzZXQgPSAwLCBsZW5ndGggPSBidWZmZXIubGVuZ3RoLW9mZnNldCwgZW5jb2RpbmcgPSAndXRmOCcpXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgbGVuZ3RoID0gc3dhcDtcbiAgfVxuXG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHZhciByZXQ7XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuaGV4V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQudXRmOFdyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IHRoaXMucGFyZW50LmFzY2lpV3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IHRoaXMucGFyZW50LmJpbmFyeVdyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYmFzZTY0V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQudWNzMldyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxuXG4gIEJ1ZmZlci5fY2hhcnNXcml0dGVuID0gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5cbi8vIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKHR5cGVvZiBzdGFydCA9PSAndW5kZWZpbmVkJyB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDA7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuZCA9PSAndW5kZWZpbmVkJyB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9IGVsc2UgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgPSAwO1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCArIHRoaXMub2Zmc2V0O1xuICBlbmQgPSBlbmQgKyB0aGlzLm9mZnNldDtcblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5oZXhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC51dGY4U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYXNjaWlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYmluYXJ5U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmJhc2U2NFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnVjczJTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuXG4vLyBieXRlTGVuZ3RoXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IFNsb3dCdWZmZXIuYnl0ZUxlbmd0aDtcblxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgdmFsdWUgfHwgKHZhbHVlID0gMCk7XG4gIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICBlbmQgfHwgKGVuZCA9IHRoaXMubGVuZ3RoKTtcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgfVxuICBpZiAoISh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIGlzIG5vdCBhIG51bWJlcicpO1xuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgRXJyb3IoJ2VuZCA8IHN0YXJ0Jyk7XG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMDtcbiAgaWYgKHRoaXMubGVuZ3RoID09IDApIHJldHVybiAwO1xuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMucGFyZW50LmZpbGwodmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICsgdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCArIHRoaXMub2Zmc2V0KTtcbn07XG5cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICBlbmQgfHwgKGVuZCA9IHRoaXMubGVuZ3RoKTtcbiAgdGFyZ2V0X3N0YXJ0IHx8ICh0YXJnZXRfc3RhcnQgPSAwKTtcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIDwgc291cmNlU3RhcnQnKTtcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PSAwIHx8IHNvdXJjZS5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG5cbiAgaWYgKHRhcmdldF9zdGFydCA8IDAgfHwgdGFyZ2V0X3N0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnBhcmVudC5jb3B5KHRhcmdldC5wYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldF9zdGFydCArIHRhcmdldC5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICsgdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCArIHRoaXMub2Zmc2V0KTtcbn07XG5cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgaWYgKHN0YXJ0ID4gZW5kKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuXG4gIHJldHVybiBuZXcgQnVmZmVyKHRoaXMucGFyZW50LCBlbmQgLSBzdGFydCwgK3N0YXJ0ICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBMZWdhY3kgbWV0aG9kcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cbkJ1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygndXRmOCcsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5iaW5hcnlTbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoJ2JpbmFyeScsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5hc2NpaVNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygnYXNjaWknLCBzdGFydCwgZW5kKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICd1dGY4Jyk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmJpbmFyeVdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICdiaW5hcnknKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuYXNjaWlXcml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLndyaXRlKHN0cmluZywgb2Zmc2V0LCAnYXNjaWknKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRVSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgdmFsID0gMDtcblxuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIHZhbCA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV07XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFyIHZhbCA9IDA7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKGlzQmlnRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgMTY7XG4gICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDJdIDw8IDg7XG4gICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDNdO1xuICAgIHZhbCA9IHZhbCArIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDI0ID4+PiAwKTtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA8PCAxNjtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbiAgICB2YWwgPSB2YWwgKyAoYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFNpZ25lZCBpbnRlZ2VyIHR5cGVzLCB5YXkgdGVhbSEgQSByZW1pbmRlciBvbiBob3cgdHdvJ3MgY29tcGxlbWVudCBhY3R1YWxseVxuICogd29ya3MuIFRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ25lZCBiaXQsIGkuZS4gdGVsbHMgdXMgd2hldGhlciBvciBub3QgdGhlXG4gKiBudW1iZXIgc2hvdWxkIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLiBJZiB0aGUgdHdvJ3MgY29tcGxlbWVudCB2YWx1ZSBpc1xuICogcG9zaXRpdmUsIHRoZW4gd2UncmUgZG9uZSwgYXMgaXQncyBlcXVpdmFsZW50IHRvIHRoZSB1bnNpZ25lZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBOb3cgaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgeW91J3JlIHByZXR0eSBtdWNoIGRvbmUsIHlvdSBjYW4ganVzdCBsZXZlcmFnZVxuICogdGhlIHVuc2lnbmVkIHRyYW5zbGF0aW9ucyBhbmQgcmV0dXJuIHRob3NlLiBVbmZvcnR1bmF0ZWx5LCBuZWdhdGl2ZSBudW1iZXJzXG4gKiBhcmVuJ3QgcXVpdGUgdGhhdCBzdHJhaWdodGZvcndhcmQuXG4gKlxuICogQXQgZmlyc3QgZ2xhbmNlLCBvbmUgbWlnaHQgYmUgaW5jbGluZWQgdG8gdXNlIHRoZSB0cmFkaXRpb25hbCBmb3JtdWxhIHRvXG4gKiB0cmFuc2xhdGUgYmluYXJ5IG51bWJlcnMgYmV0d2VlbiB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcyBpbiB0d28nc1xuICogY29tcGxlbWVudC4gKFRob3VnaCBpdCBkb2Vzbid0IHF1aXRlIHdvcmsgZm9yIHRoZSBtb3N0IG5lZ2F0aXZlIHZhbHVlKVxuICogTWFpbmx5OlxuICogIC0gaW52ZXJ0IGFsbCB0aGUgYml0c1xuICogIC0gYWRkIG9uZSB0byB0aGUgcmVzdWx0XG4gKlxuICogT2YgY291cnNlLCB0aGlzIGRvZXNuJ3QgcXVpdGUgd29yayBpbiBKYXZhc2NyaXB0LiBUYWtlIGZvciBleGFtcGxlIHRoZSB2YWx1ZVxuICogb2YgLTEyOC4gVGhpcyBjb3VsZCBiZSByZXByZXNlbnRlZCBpbiAxNiBiaXRzIChiaWctZW5kaWFuKSBhcyAweGZmODAuIEJ1dCBvZlxuICogY291cnNlLCBKYXZhc2NyaXB0IHdpbGwgZG8gdGhlIGZvbGxvd2luZzpcbiAqXG4gKiA+IH4weGZmODBcbiAqIC02NTQwOVxuICpcbiAqIFdob2ggdGhlcmUsIEphdmFzY3JpcHQsIHRoYXQncyBub3QgcXVpdGUgcmlnaHQuIEJ1dCB3YWl0LCBhY2NvcmRpbmcgdG9cbiAqIEphdmFzY3JpcHQgdGhhdCdzIHBlcmZlY3RseSBjb3JyZWN0LiBXaGVuIEphdmFzY3JpcHQgZW5kcyB1cCBzZWVpbmcgdGhlXG4gKiBjb25zdGFudCAweGZmODAsIGl0IGhhcyBubyBub3Rpb24gdGhhdCBpdCBpcyBhY3R1YWxseSBhIHNpZ25lZCBudW1iZXIuIEl0XG4gKiBhc3N1bWVzIHRoYXQgd2UndmUgaW5wdXQgdGhlIHVuc2lnbmVkIHZhbHVlIDB4ZmY4MC4gVGh1cywgd2hlbiBpdCBkb2VzIHRoZVxuICogYmluYXJ5IG5lZ2F0aW9uLCBpdCBjYXN0cyBpdCBpbnRvIGEgc2lnbmVkIHZhbHVlLCAocG9zaXRpdmUgMHhmZjgwKS4gVGhlblxuICogd2hlbiB5b3UgcGVyZm9ybSBiaW5hcnkgbmVnYXRpb24gb24gdGhhdCwgaXQgdHVybnMgaXQgaW50byBhIG5lZ2F0aXZlIG51bWJlci5cbiAqXG4gKiBJbnN0ZWFkLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHVzZSB0aGUgZm9sbG93aW5nIGdlbmVyYWwgZm9ybXVsYSwgdGhhdCB3b3Jrc1xuICogaW4gYSByYXRoZXIgSmF2YXNjcmlwdCBmcmllbmRseSB3YXkuIEknbSBnbGFkIHdlIGRvbid0IHN1cHBvcnQgdGhpcyBraW5kIG9mXG4gKiB3ZWlyZCBudW1iZXJpbmcgc2NoZW1lIGluIHRoZSBrZXJuZWwuXG4gKlxuICogKEJJVC1NQVggLSAodW5zaWduZWQpdmFsICsgMSkgKiAtMVxuICpcbiAqIFRoZSBhc3R1dGUgb2JzZXJ2ZXIsIG1heSB0aGluayB0aGF0IHRoaXMgZG9lc24ndCBtYWtlIHNlbnNlIGZvciA4LWJpdCBudW1iZXJzXG4gKiAocmVhbGx5IGl0IGlzbid0IG5lY2Vzc2FyeSBmb3IgdGhlbSkuIEhvd2V2ZXIsIHdoZW4geW91IGdldCAxNi1iaXQgbnVtYmVycyxcbiAqIHlvdSBkby4gTGV0J3MgZ28gYmFjayB0byBvdXIgcHJpb3IgZXhhbXBsZSBhbmQgc2VlIGhvdyB0aGlzIHdpbGwgbG9vazpcbiAqXG4gKiAoMHhmZmZmIC0gMHhmZjgwICsgMSkgKiAtMVxuICogKDB4MDA3ZiArIDEpICogLTFcbiAqICgweDAwODApICogLTFcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG4gIHZhciBuZWc7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgbmVnID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSAmIDB4ODA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdKTtcbiAgfVxuXG4gIHJldHVybiAoKDB4ZmYgLSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdICsgMSkgKiAtMSk7XG59O1xuXG5mdW5jdGlvbiByZWFkSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgbmVnLCB2YWw7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFsID0gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgbmVnID0gdmFsICYgMHg4MDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciBuZWcsIHZhbDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICB2YWwgPSByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICBuZWcgPSB2YWwgJiAweDgwMDAwMDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiAodmFsKTtcbiAgfVxuXG4gIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGbG9hdChidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDIzLCA0KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZERvdWJsZShidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyA3IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDUyLCA4KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0IGlzXG4gKiBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdCBleGNlZWQgdGhlXG4gKiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKlxuICogICAgICB2YWx1ZSAgICAgICAgICAgVGhlIG51bWJlciB0byBjaGVjayBmb3IgdmFsaWRpdHlcbiAqXG4gKiAgICAgIG1heCAgICAgICAgICAgICBUaGUgbWF4aW11bSB2YWx1ZVxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQodmFsdWUsIG1heCkge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSAwLFxuICAgICAgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKTtcblxuICBhc3NlcnQub2soTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKTtcbiAgfVxuXG4gIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSB2YWx1ZTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSAodmFsdWUgJiAweGZmMDApID4+PiA4O1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdID0gdmFsdWUgJiAweDAwZmY7XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmMDApID4+PiA4O1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSB2YWx1ZSAmIDB4MDBmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVVSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmZmZmZmKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSAodmFsdWUgPj4+IDI0KSAmIDB4ZmY7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAzXSA9IHZhbHVlICYgMHhmZjtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSB2YWx1ZSAmIDB4ZmY7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIG5vdyBtb3ZlIG9udG8gb3VyIGZyaWVuZHMgaW4gdGhlIHNpZ25lZCBudW1iZXIgY2F0ZWdvcnkuIFVubGlrZSB1bnNpZ25lZFxuICogbnVtYmVycywgd2UncmUgZ29pbmcgdG8gaGF2ZSB0byB3b3JyeSBhIGJpdCBtb3JlIGFib3V0IGhvdyB3ZSBwdXQgdmFsdWVzIGludG9cbiAqIGFycmF5cy4gU2luY2Ugd2UgYXJlIG9ubHkgd29ycnlpbmcgYWJvdXQgc2lnbmVkIDMyLWJpdCB2YWx1ZXMsIHdlJ3JlIGluXG4gKiBzbGlnaHRseSBiZXR0ZXIgc2hhcGUuIFVuZm9ydHVuYXRlbHksIHdlIHJlYWxseSBjYW4ndCBkbyBvdXIgZmF2b3JpdGUgYmluYXJ5XG4gKiAmIGluIHRoaXMgc3lzdGVtLiBJdCByZWFsbHkgc2VlbXMgdG8gZG8gdGhlIHdyb25nIHRoaW5nLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiA+IC0zMiAmIDB4ZmZcbiAqIDIyNFxuICpcbiAqIFdoYXQncyBoYXBwZW5pbmcgYWJvdmUgaXMgcmVhbGx5OiAweGUwICYgMHhmZiA9IDB4ZTAuIEhvd2V2ZXIsIHRoZSByZXN1bHRzIG9mXG4gKiB0aGlzIGFyZW4ndCB0cmVhdGVkIGFzIGEgc2lnbmVkIG51bWJlci4gVWx0aW1hdGVseSBhIGJhZCB0aGluZy5cbiAqXG4gKiBXaGF0IHdlJ3JlIGdvaW5nIHRvIHdhbnQgdG8gZG8gaXMgYmFzaWNhbGx5IGNyZWF0ZSB0aGUgdW5zaWduZWQgZXF1aXZhbGVudCBvZlxuICogb3VyIHJlcHJlc2VudGF0aW9uIGFuZCBwYXNzIHRoYXQgb2ZmIHRvIHRoZSB3dWludCogZnVuY3Rpb25zLiBUbyBkbyB0aGF0XG4gKiB3ZSdyZSBnb2luZyB0byBkbyB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAtIGlmIHRoZSB2YWx1ZSBpcyBwb3NpdGl2ZVxuICogICAgICB3ZSBjYW4gcGFzcyBpdCBkaXJlY3RseSBvZmYgdG8gdGhlIGVxdWl2YWxlbnQgd3VpbnRcbiAqICAtIGlmIHRoZSB2YWx1ZSBpcyBuZWdhdGl2ZVxuICogICAgICB3ZSBkbyB0aGUgZm9sbG93aW5nIGNvbXB1dGF0aW9uOlxuICogICAgICAgICBtYiArIHZhbCArIDEsIHdoZXJlXG4gKiAgICAgICAgIG1iICAgaXMgdGhlIG1heGltdW0gdW5zaWduZWQgdmFsdWUgaW4gdGhhdCBieXRlIHNpemVcbiAqICAgICAgICAgdmFsICBpcyB0aGUgSmF2YXNjcmlwdCBuZWdhdGl2ZSBpbnRlZ2VyXG4gKlxuICpcbiAqIEFzIGEgY29uY3JldGUgdmFsdWUsIHRha2UgLTEyOC4gSW4gc2lnbmVkIDE2IGJpdHMgdGhpcyB3b3VsZCBiZSAweGZmODAuIElmXG4gKiB5b3UgZG8gb3V0IHRoZSBjb21wdXRhdGlvbnM6XG4gKlxuICogMHhmZmZmIC0gMTI4ICsgMVxuICogMHhmZmZmIC0gMTI3XG4gKiAweGZmODBcbiAqXG4gKiBZb3UgY2FuIHRoZW4gZW5jb2RlIHRoaXMgdmFsdWUgYXMgdGhlIHNpZ25lZCB2ZXJzaW9uLiBUaGlzIGlzIHJlYWxseSByYXRoZXJcbiAqIGhhY2t5LCBidXQgaXQgc2hvdWxkIHdvcmsgYW5kIGdldCB0aGUgam9iIGRvbmUgd2hpY2ggaXMgb3VyIGdvYWwgaGVyZS5cbiAqL1xuXG4vKlxuICogQSBzZXJpZXMgb2YgY2hlY2tzIHRvIG1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIGEgc2lnbmVkIDMyLWJpdCBudW1iZXJcbiAqL1xuZnVuY3Rpb24gdmVyaWZzaW50KHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKTtcblxuICBhc3NlcnQub2sodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayhNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpO1xufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydC5vayh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJyxcbiAgICAgICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJyk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmLCAtMHg4MCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIud3JpdGVVSW50OCgweGZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIG5vQXNzZXJ0KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZiwgLTB4ODAwMCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIHdyaXRlVUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZVVJbnQxNihidWZmZXIsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIHdyaXRlVUludDMyKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZVVJbnQzMihidWZmZXIsIDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUZsb2F0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpO1xuICB9XG5cbiAgcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLndyaXRlSUVFRTc1NChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgMjMsIDQpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZURvdWJsZShidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDcgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpO1xuICB9XG5cbiAgcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLndyaXRlSUVFRTc1NChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgNTIsIDgpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50ODtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkU7XG5cbn0pKClcbn0se1wiYXNzZXJ0XCI6MixcIi4vYnVmZmVyX2llZWU3NTRcIjo3LFwiYmFzZTY0LWpzXCI6OX1dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5KGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuXHRcblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyAnSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCc7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHBsYWNlSG9sZGVycyA9IGI2NC5pbmRleE9mKCc9Jyk7XG5cdFx0cGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSBwbGFjZUhvbGRlcnMgOiAwO1xuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gW107Ly9uZXcgVWludDhBcnJheShiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMTgpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pIDw8IDEyKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA8PCA2KSB8IGxvb2t1cC5pbmRleE9mKGI2NFtpICsgM10pO1xuXHRcdFx0YXJyLnB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNik7XG5cdFx0XHRhcnIucHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDIpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pID4+IDQpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDEwKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDFdKSA8PCA0KSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA+PiAyKTtcblx0XHRcdGFyci5wdXNoKCh0bXAgPj4gOCkgJiAweEZGKTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0KHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGg7XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdO1xuXHRcdH07XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTtcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcCk7XG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbdGVtcCA+PiAyXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA8PCA0KSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gJz09Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwW3RlbXAgPj4gMTBdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wID4+IDQpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPDwgMikgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9ICc9Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXk7XG5cdG1vZHVsZS5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0O1xufSgpKTtcblxufSx7fV19LHt9LFtdKVxuOzttb2R1bGUuZXhwb3J0cz1yZXF1aXJlKFwiYnVmZmVyLWJyb3dzZXJpZnlcIilcbiIsIihmdW5jdGlvbihwcm9jZXNzLEJ1ZmZlcil7Ly8gQ29weXJpZ2h0IDIwMTAtMjAxMiBNaWtlYWwgUm9nZXJzXG4vL1xuLy8gICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vICAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vICAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyAgICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyAgICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyAgICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vICAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vICAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG52YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKVxuICAsIGh0dHBzID0gZmFsc2VcbiAgLCB0bHMgPSBmYWxzZVxuICAsIHVybCA9IHJlcXVpcmUoJ3VybCcpXG4gICwgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuICAsIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG4gICwgcXMgPSByZXF1aXJlKCdxcycpXG4gICwgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpXG4gICwgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcblxuICAsIG9hdXRoID0gcmVxdWlyZSgnb2F1dGgtc2lnbicpXG4gICwgaGF3ayA9IHJlcXVpcmUoJ2hhd2snKVxuICAsIGF3cyA9IHJlcXVpcmUoJ2F3cy1zaWduJylcbiAgLCBodHRwU2lnbmF0dXJlID0gcmVxdWlyZSgnaHR0cC1zaWduYXR1cmUnKVxuICAsIHV1aWQgPSByZXF1aXJlKCdub2RlLXV1aWQnKVxuICAsIG1pbWUgPSByZXF1aXJlKCdtaW1lJylcbiAgLCB0dW5uZWwgPSByZXF1aXJlKCd0dW5uZWwtYWdlbnQnKVxuICAsIHNhZmVTdHJpbmdpZnkgPSByZXF1aXJlKCdqc29uLXN0cmluZ2lmeS1zYWZlJylcblxuICAsIEZvcmV2ZXJBZ2VudCA9IHJlcXVpcmUoJ2ZvcmV2ZXItYWdlbnQnKVxuICAsIEZvcm1EYXRhID0gcmVxdWlyZSgnZm9ybS1kYXRhJylcblxuICAsIENvb2tpZSA9IHJlcXVpcmUoJ2Nvb2tpZS1qYXInKVxuICAsIENvb2tpZUphciA9IENvb2tpZS5KYXJcbiAgLCBjb29raWVKYXIgPSBuZXcgQ29va2llSmFyXG4gIDtcblxudHJ5IHtcbiAgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpXG59IGNhdGNoIChlKSB7fVxuXG50cnkge1xuICB0bHMgPSByZXF1aXJlKCd0bHMnKVxufSBjYXRjaCAoZSkge31cblxudmFyIGRlYnVnXG5pZiAoL1xcYnJlcXVlc3RcXGIvLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykpIHtcbiAgZGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlLmVycm9yKCdSRVFVRVNUICVzJywgdXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKSlcbiAgfVxufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbigpIHt9XG59XG5cbmZ1bmN0aW9uIHRvQmFzZTY0IChzdHIpIHtcbiAgcmV0dXJuIChuZXcgQnVmZmVyKHN0ciB8fCBcIlwiLCBcImFzY2lpXCIpKS50b1N0cmluZyhcImJhc2U2NFwiKVxufVxuXG5mdW5jdGlvbiBtZDUgKHN0cikge1xuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ21kNScpLnVwZGF0ZShzdHIpLmRpZ2VzdCgnaGV4Jylcbn1cblxuLy8gSGFja3kgZml4IGZvciBwcmUtMC40LjQgaHR0cHNcbmlmIChodHRwcyAmJiAhaHR0cHMuQWdlbnQpIHtcbiAgaHR0cHMuQWdlbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGh0dHAuQWdlbnQuY2FsbCh0aGlzLCBvcHRpb25zKVxuICB9XG4gIHV0aWwuaW5oZXJpdHMoaHR0cHMuQWdlbnQsIGh0dHAuQWdlbnQpXG4gIGh0dHBzLkFnZW50LnByb3RvdHlwZS5fZ2V0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uIChob3N0LCBwb3J0LCBjYikge1xuICAgIHZhciBzID0gdGxzLmNvbm5lY3QocG9ydCwgaG9zdCwgdGhpcy5vcHRpb25zLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBkbyBvdGhlciBjaGVja3MgaGVyZT9cbiAgICAgIGlmIChjYikgY2IoKVxuICAgIH0pXG4gICAgcmV0dXJuIHNcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1JlYWRTdHJlYW0gKHJzKSB7XG4gIGlmIChycy5yZWFkYWJsZSAmJiBycy5wYXRoICYmIHJzLm1vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHkgKG9iaikge1xuICB2YXIgbyA9IHt9XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgIG9baV0gPSBvYmpbaV1cbiAgfSlcbiAgcmV0dXJuIG9cbn1cblxudmFyIGlzVXJsID0gL15odHRwcz86L1xuXG52YXIgZ2xvYmFsUG9vbCA9IHt9XG5cbmZ1bmN0aW9uIFJlcXVlc3QgKG9wdGlvbnMpIHtcbiAgc3RyZWFtLlN0cmVhbS5jYWxsKHRoaXMpXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlXG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7dXJpOm9wdGlvbnN9XG4gIH1cblxuICB2YXIgcmVzZXJ2ZWQgPSBPYmplY3Qua2V5cyhSZXF1ZXN0LnByb3RvdHlwZSlcbiAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgaWYgKHJlc2VydmVkLmluZGV4T2YoaSkgPT09IC0xKSB7XG4gICAgICB0aGlzW2ldID0gb3B0aW9uc1tpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnNbaV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnNbaV1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5tZXRob2QpIHtcbiAgICB0aGlzLmV4cGxpY2l0TWV0aG9kID0gdHJ1ZVxuICB9XG5cbiAgdGhpcy5pbml0KG9wdGlvbnMpXG59XG51dGlsLmluaGVyaXRzKFJlcXVlc3QsIHN0cmVhbS5TdHJlYW0pXG5SZXF1ZXN0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgLy8gaW5pdCgpIGNvbnRhaW5zIGFsbCB0aGUgY29kZSB0byBzZXR1cCB0aGUgcmVxdWVzdCBvYmplY3QuXG4gIC8vIHRoZSBhY3R1YWwgb3V0Z29pbmcgcmVxdWVzdCBpcyBub3Qgc3RhcnRlZCB1bnRpbCBzdGFydCgpIGlzIGNhbGxlZFxuICAvLyB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBmcm9tIGJvdGggdGhlIGNvbnN0cnVjdG9yIGFuZCBvbiByZWRpcmVjdC5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG5cbiAgaWYgKCFzZWxmLm1ldGhvZCkgc2VsZi5tZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCAnR0VUJ1xuICBzZWxmLmxvY2FsQWRkcmVzcyA9IG9wdGlvbnMubG9jYWxBZGRyZXNzXG5cbiAgZGVidWcob3B0aW9ucylcbiAgaWYgKCFzZWxmLnBvb2wgJiYgc2VsZi5wb29sICE9PSBmYWxzZSkgc2VsZi5wb29sID0gZ2xvYmFsUG9vbFxuICBzZWxmLmRlc3RzID0gc2VsZi5kZXN0cyB8fCBbXVxuICBzZWxmLl9faXNSZXF1ZXN0UmVxdWVzdCA9IHRydWVcblxuICAvLyBQcm90ZWN0IGFnYWluc3QgZG91YmxlIGNhbGxiYWNrXG4gIGlmICghc2VsZi5fY2FsbGJhY2sgJiYgc2VsZi5jYWxsYmFjaykge1xuICAgIHNlbGYuX2NhbGxiYWNrID0gc2VsZi5jYWxsYmFja1xuICAgIHNlbGYuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5fY2FsbGJhY2tDYWxsZWQpIHJldHVybiAvLyBQcmludCBhIHdhcm5pbmcgbWF5YmU/XG4gICAgICBzZWxmLl9jYWxsYmFja0NhbGxlZCA9IHRydWVcbiAgICAgIHNlbGYuX2NhbGxiYWNrLmFwcGx5KHNlbGYsIGFyZ3VtZW50cylcbiAgICB9XG4gICAgc2VsZi5vbignZXJyb3InLCBzZWxmLmNhbGxiYWNrLmJpbmQoKSlcbiAgICBzZWxmLm9uKCdjb21wbGV0ZScsIHNlbGYuY2FsbGJhY2suYmluZChzZWxmLCBudWxsKSlcbiAgfVxuXG4gIGlmIChzZWxmLnVybCAmJiAhc2VsZi51cmkpIHtcbiAgICAvLyBQZW9wbGUgdXNlIHRoaXMgcHJvcGVydHkgaW5zdGVhZCBhbGwgdGhlIHRpbWUgc28gd2h5IG5vdCBqdXN0IHN1cHBvcnQgaXQuXG4gICAgc2VsZi51cmkgPSBzZWxmLnVybFxuICAgIGRlbGV0ZSBzZWxmLnVybFxuICB9XG5cbiAgaWYgKCFzZWxmLnVyaSkge1xuICAgIC8vIHRoaXMgd2lsbCB0aHJvdyBpZiB1bmhhbmRsZWQgYnV0IGlzIGhhbmRsZWFibGUgd2hlbiBpbiBhIHJlZGlyZWN0XG4gICAgcmV0dXJuIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoXCJvcHRpb25zLnVyaSBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50XCIpKVxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2Ygc2VsZi51cmkgPT0gXCJzdHJpbmdcIikgc2VsZi51cmkgPSB1cmwucGFyc2Uoc2VsZi51cmkpXG4gIH1cblxuICBpZiAoc2VsZi5zdHJpY3RTU0wgPT09IGZhbHNlKSB7XG4gICAgc2VsZi5yZWplY3RVbmF1dGhvcml6ZWQgPSBmYWxzZVxuICB9XG5cbiAgaWYgKHNlbGYucHJveHkpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYucHJveHkgPT0gJ3N0cmluZycpIHNlbGYucHJveHkgPSB1cmwucGFyc2Uoc2VsZi5wcm94eSlcblxuICAgIC8vIGRvIHRoZSBIVFRQIENPTk5FQ1QgZGFuY2UgdXNpbmcga29pY2hpay9ub2RlLXR1bm5lbFxuICAgIGlmIChodHRwLmdsb2JhbEFnZW50ICYmIHNlbGYudXJpLnByb3RvY29sID09PSBcImh0dHBzOlwiKSB7XG4gICAgICB2YXIgdHVubmVsRm4gPSBzZWxmLnByb3h5LnByb3RvY29sID09PSBcImh0dHA6XCJcbiAgICAgICAgICAgICAgICAgICA/IHR1bm5lbC5odHRwc092ZXJIdHRwIDogdHVubmVsLmh0dHBzT3Zlckh0dHBzXG5cbiAgICAgIHZhciB0dW5uZWxPcHRpb25zID0geyBwcm94eTogeyBob3N0OiBzZWxmLnByb3h5Lmhvc3RuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgcG9ydDogK3NlbGYucHJveHkucG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHByb3h5QXV0aDogc2VsZi5wcm94eS5hdXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgaGVhZGVyczogeyBIb3N0OiBzZWxmLnVyaS5ob3N0bmFtZSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNlbGYudXJpLnBvcnQgfHwgc2VsZi51cmkucHJvdG9jb2wgPT09ICdodHRwczonID8gNDQzIDogODApIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICwgcmVqZWN0VW5hdXRob3JpemVkOiBzZWxmLnJlamVjdFVuYXV0aG9yaXplZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAsIGNhOiB0aGlzLmNhIH1cblxuICAgICAgc2VsZi5hZ2VudCA9IHR1bm5lbEZuKHR1bm5lbE9wdGlvbnMpXG4gICAgICBzZWxmLnR1bm5lbCA9IHRydWVcbiAgICB9XG4gIH1cblxuICBpZiAoIXNlbGYudXJpLmhvc3QgfHwgIXNlbGYudXJpLnBhdGhuYW1lKSB7XG4gICAgLy8gSW52YWxpZCBVUkk6IGl0IG1heSBnZW5lcmF0ZSBsb3Qgb2YgYmFkIGVycm9ycywgbGlrZSBcIlR5cGVFcnJvcjogQ2Fubm90IGNhbGwgbWV0aG9kICdpbmRleE9mJyBvZiB1bmRlZmluZWRcIiBpbiBDb29raWVKYXJcbiAgICAvLyBEZXRlY3QgYW5kIHJlamVjdCBpdCBhcyBzb29uIGFzIHBvc3NpYmxlXG4gICAgdmFyIGZhdWx0eVVyaSA9IHVybC5mb3JtYXQoc2VsZi51cmkpXG4gICAgdmFyIG1lc3NhZ2UgPSAnSW52YWxpZCBVUkkgXCInICsgZmF1bHR5VXJpICsgJ1wiJ1xuICAgIGlmIChPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vIG9wdGlvbiA/IFRoaXMgY2FuIGJlIHRoZSBzaWduIG9mIGEgcmVkaXJlY3RcbiAgICAgIC8vIEFzIHRoaXMgaXMgYSBjYXNlIHdoZXJlIHRoZSB1c2VyIGNhbm5vdCBkbyBhbnl0aGluZyAoaGUgZGlkbid0IGNhbGwgcmVxdWVzdCBkaXJlY3RseSB3aXRoIHRoaXMgVVJMKVxuICAgICAgLy8gaGUgc2hvdWxkIGJlIHdhcm5lZCB0aGF0IGl0IGNhbiBiZSBjYXVzZWQgYnkgYSByZWRpcmVjdGlvbiAoY2FuIHNhdmUgc29tZSBoYWlyKVxuICAgICAgbWVzc2FnZSArPSAnLiBUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSBjcmFwcHkgcmVkaXJlY3Rpb24uJ1xuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKG1lc3NhZ2UpKVxuICAgIHJldHVybiAvLyBUaGlzIGVycm9yIHdhcyBmYXRhbFxuICB9XG5cbiAgc2VsZi5fcmVkaXJlY3RzRm9sbG93ZWQgPSBzZWxmLl9yZWRpcmVjdHNGb2xsb3dlZCB8fCAwXG4gIHNlbGYubWF4UmVkaXJlY3RzID0gKHNlbGYubWF4UmVkaXJlY3RzICE9PSB1bmRlZmluZWQpID8gc2VsZi5tYXhSZWRpcmVjdHMgOiAxMFxuICBzZWxmLmZvbGxvd1JlZGlyZWN0ID0gKHNlbGYuZm9sbG93UmVkaXJlY3QgIT09IHVuZGVmaW5lZCkgPyBzZWxmLmZvbGxvd1JlZGlyZWN0IDogdHJ1ZVxuICBzZWxmLmZvbGxvd0FsbFJlZGlyZWN0cyA9IChzZWxmLmZvbGxvd0FsbFJlZGlyZWN0cyAhPT0gdW5kZWZpbmVkKSA/IHNlbGYuZm9sbG93QWxsUmVkaXJlY3RzIDogZmFsc2VcbiAgaWYgKHNlbGYuZm9sbG93UmVkaXJlY3QgfHwgc2VsZi5mb2xsb3dBbGxSZWRpcmVjdHMpXG4gICAgc2VsZi5yZWRpcmVjdHMgPSBzZWxmLnJlZGlyZWN0cyB8fCBbXVxuXG4gIHNlbGYuaGVhZGVycyA9IHNlbGYuaGVhZGVycyA/IGNvcHkoc2VsZi5oZWFkZXJzKSA6IHt9XG5cbiAgc2VsZi5zZXRIb3N0ID0gZmFsc2VcbiAgaWYgKCEoc2VsZi5oZWFkZXJzLmhvc3QgfHwgc2VsZi5oZWFkZXJzLkhvc3QpKSB7XG4gICAgc2VsZi5oZWFkZXJzLmhvc3QgPSBzZWxmLnVyaS5ob3N0bmFtZVxuICAgIGlmIChzZWxmLnVyaS5wb3J0KSB7XG4gICAgICBpZiAoICEoc2VsZi51cmkucG9ydCA9PT0gODAgJiYgc2VsZi51cmkucHJvdG9jb2wgPT09ICdodHRwOicpICYmXG4gICAgICAgICAgICEoc2VsZi51cmkucG9ydCA9PT0gNDQzICYmIHNlbGYudXJpLnByb3RvY29sID09PSAnaHR0cHM6JykgKVxuICAgICAgc2VsZi5oZWFkZXJzLmhvc3QgKz0gKCc6JytzZWxmLnVyaS5wb3J0KVxuICAgIH1cbiAgICBzZWxmLnNldEhvc3QgPSB0cnVlXG4gIH1cblxuICBzZWxmLmphcihzZWxmLl9qYXIgfHwgb3B0aW9ucy5qYXIpXG5cbiAgaWYgKCFzZWxmLnVyaS5wYXRobmFtZSkge3NlbGYudXJpLnBhdGhuYW1lID0gJy8nfVxuICBpZiAoIXNlbGYudXJpLnBvcnQpIHtcbiAgICBpZiAoc2VsZi51cmkucHJvdG9jb2wgPT0gJ2h0dHA6Jykge3NlbGYudXJpLnBvcnQgPSA4MH1cbiAgICBlbHNlIGlmIChzZWxmLnVyaS5wcm90b2NvbCA9PSAnaHR0cHM6Jykge3NlbGYudXJpLnBvcnQgPSA0NDN9XG4gIH1cblxuICBpZiAoc2VsZi5wcm94eSAmJiAhc2VsZi50dW5uZWwpIHtcbiAgICBzZWxmLnBvcnQgPSBzZWxmLnByb3h5LnBvcnRcbiAgICBzZWxmLmhvc3QgPSBzZWxmLnByb3h5Lmhvc3RuYW1lXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5wb3J0ID0gc2VsZi51cmkucG9ydFxuICAgIHNlbGYuaG9zdCA9IHNlbGYudXJpLmhvc3RuYW1lXG4gIH1cblxuICBzZWxmLmNsaWVudEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIGlmIChzZWxmLl9hYm9ydGVkKSByZXR1cm5cblxuICAgIGlmIChzZWxmLnJlcSAmJiBzZWxmLnJlcS5fcmV1c2VkU29ja2V0ICYmIGVycm9yLmNvZGUgPT09ICdFQ09OTlJFU0VUJ1xuICAgICAgICAmJiBzZWxmLmFnZW50LmFkZFJlcXVlc3ROb3JldXNlKSB7XG4gICAgICBzZWxmLmFnZW50ID0geyBhZGRSZXF1ZXN0OiBzZWxmLmFnZW50LmFkZFJlcXVlc3ROb3JldXNlLmJpbmQoc2VsZi5hZ2VudCkgfVxuICAgICAgc2VsZi5zdGFydCgpXG4gICAgICBzZWxmLnJlcS5lbmQoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChzZWxmLnRpbWVvdXQgJiYgc2VsZi50aW1lb3V0VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChzZWxmLnRpbWVvdXRUaW1lcilcbiAgICAgIHNlbGYudGltZW91dFRpbWVyID0gbnVsbFxuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyb3IpXG4gIH1cblxuICBzZWxmLl9wYXJzZXJFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBpZiAodGhpcy5yZXMpIHtcbiAgICAgIGlmICh0aGlzLnJlcy5yZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMucmVzLnJlcXVlc3QuZW1pdCgnZXJyb3InLCBlcnJvcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVzLmVtaXQoJ2Vycm9yJywgZXJyb3IpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2h0dHBNZXNzYWdlLmVtaXQoJ2Vycm9yJywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuZm9ybSkge1xuICAgIHNlbGYuZm9ybShvcHRpb25zLmZvcm0pXG4gIH1cblxuICBpZiAob3B0aW9ucy5xcykgc2VsZi5xcyhvcHRpb25zLnFzKVxuXG4gIGlmIChzZWxmLnVyaS5wYXRoKSB7XG4gICAgc2VsZi5wYXRoID0gc2VsZi51cmkucGF0aFxuICB9IGVsc2Uge1xuICAgIHNlbGYucGF0aCA9IHNlbGYudXJpLnBhdGhuYW1lICsgKHNlbGYudXJpLnNlYXJjaCB8fCBcIlwiKVxuICB9XG5cbiAgaWYgKHNlbGYucGF0aC5sZW5ndGggPT09IDApIHNlbGYucGF0aCA9ICcvJ1xuXG5cbiAgLy8gQXV0aCBtdXN0IGhhcHBlbiBsYXN0IGluIGNhc2Ugc2lnbmluZyBpcyBkZXBlbmRlbnQgb24gb3RoZXIgaGVhZGVyc1xuICBpZiAob3B0aW9ucy5vYXV0aCkge1xuICAgIHNlbGYub2F1dGgob3B0aW9ucy5vYXV0aClcbiAgfVxuXG4gIGlmIChvcHRpb25zLmF3cykge1xuICAgIHNlbGYuYXdzKG9wdGlvbnMuYXdzKVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGF3aykge1xuICAgIHNlbGYuaGF3ayhvcHRpb25zLmhhd2spXG4gIH1cblxuICBpZiAob3B0aW9ucy5odHRwU2lnbmF0dXJlKSB7XG4gICAgc2VsZi5odHRwU2lnbmF0dXJlKG9wdGlvbnMuaHR0cFNpZ25hdHVyZSlcbiAgfVxuXG4gIGlmIChvcHRpb25zLmF1dGgpIHtcbiAgICBzZWxmLmF1dGgoXG4gICAgICAob3B0aW9ucy5hdXRoLnVzZXI9PT1cIlwiKSA/IG9wdGlvbnMuYXV0aC51c2VyIDogKG9wdGlvbnMuYXV0aC51c2VyIHx8IG9wdGlvbnMuYXV0aC51c2VybmFtZSApLFxuICAgICAgb3B0aW9ucy5hdXRoLnBhc3MgfHwgb3B0aW9ucy5hdXRoLnBhc3N3b3JkLFxuICAgICAgb3B0aW9ucy5hdXRoLnNlbmRJbW1lZGlhdGVseSlcbiAgfVxuXG4gIGlmIChzZWxmLnVyaS5hdXRoICYmICFzZWxmLmhlYWRlcnMuYXV0aG9yaXphdGlvbikge1xuICAgIHZhciBhdXRoUGllY2VzID0gc2VsZi51cmkuYXV0aC5zcGxpdCgnOicpLm1hcChmdW5jdGlvbihpdGVtKXsgcmV0dXJuIHF1ZXJ5c3RyaW5nLnVuZXNjYXBlKGl0ZW0pIH0pXG4gICAgc2VsZi5hdXRoKGF1dGhQaWVjZXNbMF0sIGF1dGhQaWVjZXMuc2xpY2UoMSkuam9pbignOicpLCB0cnVlKVxuICB9XG4gIGlmIChzZWxmLnByb3h5ICYmIHNlbGYucHJveHkuYXV0aCAmJiAhc2VsZi5oZWFkZXJzWydwcm94eS1hdXRob3JpemF0aW9uJ10gJiYgIXNlbGYudHVubmVsKSB7XG4gICAgc2VsZi5oZWFkZXJzWydwcm94eS1hdXRob3JpemF0aW9uJ10gPSBcIkJhc2ljIFwiICsgdG9CYXNlNjQoc2VsZi5wcm94eS5hdXRoLnNwbGl0KCc6JykubWFwKGZ1bmN0aW9uKGl0ZW0peyByZXR1cm4gcXVlcnlzdHJpbmcudW5lc2NhcGUoaXRlbSl9KS5qb2luKCc6JykpXG4gIH1cblxuXG4gIGlmIChzZWxmLnByb3h5ICYmICFzZWxmLnR1bm5lbCkgc2VsZi5wYXRoID0gKHNlbGYudXJpLnByb3RvY29sICsgJy8vJyArIHNlbGYudXJpLmhvc3QgKyBzZWxmLnBhdGgpXG5cbiAgaWYgKG9wdGlvbnMuanNvbikge1xuICAgIHNlbGYuanNvbihvcHRpb25zLmpzb24pXG4gIH0gZWxzZSBpZiAob3B0aW9ucy5tdWx0aXBhcnQpIHtcbiAgICBzZWxmLmJvdW5kYXJ5ID0gdXVpZCgpXG4gICAgc2VsZi5tdWx0aXBhcnQob3B0aW9ucy5tdWx0aXBhcnQpXG4gIH1cblxuICBpZiAoc2VsZi5ib2R5KSB7XG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihzZWxmLmJvZHkpKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxmLmJvZHkpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGVuZ3RoICs9IHNlbGYuYm9keVtpXS5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5ib2R5ID0gbmV3IEJ1ZmZlcihzZWxmLmJvZHkpXG4gICAgICAgIGxlbmd0aCA9IHNlbGYuYm9keS5sZW5ndGhcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gc2VsZi5ib2R5Lmxlbmd0aFxuICAgIH1cbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBpZighc2VsZi5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddICYmICFzZWxmLmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10pXG4gICAgICBzZWxmLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gPSBsZW5ndGhcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCBlcnJvciwgb3B0aW9ucy5ib2R5LicpXG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvY29sID0gc2VsZi5wcm94eSAmJiAhc2VsZi50dW5uZWwgPyBzZWxmLnByb3h5LnByb3RvY29sIDogc2VsZi51cmkucHJvdG9jb2xcbiAgICAsIGRlZmF1bHRNb2R1bGVzID0geydodHRwOic6aHR0cCwgJ2h0dHBzOic6aHR0cHN9XG4gICAgLCBodHRwTW9kdWxlcyA9IHNlbGYuaHR0cE1vZHVsZXMgfHwge31cbiAgICA7XG4gIHNlbGYuaHR0cE1vZHVsZSA9IGh0dHBNb2R1bGVzW3Byb3RvY29sXSB8fCBkZWZhdWx0TW9kdWxlc1twcm90b2NvbF1cblxuICBpZiAoIXNlbGYuaHR0cE1vZHVsZSkgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3RvY29sXCIpKVxuXG4gIGlmIChvcHRpb25zLmNhKSBzZWxmLmNhID0gb3B0aW9ucy5jYVxuXG4gIGlmICghc2VsZi5hZ2VudCkge1xuICAgIGlmIChvcHRpb25zLmFnZW50T3B0aW9ucykgc2VsZi5hZ2VudE9wdGlvbnMgPSBvcHRpb25zLmFnZW50T3B0aW9uc1xuXG4gICAgaWYgKG9wdGlvbnMuYWdlbnRDbGFzcykge1xuICAgICAgc2VsZi5hZ2VudENsYXNzID0gb3B0aW9ucy5hZ2VudENsYXNzXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmZvcmV2ZXIpIHtcbiAgICAgIHNlbGYuYWdlbnRDbGFzcyA9IHByb3RvY29sID09PSAnaHR0cDonID8gRm9yZXZlckFnZW50IDogRm9yZXZlckFnZW50LlNTTFxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmFnZW50Q2xhc3MgPSBzZWxmLmh0dHBNb2R1bGUuQWdlbnRcbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZi5wb29sID09PSBmYWxzZSkge1xuICAgIHNlbGYuYWdlbnQgPSBmYWxzZVxuICB9IGVsc2Uge1xuICAgIHNlbGYuYWdlbnQgPSBzZWxmLmFnZW50IHx8IHNlbGYuZ2V0QWdlbnQoKVxuICAgIGlmIChzZWxmLm1heFNvY2tldHMpIHtcbiAgICAgIC8vIERvbid0IHVzZSBvdXIgcG9vbGluZyBpZiBub2RlIGhhcyB0aGUgcmVmYWN0b3JlZCBjbGllbnRcbiAgICAgIHNlbGYuYWdlbnQubWF4U29ja2V0cyA9IHNlbGYubWF4U29ja2V0c1xuICAgIH1cbiAgICBpZiAoc2VsZi5wb29sLm1heFNvY2tldHMpIHtcbiAgICAgIC8vIERvbid0IHVzZSBvdXIgcG9vbGluZyBpZiBub2RlIGhhcyB0aGUgcmVmYWN0b3JlZCBjbGllbnRcbiAgICAgIHNlbGYuYWdlbnQubWF4U29ja2V0cyA9IHNlbGYucG9vbC5tYXhTb2NrZXRzXG4gICAgfVxuICB9XG5cbiAgc2VsZi5vbigncGlwZScsIGZ1bmN0aW9uIChzcmMpIHtcbiAgICBpZiAoc2VsZi5udGljayAmJiBzZWxmLl9zdGFydGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2Fubm90IHBpcGUgdG8gdGhpcyBzdHJlYW0gYWZ0ZXIgdGhlIG91dGJvdW5kIHJlcXVlc3QgaGFzIHN0YXJ0ZWQuXCIpXG4gICAgc2VsZi5zcmMgPSBzcmNcbiAgICBpZiAoaXNSZWFkU3RyZWFtKHNyYykpIHtcbiAgICAgIGlmICghc2VsZi5oZWFkZXJzWydjb250ZW50LXR5cGUnXSAmJiAhc2VsZi5oZWFkZXJzWydDb250ZW50LVR5cGUnXSlcbiAgICAgICAgc2VsZi5oZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IG1pbWUubG9va3VwKHNyYy5wYXRoKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3JjLmhlYWRlcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBzcmMuaGVhZGVycykge1xuICAgICAgICAgIGlmICghc2VsZi5oZWFkZXJzW2ldKSB7XG4gICAgICAgICAgICBzZWxmLmhlYWRlcnNbaV0gPSBzcmMuaGVhZGVyc1tpXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlbGYuX2pzb24gJiYgIXNlbGYuaGVhZGVyc1snY29udGVudC10eXBlJ10gJiYgIXNlbGYuaGVhZGVyc1snQ29udGVudC1UeXBlJ10pXG4gICAgICAgIHNlbGYuaGVhZGVyc1snY29udGVudC10eXBlJ10gPSAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIGlmIChzcmMubWV0aG9kICYmICFzZWxmLmV4cGxpY2l0TWV0aG9kKSB7XG4gICAgICAgIHNlbGYubWV0aG9kID0gc3JjLm1ldGhvZFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNlbGYub24oJ3BpcGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgLy8gICBjb25zb2xlLmVycm9yKFwiWW91IGhhdmUgYWxyZWFkeSBwaXBlZCB0byB0aGlzIHN0cmVhbS4gUGlwZWluZyB0d2ljZSBpcyBsaWtlbHkgdG8gYnJlYWsgdGhlIHJlcXVlc3QuXCIpXG4gICAgLy8gfSlcbiAgfSlcblxuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5fYWJvcnRlZCkgcmV0dXJuXG5cbiAgICBpZiAoc2VsZi5fZm9ybSkge1xuICAgICAgc2VsZi5zZXRIZWFkZXJzKHNlbGYuX2Zvcm0uZ2V0SGVhZGVycygpKVxuICAgICAgc2VsZi5fZm9ybS5waXBlKHNlbGYpXG4gICAgfVxuICAgIGlmIChzZWxmLmJvZHkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGYuYm9keSkpIHtcbiAgICAgICAgc2VsZi5ib2R5LmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgICBzZWxmLndyaXRlKHBhcnQpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLndyaXRlKHNlbGYuYm9keSlcbiAgICAgIH1cbiAgICAgIHNlbGYuZW5kKClcbiAgICB9IGVsc2UgaWYgKHNlbGYucmVxdWVzdEJvZHlTdHJlYW0pIHtcbiAgICAgIGNvbnNvbGUud2FybihcIm9wdGlvbnMucmVxdWVzdEJvZHlTdHJlYW0gaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHBhc3MgdGhlIHJlcXVlc3Qgb2JqZWN0IHRvIHN0cmVhbS5waXBlLlwiKVxuICAgICAgc2VsZi5yZXF1ZXN0Qm9keVN0cmVhbS5waXBlKHNlbGYpXG4gICAgfSBlbHNlIGlmICghc2VsZi5zcmMpIHtcbiAgICAgIGlmIChzZWxmLm1ldGhvZCAhPT0gJ0dFVCcgJiYgdHlwZW9mIHNlbGYubWV0aG9kICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzZWxmLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gPSAwXG4gICAgICB9XG4gICAgICBzZWxmLmVuZCgpXG4gICAgfVxuICAgIHNlbGYubnRpY2sgPSB0cnVlXG4gIH0pXG59XG5cbi8vIE11c3QgY2FsbCB0aGlzIHdoZW4gZm9sbG93aW5nIGEgcmVkaXJlY3QgZnJvbSBodHRwcyB0byBodHRwIG9yIHZpY2UgdmVyc2Fcbi8vIEF0dGVtcHRzIHRvIGtlZXAgZXZlcnl0aGluZyBhcyBpZGVudGljYWwgYXMgcG9zc2libGUsIGJ1dCB1cGRhdGUgdGhlXG4vLyBodHRwTW9kdWxlLCBUdW5uZWxpbmcgYWdlbnQsIGFuZC9vciBGb3JldmVyIEFnZW50IGluIHVzZS5cblJlcXVlc3QucHJvdG90eXBlLl91cGRhdGVQcm90b2NvbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBwcm90b2NvbCA9IHNlbGYudXJpLnByb3RvY29sXG5cbiAgaWYgKHByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgIC8vIHByZXZpb3VzbHkgd2FzIGRvaW5nIGh0dHAsIG5vdyBkb2luZyBodHRwc1xuICAgIC8vIGlmIGl0J3MgaHR0cHMsIHRoZW4gd2UgbWlnaHQgbmVlZCB0byB0dW5uZWwgbm93LlxuICAgIGlmIChzZWxmLnByb3h5KSB7XG4gICAgICBzZWxmLnR1bm5lbCA9IHRydWVcbiAgICAgIHZhciB0dW5uZWxGbiA9IHNlbGYucHJveHkucHJvdG9jb2wgPT09ICdodHRwOidcbiAgICAgICAgICAgICAgICAgICA/IHR1bm5lbC5odHRwc092ZXJIdHRwIDogdHVubmVsLmh0dHBzT3Zlckh0dHBzXG4gICAgICB2YXIgdHVubmVsT3B0aW9ucyA9IHsgcHJveHk6IHsgaG9zdDogc2VsZi5wcm94eS5ob3N0bmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHBvcnQ6ICtzZWxmLnByb3h5LnBvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBwcm94eUF1dGg6IHNlbGYucHJveHkuYXV0aCB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICwgcmVqZWN0VW5hdXRob3JpemVkOiBzZWxmLnJlamVjdFVuYXV0aG9yaXplZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAsIGNhOiBzZWxmLmNhIH1cbiAgICAgIHNlbGYuYWdlbnQgPSB0dW5uZWxGbih0dW5uZWxPcHRpb25zKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc2VsZi5odHRwTW9kdWxlID0gaHR0cHNcbiAgICBzd2l0Y2ggKHNlbGYuYWdlbnRDbGFzcykge1xuICAgICAgY2FzZSBGb3JldmVyQWdlbnQ6XG4gICAgICAgIHNlbGYuYWdlbnRDbGFzcyA9IEZvcmV2ZXJBZ2VudC5TU0xcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgaHR0cC5BZ2VudDpcbiAgICAgICAgc2VsZi5hZ2VudENsYXNzID0gaHR0cHMuQWdlbnRcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIG5vdGhpbmcgd2UgY2FuIGRvLiAgSnVzdCBob3BlIGZvciB0aGUgYmVzdC5cbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gaWYgdGhlcmUncyBhbiBhZ2VudCwgd2UgbmVlZCB0byBnZXQgYSBuZXcgb25lLlxuICAgIGlmIChzZWxmLmFnZW50KSBzZWxmLmFnZW50ID0gc2VsZi5nZXRBZ2VudCgpXG5cbiAgfSBlbHNlIHtcbiAgICAvLyBwcmV2aW91c2x5IHdhcyBkb2luZyBodHRwcywgbm93IGRvaW5nIGh0dHBcbiAgICAvLyBzdG9wIGFueSB0dW5uZWxpbmcuXG4gICAgaWYgKHNlbGYudHVubmVsKSBzZWxmLnR1bm5lbCA9IGZhbHNlXG4gICAgc2VsZi5odHRwTW9kdWxlID0gaHR0cFxuICAgIHN3aXRjaCAoc2VsZi5hZ2VudENsYXNzKSB7XG4gICAgICBjYXNlIEZvcmV2ZXJBZ2VudC5TU0w6XG4gICAgICAgIHNlbGYuYWdlbnRDbGFzcyA9IEZvcmV2ZXJBZ2VudFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBodHRwcy5BZ2VudDpcbiAgICAgICAgc2VsZi5hZ2VudENsYXNzID0gaHR0cC5BZ2VudFxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gbm90aGluZyB3ZSBjYW4gZG8uICBqdXN0IGhvcGUgZm9yIHRoZSBiZXN0XG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGlmIHRoZXJlJ3MgYW4gYWdlbnQsIHRoZW4gZ2V0IGEgbmV3IG9uZS5cbiAgICBpZiAoc2VsZi5hZ2VudCkge1xuICAgICAgc2VsZi5hZ2VudCA9IG51bGxcbiAgICAgIHNlbGYuYWdlbnQgPSBzZWxmLmdldEFnZW50KClcbiAgICB9XG4gIH1cbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuZ2V0QWdlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBBZ2VudCA9IHRoaXMuYWdlbnRDbGFzc1xuICB2YXIgb3B0aW9ucyA9IHt9XG4gIGlmICh0aGlzLmFnZW50T3B0aW9ucykge1xuICAgIGZvciAodmFyIGkgaW4gdGhpcy5hZ2VudE9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnNbaV0gPSB0aGlzLmFnZW50T3B0aW9uc1tpXVxuICAgIH1cbiAgfVxuICBpZiAodGhpcy5jYSkgb3B0aW9ucy5jYSA9IHRoaXMuY2FcbiAgaWYgKHR5cGVvZiB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCAhPT0gJ3VuZGVmaW5lZCcpIG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWRcblxuICBpZiAodGhpcy5jZXJ0ICYmIHRoaXMua2V5KSB7XG4gICAgb3B0aW9ucy5rZXkgPSB0aGlzLmtleVxuICAgIG9wdGlvbnMuY2VydCA9IHRoaXMuY2VydFxuICB9XG5cbiAgdmFyIHBvb2xLZXkgPSAnJ1xuXG4gIC8vIGRpZmZlcmVudCB0eXBlcyBvZiBhZ2VudHMgYXJlIGluIGRpZmZlcmVudCBwb29sc1xuICBpZiAoQWdlbnQgIT09IHRoaXMuaHR0cE1vZHVsZS5BZ2VudCkge1xuICAgIHBvb2xLZXkgKz0gQWdlbnQubmFtZVxuICB9XG5cbiAgaWYgKCF0aGlzLmh0dHBNb2R1bGUuZ2xvYmFsQWdlbnQpIHtcbiAgICAvLyBub2RlIDAuNC54XG4gICAgb3B0aW9ucy5ob3N0ID0gdGhpcy5ob3N0XG4gICAgb3B0aW9ucy5wb3J0ID0gdGhpcy5wb3J0XG4gICAgaWYgKHBvb2xLZXkpIHBvb2xLZXkgKz0gJzonXG4gICAgcG9vbEtleSArPSB0aGlzLmhvc3QgKyAnOicgKyB0aGlzLnBvcnRcbiAgfVxuXG4gIC8vIGNhIG9wdGlvbiBpcyBvbmx5IHJlbGV2YW50IGlmIHByb3h5IG9yIGRlc3RpbmF0aW9uIGFyZSBodHRwc1xuICB2YXIgcHJveHkgPSB0aGlzLnByb3h5XG4gIGlmICh0eXBlb2YgcHJveHkgPT09ICdzdHJpbmcnKSBwcm94eSA9IHVybC5wYXJzZShwcm94eSlcbiAgdmFyIGlzSHR0cHMgPSAocHJveHkgJiYgcHJveHkucHJvdG9jb2wgPT09ICdodHRwczonKSB8fCB0aGlzLnVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzOidcbiAgaWYgKGlzSHR0cHMpIHtcbiAgICBpZiAob3B0aW9ucy5jYSkge1xuICAgICAgaWYgKHBvb2xLZXkpIHBvb2xLZXkgKz0gJzonXG4gICAgICBwb29sS2V5ICs9IG9wdGlvbnMuY2FcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHBvb2xLZXkpIHBvb2xLZXkgKz0gJzonXG4gICAgICBwb29sS2V5ICs9IG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY2VydClcbiAgICAgIHBvb2xLZXkgKz0gb3B0aW9ucy5jZXJ0LnRvU3RyaW5nKCdhc2NpaScpICsgb3B0aW9ucy5rZXkudG9TdHJpbmcoJ2FzY2lpJylcblxuICAgIGlmIChvcHRpb25zLmNpcGhlcnMpIHtcbiAgICAgIGlmIChwb29sS2V5KSBwb29sS2V5ICs9ICc6J1xuICAgICAgcG9vbEtleSArPSBvcHRpb25zLmNpcGhlcnNcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zZWN1cmVPcHRpb25zKSB7XG4gICAgICBpZiAocG9vbEtleSkgcG9vbEtleSArPSAnOidcbiAgICAgIHBvb2xLZXkgKz0gb3B0aW9ucy5zZWN1cmVPcHRpb25zXG4gICAgfVxuICB9XG5cbiAgaWYgKCFwb29sS2V5ICYmIE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmh0dHBNb2R1bGUuZ2xvYmFsQWdlbnQpIHtcbiAgICAvLyBub3QgZG9pbmcgYW55dGhpbmcgc3BlY2lhbC4gIFVzZSB0aGUgZ2xvYmFsQWdlbnRcbiAgICByZXR1cm4gdGhpcy5odHRwTW9kdWxlLmdsb2JhbEFnZW50XG4gIH1cblxuICAvLyB3ZSdyZSB1c2luZyBhIHN0b3JlZCBhZ2VudC4gIE1ha2Ugc3VyZSBpdCdzIHByb3RvY29sLXNwZWNpZmljXG4gIHBvb2xLZXkgPSB0aGlzLnVyaS5wcm90b2NvbCArIHBvb2xLZXlcblxuICAvLyBhbHJlYWR5IGdlbmVyYXRlZCBhbiBhZ2VudCBmb3IgdGhpcyBzZXR0aW5nXG4gIGlmICh0aGlzLnBvb2xbcG9vbEtleV0pIHJldHVybiB0aGlzLnBvb2xbcG9vbEtleV1cblxuICByZXR1cm4gdGhpcy5wb29sW3Bvb2xLZXldID0gbmV3IEFnZW50KG9wdGlvbnMpXG59XG5cblJlcXVlc3QucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBzdGFydCgpIGlzIGNhbGxlZCBvbmNlIHdlIGFyZSByZWFkeSB0byBzZW5kIHRoZSBvdXRnb2luZyBIVFRQIHJlcXVlc3QuXG4gIC8vIHRoaXMgaXMgdXN1YWxseSBjYWxsZWQgb24gdGhlIGZpcnN0IHdyaXRlKCksIGVuZCgpIG9yIG9uIG5leHRUaWNrKClcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgaWYgKHNlbGYuX2Fib3J0ZWQpIHJldHVyblxuXG4gIHNlbGYuX3N0YXJ0ZWQgPSB0cnVlXG4gIHNlbGYubWV0aG9kID0gc2VsZi5tZXRob2QgfHwgJ0dFVCdcbiAgc2VsZi5ocmVmID0gc2VsZi51cmkuaHJlZlxuXG4gIGlmIChzZWxmLnNyYyAmJiBzZWxmLnNyYy5zdGF0ICYmIHNlbGYuc3JjLnN0YXQuc2l6ZSAmJiAhc2VsZi5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddICYmICFzZWxmLmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10pIHtcbiAgICBzZWxmLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gPSBzZWxmLnNyYy5zdGF0LnNpemVcbiAgfVxuICBpZiAoc2VsZi5fYXdzKSB7XG4gICAgc2VsZi5hd3Moc2VsZi5fYXdzLCB0cnVlKVxuICB9XG5cbiAgLy8gV2UgaGF2ZSBhIG1ldGhvZCBuYW1lZCBhdXRoLCB3aGljaCBpcyBjb21wbGV0ZWx5IGRpZmZlcmVudCBmcm9tIHRoZSBodHRwLnJlcXVlc3RcbiAgLy8gYXV0aCBvcHRpb24uICBJZiB3ZSBkb24ndCByZW1vdmUgaXQsIHdlJ3JlIGdvbm5hIGhhdmUgYSBiYWQgdGltZS5cbiAgdmFyIHJlcU9wdGlvbnMgPSBjb3B5KHNlbGYpXG4gIGRlbGV0ZSByZXFPcHRpb25zLmF1dGhcblxuICBkZWJ1ZygnbWFrZSByZXF1ZXN0Jywgc2VsZi51cmkuaHJlZilcbiAgc2VsZi5yZXEgPSBzZWxmLmh0dHBNb2R1bGUucmVxdWVzdChyZXFPcHRpb25zLCBzZWxmLm9uUmVzcG9uc2UuYmluZChzZWxmKSlcblxuICBpZiAoc2VsZi50aW1lb3V0ICYmICFzZWxmLnRpbWVvdXRUaW1lcikge1xuICAgIHNlbGYudGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLnJlcS5hYm9ydCgpXG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcihcIkVUSU1FRE9VVFwiKVxuICAgICAgZS5jb2RlID0gXCJFVElNRURPVVRcIlxuICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZSlcbiAgICB9LCBzZWxmLnRpbWVvdXQpXG5cbiAgICAvLyBTZXQgYWRkaXRpb25hbCB0aW1lb3V0IG9uIHNvY2tldCAtIGluIGNhc2UgaWYgcmVtb3RlXG4gICAgLy8gc2VydmVyIGZyZWV6ZSBhZnRlciBzZW5kaW5nIGhlYWRlcnNcbiAgICBpZiAoc2VsZi5yZXEuc2V0VGltZW91dCkgeyAvLyBvbmx5IHdvcmtzIG9uIG5vZGUgMC42K1xuICAgICAgc2VsZi5yZXEuc2V0VGltZW91dChzZWxmLnRpbWVvdXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNlbGYucmVxKSB7XG4gICAgICAgICAgc2VsZi5yZXEuYWJvcnQoKVxuICAgICAgICAgIHZhciBlID0gbmV3IEVycm9yKFwiRVNPQ0tFVFRJTUVET1VUXCIpXG4gICAgICAgICAgZS5jb2RlID0gXCJFU09DS0VUVElNRURPVVRcIlxuICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgc2VsZi5yZXEub24oJ2Vycm9yJywgc2VsZi5jbGllbnRFcnJvckhhbmRsZXIpXG4gIHNlbGYucmVxLm9uKCdkcmFpbicsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgnZHJhaW4nKVxuICB9KVxuICBzZWxmLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoIHNlbGYucmVxLmNvbm5lY3Rpb24gKSBzZWxmLnJlcS5jb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNlbGYuX3BhcnNlckVycm9ySGFuZGxlcilcbiAgfSlcbiAgc2VsZi5lbWl0KCdyZXF1ZXN0Jywgc2VsZi5yZXEpXG59XG5SZXF1ZXN0LnByb3RvdHlwZS5vblJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBkZWJ1Zygnb25SZXNwb25zZScsIHNlbGYudXJpLmhyZWYsIHJlc3BvbnNlLnN0YXR1c0NvZGUsIHJlc3BvbnNlLmhlYWRlcnMpXG4gIHJlc3BvbnNlLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygncmVzcG9uc2UgZW5kJywgc2VsZi51cmkuaHJlZiwgcmVzcG9uc2Uuc3RhdHVzQ29kZSwgcmVzcG9uc2UuaGVhZGVycylcbiAgfSk7XG5cbiAgaWYgKHJlc3BvbnNlLmNvbm5lY3Rpb24ubGlzdGVuZXJzKCdlcnJvcicpLmluZGV4T2Yoc2VsZi5fcGFyc2VyRXJyb3JIYW5kbGVyKSA9PT0gLTEpIHtcbiAgICByZXNwb25zZS5jb25uZWN0aW9uLm9uY2UoJ2Vycm9yJywgc2VsZi5fcGFyc2VyRXJyb3JIYW5kbGVyKVxuICB9XG4gIGlmIChzZWxmLl9hYm9ydGVkKSB7XG4gICAgZGVidWcoJ2Fib3J0ZWQnLCBzZWxmLnVyaS5ocmVmKVxuICAgIHJlc3BvbnNlLnJlc3VtZSgpXG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHNlbGYuX3BhdXNlZCkgcmVzcG9uc2UucGF1c2UoKVxuICBlbHNlIHJlc3BvbnNlLnJlc3VtZSgpXG5cbiAgc2VsZi5yZXNwb25zZSA9IHJlc3BvbnNlXG4gIHJlc3BvbnNlLnJlcXVlc3QgPSBzZWxmXG4gIHJlc3BvbnNlLnRvSlNPTiA9IHRvSlNPTlxuXG4gIC8vIFhYWCBUaGlzIGlzIGRpZmZlcmVudCBvbiAwLjEwLCBiZWNhdXNlIFNTTCBpcyBzdHJpY3QgYnkgZGVmYXVsdFxuICBpZiAoc2VsZi5odHRwTW9kdWxlID09PSBodHRwcyAmJlxuICAgICAgc2VsZi5zdHJpY3RTU0wgJiZcbiAgICAgICFyZXNwb25zZS5jbGllbnQuYXV0aG9yaXplZCkge1xuICAgIGRlYnVnKCdzdHJpY3Qgc3NsIGVycm9yJywgc2VsZi51cmkuaHJlZilcbiAgICB2YXIgc3NsRXJyID0gcmVzcG9uc2UuY2xpZW50LmF1dGhvcml6YXRpb25FcnJvclxuICAgIHNlbGYuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1NTTCBFcnJvcjogJysgc3NsRXJyKSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChzZWxmLnNldEhvc3QpIGRlbGV0ZSBzZWxmLmhlYWRlcnMuaG9zdFxuICBpZiAoc2VsZi50aW1lb3V0ICYmIHNlbGYudGltZW91dFRpbWVyKSB7XG4gICAgY2xlYXJUaW1lb3V0KHNlbGYudGltZW91dFRpbWVyKVxuICAgIHNlbGYudGltZW91dFRpbWVyID0gbnVsbFxuICB9XG5cbiAgdmFyIGFkZENvb2tpZSA9IGZ1bmN0aW9uIChjb29raWUpIHtcbiAgICBpZiAoc2VsZi5famFyKSBzZWxmLl9qYXIuYWRkKG5ldyBDb29raWUoY29va2llKSlcbiAgICBlbHNlIGNvb2tpZUphci5hZGQobmV3IENvb2tpZShjb29raWUpKVxuICB9XG5cbiAgaWYgKHJlc3BvbnNlLmhlYWRlcnNbJ3NldC1jb29raWUnXSAmJiAoIXNlbGYuX2Rpc2FibGVDb29raWVzKSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3BvbnNlLmhlYWRlcnNbJ3NldC1jb29raWUnXSkpIHJlc3BvbnNlLmhlYWRlcnNbJ3NldC1jb29raWUnXS5mb3JFYWNoKGFkZENvb2tpZSlcbiAgICBlbHNlIGFkZENvb2tpZShyZXNwb25zZS5oZWFkZXJzWydzZXQtY29va2llJ10pXG4gIH1cblxuICB2YXIgcmVkaXJlY3RUbyA9IG51bGxcbiAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gMzAwICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgPCA0MDAgJiYgcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbikge1xuICAgIGRlYnVnKCdyZWRpcmVjdCcsIHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb24pXG5cbiAgICBpZiAoc2VsZi5mb2xsb3dBbGxSZWRpcmVjdHMpIHtcbiAgICAgIHJlZGlyZWN0VG8gPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uXG4gICAgfSBlbHNlIGlmIChzZWxmLmZvbGxvd1JlZGlyZWN0KSB7XG4gICAgICBzd2l0Y2ggKHNlbGYubWV0aG9kKSB7XG4gICAgICAgIGNhc2UgJ1BBVENIJzpcbiAgICAgICAgY2FzZSAnUFVUJzpcbiAgICAgICAgY2FzZSAnUE9TVCc6XG4gICAgICAgIGNhc2UgJ0RFTEVURSc6XG4gICAgICAgICAgLy8gRG8gbm90IGZvbGxvdyByZWRpcmVjdHNcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlZGlyZWN0VG8gPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PSA0MDEgJiYgc2VsZi5faGFzQXV0aCAmJiAhc2VsZi5fc2VudEF1dGgpIHtcbiAgICB2YXIgYXV0aEhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnNbJ3d3dy1hdXRoZW50aWNhdGUnXVxuICAgIHZhciBhdXRoVmVyYiA9IGF1dGhIZWFkZXIgJiYgYXV0aEhlYWRlci5zcGxpdCgnICcpWzBdXG4gICAgZGVidWcoJ3JlYXV0aCcsIGF1dGhWZXJiKVxuXG4gICAgc3dpdGNoIChhdXRoVmVyYikge1xuICAgICAgY2FzZSAnQmFzaWMnOlxuICAgICAgICBzZWxmLmF1dGgoc2VsZi5fdXNlciwgc2VsZi5fcGFzcywgdHJ1ZSlcbiAgICAgICAgcmVkaXJlY3RUbyA9IHNlbGYudXJpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ0RpZ2VzdCc6XG4gICAgICAgIC8vIFRPRE86IE1vcmUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgUkZDIDI2MTcuICBGb3IgcmVmZXJlbmNlOlxuICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyNjE3I3NlY3Rpb24tM1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYmFnZGVyL2N1cmwvYmxvYi9tYXN0ZXIvbGliL2h0dHBfZGlnZXN0LmNcblxuICAgICAgICB2YXIgbWF0Y2hlcyA9IGF1dGhIZWFkZXIubWF0Y2goLyhbYS16MC05Xy1dKyk9XCIoW15cIl0rKVwiL2dpKVxuICAgICAgICB2YXIgY2hhbGxlbmdlID0ge31cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZXFQb3MgPSBtYXRjaGVzW2ldLmluZGV4T2YoJz0nKVxuICAgICAgICAgIHZhciBrZXkgPSBtYXRjaGVzW2ldLnN1YnN0cmluZygwLCBlcVBvcylcbiAgICAgICAgICB2YXIgcXVvdGVkVmFsdWUgPSBtYXRjaGVzW2ldLnN1YnN0cmluZyhlcVBvcyArIDEpXG4gICAgICAgICAgY2hhbGxlbmdlW2tleV0gPSBxdW90ZWRWYWx1ZS5zdWJzdHJpbmcoMSwgcXVvdGVkVmFsdWUubGVuZ3RoIC0gMSlcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYTEgPSBtZDUoc2VsZi5fdXNlciArICc6JyArIGNoYWxsZW5nZS5yZWFsbSArICc6JyArIHNlbGYuX3Bhc3MpXG4gICAgICAgIHZhciBoYTIgPSBtZDUoc2VsZi5tZXRob2QgKyAnOicgKyBzZWxmLnVyaS5wYXRoKVxuICAgICAgICB2YXIgZGlnZXN0UmVzcG9uc2UgPSBtZDUoaGExICsgJzonICsgY2hhbGxlbmdlLm5vbmNlICsgJzoxOjphdXRoOicgKyBoYTIpXG4gICAgICAgIHZhciBhdXRoVmFsdWVzID0ge1xuICAgICAgICAgIHVzZXJuYW1lOiBzZWxmLl91c2VyLFxuICAgICAgICAgIHJlYWxtOiBjaGFsbGVuZ2UucmVhbG0sXG4gICAgICAgICAgbm9uY2U6IGNoYWxsZW5nZS5ub25jZSxcbiAgICAgICAgICB1cmk6IHNlbGYudXJpLnBhdGgsXG4gICAgICAgICAgcW9wOiBjaGFsbGVuZ2UucW9wLFxuICAgICAgICAgIHJlc3BvbnNlOiBkaWdlc3RSZXNwb25zZSxcbiAgICAgICAgICBuYzogMSxcbiAgICAgICAgICBjbm9uY2U6ICcnXG4gICAgICAgIH1cblxuICAgICAgICBhdXRoSGVhZGVyID0gW11cbiAgICAgICAgZm9yICh2YXIgayBpbiBhdXRoVmFsdWVzKSB7XG4gICAgICAgICAgYXV0aEhlYWRlci5wdXNoKGsgKyAnPVwiJyArIGF1dGhWYWx1ZXNba10gKyAnXCInKVxuICAgICAgICB9XG4gICAgICAgIGF1dGhIZWFkZXIgPSAnRGlnZXN0ICcgKyBhdXRoSGVhZGVyLmpvaW4oJywgJylcbiAgICAgICAgc2VsZi5zZXRIZWFkZXIoJ2F1dGhvcml6YXRpb24nLCBhdXRoSGVhZGVyKVxuICAgICAgICBzZWxmLl9zZW50QXV0aCA9IHRydWVcblxuICAgICAgICByZWRpcmVjdFRvID0gc2VsZi51cmlcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAocmVkaXJlY3RUbykge1xuICAgIGRlYnVnKCdyZWRpcmVjdCB0bycsIHJlZGlyZWN0VG8pXG5cbiAgICAvLyBpZ25vcmUgYW55IHBvdGVudGlhbCByZXNwb25zZSBib2R5LiAgaXQgY2Fubm90IHBvc3NpYmx5IGJlIHVzZWZ1bFxuICAgIC8vIHRvIHVzIGF0IHRoaXMgcG9pbnQuXG4gICAgaWYgKHNlbGYuX3BhdXNlZCkgcmVzcG9uc2UucmVzdW1lKClcblxuICAgIGlmIChzZWxmLl9yZWRpcmVjdHNGb2xsb3dlZCA+PSBzZWxmLm1heFJlZGlyZWN0cykge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihcIkV4Y2VlZGVkIG1heFJlZGlyZWN0cy4gUHJvYmFibHkgc3R1Y2sgaW4gYSByZWRpcmVjdCBsb29wIFwiK3NlbGYudXJpLmhyZWYpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlbGYuX3JlZGlyZWN0c0ZvbGxvd2VkICs9IDFcblxuICAgIGlmICghaXNVcmwudGVzdChyZWRpcmVjdFRvKSkge1xuICAgICAgcmVkaXJlY3RUbyA9IHVybC5yZXNvbHZlKHNlbGYudXJpLmhyZWYsIHJlZGlyZWN0VG8pXG4gICAgfVxuXG4gICAgdmFyIHVyaVByZXYgPSBzZWxmLnVyaVxuICAgIHNlbGYudXJpID0gdXJsLnBhcnNlKHJlZGlyZWN0VG8pXG5cbiAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgY2hhbmdlIHByb3RvY29sIGZyb20gaHR0cHMgdG8gaHR0cCBvciB2aWNlIHZlcnNhXG4gICAgaWYgKHNlbGYudXJpLnByb3RvY29sICE9PSB1cmlQcmV2LnByb3RvY29sKSB7XG4gICAgICBzZWxmLl91cGRhdGVQcm90b2NvbCgpXG4gICAgfVxuXG4gICAgc2VsZi5yZWRpcmVjdHMucHVzaChcbiAgICAgIHsgc3RhdHVzQ29kZSA6IHJlc3BvbnNlLnN0YXR1c0NvZGVcbiAgICAgICwgcmVkaXJlY3RVcmk6IHJlZGlyZWN0VG9cbiAgICAgIH1cbiAgICApXG4gICAgaWYgKHNlbGYuZm9sbG93QWxsUmVkaXJlY3RzICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgIT0gNDAxKSBzZWxmLm1ldGhvZCA9ICdHRVQnXG4gICAgLy8gc2VsZi5tZXRob2QgPSAnR0VUJyAvLyBGb3JjZSBhbGwgcmVkaXJlY3RzIHRvIHVzZSBHRVQgfHwgY29tbWVudGVkIG91dCBmaXhlcyAjMjE1XG4gICAgZGVsZXRlIHNlbGYuc3JjXG4gICAgZGVsZXRlIHNlbGYucmVxXG4gICAgZGVsZXRlIHNlbGYuYWdlbnRcbiAgICBkZWxldGUgc2VsZi5fc3RhcnRlZFxuICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlICE9IDQwMSkge1xuICAgICAgLy8gUmVtb3ZlIHBhcmFtZXRlcnMgZnJvbSB0aGUgcHJldmlvdXMgcmVzcG9uc2UsIHVubGVzcyB0aGlzIGlzIHRoZSBzZWNvbmQgcmVxdWVzdFxuICAgICAgLy8gZm9yIGEgc2VydmVyIHRoYXQgcmVxdWlyZXMgZGlnZXN0IGF1dGhlbnRpY2F0aW9uLlxuICAgICAgZGVsZXRlIHNlbGYuYm9keVxuICAgICAgZGVsZXRlIHNlbGYuX2Zvcm1cbiAgICAgIGlmIChzZWxmLmhlYWRlcnMpIHtcbiAgICAgICAgZGVsZXRlIHNlbGYuaGVhZGVycy5ob3N0XG4gICAgICAgIGRlbGV0ZSBzZWxmLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXG4gICAgICAgIGRlbGV0ZSBzZWxmLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ11cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmLmVtaXQoJ3JlZGlyZWN0Jyk7XG5cbiAgICBzZWxmLmluaXQoKVxuICAgIHJldHVybiAvLyBJZ25vcmUgdGhlIHJlc3Qgb2YgdGhlIHJlc3BvbnNlXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5fcmVkaXJlY3RzRm9sbG93ZWQgPSBzZWxmLl9yZWRpcmVjdHNGb2xsb3dlZCB8fCAwXG4gICAgLy8gQmUgYSBnb29kIHN0cmVhbSBhbmQgZW1pdCBlbmQgd2hlbiB0aGUgcmVzcG9uc2UgaXMgZmluaXNoZWQuXG4gICAgLy8gSGFjayB0byBlbWl0IGVuZCBvbiBjbG9zZSBiZWNhdXNlIG9mIGEgY29yZSBidWcgdGhhdCBuZXZlciBmaXJlcyBlbmRcbiAgICByZXNwb25zZS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNlbGYuX2VuZGVkKSBzZWxmLnJlc3BvbnNlLmVtaXQoJ2VuZCcpXG4gICAgfSlcblxuICAgIGlmIChzZWxmLmVuY29kaW5nKSB7XG4gICAgICBpZiAoc2VsZi5kZXN0cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIklnbm9yaW5nIGVuY29kaW5nIHBhcmFtZXRlciBhcyB0aGlzIHN0cmVhbSBpcyBiZWluZyBwaXBlZCB0byBhbm90aGVyIHN0cmVhbSB3aGljaCBtYWtlcyB0aGUgZW5jb2Rpbmcgb3B0aW9uIGludmFsaWQuXCIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwb25zZS5zZXRFbmNvZGluZyhzZWxmLmVuY29kaW5nKVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZXNwb25zZSlcblxuICAgIHNlbGYuZGVzdHMuZm9yRWFjaChmdW5jdGlvbiAoZGVzdCkge1xuICAgICAgc2VsZi5waXBlRGVzdChkZXN0KVxuICAgIH0pXG5cbiAgICByZXNwb25zZS5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBzZWxmLl9kZXN0ZGF0YSA9IHRydWVcbiAgICAgIHNlbGYuZW1pdChcImRhdGFcIiwgY2h1bmspXG4gICAgfSlcbiAgICByZXNwb25zZS5vbihcImVuZFwiLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHNlbGYuX2VuZGVkID0gdHJ1ZVxuICAgICAgc2VsZi5lbWl0KFwiZW5kXCIsIGNodW5rKVxuICAgIH0pXG4gICAgcmVzcG9uc2Uub24oXCJjbG9zZVwiLCBmdW5jdGlvbiAoKSB7c2VsZi5lbWl0KFwiY2xvc2VcIil9KVxuXG4gICAgaWYgKHNlbGYuY2FsbGJhY2spIHtcbiAgICAgIHZhciBidWZmZXIgPSBbXVxuICAgICAgdmFyIGJvZHlMZW4gPSAwXG4gICAgICBzZWxmLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgYnVmZmVyLnB1c2goY2h1bmspXG4gICAgICAgIGJvZHlMZW4gKz0gY2h1bmsubGVuZ3RoXG4gICAgICB9KVxuICAgICAgc2VsZi5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCdlbmQgZXZlbnQnLCBzZWxmLnVyaS5ocmVmKVxuICAgICAgICBpZiAoc2VsZi5fYWJvcnRlZCkge1xuICAgICAgICAgIGRlYnVnKCdhYm9ydGVkJywgc2VsZi51cmkuaHJlZilcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoICYmIEJ1ZmZlci5pc0J1ZmZlcihidWZmZXJbMF0pKSB7XG4gICAgICAgICAgZGVidWcoJ2hhcyBib2R5Jywgc2VsZi51cmkuaHJlZiwgYm9keUxlbilcbiAgICAgICAgICB2YXIgYm9keSA9IG5ldyBCdWZmZXIoYm9keUxlbilcbiAgICAgICAgICB2YXIgaSA9IDBcbiAgICAgICAgICBidWZmZXIuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIGNodW5rLmNvcHkoYm9keSwgaSwgMCwgY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgaSArPSBjaHVuay5sZW5ndGhcbiAgICAgICAgICB9KVxuICAgICAgICAgIGlmIChzZWxmLmVuY29kaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXNwb25zZS5ib2R5ID0gYm9keVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZS5ib2R5ID0gYm9keS50b1N0cmluZyhzZWxmLmVuY29kaW5nKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gVGhlIFVURjggQk9NIFsweEVGLDB4QkIsMHhCRl0gaXMgY29udmVydGVkIHRvIFsweEZFLDB4RkZdIGluIHRoZSBKUyBVVEMxNi9VQ1MyIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgIC8vIFN0cmlwIHRoaXMgdmFsdWUgb3V0IHdoZW4gdGhlIGVuY29kaW5nIGlzIHNldCB0byAndXRmOCcsIGFzIHVwc3RyZWFtIGNvbnN1bWVycyB3b24ndCBleHBlY3QgaXQgYW5kIGl0IGJyZWFrcyBKU09OLnBhcnNlKCkuXG4gICAgICAgICAgaWYgKHNlbGYuZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBidWZmZXJbMF0ubGVuZ3RoID4gMCAmJiBidWZmZXJbMF1bMF0gPT09IFwiXFx1RkVGRlwiKSB7XG4gICAgICAgICAgICBidWZmZXJbMF0gPSBidWZmZXJbMF0uc3Vic3RyaW5nKDEpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3BvbnNlLmJvZHkgPSBidWZmZXIuam9pbignJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLl9qc29uKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmJvZHkgPSBKU09OLnBhcnNlKHJlc3BvbnNlLmJvZHkpXG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZygnZW1pdHRpbmcgY29tcGxldGUnLCBzZWxmLnVyaS5ocmVmKVxuICAgICAgICBpZihyZXNwb25zZS5ib2R5ID09IHVuZGVmaW5lZCAmJiAhc2VsZi5fanNvbikge1xuICAgICAgICAgIHJlc3BvbnNlLmJvZHkgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuZW1pdCgnY29tcGxldGUnLCByZXNwb25zZSwgcmVzcG9uc2UuYm9keSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG4gIGRlYnVnKCdmaW5pc2ggaW5pdCBmdW5jdGlvbicsIHNlbGYudXJpLmhyZWYpXG59XG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hYm9ydGVkID0gdHJ1ZVxuXG4gIGlmICh0aGlzLnJlcSkge1xuICAgIHRoaXMucmVxLmFib3J0KClcbiAgfVxuICBlbHNlIGlmICh0aGlzLnJlc3BvbnNlKSB7XG4gICAgdGhpcy5yZXNwb25zZS5hYm9ydCgpXG4gIH1cblxuICB0aGlzLmVtaXQoXCJhYm9ydFwiKVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5waXBlRGVzdCA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciByZXNwb25zZSA9IHRoaXMucmVzcG9uc2VcbiAgLy8gQ2FsbGVkIGFmdGVyIHRoZSByZXNwb25zZSBpcyByZWNlaXZlZFxuICBpZiAoZGVzdC5oZWFkZXJzKSB7XG4gICAgZGVzdC5oZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXG4gICAgaWYgKHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pIHtcbiAgICAgIGRlc3QuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSA9IHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ11cbiAgICB9XG4gIH1cbiAgaWYgKGRlc3Quc2V0SGVhZGVyKSB7XG4gICAgZm9yICh2YXIgaSBpbiByZXNwb25zZS5oZWFkZXJzKSB7XG4gICAgICBkZXN0LnNldEhlYWRlcihpLCByZXNwb25zZS5oZWFkZXJzW2ldKVxuICAgIH1cbiAgICBkZXN0LnN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXNDb2RlXG4gIH1cbiAgaWYgKHRoaXMucGlwZWZpbHRlcikgdGhpcy5waXBlZmlsdGVyKHJlc3BvbnNlLCBkZXN0KVxufVxuXG4vLyBDb21wb3NhYmxlIEFQSVxuUmVxdWVzdC5wcm90b3R5cGUuc2V0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBjbG9iYmVyKSB7XG4gIGlmIChjbG9iYmVyID09PSB1bmRlZmluZWQpIGNsb2JiZXIgPSB0cnVlXG4gIGlmIChjbG9iYmVyIHx8ICF0aGlzLmhlYWRlcnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHRoaXMuaGVhZGVyc1tuYW1lXSA9IHZhbHVlXG4gIGVsc2UgdGhpcy5oZWFkZXJzW25hbWVdICs9ICcsJyArIHZhbHVlXG4gIHJldHVybiB0aGlzXG59XG5SZXF1ZXN0LnByb3RvdHlwZS5zZXRIZWFkZXJzID0gZnVuY3Rpb24gKGhlYWRlcnMpIHtcbiAgZm9yICh2YXIgaSBpbiBoZWFkZXJzKSB7dGhpcy5zZXRIZWFkZXIoaSwgaGVhZGVyc1tpXSl9XG4gIHJldHVybiB0aGlzXG59XG5SZXF1ZXN0LnByb3RvdHlwZS5xcyA9IGZ1bmN0aW9uIChxLCBjbG9iYmVyKSB7XG4gIHZhciBiYXNlXG4gIGlmICghY2xvYmJlciAmJiB0aGlzLnVyaS5xdWVyeSkgYmFzZSA9IHFzLnBhcnNlKHRoaXMudXJpLnF1ZXJ5KVxuICBlbHNlIGJhc2UgPSB7fVxuXG4gIGZvciAodmFyIGkgaW4gcSkge1xuICAgIGJhc2VbaV0gPSBxW2ldXG4gIH1cblxuICBpZiAocXMuc3RyaW5naWZ5KGJhc2UpID09PSAnJyl7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRoaXMudXJpID0gdXJsLnBhcnNlKHRoaXMudXJpLmhyZWYuc3BsaXQoJz8nKVswXSArICc/JyArIHFzLnN0cmluZ2lmeShiYXNlKSlcbiAgdGhpcy51cmwgPSB0aGlzLnVyaVxuICB0aGlzLnBhdGggPSB0aGlzLnVyaS5wYXRoXG5cbiAgcmV0dXJuIHRoaXNcbn1cblJlcXVlc3QucHJvdG90eXBlLmZvcm0gPSBmdW5jdGlvbiAoZm9ybSkge1xuICBpZiAoZm9ybSkge1xuICAgIHRoaXMuaGVhZGVyc1snY29udGVudC10eXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PXV0Zi04J1xuICAgIHRoaXMuYm9keSA9IHFzLnN0cmluZ2lmeShmb3JtKS50b1N0cmluZygndXRmOCcpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICAvLyBjcmVhdGUgZm9ybS1kYXRhIG9iamVjdFxuICB0aGlzLl9mb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgcmV0dXJuIHRoaXMuX2Zvcm1cbn1cblJlcXVlc3QucHJvdG90eXBlLm11bHRpcGFydCA9IGZ1bmN0aW9uIChtdWx0aXBhcnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYuYm9keSA9IFtdXG5cbiAgaWYgKCFzZWxmLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKSB7XG4gICAgc2VsZi5oZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdtdWx0aXBhcnQvcmVsYXRlZDsgYm91bmRhcnk9JyArIHNlbGYuYm91bmRhcnlcbiAgfSBlbHNlIHtcbiAgICBzZWxmLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gc2VsZi5oZWFkZXJzWydjb250ZW50LXR5cGUnXS5zcGxpdCgnOycpWzBdICsgJzsgYm91bmRhcnk9JyArIHNlbGYuYm91bmRhcnlcbiAgfVxuXG4gIGlmICghbXVsdGlwYXJ0LmZvckVhY2gpIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgZXJyb3IsIG9wdGlvbnMubXVsdGlwYXJ0LicpXG5cbiAgaWYgKHNlbGYucHJlYW1ibGVDUkxGKSB7XG4gICAgc2VsZi5ib2R5LnB1c2gobmV3IEJ1ZmZlcignXFxyXFxuJykpXG4gIH1cblxuICBtdWx0aXBhcnQuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuICAgIHZhciBib2R5ID0gcGFydC5ib2R5XG4gICAgaWYoYm9keSA9PSBudWxsKSB0aHJvdyBFcnJvcignQm9keSBhdHRyaWJ1dGUgbWlzc2luZyBpbiBtdWx0aXBhcnQuJylcbiAgICBkZWxldGUgcGFydC5ib2R5XG4gICAgdmFyIHByZWFtYmxlID0gJy0tJyArIHNlbGYuYm91bmRhcnkgKyAnXFxyXFxuJ1xuICAgIE9iamVjdC5rZXlzKHBhcnQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgcHJlYW1ibGUgKz0ga2V5ICsgJzogJyArIHBhcnRba2V5XSArICdcXHJcXG4nXG4gICAgfSlcbiAgICBwcmVhbWJsZSArPSAnXFxyXFxuJ1xuICAgIHNlbGYuYm9keS5wdXNoKG5ldyBCdWZmZXIocHJlYW1ibGUpKVxuICAgIHNlbGYuYm9keS5wdXNoKG5ldyBCdWZmZXIoYm9keSkpXG4gICAgc2VsZi5ib2R5LnB1c2gobmV3IEJ1ZmZlcignXFxyXFxuJykpXG4gIH0pXG4gIHNlbGYuYm9keS5wdXNoKG5ldyBCdWZmZXIoJy0tJyArIHNlbGYuYm91bmRhcnkgKyAnLS0nKSlcbiAgcmV0dXJuIHNlbGZcbn1cblJlcXVlc3QucHJvdG90eXBlLmpzb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNldEFjY2VwdEhlYWRlciA9IGZ1bmN0aW9uKCkge1xuICBcdGlmICghc2VsZi5oZWFkZXJzWydhY2NlcHQnXSAmJiAhc2VsZi5oZWFkZXJzWydBY2NlcHQnXSkge1xuXHRcdFx0ICBzZWxmLnNldEhlYWRlcignYWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuXHRcdH1cblx0fVxuICBzZXRBY2NlcHRIZWFkZXIoKTtcbiAgdGhpcy5fanNvbiA9IHRydWVcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIGlmICh0eXBlb2YgdGhpcy5ib2R5ID09PSAnb2JqZWN0Jykge1xuICAgICAgc2V0QWNjZXB0SGVhZGVyKCk7XG4gICAgICB0aGlzLmJvZHkgPSBzYWZlU3RyaW5naWZ5KHRoaXMuYm9keSlcbiAgICAgIHNlbGYuc2V0SGVhZGVyKCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNldEFjY2VwdEhlYWRlcigpO1xuICAgIHRoaXMuYm9keSA9IHNhZmVTdHJpbmdpZnkodmFsKVxuICAgIHNlbGYuc2V0SGVhZGVyKCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cbmZ1bmN0aW9uIGdldEhlYWRlcihuYW1lLCBoZWFkZXJzKSB7XG4gICAgdmFyIHJlc3VsdCwgcmUsIG1hdGNoXG4gICAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJlID0gbmV3IFJlZ0V4cChuYW1lLCAnaScpXG4gICAgICAgIG1hdGNoID0ga2V5Lm1hdGNoKHJlKVxuICAgICAgICBpZiAobWF0Y2gpIHJlc3VsdCA9IGhlYWRlcnNba2V5XVxuICAgIH0pXG4gICAgcmV0dXJuIHJlc3VsdFxufVxuUmVxdWVzdC5wcm90b3R5cGUuYXV0aCA9IGZ1bmN0aW9uICh1c2VyLCBwYXNzLCBzZW5kSW1tZWRpYXRlbHkpIHtcbiAgaWYgKHR5cGVvZiB1c2VyICE9PSAnc3RyaW5nJyB8fCAocGFzcyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBwYXNzICE9PSAnc3RyaW5nJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dGgoKSByZWNlaXZlZCBpbnZhbGlkIHVzZXIgb3IgcGFzc3dvcmQnKVxuICB9XG4gIHRoaXMuX3VzZXIgPSB1c2VyXG4gIHRoaXMuX3Bhc3MgPSBwYXNzXG4gIHRoaXMuX2hhc0F1dGggPSB0cnVlXG4gIGlmIChzZW5kSW1tZWRpYXRlbHkgfHwgdHlwZW9mIHNlbmRJbW1lZGlhdGVseSA9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuc2V0SGVhZGVyKCdhdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyB0b0Jhc2U2NCh1c2VyICsgJzonICsgcGFzcykpXG4gICAgdGhpcy5fc2VudEF1dGggPSB0cnVlXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblJlcXVlc3QucHJvdG90eXBlLmF3cyA9IGZ1bmN0aW9uIChvcHRzLCBub3cpIHtcbiAgaWYgKCFub3cpIHtcbiAgICB0aGlzLl9hd3MgPSBvcHRzXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKClcbiAgdGhpcy5zZXRIZWFkZXIoJ2RhdGUnLCBkYXRlLnRvVVRDU3RyaW5nKCkpXG4gIHZhciBhdXRoID1cbiAgICB7IGtleTogb3B0cy5rZXlcbiAgICAsIHNlY3JldDogb3B0cy5zZWNyZXRcbiAgICAsIHZlcmI6IHRoaXMubWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICAsIGRhdGU6IGRhdGVcbiAgICAsIGNvbnRlbnRUeXBlOiBnZXRIZWFkZXIoJ2NvbnRlbnQtdHlwZScsIHRoaXMuaGVhZGVycykgfHwgJydcbiAgICAsIG1kNTogZ2V0SGVhZGVyKCdjb250ZW50LW1kNScsIHRoaXMuaGVhZGVycykgfHwgJydcbiAgICAsIGFtYXpvbkhlYWRlcnM6IGF3cy5jYW5vbmljYWxpemVIZWFkZXJzKHRoaXMuaGVhZGVycylcbiAgICB9XG4gIGlmIChvcHRzLmJ1Y2tldCAmJiB0aGlzLnBhdGgpIHtcbiAgICBhdXRoLnJlc291cmNlID0gJy8nICsgb3B0cy5idWNrZXQgKyB0aGlzLnBhdGhcbiAgfSBlbHNlIGlmIChvcHRzLmJ1Y2tldCAmJiAhdGhpcy5wYXRoKSB7XG4gICAgYXV0aC5yZXNvdXJjZSA9ICcvJyArIG9wdHMuYnVja2V0XG4gIH0gZWxzZSBpZiAoIW9wdHMuYnVja2V0ICYmIHRoaXMucGF0aCkge1xuICAgIGF1dGgucmVzb3VyY2UgPSB0aGlzLnBhdGhcbiAgfSBlbHNlIGlmICghb3B0cy5idWNrZXQgJiYgIXRoaXMucGF0aCkge1xuICAgIGF1dGgucmVzb3VyY2UgPSAnLydcbiAgfVxuICBhdXRoLnJlc291cmNlID0gYXdzLmNhbm9uaWNhbGl6ZVJlc291cmNlKGF1dGgucmVzb3VyY2UpXG4gIHRoaXMuc2V0SGVhZGVyKCdhdXRob3JpemF0aW9uJywgYXdzLmF1dGhvcml6YXRpb24oYXV0aCkpXG5cbiAgcmV0dXJuIHRoaXNcbn1cblJlcXVlc3QucHJvdG90eXBlLmh0dHBTaWduYXR1cmUgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgcmVxID0gdGhpc1xuICBodHRwU2lnbmF0dXJlLnNpZ25SZXF1ZXN0KHtcbiAgICBnZXRIZWFkZXI6IGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgcmV0dXJuIGdldEhlYWRlcihoZWFkZXIsIHJlcS5oZWFkZXJzKVxuICAgIH0sXG4gICAgc2V0SGVhZGVyOiBmdW5jdGlvbihoZWFkZXIsIHZhbHVlKSB7XG4gICAgICByZXEuc2V0SGVhZGVyKGhlYWRlciwgdmFsdWUpXG4gICAgfSxcbiAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgIHBhdGg6IHRoaXMucGF0aFxuICB9LCBvcHRzKVxuICBkZWJ1ZygnaHR0cFNpZ25hdHVyZSBhdXRob3JpemF0aW9uJywgZ2V0SGVhZGVyKCdhdXRob3JpemF0aW9uJywgdGhpcy5oZWFkZXJzKSlcblxuICByZXR1cm4gdGhpc1xufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5oYXdrID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgdGhpcy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBoYXdrLmNsaWVudC5oZWFkZXIodGhpcy51cmksIHRoaXMubWV0aG9kLCBvcHRzKS5maWVsZFxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5vYXV0aCA9IGZ1bmN0aW9uIChfb2F1dGgpIHtcbiAgdmFyIGZvcm1cbiAgaWYgKHRoaXMuaGVhZGVyc1snY29udGVudC10eXBlJ10gJiZcbiAgICAgIHRoaXMuaGVhZGVyc1snY29udGVudC10eXBlJ10uc2xpY2UoMCwgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcubGVuZ3RoKSA9PT1cbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbiAgICAgKSB7XG4gICAgZm9ybSA9IHFzLnBhcnNlKHRoaXMuYm9keSlcbiAgfVxuICBpZiAodGhpcy51cmkucXVlcnkpIHtcbiAgICBmb3JtID0gcXMucGFyc2UodGhpcy51cmkucXVlcnkpXG4gIH1cbiAgaWYgKCFmb3JtKSBmb3JtID0ge31cbiAgdmFyIG9hID0ge31cbiAgZm9yICh2YXIgaSBpbiBmb3JtKSBvYVtpXSA9IGZvcm1baV1cbiAgZm9yICh2YXIgaSBpbiBfb2F1dGgpIG9hWydvYXV0aF8nK2ldID0gX29hdXRoW2ldXG4gIGlmICghb2Eub2F1dGhfdmVyc2lvbikgb2Eub2F1dGhfdmVyc2lvbiA9ICcxLjAnXG4gIGlmICghb2Eub2F1dGhfdGltZXN0YW1wKSBvYS5vYXV0aF90aW1lc3RhbXAgPSBNYXRoLmZsb29yKCBEYXRlLm5vdygpIC8gMTAwMCApLnRvU3RyaW5nKClcbiAgaWYgKCFvYS5vYXV0aF9ub25jZSkgb2Eub2F1dGhfbm9uY2UgPSB1dWlkKCkucmVwbGFjZSgvLS9nLCAnJylcblxuICBvYS5vYXV0aF9zaWduYXR1cmVfbWV0aG9kID0gJ0hNQUMtU0hBMSdcblxuICB2YXIgY29uc3VtZXJfc2VjcmV0ID0gb2Eub2F1dGhfY29uc3VtZXJfc2VjcmV0XG4gIGRlbGV0ZSBvYS5vYXV0aF9jb25zdW1lcl9zZWNyZXRcbiAgdmFyIHRva2VuX3NlY3JldCA9IG9hLm9hdXRoX3Rva2VuX3NlY3JldFxuICBkZWxldGUgb2Eub2F1dGhfdG9rZW5fc2VjcmV0XG4gIHZhciB0aW1lc3RhbXAgPSBvYS5vYXV0aF90aW1lc3RhbXBcblxuICB2YXIgYmFzZXVybCA9IHRoaXMudXJpLnByb3RvY29sICsgJy8vJyArIHRoaXMudXJpLmhvc3QgKyB0aGlzLnVyaS5wYXRobmFtZVxuICB2YXIgc2lnbmF0dXJlID0gb2F1dGguaG1hY3NpZ24odGhpcy5tZXRob2QsIGJhc2V1cmwsIG9hLCBjb25zdW1lcl9zZWNyZXQsIHRva2VuX3NlY3JldClcblxuICAvLyBvYS5vYXV0aF9zaWduYXR1cmUgPSBzaWduYXR1cmVcbiAgZm9yICh2YXIgaSBpbiBmb3JtKSB7XG4gICAgaWYgKCBpLnNsaWNlKDAsICdvYXV0aF8nKSBpbiBfb2F1dGgpIHtcbiAgICAgIC8vIHNraXBcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIG9hWydvYXV0aF8nK2ldXG4gICAgICBpZiAoaSAhPT0gJ3hfYXV0aF9tb2RlJykgZGVsZXRlIG9hW2ldXG4gICAgfVxuICB9XG4gIG9hLm9hdXRoX3RpbWVzdGFtcCA9IHRpbWVzdGFtcFxuICB0aGlzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9XG4gICAgJ09BdXRoICcrT2JqZWN0LmtleXMob2EpLnNvcnQoKS5tYXAoZnVuY3Rpb24gKGkpIHtyZXR1cm4gaSsnPVwiJytvYXV0aC5yZmMzOTg2KG9hW2ldKSsnXCInfSkuam9pbignLCcpXG4gIHRoaXMuaGVhZGVycy5BdXRob3JpemF0aW9uICs9ICcsb2F1dGhfc2lnbmF0dXJlPVwiJyArIG9hdXRoLnJmYzM5ODYoc2lnbmF0dXJlKSArICdcIidcbiAgcmV0dXJuIHRoaXNcbn1cblJlcXVlc3QucHJvdG90eXBlLmphciA9IGZ1bmN0aW9uIChqYXIpIHtcbiAgdmFyIGNvb2tpZXNcblxuICBpZiAodGhpcy5fcmVkaXJlY3RzRm9sbG93ZWQgPT09IDApIHtcbiAgICB0aGlzLm9yaWdpbmFsQ29va2llSGVhZGVyID0gdGhpcy5oZWFkZXJzLmNvb2tpZVxuICB9XG5cbiAgaWYgKGphciA9PT0gZmFsc2UpIHtcbiAgICAvLyBkaXNhYmxlIGNvb2tpZXNcbiAgICBjb29raWVzID0gZmFsc2VcbiAgICB0aGlzLl9kaXNhYmxlQ29va2llcyA9IHRydWVcbiAgfSBlbHNlIGlmIChqYXIpIHtcbiAgICAvLyBmZXRjaCBjb29raWUgZnJvbSB0aGUgdXNlciBkZWZpbmVkIGNvb2tpZSBqYXJcbiAgICBjb29raWVzID0gamFyLmdldCh7IHVybDogdGhpcy51cmkuaHJlZiB9KVxuICB9IGVsc2Uge1xuICAgIC8vIGZldGNoIGNvb2tpZSBmcm9tIHRoZSBnbG9iYWwgY29va2llIGphclxuICAgIGNvb2tpZXMgPSBjb29raWVKYXIuZ2V0KHsgdXJsOiB0aGlzLnVyaS5ocmVmIH0pXG4gIH1cblxuICBpZiAoY29va2llcyAmJiBjb29raWVzLmxlbmd0aCkge1xuICAgIHZhciBjb29raWVTdHJpbmcgPSBjb29raWVzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMubmFtZSArIFwiPVwiICsgYy52YWx1ZVxuICAgIH0pLmpvaW4oXCI7IFwiKVxuXG4gICAgaWYgKHRoaXMub3JpZ2luYWxDb29raWVIZWFkZXIpIHtcbiAgICAgIC8vIERvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBDb29raWUgaGVhZGVyXG4gICAgICB0aGlzLmhlYWRlcnMuY29va2llID0gdGhpcy5vcmlnaW5hbENvb2tpZUhlYWRlciArICc7ICcgKyBjb29raWVTdHJpbmdcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkZXJzLmNvb2tpZSA9IGNvb2tpZVN0cmluZ1xuICAgIH1cbiAgfVxuICB0aGlzLl9qYXIgPSBqYXJcbiAgcmV0dXJuIHRoaXNcbn1cblxuXG4vLyBTdHJlYW0gQVBJXG5SZXF1ZXN0LnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIG9wdHMpIHtcbiAgaWYgKHRoaXMucmVzcG9uc2UpIHtcbiAgICBpZiAodGhpcy5fZGVzdGRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW5ub3QgcGlwZSBhZnRlciBkYXRhIGhhcyBiZWVuIGVtaXR0ZWQgZnJvbSB0aGUgcmVzcG9uc2UuXCIpXG4gICAgfSBlbHNlIGlmICh0aGlzLl9lbmRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBwaXBlIGFmdGVyIHRoZSByZXNwb25zZSBoYXMgYmVlbiBlbmRlZC5cIilcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLlN0cmVhbS5wcm90b3R5cGUucGlwZS5jYWxsKHRoaXMsIGRlc3QsIG9wdHMpXG4gICAgICB0aGlzLnBpcGVEZXN0KGRlc3QpXG4gICAgICByZXR1cm4gZGVzdFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlc3RzLnB1c2goZGVzdClcbiAgICBzdHJlYW0uU3RyZWFtLnByb3RvdHlwZS5waXBlLmNhbGwodGhpcywgZGVzdCwgb3B0cylcbiAgICByZXR1cm4gZGVzdFxuICB9XG59XG5SZXF1ZXN0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLl9zdGFydGVkKSB0aGlzLnN0YXJ0KClcbiAgcmV0dXJuIHRoaXMucmVxLndyaXRlLmFwcGx5KHRoaXMucmVxLCBhcmd1bWVudHMpXG59XG5SZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgaWYgKGNodW5rKSB0aGlzLndyaXRlKGNodW5rKVxuICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHRoaXMuc3RhcnQoKVxuICB0aGlzLnJlcS5lbmQoKVxufVxuUmVxdWVzdC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5yZXNwb25zZSkgdGhpcy5fcGF1c2VkID0gdHJ1ZVxuICBlbHNlIHRoaXMucmVzcG9uc2UucGF1c2UuYXBwbHkodGhpcy5yZXNwb25zZSwgYXJndW1lbnRzKVxufVxuUmVxdWVzdC5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMucmVzcG9uc2UpIHRoaXMuX3BhdXNlZCA9IGZhbHNlXG4gIGVsc2UgdGhpcy5yZXNwb25zZS5yZXN1bWUuYXBwbHkodGhpcy5yZXNwb25zZSwgYXJndW1lbnRzKVxufVxuUmVxdWVzdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLl9lbmRlZCkgdGhpcy5lbmQoKVxuICBlbHNlIGlmICh0aGlzLnJlc3BvbnNlKSB0aGlzLnJlc3BvbnNlLmRlc3Ryb3koKVxufVxuXG4vLyBvcmdhbml6ZSBwYXJhbXMgZm9yIHBhdGNoLCBwb3N0LCBwdXQsIGhlYWQsIGRlbFxuZnVuY3Rpb24gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICgodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpICYmICFjYWxsYmFjaykgY2FsbGJhY2sgPSBvcHRpb25zXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMudXJpID0gdXJpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHVyaSA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0ge3VyaTp1cml9XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IHVyaVxuICAgIHVyaSA9IG9wdGlvbnMudXJpXG4gIH1cbiAgcmV0dXJuIHsgdXJpOiB1cmksIG9wdGlvbnM6IG9wdGlvbnMsIGNhbGxiYWNrOiBjYWxsYmFjayB9XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3QgKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiB1cmkgPT09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgRXJyb3IoJ3VuZGVmaW5lZCBpcyBub3QgYSB2YWxpZCB1cmkgb3Igb3B0aW9ucyBvYmplY3QuJylcbiAgaWYgKCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykgJiYgIWNhbGxiYWNrKSBjYWxsYmFjayA9IG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucy51cmkgPSB1cmlcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7dXJpOnVyaX1cbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0gdXJpXG4gIH1cblxuICBvcHRpb25zID0gY29weShvcHRpb25zKVxuXG4gIGlmIChjYWxsYmFjaykgb3B0aW9ucy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gIHZhciByID0gbmV3IFJlcXVlc3Qob3B0aW9ucylcbiAgcmV0dXJuIHJcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1ZXN0XG5cbnJlcXVlc3QuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbnJlcXVlc3QuZGVidWcgPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHICYmIC9yZXF1ZXN0Ly50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpXG5cbnJlcXVlc3QuaW5pdFBhcmFtcyA9IGluaXRQYXJhbXNcblxucmVxdWVzdC5kZWZhdWx0cyA9IGZ1bmN0aW9uIChvcHRpb25zLCByZXF1ZXN0ZXIpIHtcbiAgdmFyIGRlZiA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICB2YXIgZCA9IGZ1bmN0aW9uICh1cmksIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgcGFyYW1zID0gaW5pdFBhcmFtcyh1cmksIG9wdHMsIGNhbGxiYWNrKVxuICAgICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmIChwYXJhbXMub3B0aW9uc1tpXSA9PT0gdW5kZWZpbmVkKSBwYXJhbXMub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV1cbiAgICAgIH1cbiAgICAgIGlmKHR5cGVvZiByZXF1ZXN0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYobWV0aG9kID09PSByZXF1ZXN0KSB7XG4gICAgICAgICAgbWV0aG9kID0gcmVxdWVzdGVyXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyYW1zLm9wdGlvbnMuX3JlcXVlc3RlciA9IHJlcXVlc3RlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWV0aG9kKHBhcmFtcy5vcHRpb25zLCBwYXJhbXMuY2FsbGJhY2spXG4gICAgfVxuICAgIHJldHVybiBkXG4gIH1cbiAgdmFyIGRlID0gZGVmKHJlcXVlc3QpXG4gIGRlLmdldCA9IGRlZihyZXF1ZXN0LmdldClcbiAgZGUucGF0Y2ggPSBkZWYocmVxdWVzdC5wYXRjaClcbiAgZGUucG9zdCA9IGRlZihyZXF1ZXN0LnBvc3QpXG4gIGRlLnB1dCA9IGRlZihyZXF1ZXN0LnB1dClcbiAgZGUuaGVhZCA9IGRlZihyZXF1ZXN0LmhlYWQpXG4gIGRlLmRlbCA9IGRlZihyZXF1ZXN0LmRlbClcbiAgZGUuY29va2llID0gZGVmKHJlcXVlc3QuY29va2llKVxuICBkZS5qYXIgPSByZXF1ZXN0LmphclxuICByZXR1cm4gZGVcbn1cblxucmVxdWVzdC5mb3JldmVyID0gZnVuY3Rpb24gKGFnZW50T3B0aW9ucywgb3B0aW9uc0FyZykge1xuICB2YXIgb3B0aW9ucyA9IHt9XG4gIGlmIChvcHRpb25zQXJnKSB7XG4gICAgZm9yIChvcHRpb24gaW4gb3B0aW9uc0FyZykge1xuICAgICAgb3B0aW9uc1tvcHRpb25dID0gb3B0aW9uc0FyZ1tvcHRpb25dXG4gICAgfVxuICB9XG4gIGlmIChhZ2VudE9wdGlvbnMpIG9wdGlvbnMuYWdlbnRPcHRpb25zID0gYWdlbnRPcHRpb25zXG4gIG9wdGlvbnMuZm9yZXZlciA9IHRydWVcbiAgcmV0dXJuIHJlcXVlc3QuZGVmYXVsdHMob3B0aW9ucylcbn1cblxucmVxdWVzdC5nZXQgPSByZXF1ZXN0XG5yZXF1ZXN0LnBvc3QgPSBmdW5jdGlvbiAodXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgcGFyYW1zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKVxuICBwYXJhbXMub3B0aW9ucy5tZXRob2QgPSAnUE9TVCdcbiAgcmV0dXJuIHJlcXVlc3QocGFyYW1zLnVyaSB8fCBudWxsLCBwYXJhbXMub3B0aW9ucywgcGFyYW1zLmNhbGxiYWNrKVxufVxucmVxdWVzdC5wdXQgPSBmdW5jdGlvbiAodXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgcGFyYW1zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKVxuICBwYXJhbXMub3B0aW9ucy5tZXRob2QgPSAnUFVUJ1xuICByZXR1cm4gcmVxdWVzdChwYXJhbXMudXJpIHx8IG51bGwsIHBhcmFtcy5vcHRpb25zLCBwYXJhbXMuY2FsbGJhY2spXG59XG5yZXF1ZXN0LnBhdGNoID0gZnVuY3Rpb24gKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdmFyIHBhcmFtcyA9IGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgcGFyYW1zLm9wdGlvbnMubWV0aG9kID0gJ1BBVENIJ1xuICByZXR1cm4gcmVxdWVzdChwYXJhbXMudXJpIHx8IG51bGwsIHBhcmFtcy5vcHRpb25zLCBwYXJhbXMuY2FsbGJhY2spXG59XG5yZXF1ZXN0LmhlYWQgPSBmdW5jdGlvbiAodXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgcGFyYW1zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKVxuICBwYXJhbXMub3B0aW9ucy5tZXRob2QgPSAnSEVBRCdcbiAgaWYgKHBhcmFtcy5vcHRpb25zLmJvZHkgfHxcbiAgICAgIHBhcmFtcy5vcHRpb25zLnJlcXVlc3RCb2R5U3RyZWFtIHx8XG4gICAgICAocGFyYW1zLm9wdGlvbnMuanNvbiAmJiB0eXBlb2YgcGFyYW1zLm9wdGlvbnMuanNvbiAhPT0gJ2Jvb2xlYW4nKSB8fFxuICAgICAgcGFyYW1zLm9wdGlvbnMubXVsdGlwYXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSFRUUCBIRUFEIHJlcXVlc3RzIE1VU1QgTk9UIGluY2x1ZGUgYSByZXF1ZXN0IGJvZHkuXCIpXG4gIH1cbiAgcmV0dXJuIHJlcXVlc3QocGFyYW1zLnVyaSB8fCBudWxsLCBwYXJhbXMub3B0aW9ucywgcGFyYW1zLmNhbGxiYWNrKVxufVxucmVxdWVzdC5kZWwgPSBmdW5jdGlvbiAodXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIgcGFyYW1zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKVxuICBwYXJhbXMub3B0aW9ucy5tZXRob2QgPSAnREVMRVRFJ1xuICBpZih0eXBlb2YgcGFyYW1zLm9wdGlvbnMuX3JlcXVlc3RlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlcXVlc3QgPSBwYXJhbXMub3B0aW9ucy5fcmVxdWVzdGVyXG4gIH1cbiAgcmV0dXJuIHJlcXVlc3QocGFyYW1zLnVyaSB8fCBudWxsLCBwYXJhbXMub3B0aW9ucywgcGFyYW1zLmNhbGxiYWNrKVxufVxucmVxdWVzdC5qYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgQ29va2llSmFyXG59XG5yZXF1ZXN0LmNvb2tpZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKHN0ciAmJiBzdHIudXJpKSBzdHIgPSBzdHIudXJpXG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvb2tpZSBmdW5jdGlvbiBvbmx5IGFjY2VwdHMgU1RSSU5HIGFzIHBhcmFtXCIpXG4gIHJldHVybiBuZXcgQ29va2llKHN0cilcbn1cblxuLy8gU2FmZSB0b0pTT05cblxuZnVuY3Rpb24gZ2V0U2FmZSAoc2VsZiwgdXVpZCkge1xuICBpZiAodHlwZW9mIHNlbGYgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBzZWxmID09PSAnZnVuY3Rpb24nKSB2YXIgc2FmZSA9IHt9XG4gIGlmIChBcnJheS5pc0FycmF5KHNlbGYpKSB2YXIgc2FmZSA9IFtdXG5cbiAgdmFyIHJlY3Vyc2UgPSBbXVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCB1dWlkLCB7fSlcblxuICB2YXIgYXR0cnMgPSBPYmplY3Qua2V5cyhzZWxmKS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICBpZiAoaSA9PT0gdXVpZCkgcmV0dXJuIGZhbHNlXG4gICAgaWYgKCAodHlwZW9mIHNlbGZbaV0gIT09ICdvYmplY3QnICYmIHR5cGVvZiBzZWxmW2ldICE9PSAnZnVuY3Rpb24nKSB8fCBzZWxmW2ldID09PSBudWxsKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiAhKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc2VsZltpXSwgdXVpZCkpXG4gIH0pXG5cblxuICBmb3IgKHZhciBpPTA7aTxhdHRycy5sZW5ndGg7aSsrKSB7XG4gICAgaWYgKCAodHlwZW9mIHNlbGZbYXR0cnNbaV1dICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygc2VsZlthdHRyc1tpXV0gIT09ICdmdW5jdGlvbicpIHx8XG4gICAgICAgICAgc2VsZlthdHRyc1tpXV0gPT09IG51bGxcbiAgICAgICAgKSB7XG4gICAgICBzYWZlW2F0dHJzW2ldXSA9IHNlbGZbYXR0cnNbaV1dXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY3Vyc2UucHVzaChhdHRyc1tpXSlcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmW2F0dHJzW2ldXSwgdXVpZCwge30pXG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaT0wO2k8cmVjdXJzZS5sZW5ndGg7aSsrKSB7XG4gICAgc2FmZVtyZWN1cnNlW2ldXSA9IGdldFNhZmUoc2VsZltyZWN1cnNlW2ldXSwgdXVpZClcbiAgfVxuXG4gIHJldHVybiBzYWZlXG59XG5cbmZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiBnZXRTYWZlKHRoaXMsICdfXycgKyAoKCgxK01hdGgucmFuZG9tKCkpKjB4MTAwMDApfDApLnRvU3RyaW5nKDE2KSlcbn1cblxuUmVxdWVzdC5wcm90b3R5cGUudG9KU09OID0gdG9KU09OXG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSxyZXF1aXJlKFwiX19icm93c2VyaWZ5X2J1ZmZlclwiKS5CdWZmZXIpIiwiLy8gT3JpZ2luYWwgY29kZSBhZGFwdGVkIGZyb20gUm9iZXJ0IEtpZWZmZXIuXG4vLyBkZXRhaWxzIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBfZ2xvYmFsID0gdGhpcztcblxuICB2YXIgbWF0aFJORywgd2hhdHdnUk5HO1xuXG4gIC8vIE5PVEU6IE1hdGgucmFuZG9tKCkgZG9lcyBub3QgZ3VhcmFudGVlIFwiY3J5cHRvZ3JhcGhpYyBxdWFsaXR5XCJcbiAgbWF0aFJORyA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgdmFyIHI7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IHNpemU7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT0gMCkgciA9IE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMDtcbiAgICAgIGJ5dGVzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBieXRlcztcbiAgfVxuXG4gIC8vIGN1cnJlbnRseSBvbmx5IGF2YWlsYWJsZSBpbiB3ZWJraXQtYmFzZWQgYnJvd3NlcnMuXG4gIGlmIChfZ2xvYmFsLmNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgdmFyIF9ybmRzID0gbmV3IFVpbnQzMkFycmF5KDQpO1xuICAgIHdoYXR3Z1JORyA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShzaXplKTtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoX3JuZHMpO1xuXG4gICAgICBmb3IgKHZhciBjID0gMCA7IGMgPCBzaXplOyBjKyspIHtcbiAgICAgICAgYnl0ZXNbY10gPSBfcm5kc1tjID4+IDJdID4+PiAoKGMgJiAweDAzKSAqIDgpICYgMHhmZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gIH1cblxuICBtb2R1bGUuZXhwb3J0cyA9IHdoYXR3Z1JORyB8fCBtYXRoUk5HO1xuXG59KCkpIiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMSwgYXMgZGVmaW5lZFxuICogaW4gRklQUyBQVUIgMTgwLTFcbiAqIFZlcnNpb24gMi4xYSBDb3B5cmlnaHQgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwMi5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIGRldGFpbHMuXG4gKi9cblxuZXhwb3J0cy5oZXhfc2hhMSA9IGhleF9zaGExO1xuZXhwb3J0cy5iNjRfc2hhMSA9IGI2NF9zaGExO1xuZXhwb3J0cy5zdHJfc2hhMSA9IHN0cl9zaGExO1xuZXhwb3J0cy5oZXhfaG1hY19zaGExID0gaGV4X2htYWNfc2hhMTtcbmV4cG9ydHMuYjY0X2htYWNfc2hhMSA9IGI2NF9obWFjX3NoYTE7XG5leHBvcnRzLnN0cl9obWFjX3NoYTEgPSBzdHJfaG1hY19zaGExO1xuXG4vKlxuICogQ29uZmlndXJhYmxlIHZhcmlhYmxlcy4gWW91IG1heSBuZWVkIHRvIHR3ZWFrIHRoZXNlIHRvIGJlIGNvbXBhdGlibGUgd2l0aFxuICogdGhlIHNlcnZlci1zaWRlLCBidXQgdGhlIGRlZmF1bHRzIHdvcmsgaW4gbW9zdCBjYXNlcy5cbiAqL1xudmFyIGhleGNhc2UgPSAwOyAgLyogaGV4IG91dHB1dCBmb3JtYXQuIDAgLSBsb3dlcmNhc2U7IDEgLSB1cHBlcmNhc2UgICAgICAgICovXG52YXIgYjY0cGFkICA9IFwiXCI7IC8qIGJhc2UtNjQgcGFkIGNoYXJhY3Rlci4gXCI9XCIgZm9yIHN0cmljdCBSRkMgY29tcGxpYW5jZSAgICovXG52YXIgY2hyc3ogICA9IDg7ICAvKiBiaXRzIHBlciBpbnB1dCBjaGFyYWN0ZXIuIDggLSBBU0NJSTsgMTYgLSBVbmljb2RlICAgICAgKi9cblxuLypcbiAqIFRoZXNlIGFyZSB0aGUgZnVuY3Rpb25zIHlvdSdsbCB1c3VhbGx5IHdhbnQgdG8gY2FsbFxuICogVGhleSB0YWtlIHN0cmluZyBhcmd1bWVudHMgYW5kIHJldHVybiBlaXRoZXIgaGV4IG9yIGJhc2UtNjQgZW5jb2RlZCBzdHJpbmdzXG4gKi9cbmZ1bmN0aW9uIGhleF9zaGExKHMpe3JldHVybiBiaW5iMmhleChjb3JlX3NoYTEoc3RyMmJpbmIocykscy5sZW5ndGggKiBjaHJzeikpO31cbmZ1bmN0aW9uIGI2NF9zaGExKHMpe3JldHVybiBiaW5iMmI2NChjb3JlX3NoYTEoc3RyMmJpbmIocykscy5sZW5ndGggKiBjaHJzeikpO31cbmZ1bmN0aW9uIHN0cl9zaGExKHMpe3JldHVybiBiaW5iMnN0cihjb3JlX3NoYTEoc3RyMmJpbmIocykscy5sZW5ndGggKiBjaHJzeikpO31cbmZ1bmN0aW9uIGhleF9obWFjX3NoYTEoa2V5LCBkYXRhKXsgcmV0dXJuIGJpbmIyaGV4KGNvcmVfaG1hY19zaGExKGtleSwgZGF0YSkpO31cbmZ1bmN0aW9uIGI2NF9obWFjX3NoYTEoa2V5LCBkYXRhKXsgcmV0dXJuIGJpbmIyYjY0KGNvcmVfaG1hY19zaGExKGtleSwgZGF0YSkpO31cbmZ1bmN0aW9uIHN0cl9obWFjX3NoYTEoa2V5LCBkYXRhKXsgcmV0dXJuIGJpbmIyc3RyKGNvcmVfaG1hY19zaGExKGtleSwgZGF0YSkpO31cblxuLypcbiAqIFBlcmZvcm0gYSBzaW1wbGUgc2VsZi10ZXN0IHRvIHNlZSBpZiB0aGUgVk0gaXMgd29ya2luZ1xuICovXG5mdW5jdGlvbiBzaGExX3ZtX3Rlc3QoKVxue1xuICByZXR1cm4gaGV4X3NoYTEoXCJhYmNcIikgPT0gXCJhOTk5M2UzNjQ3MDY4MTZhYmEzZTI1NzE3ODUwYzI2YzljZDBkODlkXCI7XG59XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIFNIQS0xIG9mIGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gY29yZV9zaGExKHgsIGxlbilcbntcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBsZW4gJSAzMik7XG4gIHhbKChsZW4gKyA2NCA+PiA5KSA8PCA0KSArIDE1XSA9IGxlbjtcblxuICB2YXIgdyA9IEFycmF5KDgwKTtcbiAgdmFyIGEgPSAgMTczMjU4NDE5MztcbiAgdmFyIGIgPSAtMjcxNzMzODc5O1xuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xuICB2YXIgZCA9ICAyNzE3MzM4Nzg7XG4gIHZhciBlID0gLTEwMDk1ODk3NzY7XG5cbiAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KVxuICB7XG4gICAgdmFyIG9sZGEgPSBhO1xuICAgIHZhciBvbGRiID0gYjtcbiAgICB2YXIgb2xkYyA9IGM7XG4gICAgdmFyIG9sZGQgPSBkO1xuICAgIHZhciBvbGRlID0gZTtcblxuICAgIGZvcih2YXIgaiA9IDA7IGogPCA4MDsgaisrKVxuICAgIHtcbiAgICAgIGlmKGogPCAxNikgd1tqXSA9IHhbaSArIGpdO1xuICAgICAgZWxzZSB3W2pdID0gcm9sKHdbai0zXSBeIHdbai04XSBeIHdbai0xNF0gXiB3W2otMTZdLCAxKTtcbiAgICAgIHZhciB0ID0gc2FmZV9hZGQoc2FmZV9hZGQocm9sKGEsIDUpLCBzaGExX2Z0KGosIGIsIGMsIGQpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgc2FmZV9hZGQoc2FmZV9hZGQoZSwgd1tqXSksIHNoYTFfa3QoaikpKTtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gcm9sKGIsIDMwKTtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuXG4gICAgYSA9IHNhZmVfYWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlX2FkZChiLCBvbGRiKTtcbiAgICBjID0gc2FmZV9hZGQoYywgb2xkYyk7XG4gICAgZCA9IHNhZmVfYWRkKGQsIG9sZGQpO1xuICAgIGUgPSBzYWZlX2FkZChlLCBvbGRlKTtcbiAgfVxuICByZXR1cm4gQXJyYXkoYSwgYiwgYywgZCwgZSk7XG5cbn1cblxuLypcbiAqIFBlcmZvcm0gdGhlIGFwcHJvcHJpYXRlIHRyaXBsZXQgY29tYmluYXRpb24gZnVuY3Rpb24gZm9yIHRoZSBjdXJyZW50XG4gKiBpdGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gc2hhMV9mdCh0LCBiLCBjLCBkKVxue1xuICBpZih0IDwgMjApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKTtcbiAgaWYodCA8IDQwKSByZXR1cm4gYiBeIGMgXiBkO1xuICBpZih0IDwgNjApIHJldHVybiAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCk7XG4gIHJldHVybiBiIF4gYyBeIGQ7XG59XG5cbi8qXG4gKiBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGFkZGl0aXZlIGNvbnN0YW50IGZvciB0aGUgY3VycmVudCBpdGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gc2hhMV9rdCh0KVxue1xuICByZXR1cm4gKHQgPCAyMCkgPyAgMTUxODUwMDI0OSA6ICh0IDwgNDApID8gIDE4NTk3NzUzOTMgOlxuICAgICAgICAgKHQgPCA2MCkgPyAtMTg5NDAwNzU4OCA6IC04OTk0OTc1MTQ7XG59XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIEhNQUMtU0hBMSBvZiBhIGtleSBhbmQgc29tZSBkYXRhXG4gKi9cbmZ1bmN0aW9uIGNvcmVfaG1hY19zaGExKGtleSwgZGF0YSlcbntcbiAgdmFyIGJrZXkgPSBzdHIyYmluYihrZXkpO1xuICBpZihia2V5Lmxlbmd0aCA+IDE2KSBia2V5ID0gY29yZV9zaGExKGJrZXksIGtleS5sZW5ndGggKiBjaHJzeik7XG5cbiAgdmFyIGlwYWQgPSBBcnJheSgxNiksIG9wYWQgPSBBcnJheSgxNik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICB7XG4gICAgaXBhZFtpXSA9IGJrZXlbaV0gXiAweDM2MzYzNjM2O1xuICAgIG9wYWRbaV0gPSBia2V5W2ldIF4gMHg1QzVDNUM1QztcbiAgfVxuXG4gIHZhciBoYXNoID0gY29yZV9zaGExKGlwYWQuY29uY2F0KHN0cjJiaW5iKGRhdGEpKSwgNTEyICsgZGF0YS5sZW5ndGggKiBjaHJzeik7XG4gIHJldHVybiBjb3JlX3NoYTEob3BhZC5jb25jYXQoaGFzaCksIDUxMiArIDE2MCk7XG59XG5cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5mdW5jdGlvbiBzYWZlX2FkZCh4LCB5KVxue1xuICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xufVxuXG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5mdW5jdGlvbiByb2wobnVtLCBjbnQpXG57XG4gIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcbn1cblxuLypcbiAqIENvbnZlcnQgYW4gOC1iaXQgb3IgMTYtYml0IHN0cmluZyB0byBhbiBhcnJheSBvZiBiaWctZW5kaWFuIHdvcmRzXG4gKiBJbiA4LWJpdCBmdW5jdGlvbiwgY2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGktYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxuICovXG5mdW5jdGlvbiBzdHIyYmluYihzdHIpXG57XG4gIHZhciBiaW4gPSBBcnJheSgpO1xuICB2YXIgbWFzayA9ICgxIDw8IGNocnN6KSAtIDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoICogY2hyc3o7IGkgKz0gY2hyc3opXG4gICAgYmluW2k+PjVdIHw9IChzdHIuY2hhckNvZGVBdChpIC8gY2hyc3opICYgbWFzaykgPDwgKDMyIC0gY2hyc3ogLSBpJTMyKTtcbiAgcmV0dXJuIGJpbjtcbn1cblxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3JkcyB0byBhIHN0cmluZ1xuICovXG5mdW5jdGlvbiBiaW5iMnN0cihiaW4pXG57XG4gIHZhciBzdHIgPSBcIlwiO1xuICB2YXIgbWFzayA9ICgxIDw8IGNocnN6KSAtIDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoICogMzI7IGkgKz0gY2hyc3opXG4gICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGJpbltpPj41XSA+Pj4gKDMyIC0gY2hyc3ogLSBpJTMyKSkgJiBtYXNrKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3JkcyB0byBhIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJpbmIyaGV4KGJpbmFycmF5KVxue1xuICB2YXIgaGV4X3RhYiA9IGhleGNhc2UgPyBcIjAxMjM0NTY3ODlBQkNERUZcIiA6IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICB2YXIgc3RyID0gXCJcIjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJpbmFycmF5Lmxlbmd0aCAqIDQ7IGkrKylcbiAge1xuICAgIHN0ciArPSBoZXhfdGFiLmNoYXJBdCgoYmluYXJyYXlbaT4+Ml0gPj4gKCgzIC0gaSU0KSo4KzQpKSAmIDB4RikgK1xuICAgICAgICAgICBoZXhfdGFiLmNoYXJBdCgoYmluYXJyYXlbaT4+Ml0gPj4gKCgzIC0gaSU0KSo4ICApKSAmIDB4Rik7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3JkcyB0byBhIGJhc2UtNjQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGJpbmIyYjY0KGJpbmFycmF5KVxue1xuICB2YXIgdGFiID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG4gIHZhciBzdHIgPSBcIlwiO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYmluYXJyYXkubGVuZ3RoICogNDsgaSArPSAzKVxuICB7XG4gICAgdmFyIHRyaXBsZXQgPSAoKChiaW5hcnJheVtpICAgPj4gMl0gPj4gOCAqICgzIC0gIGkgICAlNCkpICYgMHhGRikgPDwgMTYpXG4gICAgICAgICAgICAgICAgfCAoKChiaW5hcnJheVtpKzEgPj4gMl0gPj4gOCAqICgzIC0gKGkrMSklNCkpICYgMHhGRikgPDwgOCApXG4gICAgICAgICAgICAgICAgfCAgKChiaW5hcnJheVtpKzIgPj4gMl0gPj4gOCAqICgzIC0gKGkrMiklNCkpICYgMHhGRik7XG4gICAgZm9yKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICB7XG4gICAgICBpZihpICogOCArIGogKiA2ID4gYmluYXJyYXkubGVuZ3RoICogMzIpIHN0ciArPSBiNjRwYWQ7XG4gICAgICBlbHNlIHN0ciArPSB0YWIuY2hhckF0KCh0cmlwbGV0ID4+IDYqKDMtaikpICYgMHgzRik7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbiIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFJTQSBEYXRhIFNlY3VyaXR5LCBJbmMuIE1ENSBNZXNzYWdlXG4gKiBEaWdlc3QgQWxnb3JpdGhtLCBhcyBkZWZpbmVkIGluIFJGQyAxMzIxLlxuICogVmVyc2lvbiAyLjIgQ29weXJpZ2h0IChDKSBQYXVsIEpvaG5zdG9uIDE5OTkgLSAyMDA5XG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXG4gKi9cblxuLypcbiAqIENvbmZpZ3VyYWJsZSB2YXJpYWJsZXMuIFlvdSBtYXkgbmVlZCB0byB0d2VhayB0aGVzZSB0byBiZSBjb21wYXRpYmxlIHdpdGhcbiAqIHRoZSBzZXJ2ZXItc2lkZSwgYnV0IHRoZSBkZWZhdWx0cyB3b3JrIGluIG1vc3QgY2FzZXMuXG4gKi9cbnZhciBoZXhjYXNlID0gMDsgICAvKiBoZXggb3V0cHV0IGZvcm1hdC4gMCAtIGxvd2VyY2FzZTsgMSAtIHVwcGVyY2FzZSAgICAgICAgKi9cbnZhciBiNjRwYWQgID0gXCJcIjsgIC8qIGJhc2UtNjQgcGFkIGNoYXJhY3Rlci4gXCI9XCIgZm9yIHN0cmljdCBSRkMgY29tcGxpYW5jZSAgICovXG5cbi8qXG4gKiBUaGVzZSBhcmUgdGhlIGZ1bmN0aW9ucyB5b3UnbGwgdXN1YWxseSB3YW50IHRvIGNhbGxcbiAqIFRoZXkgdGFrZSBzdHJpbmcgYXJndW1lbnRzIGFuZCByZXR1cm4gZWl0aGVyIGhleCBvciBiYXNlLTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5mdW5jdGlvbiBoZXhfbWQ1KHMpICAgIHsgcmV0dXJuIHJzdHIyaGV4KHJzdHJfbWQ1KHN0cjJyc3RyX3V0ZjgocykpKTsgfVxuZnVuY3Rpb24gYjY0X21kNShzKSAgICB7IHJldHVybiByc3RyMmI2NChyc3RyX21kNShzdHIycnN0cl91dGY4KHMpKSk7IH1cbmZ1bmN0aW9uIGFueV9tZDUocywgZSkgeyByZXR1cm4gcnN0cjJhbnkocnN0cl9tZDUoc3RyMnJzdHJfdXRmOChzKSksIGUpOyB9XG5mdW5jdGlvbiBoZXhfaG1hY19tZDUoaywgZClcbiAgeyByZXR1cm4gcnN0cjJoZXgocnN0cl9obWFjX21kNShzdHIycnN0cl91dGY4KGspLCBzdHIycnN0cl91dGY4KGQpKSk7IH1cbmZ1bmN0aW9uIGI2NF9obWFjX21kNShrLCBkKVxuICB7IHJldHVybiByc3RyMmI2NChyc3RyX2htYWNfbWQ1KHN0cjJyc3RyX3V0ZjgoayksIHN0cjJyc3RyX3V0ZjgoZCkpKTsgfVxuZnVuY3Rpb24gYW55X2htYWNfbWQ1KGssIGQsIGUpXG4gIHsgcmV0dXJuIHJzdHIyYW55KHJzdHJfaG1hY19tZDUoc3RyMnJzdHJfdXRmOChrKSwgc3RyMnJzdHJfdXRmOChkKSksIGUpOyB9XG5cbi8qXG4gKiBQZXJmb3JtIGEgc2ltcGxlIHNlbGYtdGVzdCB0byBzZWUgaWYgdGhlIFZNIGlzIHdvcmtpbmdcbiAqL1xuZnVuY3Rpb24gbWQ1X3ZtX3Rlc3QoKVxue1xuICByZXR1cm4gaGV4X21kNShcImFiY1wiKS50b0xvd2VyQ2FzZSgpID09IFwiOTAwMTUwOTgzY2QyNGZiMGQ2OTYzZjdkMjhlMTdmNzJcIjtcbn1cblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGEgcmF3IHN0cmluZ1xuICovXG5mdW5jdGlvbiByc3RyX21kNShzKVxue1xuICByZXR1cm4gYmlubDJyc3RyKGJpbmxfbWQ1KHJzdHIyYmlubChzKSwgcy5sZW5ndGggKiA4KSk7XG59XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIEhNQUMtTUQ1LCBvZiBhIGtleSBhbmQgc29tZSBkYXRhIChyYXcgc3RyaW5ncylcbiAqL1xuZnVuY3Rpb24gcnN0cl9obWFjX21kNShrZXksIGRhdGEpXG57XG4gIHZhciBia2V5ID0gcnN0cjJiaW5sKGtleSk7XG4gIGlmKGJrZXkubGVuZ3RoID4gMTYpIGJrZXkgPSBiaW5sX21kNShia2V5LCBrZXkubGVuZ3RoICogOCk7XG5cbiAgdmFyIGlwYWQgPSBBcnJheSgxNiksIG9wYWQgPSBBcnJheSgxNik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICB7XG4gICAgaXBhZFtpXSA9IGJrZXlbaV0gXiAweDM2MzYzNjM2O1xuICAgIG9wYWRbaV0gPSBia2V5W2ldIF4gMHg1QzVDNUM1QztcbiAgfVxuXG4gIHZhciBoYXNoID0gYmlubF9tZDUoaXBhZC5jb25jYXQocnN0cjJiaW5sKGRhdGEpKSwgNTEyICsgZGF0YS5sZW5ndGggKiA4KTtcbiAgcmV0dXJuIGJpbmwycnN0cihiaW5sX21kNShvcGFkLmNvbmNhdChoYXNoKSwgNTEyICsgMTI4KSk7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGEgcmF3IHN0cmluZyB0byBhIGhleCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gcnN0cjJoZXgoaW5wdXQpXG57XG4gIHRyeSB7IGhleGNhc2UgfSBjYXRjaChlKSB7IGhleGNhc2U9MDsgfVxuICB2YXIgaGV4X3RhYiA9IGhleGNhc2UgPyBcIjAxMjM0NTY3ODlBQkNERUZcIiA6IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgdmFyIHg7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKylcbiAge1xuICAgIHggPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgIG91dHB1dCArPSBoZXhfdGFiLmNoYXJBdCgoeCA+Pj4gNCkgJiAweDBGKVxuICAgICAgICAgICArICBoZXhfdGFiLmNoYXJBdCggeCAgICAgICAgJiAweDBGKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYSBiYXNlLTY0IHN0cmluZ1xuICovXG5mdW5jdGlvbiByc3RyMmI2NChpbnB1dClcbntcbiAgdHJ5IHsgYjY0cGFkIH0gY2F0Y2goZSkgeyBiNjRwYWQ9Jyc7IH1cbiAgdmFyIHRhYiA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgdmFyIGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAzKVxuICB7XG4gICAgdmFyIHRyaXBsZXQgPSAoaW5wdXQuY2hhckNvZGVBdChpKSA8PCAxNilcbiAgICAgICAgICAgICAgICB8IChpICsgMSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsxKSA8PCA4IDogMClcbiAgICAgICAgICAgICAgICB8IChpICsgMiA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsyKSAgICAgIDogMCk7XG4gICAgZm9yKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICB7XG4gICAgICBpZihpICogOCArIGogKiA2ID4gaW5wdXQubGVuZ3RoICogOCkgb3V0cHV0ICs9IGI2NHBhZDtcbiAgICAgIGVsc2Ugb3V0cHV0ICs9IHRhYi5jaGFyQXQoKHRyaXBsZXQgPj4+IDYqKDMtaikpICYgMHgzRik7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGEgcmF3IHN0cmluZyB0byBhbiBhcmJpdHJhcnkgc3RyaW5nIGVuY29kaW5nXG4gKi9cbmZ1bmN0aW9uIHJzdHIyYW55KGlucHV0LCBlbmNvZGluZylcbntcbiAgdmFyIGRpdmlzb3IgPSBlbmNvZGluZy5sZW5ndGg7XG4gIHZhciBpLCBqLCBxLCB4LCBxdW90aWVudDtcblxuICAvKiBDb252ZXJ0IHRvIGFuIGFycmF5IG9mIDE2LWJpdCBiaWctZW5kaWFuIHZhbHVlcywgZm9ybWluZyB0aGUgZGl2aWRlbmQgKi9cbiAgdmFyIGRpdmlkZW5kID0gQXJyYXkoTWF0aC5jZWlsKGlucHV0Lmxlbmd0aCAvIDIpKTtcbiAgZm9yKGkgPSAwOyBpIDwgZGl2aWRlbmQubGVuZ3RoOyBpKyspXG4gIHtcbiAgICBkaXZpZGVuZFtpXSA9IChpbnB1dC5jaGFyQ29kZUF0KGkgKiAyKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQoaSAqIDIgKyAxKTtcbiAgfVxuXG4gIC8qXG4gICAqIFJlcGVhdGVkbHkgcGVyZm9ybSBhIGxvbmcgZGl2aXNpb24uIFRoZSBiaW5hcnkgYXJyYXkgZm9ybXMgdGhlIGRpdmlkZW5kLFxuICAgKiB0aGUgbGVuZ3RoIG9mIHRoZSBlbmNvZGluZyBpcyB0aGUgZGl2aXNvci4gT25jZSBjb21wdXRlZCwgdGhlIHF1b3RpZW50XG4gICAqIGZvcm1zIHRoZSBkaXZpZGVuZCBmb3IgdGhlIG5leHQgc3RlcC4gQWxsIHJlbWFpbmRlcnMgYXJlIHN0b3JlZCBmb3IgbGF0ZXJcbiAgICogdXNlLlxuICAgKi9cbiAgdmFyIGZ1bGxfbGVuZ3RoID0gTWF0aC5jZWlsKGlucHV0Lmxlbmd0aCAqIDggL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKE1hdGgubG9nKGVuY29kaW5nLmxlbmd0aCkgLyBNYXRoLmxvZygyKSkpO1xuICB2YXIgcmVtYWluZGVycyA9IEFycmF5KGZ1bGxfbGVuZ3RoKTtcbiAgZm9yKGogPSAwOyBqIDwgZnVsbF9sZW5ndGg7IGorKylcbiAge1xuICAgIHF1b3RpZW50ID0gQXJyYXkoKTtcbiAgICB4ID0gMDtcbiAgICBmb3IoaSA9IDA7IGkgPCBkaXZpZGVuZC5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICB4ID0gKHggPDwgMTYpICsgZGl2aWRlbmRbaV07XG4gICAgICBxID0gTWF0aC5mbG9vcih4IC8gZGl2aXNvcik7XG4gICAgICB4IC09IHEgKiBkaXZpc29yO1xuICAgICAgaWYocXVvdGllbnQubGVuZ3RoID4gMCB8fCBxID4gMClcbiAgICAgICAgcXVvdGllbnRbcXVvdGllbnQubGVuZ3RoXSA9IHE7XG4gICAgfVxuICAgIHJlbWFpbmRlcnNbal0gPSB4O1xuICAgIGRpdmlkZW5kID0gcXVvdGllbnQ7XG4gIH1cblxuICAvKiBDb252ZXJ0IHRoZSByZW1haW5kZXJzIHRvIHRoZSBvdXRwdXQgc3RyaW5nICovXG4gIHZhciBvdXRwdXQgPSBcIlwiO1xuICBmb3IoaSA9IHJlbWFpbmRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgb3V0cHV0ICs9IGVuY29kaW5nLmNoYXJBdChyZW1haW5kZXJzW2ldKTtcblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogRW5jb2RlIGEgc3RyaW5nIGFzIHV0Zi04LlxuICogRm9yIGVmZmljaWVuY3ksIHRoaXMgYXNzdW1lcyB0aGUgaW5wdXQgaXMgdmFsaWQgdXRmLTE2LlxuICovXG5mdW5jdGlvbiBzdHIycnN0cl91dGY4KGlucHV0KVxue1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIHgsIHk7XG5cbiAgd2hpbGUoKytpIDwgaW5wdXQubGVuZ3RoKVxuICB7XG4gICAgLyogRGVjb2RlIHV0Zi0xNiBzdXJyb2dhdGUgcGFpcnMgKi9cbiAgICB4ID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICB5ID0gaSArIDEgPCBpbnB1dC5sZW5ndGggPyBpbnB1dC5jaGFyQ29kZUF0KGkgKyAxKSA6IDA7XG4gICAgaWYoMHhEODAwIDw9IHggJiYgeCA8PSAweERCRkYgJiYgMHhEQzAwIDw9IHkgJiYgeSA8PSAweERGRkYpXG4gICAge1xuICAgICAgeCA9IDB4MTAwMDAgKyAoKHggJiAweDAzRkYpIDw8IDEwKSArICh5ICYgMHgwM0ZGKTtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICAvKiBFbmNvZGUgb3V0cHV0IGFzIHV0Zi04ICovXG4gICAgaWYoeCA8PSAweDdGKVxuICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoeCk7XG4gICAgZWxzZSBpZih4IDw9IDB4N0ZGKVxuICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhDMCB8ICgoeCA+Pj4gNiApICYgMHgxRiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCB4ICAgICAgICAgJiAweDNGKSk7XG4gICAgZWxzZSBpZih4IDw9IDB4RkZGRilcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RTAgfCAoKHggPj4+IDEyKSAmIDB4MEYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoeCA+Pj4gNiApICYgMHgzRiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCB4ICAgICAgICAgJiAweDNGKSk7XG4gICAgZWxzZSBpZih4IDw9IDB4MUZGRkZGKVxuICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGMCB8ICgoeCA+Pj4gMTgpICYgMHgwNyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCh4ID4+PiAxMikgJiAweDNGKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKHggPj4+IDYgKSAmIDB4M0YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICggeCAgICAgICAgICYgMHgzRikpO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qXG4gKiBFbmNvZGUgYSBzdHJpbmcgYXMgdXRmLTE2XG4gKi9cbmZ1bmN0aW9uIHN0cjJyc3RyX3V0ZjE2bGUoaW5wdXQpXG57XG4gIHZhciBvdXRwdXQgPSBcIlwiO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspXG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoIGlucHV0LmNoYXJDb2RlQXQoaSkgICAgICAgICYgMHhGRixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW5wdXQuY2hhckNvZGVBdChpKSA+Pj4gOCkgJiAweEZGKTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gc3RyMnJzdHJfdXRmMTZiZShpbnB1dClcbntcbiAgdmFyIG91dHB1dCA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKylcbiAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoaW5wdXQuY2hhckNvZGVBdChpKSA+Pj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5jaGFyQ29kZUF0KGkpICAgICAgICAmIDB4RkYpO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3Jkc1xuICogQ2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGlnaC1ieXRlIHNpbGVudGx5IGlnbm9yZWQuXG4gKi9cbmZ1bmN0aW9uIHJzdHIyYmlubChpbnB1dClcbntcbiAgdmFyIG91dHB1dCA9IEFycmF5KGlucHV0Lmxlbmd0aCA+PiAyKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkrKylcbiAgICBvdXRwdXRbaV0gPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoICogODsgaSArPSA4KVxuICAgIG91dHB1dFtpPj41XSB8PSAoaW5wdXQuY2hhckNvZGVBdChpIC8gOCkgJiAweEZGKSA8PCAoaSUzMik7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMgdG8gYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYmlubDJyc3RyKGlucHV0KVxue1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCAqIDMyOyBpICs9IDgpXG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGlucHV0W2k+PjVdID4+PiAoaSAlIDMyKSkgJiAweEZGKTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGJpbmxfbWQ1KHgsIGxlbilcbntcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAoKGxlbikgJSAzMik7XG4gIHhbKCgobGVuICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IGxlbjtcblxuICB2YXIgYSA9ICAxNzMyNTg0MTkzO1xuICB2YXIgYiA9IC0yNzE3MzM4Nzk7XG4gIHZhciBjID0gLTE3MzI1ODQxOTQ7XG4gIHZhciBkID0gIDI3MTczMzg3ODtcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpXG4gIHtcbiAgICB2YXIgb2xkYSA9IGE7XG4gICAgdmFyIG9sZGIgPSBiO1xuICAgIHZhciBvbGRjID0gYztcbiAgICB2YXIgb2xkZCA9IGQ7XG5cbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgMF0sIDcgLCAtNjgwODc2OTM2KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgMV0sIDEyLCAtMzg5NTY0NTg2KTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsgMl0sIDE3LCAgNjA2MTA1ODE5KTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDRdLCA3ICwgLTE3NjQxODg5Nyk7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDVdLCAxMiwgIDEyMDAwODA0MjYpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKyA2XSwgMTcsIC0xNDczMjMxMzQxKTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsgN10sIDIyLCAtNDU3MDU5ODMpO1xuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyA4XSwgNyAsICAxNzcwMDM1NDE2KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krMTBdLCAxNywgLTQyMDYzKTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krMTJdLCA3ICwgIDE4MDQ2MDM2ODIpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKzEzXSwgMTIsIC00MDM0MTEwMSk7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKzE1XSwgMjIsICAxMjM2NTM1MzI5KTtcblxuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyAxXSwgNSAsIC0xNjU3OTY1MTApO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyA2XSwgOSAsIC0xMDY5NTAxNjMyKTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE0LCAgNjQzNzE3NzEzKTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgMF0sIDIwLCAtMzczODk3MzAyKTtcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgNV0sIDUgLCAtNzAxNTU4NjkxKTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsxMF0sIDkgLCAgMzgwMTYwODMpO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKzE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyA5XSwgNSAsICA1Njg0NDY0MzgpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKzE0XSwgOSAsIC0xMDE5ODAzNjkwKTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgOF0sIDIwLCAgMTE2MzUzMTUwMSk7XG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krMTNdLCA1ICwgLTE0NDQ2ODE0NjcpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKyAyXSwgOSAsIC01MTQwMzc4NCk7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krIDddLCAxNCwgIDE3MzUzMjg0NzMpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKzEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcblxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA1XSwgNCAsIC0zNzg1NTgpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsxMV0sIDE2LCAgMTgzOTAzMDU2Mik7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgMV0sIDQgLCAtMTUzMDk5MjA2MCk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDRdLCAxMSwgIDEyNzI4OTMzNTMpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKzEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsxM10sIDQgLCAgNjgxMjc5MTc0KTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgMF0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsgNl0sIDIzLCAgNzYwMjkxODkpO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyA5XSwgNCAsIC02NDAzNjQ0ODcpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKzEyXSwgMTEsIC00MjE4MTU4MzUpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKzE1XSwgMTYsICA1MzA3NDI1MjApO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xuXG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDBdLCA2ICwgLTE5ODYzMDg0NCk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krIDddLCAxMCwgIDExMjY4OTE0MTUpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKzE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgNV0sIDIxLCAtNTc0MzQwNTUpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKzEyXSwgNiAsICAxNzAwNDg1NTcxKTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krMTBdLCAxNSwgLTEwNTE1MjMpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyAxXSwgMjEsIC0yMDU0OTIyNzk5KTtcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgOF0sIDYgLCAgMTg3MzMxMzM1OSk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krMTNdLCAyMSwgIDEzMDkxNTE2NDkpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyA0XSwgNiAsIC0xNDU1MjMwNzApO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKzExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsgMl0sIDE1LCAgNzE4Nzg3MjU5KTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgOV0sIDIxLCAtMzQzNDg1NTUxKTtcblxuICAgIGEgPSBzYWZlX2FkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVfYWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlX2FkZChkLCBvbGRkKTtcbiAgfVxuICByZXR1cm4gQXJyYXkoYSwgYiwgYywgZCk7XG59XG5cbi8qXG4gKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IHRoZSBmb3VyIGJhc2ljIG9wZXJhdGlvbnMgdGhlIGFsZ29yaXRobSB1c2VzLlxuICovXG5mdW5jdGlvbiBtZDVfY21uKHEsIGEsIGIsIHgsIHMsIHQpXG57XG4gIHJldHVybiBzYWZlX2FkZChiaXRfcm9sKHNhZmVfYWRkKHNhZmVfYWRkKGEsIHEpLCBzYWZlX2FkZCh4LCB0KSksIHMpLGIpO1xufVxuZnVuY3Rpb24gbWQ1X2ZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNV9nZyhhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbigoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfaGgoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNV9paShhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbihjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG59XG5cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5mdW5jdGlvbiBzYWZlX2FkZCh4LCB5KVxue1xuICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xufVxuXG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5mdW5jdGlvbiBiaXRfcm9sKG51bSwgY250KVxue1xuICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XG59XG5cblxuZXhwb3J0cy5oZXhfbWQ1ID0gaGV4X21kNTtcbmV4cG9ydHMuYjY0X21kNSA9IGI2NF9tZDU7XG5leHBvcnRzLmFueV9tZDUgPSBhbnlfbWQ1O1xuIiwiLy8gdG9kb1xuIixudWxsLCJ2YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcbiAgLCBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJylcbiAgO1xuXG5mdW5jdGlvbiBzaGExIChrZXksIGJvZHkpIHtcbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIbWFjKCdzaGExJywga2V5KS51cGRhdGUoYm9keSkuZGlnZXN0KCdiYXNlNjQnKVxufVxuXG5mdW5jdGlvbiByZmMzOTg2IChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpXG4gICAgLnJlcGxhY2UoLyEvZywnJTIxJylcbiAgICAucmVwbGFjZSgvXFwqL2csJyUyQScpXG4gICAgLnJlcGxhY2UoL1xcKC9nLCclMjgnKVxuICAgIC5yZXBsYWNlKC9cXCkvZywnJTI5JylcbiAgICAucmVwbGFjZSgvJy9nLCclMjcnKVxuICAgIDtcbn1cblxuZnVuY3Rpb24gaG1hY3NpZ24gKGh0dHBNZXRob2QsIGJhc2VfdXJpLCBwYXJhbXMsIGNvbnN1bWVyX3NlY3JldCwgdG9rZW5fc2VjcmV0KSB7XG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2Rldi50d2l0dGVyLmNvbS9kb2NzL2F1dGgvb2F1dGggYW5kIFxuICAvLyBodHRwczovL2Rldi50d2l0dGVyLmNvbS9kb2NzL2F1dGgvY3JlYXRpbmctc2lnbmF0dXJlXG5cbiAgdmFyIHF1ZXJ5c3RyaW5nID0gT2JqZWN0LmtleXMocGFyYW1zKS5zb3J0KCkubWFwKGZ1bmN0aW9uKGtleSl7XG4gICAgLy8gYmlnIFdURiBoZXJlIHdpdGggdGhlIGVzY2FwZSArIGVuY29kaW5nIGJ1dCBpdCdzIHdoYXQgdHdpdHRlciB3YW50c1xuICAgIHJldHVybiBlc2NhcGUocmZjMzk4NihrZXkpKSArIFwiJTNEXCIgKyBlc2NhcGUocmZjMzk4NihwYXJhbXNba2V5XSkpXG4gIH0pLmpvaW4oJyUyNicpXG5cbiAgdmFyIGJhc2UgPSBbXG4gICAgaHR0cE1ldGhvZCA/IGh0dHBNZXRob2QudG9VcHBlckNhc2UoKSA6ICdHRVQnLFxuICAgIHJmYzM5ODYoYmFzZV91cmkpLFxuICAgIHF1ZXJ5c3RyaW5nXG4gIF0uam9pbignJicpXG5cbiAgdmFyIGtleSA9IFtcbiAgICBjb25zdW1lcl9zZWNyZXQsXG4gICAgdG9rZW5fc2VjcmV0IHx8ICcnXG4gIF0ubWFwKHJmYzM5ODYpLmpvaW4oJyYnKVxuXG4gIHJldHVybiBzaGExKGtleSwgYmFzZSlcbn1cblxuZXhwb3J0cy5obWFjc2lnbiA9IGhtYWNzaWduXG5leHBvcnRzLnJmYzM5ODYgPSByZmMzOTg2XG4iLCJcbi8qIVxuICoga25veCAtIGF1dGhcbiAqIENvcHlyaWdodChjKSAyMDEwIExlYXJuQm9vc3QgPGRldkBsZWFybmJvb3N0LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcbiAgLCBwYXJzZSA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlXG4gIDtcblxuLyoqXG4gKiBWYWxpZCBrZXlzLlxuICovXG5cbnZhciBrZXlzID0gXG4gIFsgJ2FjbCdcbiAgLCAnbG9jYXRpb24nXG4gICwgJ2xvZ2dpbmcnXG4gICwgJ25vdGlmaWNhdGlvbidcbiAgLCAncGFydE51bWJlcidcbiAgLCAncG9saWN5J1xuICAsICdyZXF1ZXN0UGF5bWVudCdcbiAgLCAndG9ycmVudCdcbiAgLCAndXBsb2FkSWQnXG4gICwgJ3VwbG9hZHMnXG4gICwgJ3ZlcnNpb25JZCdcbiAgLCAndmVyc2lvbmluZydcbiAgLCAndmVyc2lvbnMnXG4gICwgJ3dlYnNpdGUnXG4gIF1cblxuLyoqXG4gKiBSZXR1cm4gYW4gXCJBdXRob3JpemF0aW9uXCIgaGVhZGVyIHZhbHVlIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYFxuICogaW4gdGhlIGZvcm0gb2YgXCJBV1MgPGtleT46PHNpZ25hdHVyZT5cIlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBhdXRob3JpemF0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiAnQVdTICcgKyBvcHRpb25zLmtleSArICc6JyArIHNpZ24ob3B0aW9ucylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhdXRob3JpemF0aW9uXG5tb2R1bGUuZXhwb3J0cy5hdXRob3JpemF0aW9uID0gYXV0aG9yaXphdGlvblxuXG4vKipcbiAqIFNpbXBsZSBITUFDLVNIQTEgV3JhcHBlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqLyBcblxuZnVuY3Rpb24gaG1hY1NoYTEgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIbWFjKCdzaGExJywgb3B0aW9ucy5zZWNyZXQpLnVwZGF0ZShvcHRpb25zLm1lc3NhZ2UpLmRpZ2VzdCgnYmFzZTY0Jylcbn1cblxubW9kdWxlLmV4cG9ydHMuaG1hY1NoYTEgPSBobWFjU2hhMVxuXG4vKipcbiAqIENyZWF0ZSBhIGJhc2U2NCBzaGExIEhNQUMgZm9yIGBvcHRpb25zYC4gXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzaWduIChvcHRpb25zKSB7XG4gIG9wdGlvbnMubWVzc2FnZSA9IHN0cmluZ1RvU2lnbihvcHRpb25zKVxuICByZXR1cm4gaG1hY1NoYTEob3B0aW9ucylcbn1cbm1vZHVsZS5leHBvcnRzLnNpZ24gPSBzaWduXG5cbi8qKlxuICogQ3JlYXRlIGEgYmFzZTY0IHNoYTEgSE1BQyBmb3IgYG9wdGlvbnNgLiBcbiAqXG4gKiBTcGVjaWZpY2FsbHkgdG8gYmUgdXNlZCB3aXRoIFMzIHByZXNpZ25lZCBVUkxzXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzaWduUXVlcnkgKG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5tZXNzYWdlID0gcXVlcnlTdHJpbmdUb1NpZ24ob3B0aW9ucylcbiAgcmV0dXJuIGhtYWNTaGExKG9wdGlvbnMpXG59XG5tb2R1bGUuZXhwb3J0cy5zaWduUXVlcnk9IHNpZ25RdWVyeVxuXG4vKipcbiAqIFJldHVybiBhIHN0cmluZyBmb3Igc2lnbigpIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYC5cbiAqXG4gKiBTcGVjOlxuICogXG4gKiAgICA8dmVyYj5cXG5cbiAqICAgIDxtZDU+XFxuXG4gKiAgICA8Y29udGVudC10eXBlPlxcblxuICogICAgPGRhdGU+XFxuXG4gKiAgICBbaGVhZGVyc1xcbl1cbiAqICAgIDxyZXNvdXJjZT5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc3RyaW5nVG9TaWduIChvcHRpb25zKSB7XG4gIHZhciBoZWFkZXJzID0gb3B0aW9ucy5hbWF6b25IZWFkZXJzIHx8ICcnXG4gIGlmIChoZWFkZXJzKSBoZWFkZXJzICs9ICdcXG4nXG4gIHZhciByID0gXG4gICAgWyBvcHRpb25zLnZlcmJcbiAgICAsIG9wdGlvbnMubWQ1XG4gICAgLCBvcHRpb25zLmNvbnRlbnRUeXBlXG4gICAgLCBvcHRpb25zLmRhdGUudG9VVENTdHJpbmcoKVxuICAgICwgaGVhZGVycyArIG9wdGlvbnMucmVzb3VyY2VcbiAgICBdXG4gIHJldHVybiByLmpvaW4oJ1xcbicpXG59XG5tb2R1bGUuZXhwb3J0cy5xdWVyeVN0cmluZ1RvU2lnbiA9IHN0cmluZ1RvU2lnblxuXG4vKipcbiAqIFJldHVybiBhIHN0cmluZyBmb3Igc2lnbigpIHdpdGggdGhlIGdpdmVuIGBvcHRpb25zYCwgYnV0IGlzIG1lYW50IGV4Y2x1c2l2ZWx5XG4gKiBmb3IgUzMgcHJlc2lnbmVkIFVSTHNcbiAqXG4gKiBTcGVjOlxuICogXG4gKiAgICA8ZGF0ZT5cXG5cbiAqICAgIDxyZXNvdXJjZT5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcXVlcnlTdHJpbmdUb1NpZ24gKG9wdGlvbnMpe1xuICByZXR1cm4gJ0dFVFxcblxcblxcbicgKyBvcHRpb25zLmRhdGUgKyAnXFxuJyArIG9wdGlvbnMucmVzb3VyY2Vcbn1cbm1vZHVsZS5leHBvcnRzLnF1ZXJ5U3RyaW5nVG9TaWduID0gcXVlcnlTdHJpbmdUb1NpZ25cblxuLyoqXG4gKiBQZXJmb3JtIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogIC0gaWdub3JlIG5vbi1hbWF6b24gaGVhZGVyc1xuICogIC0gbG93ZXJjYXNlIGZpZWxkc1xuICogIC0gc29ydCBsZXhpY29ncmFwaGljYWxseVxuICogIC0gdHJpbSB3aGl0ZXNwYWNlIGJldHdlZW4gXCI6XCJcbiAqICAtIGpvaW4gd2l0aCBuZXdsaW5lXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZUhlYWRlcnMgKGhlYWRlcnMpIHtcbiAgdmFyIGJ1ZiA9IFtdXG4gICAgLCBmaWVsZHMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgIDtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXVxuICAgICAgLCB2YWwgPSBoZWFkZXJzW2ZpZWxkXVxuICAgICAgLCBmaWVsZCA9IGZpZWxkLnRvTG93ZXJDYXNlKClcbiAgICAgIDtcbiAgICBpZiAoMCAhPT0gZmllbGQuaW5kZXhPZigneC1hbXonKSkgY29udGludWVcbiAgICBidWYucHVzaChmaWVsZCArICc6JyArIHZhbClcbiAgfVxuICByZXR1cm4gYnVmLnNvcnQoKS5qb2luKCdcXG4nKVxufVxubW9kdWxlLmV4cG9ydHMuY2Fub25pY2FsaXplSGVhZGVycyA9IGNhbm9uaWNhbGl6ZUhlYWRlcnNcblxuLyoqXG4gKiBQZXJmb3JtIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogIC0gaWdub3JlIG5vbiBzdWItcmVzb3VyY2VzXG4gKiAgLSBzb3J0IGxleGljb2dyYXBoaWNhbGx5XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlc291cmNlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjYW5vbmljYWxpemVSZXNvdXJjZSAocmVzb3VyY2UpIHtcbiAgdmFyIHVybCA9IHBhcnNlKHJlc291cmNlLCB0cnVlKVxuICAgICwgcGF0aCA9IHVybC5wYXRobmFtZVxuICAgICwgYnVmID0gW11cbiAgICA7XG5cbiAgT2JqZWN0LmtleXModXJsLnF1ZXJ5KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7XG4gICAgaWYgKCF+a2V5cy5pbmRleE9mKGtleSkpIHJldHVyblxuICAgIHZhciB2YWwgPSAnJyA9PSB1cmwucXVlcnlba2V5XSA/ICcnIDogJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHVybC5xdWVyeVtrZXldKVxuICAgIGJ1Zi5wdXNoKGtleSArIHZhbClcbiAgfSlcblxuICByZXR1cm4gcGF0aCArIChidWYubGVuZ3RoID8gJz8nICsgYnVmLnNvcnQoKS5qb2luKCcmJykgOiAnJylcbn1cbm1vZHVsZS5leHBvcnRzLmNhbm9uaWNhbGl6ZVJlc291cmNlID0gY2Fub25pY2FsaXplUmVzb3VyY2VcbiIsIihmdW5jdGlvbihwcm9jZXNzLF9fZGlybmFtZSl7dmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuXG5mdW5jdGlvbiBNaW1lKCkge1xuICAvLyBNYXAgb2YgZXh0ZW5zaW9uIC0+IG1pbWUgdHlwZVxuICB0aGlzLnR5cGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvLyBNYXAgb2YgbWltZSB0eXBlIC0+IGV4dGVuc2lvblxuICB0aGlzLmV4dGVuc2lvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG4vKipcbiAqIERlZmluZSBtaW1ldHlwZSAtPiBleHRlbnNpb24gbWFwcGluZ3MuICBFYWNoIGtleSBpcyBhIG1pbWUtdHlwZSB0aGF0IG1hcHNcbiAqIHRvIGFuIGFycmF5IG9mIGV4dGVuc2lvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0eXBlLiAgVGhlIGZpcnN0IGV4dGVuc2lvbiBpc1xuICogdXNlZCBhcyB0aGUgZGVmYXVsdCBleHRlbnNpb24gZm9yIHRoZSB0eXBlLlxuICpcbiAqIGUuZy4gbWltZS5kZWZpbmUoeydhdWRpby9vZ2cnLCBbJ29nYScsICdvZ2cnLCAnc3B4J119KTtcbiAqXG4gKiBAcGFyYW0gbWFwIChPYmplY3QpIHR5cGUgZGVmaW5pdGlvbnNcbiAqL1xuTWltZS5wcm90b3R5cGUuZGVmaW5lID0gZnVuY3Rpb24gKG1hcCkge1xuICBmb3IgKHZhciB0eXBlIGluIG1hcCkge1xuICAgIHZhciBleHRzID0gbWFwW3R5cGVdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuREVCVUdfTUlNRSAmJiB0aGlzLnR5cGVzW2V4dHNdKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybih0aGlzLl9sb2FkaW5nLnJlcGxhY2UoLy4qXFwvLywgJycpLCAnY2hhbmdlcyBcIicgKyBleHRzW2ldICsgJ1wiIGV4dGVuc2lvbiB0eXBlIGZyb20gJyArXG4gICAgICAgICAgdGhpcy50eXBlc1tleHRzXSArICcgdG8gJyArIHR5cGUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnR5cGVzW2V4dHNbaV1dID0gdHlwZTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IGV4dGVuc2lvbiBpcyB0aGUgZmlyc3Qgb25lIHdlIGVuY291bnRlclxuICAgIGlmICghdGhpcy5leHRlbnNpb25zW3R5cGVdKSB7XG4gICAgICB0aGlzLmV4dGVuc2lvbnNbdHlwZV0gPSBleHRzWzBdO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBMb2FkIGFuIEFwYWNoZTItc3R5bGUgXCIudHlwZXNcIiBmaWxlXG4gKlxuICogVGhpcyBtYXkgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIChpdCdzIGV4cGVjdGVkKS4gIFdoZXJlIGZpbGVzIGRlY2xhcmVcbiAqIG92ZXJsYXBwaW5nIHR5cGVzL2V4dGVuc2lvbnMsIHRoZSBsYXN0IGZpbGUgd2lucy5cbiAqXG4gKiBAcGFyYW0gZmlsZSAoU3RyaW5nKSBwYXRoIG9mIGZpbGUgdG8gbG9hZC5cbiAqL1xuTWltZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKGZpbGUpIHtcblxuICB0aGlzLl9sb2FkaW5nID0gZmlsZTtcbiAgLy8gUmVhZCBmaWxlIGFuZCBzcGxpdCBpbnRvIGxpbmVzXG4gIHZhciBtYXAgPSB7fSxcbiAgICAgIGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ2FzY2lpJyksXG4gICAgICBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoL1tcXHJcXG5dKy8pO1xuXG4gIGxpbmVzLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgIC8vIENsZWFuIHVwIHdoaXRlc3BhY2UvY29tbWVudHMsIGFuZCBzcGxpdCBpbnRvIGZpZWxkc1xuICAgIHZhciBmaWVsZHMgPSBsaW5lLnJlcGxhY2UoL1xccyojLip8Xlxccyp8XFxzKiQvZywgJycpLnNwbGl0KC9cXHMrLyk7XG4gICAgbWFwW2ZpZWxkcy5zaGlmdCgpXSA9IGZpZWxkcztcbiAgfSk7XG5cbiAgdGhpcy5kZWZpbmUobWFwKTtcblxuICB0aGlzLl9sb2FkaW5nID0gbnVsbDtcbn07XG5cbi8qKlxuICogTG9va3VwIGEgbWltZSB0eXBlIGJhc2VkIG9uIGV4dGVuc2lvblxuICovXG5NaW1lLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbihwYXRoLCBmYWxsYmFjaykge1xuICB2YXIgZXh0ID0gcGF0aC5yZXBsYWNlKC8uKltcXC5cXC9dLywgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIHRoaXMudHlwZXNbZXh0XSB8fCBmYWxsYmFjayB8fCB0aGlzLmRlZmF1bHRfdHlwZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGZpbGUgZXh0ZW5zaW9uIGFzc29jaWF0ZWQgd2l0aCBhIG1pbWUgdHlwZVxuICovXG5NaW1lLnByb3RvdHlwZS5leHRlbnNpb24gPSBmdW5jdGlvbihtaW1lVHlwZSkge1xuICByZXR1cm4gdGhpcy5leHRlbnNpb25zW21pbWVUeXBlXTtcbn07XG5cbi8vIERlZmF1bHQgaW5zdGFuY2VcbnZhciBtaW1lID0gbmV3IE1pbWUoKTtcblxuLy8gTG9hZCBsb2NhbCBjb3B5IG9mXG4vLyBodHRwOi8vc3ZuLmFwYWNoZS5vcmcvcmVwb3MvYXNmL2h0dHBkL2h0dHBkL3RydW5rL2RvY3MvY29uZi9taW1lLnR5cGVzXG5taW1lLmxvYWQocGF0aC5qb2luKF9fZGlybmFtZSwgJ3R5cGVzL21pbWUudHlwZXMnKSk7XG5cbi8vIExvYWQgYWRkaXRpb25hbCB0eXBlcyBmcm9tIG5vZGUuanMgY29tbXVuaXR5XG5taW1lLmxvYWQocGF0aC5qb2luKF9fZGlybmFtZSwgJ3R5cGVzL25vZGUudHlwZXMnKSk7XG5cbi8vIERlZmF1bHQgdHlwZVxubWltZS5kZWZhdWx0X3R5cGUgPSBtaW1lLmxvb2t1cCgnYmluJyk7XG5cbi8vXG4vLyBBZGRpdGlvbmFsIEFQSSBzcGVjaWZpYyB0byB0aGUgZGVmYXVsdCBpbnN0YW5jZVxuLy9cblxubWltZS5NaW1lID0gTWltZTtcblxuLyoqXG4gKiBMb29rdXAgYSBjaGFyc2V0IGJhc2VkIG9uIG1pbWUgdHlwZS5cbiAqL1xubWltZS5jaGFyc2V0cyA9IHtcbiAgbG9va3VwOiBmdW5jdGlvbihtaW1lVHlwZSwgZmFsbGJhY2spIHtcbiAgICAvLyBBc3N1bWUgdGV4dCB0eXBlcyBhcmUgdXRmOFxuICAgIHJldHVybiAoL150ZXh0XFwvLykudGVzdChtaW1lVHlwZSkgPyAnVVRGLTgnIDogZmFsbGJhY2s7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWltZTtcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpLFwiL3JlcXVlc3Qvbm9kZV9tb2R1bGVzL21pbWVcIikiLCIoZnVuY3Rpb24oQnVmZmVyKXsvLyAgICAgdXVpZC5qc1xuLy9cbi8vICAgICAoYykgMjAxMC0yMDEyIFJvYmVydCBLaWVmZmVyXG4vLyAgICAgTUlUIExpY2Vuc2Vcbi8vICAgICBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZFxuKGZ1bmN0aW9uKCkge1xuICB2YXIgX2dsb2JhbCA9IHRoaXM7XG5cbiAgLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gIFdlIGZlYXR1cmVcbiAgLy8gZGV0ZWN0IHRvIGRldGVybWluZSB0aGUgYmVzdCBSTkcgc291cmNlLCBub3JtYWxpemluZyB0byBhIGZ1bmN0aW9uIHRoYXRcbiAgLy8gcmV0dXJucyAxMjgtYml0cyBvZiByYW5kb21uZXNzLCBzaW5jZSB0aGF0J3Mgd2hhdCdzIHVzdWFsbHkgcmVxdWlyZWRcbiAgdmFyIF9ybmc7XG5cbiAgLy8gTm9kZS5qcyBjcnlwdG8tYmFzZWQgUk5HIC0gaHR0cDovL25vZGVqcy5vcmcvZG9jcy92MC42LjIvYXBpL2NyeXB0by5odG1sXG4gIC8vXG4gIC8vIE1vZGVyYXRlbHkgZmFzdCwgaGlnaCBxdWFsaXR5XG4gIGlmICh0eXBlb2YocmVxdWlyZSkgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgX3JiID0gcmVxdWlyZSgnY3J5cHRvJykucmFuZG9tQnl0ZXM7XG4gICAgICBfcm5nID0gX3JiICYmIGZ1bmN0aW9uKCkge3JldHVybiBfcmIoMTYpO307XG4gICAgfSBjYXRjaChlKSB7fVxuICB9XG5cbiAgaWYgKCFfcm5nICYmIF9nbG9iYWwuY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBXSEFUV0cgY3J5cHRvLWJhc2VkIFJORyAtIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9DcnlwdG9cbiAgICAvL1xuICAgIC8vIE1vZGVyYXRlbHkgZmFzdCwgaGlnaCBxdWFsaXR5XG4gICAgdmFyIF9ybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICBfcm5nID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhfcm5kczgpO1xuICAgICAgcmV0dXJuIF9ybmRzODtcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFfcm5nKSB7XG4gICAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAgIC8vXG4gICAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgICAvLyBxdWFsaXR5LlxuICAgIHZhciAgX3JuZHMgPSBuZXcgQXJyYXkoMTYpO1xuICAgIF9ybmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgICBpZiAoKGkgJiAweDAzKSA9PT0gMCkgciA9IE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMDtcbiAgICAgICAgX3JuZHNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcm5kcztcbiAgICB9O1xuICB9XG5cbiAgLy8gQnVmZmVyIGNsYXNzIHRvIHVzZVxuICB2YXIgQnVmZmVyQ2xhc3MgPSB0eXBlb2YoQnVmZmVyKSA9PSAnZnVuY3Rpb24nID8gQnVmZmVyIDogQXJyYXk7XG5cbiAgLy8gTWFwcyBmb3IgbnVtYmVyIDwtPiBoZXggc3RyaW5nIGNvbnZlcnNpb25cbiAgdmFyIF9ieXRlVG9IZXggPSBbXTtcbiAgdmFyIF9oZXhUb0J5dGUgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgIF9ieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xuICAgIF9oZXhUb0J5dGVbX2J5dGVUb0hleFtpXV0gPSBpO1xuICB9XG5cbiAgLy8gKipgcGFyc2UoKWAgLSBQYXJzZSBhIFVVSUQgaW50byBpdCdzIGNvbXBvbmVudCBieXRlcyoqXG4gIGZ1bmN0aW9uIHBhcnNlKHMsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgdmFyIGkgPSAoYnVmICYmIG9mZnNldCkgfHwgMCwgaWkgPSAwO1xuXG4gICAgYnVmID0gYnVmIHx8IFtdO1xuICAgIHMudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bMC05YS1mXXsyfS9nLCBmdW5jdGlvbihvY3QpIHtcbiAgICAgIGlmIChpaSA8IDE2KSB7IC8vIERvbid0IG92ZXJmbG93IVxuICAgICAgICBidWZbaSArIGlpKytdID0gX2hleFRvQnl0ZVtvY3RdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gWmVybyBvdXQgcmVtYWluaW5nIGJ5dGVzIGlmIHN0cmluZyB3YXMgc2hvcnRcbiAgICB3aGlsZSAoaWkgPCAxNikge1xuICAgICAgYnVmW2kgKyBpaSsrXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIC8vICoqYHVucGFyc2UoKWAgLSBDb252ZXJ0IFVVSUQgYnl0ZSBhcnJheSAoYWxhIHBhcnNlKCkpIGludG8gYSBzdHJpbmcqKlxuICBmdW5jdGlvbiB1bnBhcnNlKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgdmFyIGkgPSBvZmZzZXQgfHwgMCwgYnRoID0gX2J5dGVUb0hleDtcbiAgICByZXR1cm4gIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dO1xuICB9XG5cbiAgLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuICAvL1xuICAvLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuICAvLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG4gIC8vIHJhbmRvbSAjJ3Mgd2UgbmVlZCB0byBpbml0IG5vZGUgYW5kIGNsb2Nrc2VxXG4gIHZhciBfc2VlZEJ5dGVzID0gX3JuZygpO1xuXG4gIC8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxuICB2YXIgX25vZGVJZCA9IFtcbiAgICBfc2VlZEJ5dGVzWzBdIHwgMHgwMSxcbiAgICBfc2VlZEJ5dGVzWzFdLCBfc2VlZEJ5dGVzWzJdLCBfc2VlZEJ5dGVzWzNdLCBfc2VlZEJ5dGVzWzRdLCBfc2VlZEJ5dGVzWzVdXG4gIF07XG5cbiAgLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbiAgdmFyIF9jbG9ja3NlcSA9IChfc2VlZEJ5dGVzWzZdIDw8IDggfCBfc2VlZEJ5dGVzWzddKSAmIDB4M2ZmZjtcblxuICAvLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcbiAgdmFyIF9sYXN0TVNlY3MgPSAwLCBfbGFzdE5TZWNzID0gMDtcblxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG4gIGZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gICAgdmFyIGIgPSBidWYgfHwgW107XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT0gbnVsbCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7XG5cbiAgICAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAgIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gICAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gICAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cbiAgICB2YXIgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9IG51bGwgPyBvcHRpb25zLm1zZWNzIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gICAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcbiAgICB2YXIgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9IG51bGwgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7XG5cbiAgICAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG4gICAgdmFyIGR0ID0gKG1zZWNzIC0gX2xhc3RNU2VjcykgKyAobnNlY3MgLSBfbGFzdE5TZWNzKS8xMDAwMDtcblxuICAgIC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cbiAgICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgICAvLyB0aW1lIGludGVydmFsXG4gICAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09IG51bGwpIHtcbiAgICAgIG5zZWNzID0gMDtcbiAgICB9XG5cbiAgICAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG4gICAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3V1aWQudjEoKTogQ2FuXFwndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWMnKTtcbiAgICB9XG5cbiAgICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gICAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICAgIF9jbG9ja3NlcSA9IGNsb2Nrc2VxO1xuXG4gICAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gICAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7XG5cbiAgICAvLyBgdGltZV9sb3dgXG4gICAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICAgIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gICAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gICAgYltpKytdID0gdGwgJiAweGZmO1xuXG4gICAgLy8gYHRpbWVfbWlkYFxuICAgIHZhciB0bWggPSAobXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwKSAmIDB4ZmZmZmZmZjtcbiAgICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xuICAgIGJbaSsrXSA9IHRtaCAmIDB4ZmY7XG5cbiAgICAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuICAgIGJbaSsrXSA9IHRtaCA+Pj4gMjQgJiAweGYgfCAweDEwOyAvLyBpbmNsdWRlIHZlcnNpb25cbiAgICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjtcblxuICAgIC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuICAgIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDtcblxuICAgIC8vIGBjbG9ja19zZXFfbG93YFxuICAgIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjtcblxuICAgIC8vIGBub2RlYFxuICAgIHZhciBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyBuKyspIHtcbiAgICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmID8gYnVmIDogdW5wYXJzZShiKTtcbiAgfVxuXG4gIC8vICoqYHY0KClgIC0gR2VuZXJhdGUgcmFuZG9tIFVVSUQqKlxuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbiAgZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgICAvLyBEZXByZWNhdGVkIC0gJ2Zvcm1hdCcgYXJndW1lbnQsIGFzIHN1cHBvcnRlZCBpbiB2MS4yXG4gICAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgICBpZiAodHlwZW9mKG9wdGlvbnMpID09ICdzdHJpbmcnKSB7XG4gICAgICBidWYgPSBvcHRpb25zID09ICdiaW5hcnknID8gbmV3IEJ1ZmZlckNsYXNzKDE2KSA6IG51bGw7XG4gICAgICBvcHRpb25zID0gbnVsbDtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBfcm5nKSgpO1xuXG4gICAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICAgIHJuZHNbNl0gPSAocm5kc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgICBybmRzWzhdID0gKHJuZHNbOF0gJiAweDNmKSB8IDB4ODA7XG5cbiAgICAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcbiAgICBpZiAoYnVmKSB7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgMTY7IGlpKyspIHtcbiAgICAgICAgYnVmW2kgKyBpaV0gPSBybmRzW2lpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmIHx8IHVucGFyc2Uocm5kcyk7XG4gIH1cblxuICAvLyBFeHBvcnQgcHVibGljIEFQSVxuICB2YXIgdXVpZCA9IHY0O1xuICB1dWlkLnYxID0gdjE7XG4gIHV1aWQudjQgPSB2NDtcbiAgdXVpZC5wYXJzZSA9IHBhcnNlO1xuICB1dWlkLnVucGFyc2UgPSB1bnBhcnNlO1xuICB1dWlkLkJ1ZmZlckNsYXNzID0gQnVmZmVyQ2xhc3M7XG5cbiAgaWYgKF9nbG9iYWwuZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBQdWJsaXNoIGFzIEFNRCBtb2R1bGVcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7cmV0dXJuIHV1aWQ7fSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mKG1vZHVsZSkgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAvLyBQdWJsaXNoIGFzIG5vZGUuanMgbW9kdWxlXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB1dWlkO1xuICB9IGVsc2Uge1xuICAgIC8vIFB1Ymxpc2ggYXMgZ2xvYmFsIChpbiBicm93c2VycylcbiAgICB2YXIgX3ByZXZpb3VzUm9vdCA9IF9nbG9iYWwudXVpZDtcblxuICAgIC8vICoqYG5vQ29uZmxpY3QoKWAgLSAoYnJvd3NlciBvbmx5KSB0byByZXNldCBnbG9iYWwgJ3V1aWQnIHZhcioqXG4gICAgdXVpZC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBfZ2xvYmFsLnV1aWQgPSBfcHJldmlvdXNSb290O1xuICAgICAgcmV0dXJuIHV1aWQ7XG4gICAgfTtcblxuICAgIF9nbG9iYWwudXVpZCA9IHV1aWQ7XG4gIH1cbn0oKSk7XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfYnVmZmVyXCIpLkJ1ZmZlcikiLCIoZnVuY3Rpb24ocHJvY2VzcyxCdWZmZXIpeyd1c2Ugc3RyaWN0J1xuXG52YXIgbmV0ID0gcmVxdWlyZSgnbmV0JylcbiAgLCB0bHMgPSByZXF1aXJlKCd0bHMnKVxuICAsIGh0dHAgPSByZXF1aXJlKCdodHRwJylcbiAgLCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJylcbiAgLCBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKVxuICAsIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG4gICwgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuICA7XG5cbmV4cG9ydHMuaHR0cE92ZXJIdHRwID0gaHR0cE92ZXJIdHRwXG5leHBvcnRzLmh0dHBzT3Zlckh0dHAgPSBodHRwc092ZXJIdHRwXG5leHBvcnRzLmh0dHBPdmVySHR0cHMgPSBodHRwT3Zlckh0dHBzXG5leHBvcnRzLmh0dHBzT3Zlckh0dHBzID0gaHR0cHNPdmVySHR0cHNcblxuXG5mdW5jdGlvbiBodHRwT3Zlckh0dHAob3B0aW9ucykge1xuICB2YXIgYWdlbnQgPSBuZXcgVHVubmVsaW5nQWdlbnQob3B0aW9ucylcbiAgYWdlbnQucmVxdWVzdCA9IGh0dHAucmVxdWVzdFxuICByZXR1cm4gYWdlbnRcbn1cblxuZnVuY3Rpb24gaHR0cHNPdmVySHR0cChvcHRpb25zKSB7XG4gIHZhciBhZ2VudCA9IG5ldyBUdW5uZWxpbmdBZ2VudChvcHRpb25zKVxuICBhZ2VudC5yZXF1ZXN0ID0gaHR0cC5yZXF1ZXN0XG4gIGFnZW50LmNyZWF0ZVNvY2tldCA9IGNyZWF0ZVNlY3VyZVNvY2tldFxuICByZXR1cm4gYWdlbnRcbn1cblxuZnVuY3Rpb24gaHR0cE92ZXJIdHRwcyhvcHRpb25zKSB7XG4gIHZhciBhZ2VudCA9IG5ldyBUdW5uZWxpbmdBZ2VudChvcHRpb25zKVxuICBhZ2VudC5yZXF1ZXN0ID0gaHR0cHMucmVxdWVzdFxuICByZXR1cm4gYWdlbnRcbn1cblxuZnVuY3Rpb24gaHR0cHNPdmVySHR0cHMob3B0aW9ucykge1xuICB2YXIgYWdlbnQgPSBuZXcgVHVubmVsaW5nQWdlbnQob3B0aW9ucylcbiAgYWdlbnQucmVxdWVzdCA9IGh0dHBzLnJlcXVlc3RcbiAgYWdlbnQuY3JlYXRlU29ja2V0ID0gY3JlYXRlU2VjdXJlU29ja2V0XG4gIHJldHVybiBhZ2VudFxufVxuXG5cbmZ1bmN0aW9uIFR1bm5lbGluZ0FnZW50KG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHNlbGYub3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgc2VsZi5wcm94eU9wdGlvbnMgPSBzZWxmLm9wdGlvbnMucHJveHkgfHwge31cbiAgc2VsZi5tYXhTb2NrZXRzID0gc2VsZi5vcHRpb25zLm1heFNvY2tldHMgfHwgaHR0cC5BZ2VudC5kZWZhdWx0TWF4U29ja2V0c1xuICBzZWxmLnJlcXVlc3RzID0gW11cbiAgc2VsZi5zb2NrZXRzID0gW11cblxuICBzZWxmLm9uKCdmcmVlJywgZnVuY3Rpb24gb25GcmVlKHNvY2tldCwgaG9zdCwgcG9ydCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWxmLnJlcXVlc3RzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB2YXIgcGVuZGluZyA9IHNlbGYucmVxdWVzdHNbaV1cbiAgICAgIGlmIChwZW5kaW5nLmhvc3QgPT09IGhvc3QgJiYgcGVuZGluZy5wb3J0ID09PSBwb3J0KSB7XG4gICAgICAgIC8vIERldGVjdCB0aGUgcmVxdWVzdCB0byBjb25uZWN0IHNhbWUgb3JpZ2luIHNlcnZlcixcbiAgICAgICAgLy8gcmV1c2UgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgIHNlbGYucmVxdWVzdHMuc3BsaWNlKGksIDEpXG4gICAgICAgIHBlbmRpbmcucmVxdWVzdC5vblNvY2tldChzb2NrZXQpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBzb2NrZXQuZGVzdHJveSgpXG4gICAgc2VsZi5yZW1vdmVTb2NrZXQoc29ja2V0KVxuICB9KVxufVxudXRpbC5pbmhlcml0cyhUdW5uZWxpbmdBZ2VudCwgZXZlbnRzLkV2ZW50RW1pdHRlcilcblxuVHVubmVsaW5nQWdlbnQucHJvdG90eXBlLmFkZFJlcXVlc3QgPSBmdW5jdGlvbiBhZGRSZXF1ZXN0KHJlcSwgaG9zdCwgcG9ydCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBpZiAoc2VsZi5zb2NrZXRzLmxlbmd0aCA+PSB0aGlzLm1heFNvY2tldHMpIHtcbiAgICAvLyBXZSBhcmUgb3ZlciBsaW1pdCBzbyB3ZSdsbCBhZGQgaXQgdG8gdGhlIHF1ZXVlLlxuICAgIHNlbGYucmVxdWVzdHMucHVzaCh7aG9zdDogaG9zdCwgcG9ydDogcG9ydCwgcmVxdWVzdDogcmVxfSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIElmIHdlIGFyZSB1bmRlciBtYXhTb2NrZXRzIGNyZWF0ZSBhIG5ldyBvbmUuXG4gIHNlbGYuY3JlYXRlU29ja2V0KHtob3N0OiBob3N0LCBwb3J0OiBwb3J0LCByZXF1ZXN0OiByZXF9LCBmdW5jdGlvbihzb2NrZXQpIHtcbiAgICBzb2NrZXQub24oJ2ZyZWUnLCBvbkZyZWUpXG4gICAgc29ja2V0Lm9uKCdjbG9zZScsIG9uQ2xvc2VPclJlbW92ZSlcbiAgICBzb2NrZXQub24oJ2FnZW50UmVtb3ZlJywgb25DbG9zZU9yUmVtb3ZlKVxuICAgIHJlcS5vblNvY2tldChzb2NrZXQpXG5cbiAgICBmdW5jdGlvbiBvbkZyZWUoKSB7XG4gICAgICBzZWxmLmVtaXQoJ2ZyZWUnLCBzb2NrZXQsIGhvc3QsIHBvcnQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25DbG9zZU9yUmVtb3ZlKGVycikge1xuICAgICAgc2VsZi5yZW1vdmVTb2NrZXQoKVxuICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdmcmVlJywgb25GcmVlKVxuICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2VPclJlbW92ZSlcbiAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignYWdlbnRSZW1vdmUnLCBvbkNsb3NlT3JSZW1vdmUpXG4gICAgfVxuICB9KVxufVxuXG5UdW5uZWxpbmdBZ2VudC5wcm90b3R5cGUuY3JlYXRlU29ja2V0ID0gZnVuY3Rpb24gY3JlYXRlU29ja2V0KG9wdGlvbnMsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgcGxhY2Vob2xkZXIgPSB7fVxuICBzZWxmLnNvY2tldHMucHVzaChwbGFjZWhvbGRlcilcblxuICB2YXIgY29ubmVjdE9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoe30sIHNlbGYucHJveHlPcHRpb25zLCBcbiAgICB7IG1ldGhvZDogJ0NPTk5FQ1QnXG4gICAgLCBwYXRoOiBvcHRpb25zLmhvc3QgKyAnOicgKyBvcHRpb25zLnBvcnRcbiAgICAsIGFnZW50OiBmYWxzZVxuICAgIH1cbiAgKVxuICBpZiAoY29ubmVjdE9wdGlvbnMucHJveHlBdXRoKSB7XG4gICAgY29ubmVjdE9wdGlvbnMuaGVhZGVycyA9IGNvbm5lY3RPcHRpb25zLmhlYWRlcnMgfHwge31cbiAgICBjb25uZWN0T3B0aW9ucy5oZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPSAnQmFzaWMgJyArXG4gICAgICAgIG5ldyBCdWZmZXIoY29ubmVjdE9wdGlvbnMucHJveHlBdXRoKS50b1N0cmluZygnYmFzZTY0JylcbiAgfVxuXG4gIGRlYnVnKCdtYWtpbmcgQ09OTkVDVCByZXF1ZXN0JylcbiAgdmFyIGNvbm5lY3RSZXEgPSBzZWxmLnJlcXVlc3QoY29ubmVjdE9wdGlvbnMpXG4gIGNvbm5lY3RSZXEudXNlQ2h1bmtlZEVuY29kaW5nQnlEZWZhdWx0ID0gZmFsc2UgLy8gZm9yIHYwLjZcbiAgY29ubmVjdFJlcS5vbmNlKCdyZXNwb25zZScsIG9uUmVzcG9uc2UpIC8vIGZvciB2MC42XG4gIGNvbm5lY3RSZXEub25jZSgndXBncmFkZScsIG9uVXBncmFkZSkgICAvLyBmb3IgdjAuNlxuICBjb25uZWN0UmVxLm9uY2UoJ2Nvbm5lY3QnLCBvbkNvbm5lY3QpICAgLy8gZm9yIHYwLjcgb3IgbGF0ZXJcbiAgY29ubmVjdFJlcS5vbmNlKCdlcnJvcicsIG9uRXJyb3IpXG4gIGNvbm5lY3RSZXEuZW5kKClcblxuICBmdW5jdGlvbiBvblJlc3BvbnNlKHJlcykge1xuICAgIC8vIFZlcnkgaGFja3kuIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIGF2b2lkIGh0dHAtcGFyc2VyIGxlYWtzLlxuICAgIHJlcy51cGdyYWRlID0gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gb25VcGdyYWRlKHJlcywgc29ja2V0LCBoZWFkKSB7XG4gICAgLy8gSGFja3kuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIG9uQ29ubmVjdChyZXMsIHNvY2tldCwgaGVhZClcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db25uZWN0KHJlcywgc29ja2V0LCBoZWFkKSB7XG4gICAgY29ubmVjdFJlcS5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuICAgIHNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuXG4gICAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgIGFzc2VydC5lcXVhbChoZWFkLmxlbmd0aCwgMClcbiAgICAgIGRlYnVnKCd0dW5uZWxpbmcgY29ubmVjdGlvbiBoYXMgZXN0YWJsaXNoZWQnKVxuICAgICAgc2VsZi5zb2NrZXRzW3NlbGYuc29ja2V0cy5pbmRleE9mKHBsYWNlaG9sZGVyKV0gPSBzb2NrZXRcbiAgICAgIGNiKHNvY2tldClcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ3R1bm5lbGluZyBzb2NrZXQgY291bGQgbm90IGJlIGVzdGFibGlzaGVkLCBzdGF0dXNDb2RlPSVkJywgcmVzLnN0YXR1c0NvZGUpXG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3R1bm5lbGluZyBzb2NrZXQgY291bGQgbm90IGJlIGVzdGFibGlzaGVkLCAnICsgJ3N0YXR1c0NvZGU9JyArIHJlcy5zdGF0dXNDb2RlKVxuICAgICAgZXJyb3IuY29kZSA9ICdFQ09OTlJFU0VUJ1xuICAgICAgb3B0aW9ucy5yZXF1ZXN0LmVtaXQoJ2Vycm9yJywgZXJyb3IpXG4gICAgICBzZWxmLnJlbW92ZVNvY2tldChwbGFjZWhvbGRlcilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkVycm9yKGNhdXNlKSB7XG4gICAgY29ubmVjdFJlcS5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuXG4gICAgZGVidWcoJ3R1bm5lbGluZyBzb2NrZXQgY291bGQgbm90IGJlIGVzdGFibGlzaGVkLCBjYXVzZT0lc1xcbicsIGNhdXNlLm1lc3NhZ2UsIGNhdXNlLnN0YWNrKVxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcigndHVubmVsaW5nIHNvY2tldCBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQsICcgKyAnY2F1c2U9JyArIGNhdXNlLm1lc3NhZ2UpXG4gICAgZXJyb3IuY29kZSA9ICdFQ09OTlJFU0VUJ1xuICAgIG9wdGlvbnMucmVxdWVzdC5lbWl0KCdlcnJvcicsIGVycm9yKVxuICAgIHNlbGYucmVtb3ZlU29ja2V0KHBsYWNlaG9sZGVyKVxuICB9XG59XG5cblR1bm5lbGluZ0FnZW50LnByb3RvdHlwZS5yZW1vdmVTb2NrZXQgPSBmdW5jdGlvbiByZW1vdmVTb2NrZXQoc29ja2V0KSB7XG4gIHZhciBwb3MgPSB0aGlzLnNvY2tldHMuaW5kZXhPZihzb2NrZXQpXG4gIGlmIChwb3MgPT09IC0xKSByZXR1cm5cbiAgXG4gIHRoaXMuc29ja2V0cy5zcGxpY2UocG9zLCAxKVxuXG4gIHZhciBwZW5kaW5nID0gdGhpcy5yZXF1ZXN0cy5zaGlmdCgpXG4gIGlmIChwZW5kaW5nKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBwZW5kaW5nIHJlcXVlc3RzIGFuZCBhIHNvY2tldCBnZXRzIGNsb3NlZCBhIG5ldyBvbmVcbiAgICAvLyBuZWVkcyB0byBiZSBjcmVhdGVkIHRvIHRha2Ugb3ZlciBpbiB0aGUgcG9vbCBmb3IgdGhlIG9uZSB0aGF0IGNsb3NlZC5cbiAgICB0aGlzLmNyZWF0ZVNvY2tldChwZW5kaW5nLCBmdW5jdGlvbihzb2NrZXQpIHtcbiAgICAgIHBlbmRpbmcucmVxdWVzdC5vblNvY2tldChzb2NrZXQpXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTZWN1cmVTb2NrZXQob3B0aW9ucywgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIFR1bm5lbGluZ0FnZW50LnByb3RvdHlwZS5jcmVhdGVTb2NrZXQuY2FsbChzZWxmLCBvcHRpb25zLCBmdW5jdGlvbihzb2NrZXQpIHtcbiAgICAvLyAwIGlzIGR1bW15IHBvcnQgZm9yIHYwLjZcbiAgICB2YXIgc2VjdXJlU29ja2V0ID0gdGxzLmNvbm5lY3QoMCwgbWVyZ2VPcHRpb25zKHt9LCBzZWxmLm9wdGlvbnMsIFxuICAgICAgeyBzZXJ2ZXJuYW1lOiBvcHRpb25zLmhvc3RcbiAgICAgICwgc29ja2V0OiBzb2NrZXRcbiAgICAgIH1cbiAgICApKVxuICAgIGNiKHNlY3VyZVNvY2tldClcbiAgfSlcbn1cblxuXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnModGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgb3ZlcnJpZGVzID0gYXJndW1lbnRzW2ldXG4gICAgaWYgKHR5cGVvZiBvdmVycmlkZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG92ZXJyaWRlcylcbiAgICAgIGZvciAodmFyIGogPSAwLCBrZXlMZW4gPSBrZXlzLmxlbmd0aDsgaiA8IGtleUxlbjsgKytqKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1tqXVxuICAgICAgICBpZiAob3ZlcnJpZGVzW2tdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0YXJnZXRba10gPSBvdmVycmlkZXNba11cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0XG59XG5cblxudmFyIGRlYnVnXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJiAvXFxidHVubmVsXFxiLy50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpKSB7XG4gIGRlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgYXJnc1swXSA9ICdUVU5ORUw6ICcgKyBhcmdzWzBdXG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3MudW5zaGlmdCgnVFVOTkVMOicpXG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgYXJncylcbiAgfVxufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbigpIHt9XG59XG5leHBvcnRzLmRlYnVnID0gZGVidWcgLy8gZm9yIHRlc3RcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpLHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfYnVmZmVyXCIpLkJ1ZmZlcikiLCJtb2R1bGUuZXhwb3J0cyA9IEZvcmV2ZXJBZ2VudFxuRm9yZXZlckFnZW50LlNTTCA9IEZvcmV2ZXJBZ2VudFNTTFxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuICAsIEFnZW50ID0gcmVxdWlyZSgnaHR0cCcpLkFnZW50XG4gICwgbmV0ID0gcmVxdWlyZSgnbmV0JylcbiAgLCB0bHMgPSByZXF1aXJlKCd0bHMnKVxuICAsIEFnZW50U1NMID0gcmVxdWlyZSgnaHR0cHMnKS5BZ2VudFxuXG5mdW5jdGlvbiBGb3JldmVyQWdlbnQob3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgc2VsZi5vcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICBzZWxmLnJlcXVlc3RzID0ge31cbiAgc2VsZi5zb2NrZXRzID0ge31cbiAgc2VsZi5mcmVlU29ja2V0cyA9IHt9XG4gIHNlbGYubWF4U29ja2V0cyA9IHNlbGYub3B0aW9ucy5tYXhTb2NrZXRzIHx8IEFnZW50LmRlZmF1bHRNYXhTb2NrZXRzXG4gIHNlbGYubWluU29ja2V0cyA9IHNlbGYub3B0aW9ucy5taW5Tb2NrZXRzIHx8IEZvcmV2ZXJBZ2VudC5kZWZhdWx0TWluU29ja2V0c1xuICBzZWxmLm9uKCdmcmVlJywgZnVuY3Rpb24oc29ja2V0LCBob3N0LCBwb3J0KSB7XG4gICAgdmFyIG5hbWUgPSBob3N0ICsgJzonICsgcG9ydFxuICAgIGlmIChzZWxmLnJlcXVlc3RzW25hbWVdICYmIHNlbGYucmVxdWVzdHNbbmFtZV0ubGVuZ3RoKSB7XG4gICAgICBzZWxmLnJlcXVlc3RzW25hbWVdLnNoaWZ0KCkub25Tb2NrZXQoc29ja2V0KVxuICAgIH0gZWxzZSBpZiAoc2VsZi5zb2NrZXRzW25hbWVdLmxlbmd0aCA8IHNlbGYubWluU29ja2V0cykge1xuICAgICAgaWYgKCFzZWxmLmZyZWVTb2NrZXRzW25hbWVdKSBzZWxmLmZyZWVTb2NrZXRzW25hbWVdID0gW11cbiAgICAgIHNlbGYuZnJlZVNvY2tldHNbbmFtZV0ucHVzaChzb2NrZXQpXG4gICAgICBcbiAgICAgIC8vIGlmIGFuIGVycm9yIGhhcHBlbnMgd2hpbGUgd2UgZG9uJ3QgdXNlIHRoZSBzb2NrZXQgYW55d2F5LCBtZWgsIHRocm93IHRoZSBzb2NrZXQgYXdheVxuICAgICAgZnVuY3Rpb24gb25JZGxlRXJyb3IoKSB7XG4gICAgICAgIHNvY2tldC5kZXN0cm95KClcbiAgICAgIH1cbiAgICAgIHNvY2tldC5fb25JZGxlRXJyb3IgPSBvbklkbGVFcnJvclxuICAgICAgc29ja2V0Lm9uKCdlcnJvcicsIG9uSWRsZUVycm9yKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gcGVuZGluZyByZXF1ZXN0cyBqdXN0IGRlc3Ryb3kgdGhlXG4gICAgICAvLyBzb2NrZXQgYW5kIGl0IHdpbGwgZ2V0IHJlbW92ZWQgZnJvbSB0aGUgcG9vbC4gVGhpc1xuICAgICAgLy8gZ2V0cyB1cyBvdXQgb2YgdGltZW91dCBpc3N1ZXMgYW5kIGFsbG93cyB1cyB0b1xuICAgICAgLy8gZGVmYXVsdCB0byBDb25uZWN0aW9uOmtlZXAtYWxpdmUuXG4gICAgICBzb2NrZXQuZGVzdHJveSgpXG4gICAgfVxuICB9KVxuXG59XG51dGlsLmluaGVyaXRzKEZvcmV2ZXJBZ2VudCwgQWdlbnQpXG5cbkZvcmV2ZXJBZ2VudC5kZWZhdWx0TWluU29ja2V0cyA9IDVcblxuXG5Gb3JldmVyQWdlbnQucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24gPSBuZXQuY3JlYXRlQ29ubmVjdGlvblxuRm9yZXZlckFnZW50LnByb3RvdHlwZS5hZGRSZXF1ZXN0Tm9yZXVzZSA9IEFnZW50LnByb3RvdHlwZS5hZGRSZXF1ZXN0XG5Gb3JldmVyQWdlbnQucHJvdG90eXBlLmFkZFJlcXVlc3QgPSBmdW5jdGlvbihyZXEsIGhvc3QsIHBvcnQpIHtcbiAgdmFyIG5hbWUgPSBob3N0ICsgJzonICsgcG9ydFxuICBpZiAodGhpcy5mcmVlU29ja2V0c1tuYW1lXSAmJiB0aGlzLmZyZWVTb2NrZXRzW25hbWVdLmxlbmd0aCA+IDAgJiYgIXJlcS51c2VDaHVua2VkRW5jb2RpbmdCeURlZmF1bHQpIHtcbiAgICB2YXIgaWRsZVNvY2tldCA9IHRoaXMuZnJlZVNvY2tldHNbbmFtZV0ucG9wKClcbiAgICBpZGxlU29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGlkbGVTb2NrZXQuX29uSWRsZUVycm9yKVxuICAgIGRlbGV0ZSBpZGxlU29ja2V0Ll9vbklkbGVFcnJvclxuICAgIHJlcS5fcmV1c2VkU29ja2V0ID0gdHJ1ZVxuICAgIHJlcS5vblNvY2tldChpZGxlU29ja2V0KVxuICB9IGVsc2Uge1xuICAgIHRoaXMuYWRkUmVxdWVzdE5vcmV1c2UocmVxLCBob3N0LCBwb3J0KVxuICB9XG59XG5cbkZvcmV2ZXJBZ2VudC5wcm90b3R5cGUucmVtb3ZlU29ja2V0ID0gZnVuY3Rpb24ocywgbmFtZSwgaG9zdCwgcG9ydCkge1xuICBpZiAodGhpcy5zb2NrZXRzW25hbWVdKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5zb2NrZXRzW25hbWVdLmluZGV4T2YocylcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLnNvY2tldHNbbmFtZV0uc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLnNvY2tldHNbbmFtZV0gJiYgdGhpcy5zb2NrZXRzW25hbWVdLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIGRvbid0IGxlYWtcbiAgICBkZWxldGUgdGhpcy5zb2NrZXRzW25hbWVdXG4gICAgZGVsZXRlIHRoaXMucmVxdWVzdHNbbmFtZV1cbiAgfVxuICBcbiAgaWYgKHRoaXMuZnJlZVNvY2tldHNbbmFtZV0pIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmZyZWVTb2NrZXRzW25hbWVdLmluZGV4T2YocylcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLmZyZWVTb2NrZXRzW25hbWVdLnNwbGljZShpbmRleCwgMSlcbiAgICAgIGlmICh0aGlzLmZyZWVTb2NrZXRzW25hbWVdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy5mcmVlU29ja2V0c1tuYW1lXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnJlcXVlc3RzW25hbWVdICYmIHRoaXMucmVxdWVzdHNbbmFtZV0ubGVuZ3RoKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBwZW5kaW5nIHJlcXVlc3RzIGFuZCBhIHNvY2tldCBnZXRzIGNsb3NlZCBhIG5ldyBvbmVcbiAgICAvLyBuZWVkcyB0byBiZSBjcmVhdGVkIHRvIHRha2Ugb3ZlciBpbiB0aGUgcG9vbCBmb3IgdGhlIG9uZSB0aGF0IGNsb3NlZC5cbiAgICB0aGlzLmNyZWF0ZVNvY2tldChuYW1lLCBob3N0LCBwb3J0KS5lbWl0KCdmcmVlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBGb3JldmVyQWdlbnRTU0wgKG9wdGlvbnMpIHtcbiAgRm9yZXZlckFnZW50LmNhbGwodGhpcywgb3B0aW9ucylcbn1cbnV0aWwuaW5oZXJpdHMoRm9yZXZlckFnZW50U1NMLCBGb3JldmVyQWdlbnQpXG5cbkZvcmV2ZXJBZ2VudFNTTC5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbiA9IGNyZWF0ZUNvbm5lY3Rpb25TU0xcbkZvcmV2ZXJBZ2VudFNTTC5wcm90b3R5cGUuYWRkUmVxdWVzdE5vcmV1c2UgPSBBZ2VudFNTTC5wcm90b3R5cGUuYWRkUmVxdWVzdFxuXG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uU1NMIChwb3J0LCBob3N0LCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcG9ydCA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0gcG9ydDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgaG9zdCA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0gaG9zdDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucztcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAodHlwZW9mIHBvcnQgPT09ICdudW1iZXInKSB7XG4gICAgb3B0aW9ucy5wb3J0ID0gcG9ydDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaG9zdCA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zLmhvc3QgPSBob3N0O1xuICB9XG5cbiAgcmV0dXJuIHRscy5jb25uZWN0KG9wdGlvbnMpO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdpZnk7XG5cbmZ1bmN0aW9uIGdldFNlcmlhbGl6ZSAoZm4sIGRlY3ljbGUpIHtcbiAgdmFyIHNlZW4gPSBbXTtcbiAgZGVjeWNsZSA9IGRlY3ljbGUgfHwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlKSB7XG4gICAgICBpZiAoc2Vlbi5pbmRleE9mKHZhbHVlKSAhPT0gLTEpXG4gICAgICAgIHJldCA9IGRlY3ljbGUoa2V5LCB2YWx1ZSk7XG4gICAgICBlbHNlXG4gICAgICAgIHNlZW4ucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChmbikgcmV0ID0gZm4oa2V5LCByZXQpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KG9iaiwgZm4sIHNwYWNlcywgZGVjeWNsZSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBnZXRTZXJpYWxpemUoZm4sIGRlY3ljbGUpLCBzcGFjZXMpO1xufVxuXG5zdHJpbmdpZnkuZ2V0U2VyaWFsaXplID0gZ2V0U2VyaWFsaXplO1xuIiwiLyoqXG4gKiBPYmplY3QjdG9TdHJpbmcoKSByZWYgZm9yIHN0cmluZ2lmeSgpLlxuICovXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogT2JqZWN0I2hhc093blByb3BlcnR5IHJlZlxuICovXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXJyYXkjaW5kZXhPZiBzaGltLlxuICovXG5cbnZhciBpbmRleE9mID0gdHlwZW9mIEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nXG4gID8gZnVuY3Rpb24oYXJyLCBlbCkgeyByZXR1cm4gYXJyLmluZGV4T2YoZWwpOyB9XG4gIDogZnVuY3Rpb24oYXJyLCBlbCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycltpXSA9PT0gZWwpIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG5cbi8qKlxuICogQXJyYXkuaXNBcnJheSBzaGltLlxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLyoqXG4gKiBPYmplY3Qua2V5cyBzaGltLlxuICovXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ob2JqKSB7XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikgcmV0LnB1c2goa2V5KTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogQXJyYXkjZm9yRWFjaCBzaGltLlxuICovXG5cbnZhciBmb3JFYWNoID0gdHlwZW9mIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID09PSAnZnVuY3Rpb24nXG4gID8gZnVuY3Rpb24oYXJyLCBmbikgeyByZXR1cm4gYXJyLmZvckVhY2goZm4pOyB9XG4gIDogZnVuY3Rpb24oYXJyLCBmbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGZuKGFycltpXSk7XG4gICAgfTtcblxuLyoqXG4gKiBBcnJheSNyZWR1Y2Ugc2hpbS5cbiAqL1xuXG52YXIgcmVkdWNlID0gZnVuY3Rpb24oYXJyLCBmbiwgaW5pdGlhbCkge1xuICBpZiAodHlwZW9mIGFyci5yZWR1Y2UgPT09ICdmdW5jdGlvbicpIHJldHVybiBhcnIucmVkdWNlKGZuLCBpbml0aWFsKTtcbiAgdmFyIHJlcyA9IGluaXRpYWw7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSByZXMgPSBmbihyZXMsIGFycltpXSk7XG4gIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG51bGxhcnkgb2JqZWN0IGlmIHBvc3NpYmxlXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0KCkge1xuICByZXR1cm4gT2JqZWN0LmNyZWF0ZVxuICAgID8gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIDoge307XG59XG5cbi8qKlxuICogQ2FjaGUgbm9uLWludGVnZXIgdGVzdCByZWdleHAuXG4gKi9cblxudmFyIGlzaW50ID0gL15bMC05XSskLztcblxuZnVuY3Rpb24gcHJvbW90ZShwYXJlbnQsIGtleSkge1xuICBpZiAocGFyZW50W2tleV0ubGVuZ3RoID09IDApIHJldHVybiBwYXJlbnRba2V5XSA9IGNyZWF0ZU9iamVjdCgpO1xuICB2YXIgdCA9IGNyZWF0ZU9iamVjdCgpO1xuICBmb3IgKHZhciBpIGluIHBhcmVudFtrZXldKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocGFyZW50W2tleV0sIGkpKSB7XG4gICAgICB0W2ldID0gcGFyZW50W2tleV1baV07XG4gICAgfVxuICB9XG4gIHBhcmVudFtrZXldID0gdDtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKHBhcnRzLCBwYXJlbnQsIGtleSwgdmFsKSB7XG4gIHZhciBwYXJ0ID0gcGFydHMuc2hpZnQoKTtcbiAgLy8gZW5kXG4gIGlmICghcGFydCkge1xuICAgIGlmIChpc0FycmF5KHBhcmVudFtrZXldKSkge1xuICAgICAgcGFyZW50W2tleV0ucHVzaCh2YWwpO1xuICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIHBhcmVudFtrZXldKSB7XG4gICAgICBwYXJlbnRba2V5XSA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZiBwYXJlbnRba2V5XSkge1xuICAgICAgcGFyZW50W2tleV0gPSB2YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudFtrZXldID0gW3BhcmVudFtrZXldLCB2YWxdO1xuICAgIH1cbiAgICAvLyBhcnJheVxuICB9IGVsc2Uge1xuICAgIHZhciBvYmogPSBwYXJlbnRba2V5XSA9IHBhcmVudFtrZXldIHx8IFtdO1xuICAgIGlmICgnXScgPT0gcGFydCkge1xuICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICBpZiAoJycgIT0gdmFsKSBvYmoucHVzaCh2YWwpO1xuICAgICAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgICAgIG9ialtvYmplY3RLZXlzKG9iaikubGVuZ3RoXSA9IHZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iaiA9IHBhcmVudFtrZXldID0gW3BhcmVudFtrZXldLCB2YWxdO1xuICAgICAgfVxuICAgICAgLy8gcHJvcFxuICAgIH0gZWxzZSBpZiAofmluZGV4T2YocGFydCwgJ10nKSkge1xuICAgICAgcGFydCA9IHBhcnQuc3Vic3RyKDAsIHBhcnQubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoIWlzaW50LnRlc3QocGFydCkgJiYgaXNBcnJheShvYmopKSBvYmogPSBwcm9tb3RlKHBhcmVudCwga2V5KTtcbiAgICAgIHBhcnNlKHBhcnRzLCBvYmosIHBhcnQsIHZhbCk7XG4gICAgICAvLyBrZXlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFpc2ludC50ZXN0KHBhcnQpICYmIGlzQXJyYXkob2JqKSkgb2JqID0gcHJvbW90ZShwYXJlbnQsIGtleSk7XG4gICAgICBwYXJzZShwYXJ0cywgb2JqLCBwYXJ0LCB2YWwpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHBhcmVudCBrZXkvdmFsIHBhaXIuXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2UocGFyZW50LCBrZXksIHZhbCl7XG4gIGlmICh+aW5kZXhPZihrZXksICddJykpIHtcbiAgICB2YXIgcGFydHMgPSBrZXkuc3BsaXQoJ1snKVxuICAgICAgLCBsZW4gPSBwYXJ0cy5sZW5ndGhcbiAgICAgICwgbGFzdCA9IGxlbiAtIDE7XG4gICAgcGFyc2UocGFydHMsIHBhcmVudCwgJ2Jhc2UnLCB2YWwpO1xuICAgIC8vIG9wdGltaXplXG4gIH0gZWxzZSB7XG4gICAgaWYgKCFpc2ludC50ZXN0KGtleSkgJiYgaXNBcnJheShwYXJlbnQuYmFzZSkpIHtcbiAgICAgIHZhciB0ID0gY3JlYXRlT2JqZWN0KCk7XG4gICAgICBmb3IgKHZhciBrIGluIHBhcmVudC5iYXNlKSB0W2tdID0gcGFyZW50LmJhc2Vba107XG4gICAgICBwYXJlbnQuYmFzZSA9IHQ7XG4gICAgfVxuICAgIHNldChwYXJlbnQuYmFzZSwga2V5LCB2YWwpO1xuICB9XG5cbiAgcmV0dXJuIHBhcmVudDtcbn1cblxuLyoqXG4gKiBDb21wYWN0IHNwYXJzZSBhcnJheXMuXG4gKi9cblxuZnVuY3Rpb24gY29tcGFjdChvYmopIHtcbiAgaWYgKCdvYmplY3QnICE9IHR5cGVvZiBvYmopIHJldHVybiBvYmo7XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIHZhciByZXQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSB7XG4gICAgICAgIHJldC5wdXNoKG9ialtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBvYmpba2V5XSA9IGNvbXBhY3Qob2JqW2tleV0pO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBSZXN0b3JlIE9iamVjdC5wcm90b3R5cGUuXG4gKiBzZWUgcHVsbC1yZXF1ZXN0ICM1OFxuICovXG5cbmZ1bmN0aW9uIHJlc3RvcmVQcm90byhvYmopIHtcbiAgaWYgKCFPYmplY3QuY3JlYXRlKSByZXR1cm4gb2JqO1xuICBpZiAoaXNBcnJheShvYmopKSByZXR1cm4gb2JqO1xuICBpZiAob2JqICYmICdvYmplY3QnICE9IHR5cGVvZiBvYmopIHJldHVybiBvYmo7XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgb2JqW2tleV0gPSByZXN0b3JlUHJvdG8ob2JqW2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIG9iai5fX3Byb3RvX18gPSBPYmplY3QucHJvdG90eXBlO1xuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBvYmouXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VPYmplY3Qob2JqKXtcbiAgdmFyIHJldCA9IHsgYmFzZToge30gfTtcblxuICBmb3JFYWNoKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24obmFtZSl7XG4gICAgbWVyZ2UocmV0LCBuYW1lLCBvYmpbbmFtZV0pO1xuICB9KTtcblxuICByZXR1cm4gY29tcGFjdChyZXQuYmFzZSk7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIHN0ci5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzdHIpe1xuICB2YXIgcmV0ID0gcmVkdWNlKFN0cmluZyhzdHIpLnNwbGl0KCcmJyksIGZ1bmN0aW9uKHJldCwgcGFpcil7XG4gICAgdmFyIGVxbCA9IGluZGV4T2YocGFpciwgJz0nKVxuICAgICAgLCBicmFjZSA9IGxhc3RCcmFjZUluS2V5KHBhaXIpXG4gICAgICAsIGtleSA9IHBhaXIuc3Vic3RyKDAsIGJyYWNlIHx8IGVxbClcbiAgICAgICwgdmFsID0gcGFpci5zdWJzdHIoYnJhY2UgfHwgZXFsLCBwYWlyLmxlbmd0aClcbiAgICAgICwgdmFsID0gdmFsLnN1YnN0cihpbmRleE9mKHZhbCwgJz0nKSArIDEsIHZhbC5sZW5ndGgpO1xuXG4gICAgLy8gP2Zvb1xuICAgIGlmICgnJyA9PSBrZXkpIGtleSA9IHBhaXIsIHZhbCA9ICcnO1xuICAgIGlmICgnJyA9PSBrZXkpIHJldHVybiByZXQ7XG5cbiAgICByZXR1cm4gbWVyZ2UocmV0LCBkZWNvZGUoa2V5KSwgZGVjb2RlKHZhbCkpO1xuICB9LCB7IGJhc2U6IGNyZWF0ZU9iamVjdCgpIH0pLmJhc2U7XG5cbiAgcmV0dXJuIHJlc3RvcmVQcm90byhjb21wYWN0KHJldCkpO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBxdWVyeSBgc3RyYCBvciBgb2JqYCwgcmV0dXJuaW5nIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHwge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbihzdHIpe1xuICBpZiAobnVsbCA9PSBzdHIgfHwgJycgPT0gc3RyKSByZXR1cm4ge307XG4gIHJldHVybiAnb2JqZWN0JyA9PSB0eXBlb2Ygc3RyXG4gICAgPyBwYXJzZU9iamVjdChzdHIpXG4gICAgOiBwYXJzZVN0cmluZyhzdHIpO1xufTtcblxuLyoqXG4gKiBUdXJuIHRoZSBnaXZlbiBgb2JqYCBpbnRvIGEgcXVlcnkgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG52YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbihvYmosIHByZWZpeCkge1xuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KG9iaiwgcHJlZml4KTtcbiAgfSBlbHNlIGlmICgnW29iamVjdCBPYmplY3RdJyA9PSB0b1N0cmluZy5jYWxsKG9iaikpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KG9iaiwgcHJlZml4KTtcbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVN0cmluZyhvYmosIHByZWZpeCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZWZpeCArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcob2JqKSk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlTdHJpbmcoc3RyLCBwcmVmaXgpIHtcbiAgaWYgKCFwcmVmaXgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ2lmeSBleHBlY3RzIGFuIG9iamVjdCcpO1xuICByZXR1cm4gcHJlZml4ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cik7XG59XG5cbi8qKlxuICogU3RyaW5naWZ5IHRoZSBnaXZlbiBgYXJyYC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5KGFyciwgcHJlZml4KSB7XG4gIHZhciByZXQgPSBbXTtcbiAgaWYgKCFwcmVmaXgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ2lmeSBleHBlY3RzIGFuIG9iamVjdCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIHJldC5wdXNoKHN0cmluZ2lmeShhcnJbaV0sIHByZWZpeCArICdbJyArIGkgKyAnXScpKTtcbiAgfVxuICByZXR1cm4gcmV0LmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBTdHJpbmdpZnkgdGhlIGdpdmVuIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdChvYmosIHByZWZpeCkge1xuICB2YXIgcmV0ID0gW11cbiAgICAsIGtleXMgPSBvYmplY3RLZXlzKG9iailcbiAgICAsIGtleTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCcnID09IGtleSkgY29udGludWU7XG4gICAgaWYgKG51bGwgPT0gb2JqW2tleV0pIHtcbiAgICAgIHJldC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0LnB1c2goc3RyaW5naWZ5KG9ialtrZXldLCBwcmVmaXhcbiAgICAgICAgPyBwcmVmaXggKyAnWycgKyBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICddJ1xuICAgICAgICA6IGVuY29kZVVSSUNvbXBvbmVudChrZXkpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldC5qb2luKCcmJyk7XG59XG5cbi8qKlxuICogU2V0IGBvYmpgJ3MgYGtleWAgdG8gYHZhbGAgcmVzcGVjdGluZ1xuICogdGhlIHdlaXJkIGFuZCB3b25kZXJmdWwgc3ludGF4IG9mIGEgcXMsXG4gKiB3aGVyZSBcImZvbz1iYXImZm9vPWJhelwiIGJlY29tZXMgYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2V0KG9iaiwga2V5LCB2YWwpIHtcbiAgdmFyIHYgPSBvYmpba2V5XTtcbiAgaWYgKHVuZGVmaW5lZCA9PT0gdikge1xuICAgIG9ialtrZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodikpIHtcbiAgICB2LnB1c2godmFsKTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IFt2LCB2YWxdO1xuICB9XG59XG5cbi8qKlxuICogTG9jYXRlIGxhc3QgYnJhY2UgaW4gYHN0cmAgd2l0aGluIHRoZSBrZXkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbGFzdEJyYWNlSW5LZXkoc3RyKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoXG4gICAgLCBicmFjZVxuICAgICwgYztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGMgPSBzdHJbaV07XG4gICAgaWYgKCddJyA9PSBjKSBicmFjZSA9IGZhbHNlO1xuICAgIGlmICgnWycgPT0gYykgYnJhY2UgPSB0cnVlO1xuICAgIGlmICgnPScgPT0gYyAmJiAhYnJhY2UpIHJldHVybiBpO1xuICB9XG59XG5cbi8qKlxuICogRGVjb2RlIGBzdHJgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0ci5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cbiIsInZhciBDb25uZWN0aW9uID0gcmVxdWlyZSgnLi94bXBwL2Nvbm5lY3Rpb24nKTtcbnZhciBDbGllbnQgPSByZXF1aXJlKCcuL3htcHAvY2xpZW50JykuQ2xpZW50O1xudmFyIEpJRCA9IHJlcXVpcmUoJy4veG1wcC9qaWQnKTtcbnZhciBsdHggPSByZXF1aXJlKCdsdHgnKTtcbnZhciBTdGFuemEgPSByZXF1aXJlKCcuL3htcHAvc3RhbnphJyk7XG5cbmV4cG9ydHMuQ29ubmVjdGlvbiA9IENvbm5lY3Rpb247XG5leHBvcnRzLkNsaWVudCA9IENsaWVudDtcbmV4cG9ydHMuSklEID0gSklEO1xuZXhwb3J0cy5FbGVtZW50ID0gbHR4LkVsZW1lbnQ7XG5leHBvcnRzLlN0YW56YSA9IFN0YW56YS5TdGFuemE7XG5leHBvcnRzLk1lc3NhZ2UgPSBTdGFuemEuTWVzc2FnZTtcbmV4cG9ydHMuUHJlc2VuY2UgPSBTdGFuemEuUHJlc2VuY2U7XG5leHBvcnRzLklxID0gU3RhbnphLklxO1xuXG53aW5kb3cuWE1QUCA9IGV4cG9ydHM7XG4iLCJleHBvcnRzLnJlYWRJRUVFNzU0ID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzQkUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzQkUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzQkUgPyAxIDogLTEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZUlFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQkUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNCRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNCRSA/IC0xIDogMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuIiwiKGZ1bmN0aW9uKCl7dmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXI7XG5leHBvcnRzLlNsb3dCdWZmZXIgPSBCdWZmZXI7XG5CdWZmZXIucG9vbFNpemUgPSA4MTkyO1xuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwO1xuXG5mdW5jdGlvbiBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG9mZnNldCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBvZmZzZXQpO1xuICB9XG4gIHRoaXMucGFyZW50ID0gdGhpcztcbiAgdGhpcy5vZmZzZXQgPSAwO1xuXG4gIHZhciB0eXBlO1xuXG4gIC8vIEFyZSB3ZSBzbGljaW5nP1xuICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicpIHtcbiAgICB0aGlzLmxlbmd0aCA9IGNvZXJjZShlbmNvZGluZyk7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gICAgc3dpdGNoICh0eXBlID0gdHlwZW9mIHN1YmplY3QpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHRoaXMubGVuZ3RoID0gY29lcmNlKHN1YmplY3QpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgdGhpcy5sZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOiAvLyBBc3N1bWUgb2JqZWN0IGlzIGFuIGFycmF5XG4gICAgICAgIHRoaXMubGVuZ3RoID0gY29lcmNlKHN1YmplY3QubGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBudW1iZXIsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FycmF5IG9yIHN0cmluZy4nKTtcbiAgICB9XG5cbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXkuXG4gICAgaWYgKGlzQXJyYXlJc2goc3ViamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3ViamVjdCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgIHRoaXNbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzW2ldID0gc3ViamVjdFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgLy8gV2UgYXJlIGEgc3RyaW5nXG4gICAgICB0aGlzLmxlbmd0aCA9IHRoaXMud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgcmV0dXJuIHRoaXNbaV07XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldChpLCB2KSB7XG4gIGlmIChpIDwgMCB8fCBpID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICByZXR1cm4gdGhpc1tpXSA9IHY7XG59O1xuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgXCJ1dGY4XCIpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHN0ci5sZW5ndGggLyAyO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gc3RyLmxlbmd0aDtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgYnl0ZXMsIHBvcztcbiAgcmV0dXJuIEJ1ZmZlci5fY2hhcnNXcml0dGVuID0gIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgdGhpcywgb2Zmc2V0LCBsZW5ndGgpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9ICBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmJpbmFyeVdyaXRlID0gQnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlO1xuXG5CdWZmZXIucHJvdG90eXBlLmJhc2U2NFdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmJhc2U2NFNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgcmV0dXJuIHJlcXVpcmUoXCJiYXNlNjQtanNcIikuZnJvbUJ5dGVBcnJheShieXRlcyk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnV0ZjhTbGljZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHZhciByZXMgPSBcIlwiO1xuICB2YXIgdG1wID0gXCJcIjtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IGJ5dGVzLmxlbmd0aCkge1xuICAgIGlmIChieXRlc1tpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgICAgdG1wID0gXCJcIjtcbiAgICB9IGVsc2VcbiAgICAgIHRtcCArPSBcIiVcIiArIGJ5dGVzW2ldLnRvU3RyaW5nKDE2KTtcblxuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB2YXIgcmV0ID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gIHJldHVybiByZXQ7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuYmluYXJ5U2xpY2UgPSBCdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2U7XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW10sXG4gICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pO1xuICAgIGlmIChpID09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIG91dC5qb2luKCcgJykgKyAnPic7XG59O1xuXG5cbkJ1ZmZlci5wcm90b3R5cGUuaGV4U2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgodGhpc1tpXSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcbiAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgaWYgKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGVuZ3RoO1xuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKCtlbmQgPT0gc3RhcnQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiB0aGlzLmhleFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHRoaXMudXRmOFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0dXJuIHRoaXMuYXNjaWlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdGhpcy5iaW5hcnlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gdGhpcy5iYXNlNjRTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIHJldHVybiB0aGlzLnVjczJTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuXG5CdWZmZXIucHJvdG90eXBlLmhleFdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSArb2Zmc2V0IHx8IDA7XG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gK2xlbmd0aDtcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7XG4gIGlmIChzdHJMZW4gJSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKTtcbiAgfVxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDI7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KTtcbiAgICBpZiAoaXNOYU4oYnl0ZSkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJyk7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9IGJ5dGU7XG4gIH1cbiAgQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBpICogMjtcbiAgcmV0dXJuIGk7XG59O1xuXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSBzd2FwO1xuICB9XG5cbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gdGhpcy5oZXhXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnV0ZjhXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLmFzY2lpV3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy51Y3MyV3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkgZW5kID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIodGhpcywgZW5kIC0gc3RhcnQsICtzdGFydCk7XG59O1xuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpcztcbiAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBpc05hTihlbmQpKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cbiAgdGFyZ2V0X3N0YXJ0IHx8ICh0YXJnZXRfc3RhcnQgPSAwKTtcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIDwgc291cmNlU3RhcnQnKTtcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PSAwIHx8IHNvdXJjZS5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG5cbiAgaWYgKHRhcmdldF9zdGFydCA8IDAgfHwgdGFyZ2V0X3N0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydDtcbiAgfVxuXG4gIHZhciB0ZW1wID0gW107XG4gIGZvciAodmFyIGk9c3RhcnQ7IGk8ZW5kOyBpKyspIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIHRoaXNbaV0gIT09ICd1bmRlZmluZWQnLCBcImNvcHlpbmcgdW5kZWZpbmVkIGJ1ZmZlciBieXRlcyFcIik7XG4gICAgdGVtcC5wdXNoKHRoaXNbaV0pO1xuICB9XG5cbiAgZm9yICh2YXIgaT10YXJnZXRfc3RhcnQ7IGk8dGFyZ2V0X3N0YXJ0K3RlbXAubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRbaV0gPSB0ZW1wW2ktdGFyZ2V0X3N0YXJ0XTtcbiAgfVxufTtcblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIHZhbHVlIHx8ICh2YWx1ZSA9IDApO1xuICBzdGFydCB8fCAoc3RhcnQgPSAwKTtcbiAgZW5kIHx8IChlbmQgPSB0aGlzLmxlbmd0aCk7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLmNoYXJDb2RlQXQoMCk7XG4gIH1cbiAgaWYgKCEodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd2YWx1ZSBpcyBub3QgYSBudW1iZXInKTtcbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IEVycm9yKCdlbmQgPCBzdGFydCcpO1xuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDA7XG4gIGlmICh0aGlzLmxlbmd0aCA9PSAwKSByZXR1cm4gMDtcblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZW5kIG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdGhpc1tpXSA9IHZhbHVlO1xuICB9XG59XG5cbi8vIFN0YXRpYyBtZXRob2RzXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIHJldHVybiBiIGluc3RhbmNlb2YgQnVmZmVyIHx8IGIgaW5zdGFuY2VvZiBCdWZmZXI7XG59O1xuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3QsIFt0b3RhbExlbmd0aF0pXFxuIFxcXG4gICAgICBsaXN0IHNob3VsZCBiZSBhbiBBcnJheS5cIik7XG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKTtcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0b3RhbExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICB0b3RhbExlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYnVmID0gbGlzdFtpXTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpO1xuICB2YXIgcG9zID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpO1xuICAgIHBvcyArPSBidWYubGVuZ3RoO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59O1xuXG4vLyBoZWxwZXJzXG5cbmZ1bmN0aW9uIGNvZXJjZShsZW5ndGgpIHtcbiAgLy8gQ29lcmNlIGxlbmd0aCB0byBhIG51bWJlciAocG9zc2libHkgTmFOKSwgcm91bmQgdXBcbiAgLy8gaW4gY2FzZSBpdCdzIGZyYWN0aW9uYWwgKGUuZy4gMTIzLjQ1NikgdGhlbiBkbyBhXG4gIC8vIGRvdWJsZSBuZWdhdGUgdG8gY29lcmNlIGEgTmFOIHRvIDAuIEVhc3ksIHJpZ2h0P1xuICBsZW5ndGggPSB+fk1hdGguY2VpbCgrbGVuZ3RoKTtcbiAgcmV0dXJuIGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KHN1YmplY3QpIHtcbiAgcmV0dXJuIChBcnJheS5pc0FycmF5IHx8XG4gICAgZnVuY3Rpb24oc3ViamVjdCl7XG4gICAgICByZXR1cm4ge30udG9TdHJpbmcuYXBwbHkoc3ViamVjdCkgPT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIH0pXG4gICAgKHN1YmplY3QpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlJc2goc3ViamVjdCkge1xuICByZXR1cm4gaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiB0b0hleChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSkgPD0gMHg3RilcbiAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5jaGFyQXQoaSkpLnN1YnN0cigxKS5zcGxpdCgnJScpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKVxuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpO1xuICAgIH1cblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyApXG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goIHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRiApO1xuXG4gIHJldHVybiBieXRlQXJyYXk7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoc3RyKSB7XG4gIHJldHVybiByZXF1aXJlKFwiYmFzZTY0LWpzXCIpLnRvQnl0ZUFycmF5KHN0cik7XG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBwb3MsIGkgPSAwO1xuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIGlmICgoaStvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVhaztcblxuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXTtcbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKTsgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuLy8gcmVhZC93cml0ZSBiaXQtdHdpZGRsaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICBpZiAob2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHJldHVybjtcblxuICByZXR1cm4gYnVmZmVyW29mZnNldF07XG59O1xuXG5mdW5jdGlvbiByZWFkVUludDE2KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFyIHZhbCA9IDA7XG5cblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICBpZiAob2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHJldHVybiAwO1xuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIHZhbCA9IGJ1ZmZlcltvZmZzZXRdIDw8IDg7XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB2YWwgfD0gYnVmZmVyW29mZnNldCArIDFdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZmZXJbb2Zmc2V0XTtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHZhbCB8PSBidWZmZXJbb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZFVJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciB2YWwgPSAwO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuIDA7XG5cbiAgaWYgKGlzQmlnRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsID0gYnVmZmVyW29mZnNldCArIDFdIDw8IDE2O1xuICAgIGlmIChvZmZzZXQgKyAyIDwgYnVmZmVyLmxlbmd0aClcbiAgICAgIHZhbCB8PSBidWZmZXJbb2Zmc2V0ICsgMl0gPDwgODtcbiAgICBpZiAob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgfD0gYnVmZmVyW29mZnNldCArIDNdO1xuICAgIHZhbCA9IHZhbCArIChidWZmZXJbb2Zmc2V0XSA8PCAyNCA+Pj4gMCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9mZnNldCArIDIgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsID0gYnVmZmVyW29mZnNldCArIDJdIDw8IDE2O1xuICAgIGlmIChvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aClcbiAgICAgIHZhbCB8PSBidWZmZXJbb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyW29mZnNldF07XG4gICAgaWYgKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsID0gdmFsICsgKGJ1ZmZlcltvZmZzZXQgKyAzXSA8PCAyNCA+Pj4gMCk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuXG4vKlxuICogU2lnbmVkIGludGVnZXIgdHlwZXMsIHlheSB0ZWFtISBBIHJlbWluZGVyIG9uIGhvdyB0d28ncyBjb21wbGVtZW50IGFjdHVhbGx5XG4gKiB3b3Jrcy4gVGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbmVkIGJpdCwgaS5lLiB0ZWxscyB1cyB3aGV0aGVyIG9yIG5vdCB0aGVcbiAqIG51bWJlciBzaG91bGQgYmUgcG9zaXRpdmUgb3IgbmVnYXRpdmUuIElmIHRoZSB0d28ncyBjb21wbGVtZW50IHZhbHVlIGlzXG4gKiBwb3NpdGl2ZSwgdGhlbiB3ZSdyZSBkb25lLCBhcyBpdCdzIGVxdWl2YWxlbnQgdG8gdGhlIHVuc2lnbmVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIE5vdyBpZiB0aGUgbnVtYmVyIGlzIHBvc2l0aXZlLCB5b3UncmUgcHJldHR5IG11Y2ggZG9uZSwgeW91IGNhbiBqdXN0IGxldmVyYWdlXG4gKiB0aGUgdW5zaWduZWQgdHJhbnNsYXRpb25zIGFuZCByZXR1cm4gdGhvc2UuIFVuZm9ydHVuYXRlbHksIG5lZ2F0aXZlIG51bWJlcnNcbiAqIGFyZW4ndCBxdWl0ZSB0aGF0IHN0cmFpZ2h0Zm9yd2FyZC5cbiAqXG4gKiBBdCBmaXJzdCBnbGFuY2UsIG9uZSBtaWdodCBiZSBpbmNsaW5lZCB0byB1c2UgdGhlIHRyYWRpdGlvbmFsIGZvcm11bGEgdG9cbiAqIHRyYW5zbGF0ZSBiaW5hcnkgbnVtYmVycyBiZXR3ZWVuIHRoZSBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzIGluIHR3bydzXG4gKiBjb21wbGVtZW50LiAoVGhvdWdoIGl0IGRvZXNuJ3QgcXVpdGUgd29yayBmb3IgdGhlIG1vc3QgbmVnYXRpdmUgdmFsdWUpXG4gKiBNYWlubHk6XG4gKiAgLSBpbnZlcnQgYWxsIHRoZSBiaXRzXG4gKiAgLSBhZGQgb25lIHRvIHRoZSByZXN1bHRcbiAqXG4gKiBPZiBjb3Vyc2UsIHRoaXMgZG9lc24ndCBxdWl0ZSB3b3JrIGluIEphdmFzY3JpcHQuIFRha2UgZm9yIGV4YW1wbGUgdGhlIHZhbHVlXG4gKiBvZiAtMTI4LiBUaGlzIGNvdWxkIGJlIHJlcHJlc2VudGVkIGluIDE2IGJpdHMgKGJpZy1lbmRpYW4pIGFzIDB4ZmY4MC4gQnV0IG9mXG4gKiBjb3Vyc2UsIEphdmFzY3JpcHQgd2lsbCBkbyB0aGUgZm9sbG93aW5nOlxuICpcbiAqID4gfjB4ZmY4MFxuICogLTY1NDA5XG4gKlxuICogV2hvaCB0aGVyZSwgSmF2YXNjcmlwdCwgdGhhdCdzIG5vdCBxdWl0ZSByaWdodC4gQnV0IHdhaXQsIGFjY29yZGluZyB0b1xuICogSmF2YXNjcmlwdCB0aGF0J3MgcGVyZmVjdGx5IGNvcnJlY3QuIFdoZW4gSmF2YXNjcmlwdCBlbmRzIHVwIHNlZWluZyB0aGVcbiAqIGNvbnN0YW50IDB4ZmY4MCwgaXQgaGFzIG5vIG5vdGlvbiB0aGF0IGl0IGlzIGFjdHVhbGx5IGEgc2lnbmVkIG51bWJlci4gSXRcbiAqIGFzc3VtZXMgdGhhdCB3ZSd2ZSBpbnB1dCB0aGUgdW5zaWduZWQgdmFsdWUgMHhmZjgwLiBUaHVzLCB3aGVuIGl0IGRvZXMgdGhlXG4gKiBiaW5hcnkgbmVnYXRpb24sIGl0IGNhc3RzIGl0IGludG8gYSBzaWduZWQgdmFsdWUsIChwb3NpdGl2ZSAweGZmODApLiBUaGVuXG4gKiB3aGVuIHlvdSBwZXJmb3JtIGJpbmFyeSBuZWdhdGlvbiBvbiB0aGF0LCBpdCB0dXJucyBpdCBpbnRvIGEgbmVnYXRpdmUgbnVtYmVyLlxuICpcbiAqIEluc3RlYWQsIHdlJ3JlIGdvaW5nIHRvIGhhdmUgdG8gdXNlIHRoZSBmb2xsb3dpbmcgZ2VuZXJhbCBmb3JtdWxhLCB0aGF0IHdvcmtzXG4gKiBpbiBhIHJhdGhlciBKYXZhc2NyaXB0IGZyaWVuZGx5IHdheS4gSSdtIGdsYWQgd2UgZG9uJ3Qgc3VwcG9ydCB0aGlzIGtpbmQgb2ZcbiAqIHdlaXJkIG51bWJlcmluZyBzY2hlbWUgaW4gdGhlIGtlcm5lbC5cbiAqXG4gKiAoQklULU1BWCAtICh1bnNpZ25lZCl2YWwgKyAxKSAqIC0xXG4gKlxuICogVGhlIGFzdHV0ZSBvYnNlcnZlciwgbWF5IHRoaW5rIHRoYXQgdGhpcyBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIDgtYml0IG51bWJlcnNcbiAqIChyZWFsbHkgaXQgaXNuJ3QgbmVjZXNzYXJ5IGZvciB0aGVtKS4gSG93ZXZlciwgd2hlbiB5b3UgZ2V0IDE2LWJpdCBudW1iZXJzLFxuICogeW91IGRvLiBMZXQncyBnbyBiYWNrIHRvIG91ciBwcmlvciBleGFtcGxlIGFuZCBzZWUgaG93IHRoaXMgd2lsbCBsb29rOlxuICpcbiAqICgweGZmZmYgLSAweGZmODAgKyAxKSAqIC0xXG4gKiAoMHgwMDdmICsgMSkgKiAtMVxuICogKDB4MDA4MCkgKiAtMVxuICovXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcbiAgdmFyIG5lZztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICBpZiAob2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHJldHVybjtcblxuICBuZWcgPSBidWZmZXJbb2Zmc2V0XSAmIDB4ODA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuIChidWZmZXJbb2Zmc2V0XSk7XG4gIH1cblxuICByZXR1cm4gKCgweGZmIC0gYnVmZmVyW29mZnNldF0gKyAxKSAqIC0xKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciBuZWcsIHZhbDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICB2YWwgPSByZWFkVUludDE2KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICBuZWcgPSB2YWwgJiAweDgwMDA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIHJldHVybiAoMHhmZmZmIC0gdmFsICsgMSkgKiAtMTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZEludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFyIG5lZywgdmFsO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIHZhbCA9IHJlYWRVSW50MzIoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIG5lZyA9IHZhbCAmIDB4ODAwMDAwMDA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuICh2YWwpO1xuICB9XG5cbiAgcmV0dXJuICgweGZmZmZmZmZmIC0gdmFsICsgMSkgKiAtMTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZEZsb2F0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIHJldHVybiByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0JykucmVhZElFRUU3NTQoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgMjMsIDQpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRmxvYXQodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiByZWFkRG91YmxlKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDcgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIHJldHVybiByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0JykucmVhZElFRUU3NTQoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgNTIsIDgpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWREb3VibGUodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuXG4vKlxuICogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYSB2YWxpZCBpbnRlZ2VyLiBUaGlzIG1lYW5zIHRoYXQgaXQgaXNcbiAqIG5vbi1uZWdhdGl2ZS4gSXQgaGFzIG5vIGZyYWN0aW9uYWwgY29tcG9uZW50IGFuZCB0aGF0IGl0IGRvZXMgbm90IGV4Y2VlZCB0aGVcbiAqIG1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAqXG4gKiAgICAgIHZhbHVlICAgICAgICAgICBUaGUgbnVtYmVyIHRvIGNoZWNrIGZvciB2YWxpZGl0eVxuICpcbiAqICAgICAgbWF4ICAgICAgICAgICAgIFRoZSBtYXhpbXVtIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHZlcmlmdWludCh2YWx1ZSwgbWF4KSB7XG4gIGFzc2VydC5vayh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJyxcbiAgICAgICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlID49IDAsXG4gICAgICAnc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKTtcblxuICBhc3NlcnQub2sodmFsdWUgPD0gbWF4LCAndmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZScpO1xuXG4gIGFzc2VydC5vayhNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmYpO1xuICB9XG5cbiAgaWYgKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBidWZmZXJbb2Zmc2V0XSA9IHZhbHVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZik7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWluKGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQsIDIpOyBpKyspIHtcbiAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChpc0JpZ0VuZGlhbiA/IDEgLSBpIDogaSkpKSkgPj4+XG4gICAgICAgICAgICAoaXNCaWdFbmRpYW4gPyAxIC0gaSA6IGkpICogODtcbiAgfVxuXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQzMihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZmZmZmYpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLm1pbihidWZmZXIubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSsrKSB7XG4gICAgYnVmZmVyW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlID4+PiAoaXNCaWdFbmRpYW4gPyAzIC0gaSA6IGkpICogOCkgJiAweGZmO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5cbi8qXG4gKiBXZSBub3cgbW92ZSBvbnRvIG91ciBmcmllbmRzIGluIHRoZSBzaWduZWQgbnVtYmVyIGNhdGVnb3J5LiBVbmxpa2UgdW5zaWduZWRcbiAqIG51bWJlcnMsIHdlJ3JlIGdvaW5nIHRvIGhhdmUgdG8gd29ycnkgYSBiaXQgbW9yZSBhYm91dCBob3cgd2UgcHV0IHZhbHVlcyBpbnRvXG4gKiBhcnJheXMuIFNpbmNlIHdlIGFyZSBvbmx5IHdvcnJ5aW5nIGFib3V0IHNpZ25lZCAzMi1iaXQgdmFsdWVzLCB3ZSdyZSBpblxuICogc2xpZ2h0bHkgYmV0dGVyIHNoYXBlLiBVbmZvcnR1bmF0ZWx5LCB3ZSByZWFsbHkgY2FuJ3QgZG8gb3VyIGZhdm9yaXRlIGJpbmFyeVxuICogJiBpbiB0aGlzIHN5c3RlbS4gSXQgcmVhbGx5IHNlZW1zIHRvIGRvIHRoZSB3cm9uZyB0aGluZy4gRm9yIGV4YW1wbGU6XG4gKlxuICogPiAtMzIgJiAweGZmXG4gKiAyMjRcbiAqXG4gKiBXaGF0J3MgaGFwcGVuaW5nIGFib3ZlIGlzIHJlYWxseTogMHhlMCAmIDB4ZmYgPSAweGUwLiBIb3dldmVyLCB0aGUgcmVzdWx0cyBvZlxuICogdGhpcyBhcmVuJ3QgdHJlYXRlZCBhcyBhIHNpZ25lZCBudW1iZXIuIFVsdGltYXRlbHkgYSBiYWQgdGhpbmcuXG4gKlxuICogV2hhdCB3ZSdyZSBnb2luZyB0byB3YW50IHRvIGRvIGlzIGJhc2ljYWxseSBjcmVhdGUgdGhlIHVuc2lnbmVkIGVxdWl2YWxlbnQgb2ZcbiAqIG91ciByZXByZXNlbnRhdGlvbiBhbmQgcGFzcyB0aGF0IG9mZiB0byB0aGUgd3VpbnQqIGZ1bmN0aW9ucy4gVG8gZG8gdGhhdFxuICogd2UncmUgZ29pbmcgdG8gZG8gdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAgLSBpZiB0aGUgdmFsdWUgaXMgcG9zaXRpdmVcbiAqICAgICAgd2UgY2FuIHBhc3MgaXQgZGlyZWN0bHkgb2ZmIHRvIHRoZSBlcXVpdmFsZW50IHd1aW50XG4gKiAgLSBpZiB0aGUgdmFsdWUgaXMgbmVnYXRpdmVcbiAqICAgICAgd2UgZG8gdGhlIGZvbGxvd2luZyBjb21wdXRhdGlvbjpcbiAqICAgICAgICAgbWIgKyB2YWwgKyAxLCB3aGVyZVxuICogICAgICAgICBtYiAgIGlzIHRoZSBtYXhpbXVtIHVuc2lnbmVkIHZhbHVlIGluIHRoYXQgYnl0ZSBzaXplXG4gKiAgICAgICAgIHZhbCAgaXMgdGhlIEphdmFzY3JpcHQgbmVnYXRpdmUgaW50ZWdlclxuICpcbiAqXG4gKiBBcyBhIGNvbmNyZXRlIHZhbHVlLCB0YWtlIC0xMjguIEluIHNpZ25lZCAxNiBiaXRzIHRoaXMgd291bGQgYmUgMHhmZjgwLiBJZlxuICogeW91IGRvIG91dCB0aGUgY29tcHV0YXRpb25zOlxuICpcbiAqIDB4ZmZmZiAtIDEyOCArIDFcbiAqIDB4ZmZmZiAtIDEyN1xuICogMHhmZjgwXG4gKlxuICogWW91IGNhbiB0aGVuIGVuY29kZSB0aGlzIHZhbHVlIGFzIHRoZSBzaWduZWQgdmVyc2lvbi4gVGhpcyBpcyByZWFsbHkgcmF0aGVyXG4gKiBoYWNreSwgYnV0IGl0IHNob3VsZCB3b3JrIGFuZCBnZXQgdGhlIGpvYiBkb25lIHdoaWNoIGlzIG91ciBnb2FsIGhlcmUuXG4gKi9cblxuLypcbiAqIEEgc2VyaWVzIG9mIGNoZWNrcyB0byBtYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSBhIHNpZ25lZCAzMi1iaXQgbnVtYmVyXG4gKi9cbmZ1bmN0aW9uIHZlcmlmc2ludCh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0Lm9rKHR5cGVvZiAodmFsdWUpID09ICdudW1iZXInLFxuICAgICAgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKTtcblxuICBhc3NlcnQub2sodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKTtcblxuICBhc3NlcnQub2soTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cblxuZnVuY3Rpb24gdmVyaWZJRUVFNzU0KHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKTtcblxuICBhc3NlcnQub2sodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhciBidWZmZXIgPSB0aGlzO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZiwgLTB4ODApO1xuICB9XG5cbiAgaWYgKHZhbHVlID49IDApIHtcbiAgICBidWZmZXIud3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCk7XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgoMHhmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBub0Fzc2VydCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHdyaXRlSW50MTYoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAxIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmYsIC0weDgwMDApO1xuICB9XG5cbiAgaWYgKHZhbHVlID49IDApIHtcbiAgICB3cml0ZVVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVVSW50MTYoYnVmZmVyLCAweGZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUludDMyKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApO1xuICB9XG5cbiAgaWYgKHZhbHVlID49IDApIHtcbiAgICB3cml0ZVVJbnQzMihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVVSW50MzIoYnVmZmVyLCAweGZmZmZmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVGbG9hdChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KTtcbiAgfVxuXG4gIHJlcXVpcmUoJy4vYnVmZmVyX2llZWU3NTQnKS53cml0ZUlFRUU3NTQoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDIzLCA0KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVEb3VibGUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyA3IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KTtcbiAgfVxuXG4gIHJlcXVpcmUoJy4vYnVmZmVyX2llZWU3NTQnKS53cml0ZUlFRUU3NTQoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDUyLCA4KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbn0pKCkiLCIvLyBub3RoaW5nIHRvIHNlZSBoZXJlLi4uIG5vIGZpbGUgbWV0aG9kcyBmb3IgdGhlIGJyb3dzZXJcbiIsIihmdW5jdGlvbihwcm9jZXNzKXtmdW5jdGlvbiBmaWx0ZXIgKHhzLCBmbikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmbih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFJlZ2V4IHRvIHNwbGl0IGEgZmlsZW5hbWUgaW50byBbKiwgZGlyLCBiYXNlbmFtZSwgZXh0XVxuLy8gcG9zaXggdmVyc2lvblxudmFyIHNwbGl0UGF0aFJlID0gL14oLitcXC8oPyEkKXxcXC8pPygoPzouKz8pPyhcXC5bXi5dKik/KSQvO1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbnZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbmZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgdmFyIHBhdGggPSAoaSA+PSAwKVxuICAgICAgPyBhcmd1bWVudHNbaV1cbiAgICAgIDogcHJvY2Vzcy5jd2QoKTtcblxuICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJyB8fCAhcGF0aCkge1xuICAgIGNvbnRpbnVlO1xuICB9XG5cbiAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG59XG5cbi8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbi8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4vLyBOb3JtYWxpemUgdGhlIHBhdGhcbnJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbnZhciBpc0Fic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyxcbiAgICB0cmFpbGluZ1NsYXNoID0gcGF0aC5zbGljZSgtMSkgPT09ICcvJztcblxuLy8gTm9ybWFsaXplIHRoZSBwYXRoXG5wYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG4gIFxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICByZXR1cm4gcCAmJiB0eXBlb2YgcCA9PT0gJ3N0cmluZyc7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGRpciA9IHNwbGl0UGF0aFJlLmV4ZWMocGF0aClbMV0gfHwgJyc7XG4gIHZhciBpc1dpbmRvd3MgPSBmYWxzZTtcbiAgaWYgKCFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lXG4gICAgcmV0dXJuICcuJztcbiAgfSBlbHNlIGlmIChkaXIubGVuZ3RoID09PSAxIHx8XG4gICAgICAoaXNXaW5kb3dzICYmIGRpci5sZW5ndGggPD0gMyAmJiBkaXIuY2hhckF0KDEpID09PSAnOicpKSB7XG4gICAgLy8gSXQgaXMganVzdCBhIHNsYXNoIG9yIGEgZHJpdmUgbGV0dGVyIHdpdGggYSBzbGFzaFxuICAgIHJldHVybiBkaXI7XG4gIH0gZWxzZSB7XG4gICAgLy8gSXQgaXMgYSBmdWxsIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgcmV0dXJuIGRpci5zdWJzdHJpbmcoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGhSZS5leGVjKHBhdGgpWzJdIHx8ICcnO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMocGF0aClbM10gfHwgJyc7XG59O1xuXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikpIiwiLyohXG4gKiBUb2JpIC0gQ29va2llXG4gKiBDb3B5cmlnaHQoYykgMjAxMCBMZWFybkJvb3N0IDxkZXZAbGVhcm5ib29zdC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYENvb2tpZWAgd2l0aCB0aGUgZ2l2ZW4gY29va2llIGBzdHJgIGFuZCBgcmVxYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge0luY29taW5nUmVxdWVzdH0gcmVxXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgQ29va2llID0gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQ29va2llKHN0ciwgcmVxKSB7XG4gIHRoaXMuc3RyID0gc3RyO1xuXG4gIC8vIE1hcCB0aGUga2V5L3ZhbCBwYWlyc1xuICBzdHIuc3BsaXQoLyAqOyAqLykucmVkdWNlKGZ1bmN0aW9uKG9iaiwgcGFpcil7XG4gICB2YXIgcCA9IHBhaXIuaW5kZXhPZignPScpO1xuICAgdmFyIGtleSA9IHAgPiAwID8gcGFpci5zdWJzdHJpbmcoMCwgcCkudHJpbSgpIDogcGFpci50cmltKCk7XG4gICB2YXIgbG93ZXJDYXNlZEtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgdmFyIHZhbHVlID0gcCA+IDAgPyBwYWlyLnN1YnN0cmluZyhwICsgMSkudHJpbSgpIDogdHJ1ZTtcblxuICAgaWYgKCFvYmoubmFtZSkge1xuICAgIC8vIEZpcnN0IGtleSBpcyB0aGUgbmFtZVxuICAgIG9iai5uYW1lID0ga2V5O1xuICAgIG9iai52YWx1ZSA9IHZhbHVlO1xuICAgfVxuICAgZWxzZSBpZiAobG93ZXJDYXNlZEtleSA9PT0gJ2h0dHBvbmx5Jykge1xuICAgIG9iai5odHRwT25seSA9IHZhbHVlO1xuICAgfVxuICAgZWxzZSB7XG4gICAgb2JqW2xvd2VyQ2FzZWRLZXldID0gdmFsdWU7XG4gICB9XG4gICByZXR1cm4gb2JqO1xuICB9LCB0aGlzKTtcblxuICAvLyBFeHBpcmVzXG4gIHRoaXMuZXhwaXJlcyA9IHRoaXMuZXhwaXJlc1xuICAgID8gbmV3IERhdGUodGhpcy5leHBpcmVzKVxuICAgIDogSW5maW5pdHk7XG5cbiAgLy8gRGVmYXVsdCBvciB0cmltIHBhdGhcbiAgdGhpcy5wYXRoID0gdGhpcy5wYXRoXG4gICAgPyB0aGlzLnBhdGgudHJpbSgpOiByZXEgXG4gICAgPyB1cmwucGFyc2UocmVxLnVybCkucGF0aG5hbWU6ICcvJztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBvcmlnaW5hbCBjb29raWUgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29va2llLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzLnN0cjtcbn07XG5cbm1vZHVsZS5leHBvcnRzLkphciA9IHJlcXVpcmUoJy4vamFyJykiLCIvLyBUYXJnZXQgQVBJOlxuLy9cbi8vICB2YXIgcyA9IHJlcXVpcmUoJ25ldCcpLmNyZWF0ZVN0cmVhbSgyNSwgJ3NtdHAuZXhhbXBsZS5jb20nKTtcbi8vICBzLm9uKCdjb25uZWN0JywgZnVuY3Rpb24oKSB7XG4vLyAgIHJlcXVpcmUoJ3N0YXJ0dGxzJykocywgY3JlZHMsIGZhbHNlLCBmdW5jdGlvbigpIHtcbi8vICAgICAgaWYgKCFzLmF1dGhvcml6ZWQpIHtcbi8vICAgICAgICBzLmRlc3Ryb3koKTtcbi8vICAgICAgICByZXR1cm47XG4vLyAgICAgIH1cbi8vXG4vLyAgICAgIHMuZW5kKFwiaGVsbG8gd29ybGRcXG5cIik7XG4vLyAgICB9KTtcbi8vICB9KTtcblxudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIHRscyA9IHJlcXVpcmUoJ3RscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0YXJ0dGxzKHNvY2tldCwgY3JlZGVudGlhbHMsIGlzU2VydmVyLCBjYikge1xuXG4gIHZhciBwYWlyID0gdGxzLmNyZWF0ZVNlY3VyZVBhaXIoY3JlZGVudGlhbHMsIGlzU2VydmVyLCBmYWxzZSwgIWlzU2VydmVyKTtcblxuICB2YXIgY2xlYXJ0ZXh0ID0gcGlwZShwYWlyLCBzb2NrZXQpO1xuXG4gIHBhaXIub24oJ3NlY3VyZScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzc2wgPSBwYWlyLl9zc2wgfHwgcGFpci5zc2w7XG4gICAgdmFyIHZlcmlmeUVycm9yID0gc3NsLnZlcmlmeUVycm9yKCk7XG5cbiAgICBpZiAodmVyaWZ5RXJyb3IpIHtcbiAgICAgIGNsZWFydGV4dC5hdXRob3JpemVkID0gZmFsc2U7XG4gICAgICBjbGVhcnRleHQuYXV0aG9yaXphdGlvbkVycm9yID0gdmVyaWZ5RXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFydGV4dC5hdXRob3JpemVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoY2IpIGNiKCk7XG4gIH0pO1xuXG4gIGNsZWFydGV4dC5fY29udHJvbFJlbGVhc2VkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsZWFydGV4dDtcbn07XG5cblxuZnVuY3Rpb24gcGlwZShwYWlyLCBzb2NrZXQpIHtcbiAgcGFpci5lbmNyeXB0ZWQucGlwZShzb2NrZXQpO1xuICBzb2NrZXQucGlwZShwYWlyLmVuY3J5cHRlZCk7XG5cbiAgcGFpci5mZCA9IHNvY2tldC5mZDtcbiAgdmFyIGNsZWFydGV4dCA9IHBhaXIuY2xlYXJ0ZXh0O1xuICBjbGVhcnRleHQuc29ja2V0ID0gc29ja2V0O1xuICBjbGVhcnRleHQuZW5jcnlwdGVkID0gcGFpci5lbmNyeXB0ZWQ7XG4gIGNsZWFydGV4dC5hdXRob3JpemVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gb25lcnJvcihlKSB7XG4gICAgaWYgKGNsZWFydGV4dC5fY29udHJvbFJlbGVhc2VkKSB7XG4gICAgICBjbGVhcnRleHQuZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICBzb2NrZXQub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIHNvY2tldC5vbignY2xvc2UnLCBvbmNsb3NlKTtcblxuICByZXR1cm4gY2xlYXJ0ZXh0O1xufVxuIiwiLy8gQ29weXJpZ2h0IDIwMTEgSm95ZW50LCBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKTtcbnZhciBzaWduZXIgPSByZXF1aXJlKCcuL3NpZ25lcicpO1xudmFyIHZlcmlmeSA9IHJlcXVpcmUoJy4vdmVyaWZ5Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5cblxuLy8vLS0tIEFQSVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBwYXJzZTogcGFyc2VyLnBhcnNlUmVxdWVzdCxcbiAgcGFyc2VSZXF1ZXN0OiBwYXJzZXIucGFyc2VSZXF1ZXN0LFxuXG4gIHNpZ246IHNpZ25lci5zaWduUmVxdWVzdCxcbiAgc2lnblJlcXVlc3Q6IHNpZ25lci5zaWduUmVxdWVzdCxcblxuICBzc2hLZXlUb1BFTTogdXRpbC5zc2hLZXlUb1BFTSxcbiAgc3NoS2V5RmluZ2VycHJpbnQ6IHV0aWwuZmluZ2VycHJpbnQsXG5cbiAgdmVyaWZ5OiB2ZXJpZnkudmVyaWZ5U2lnbmF0dXJlLFxuICB2ZXJpZnlTaWduYXR1cmU6IHZlcmlmeS52ZXJpZnlTaWduYXR1cmVcbn07XG4iLCIoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnI7XG5cdFxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93ICdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jztcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0cGxhY2VIb2xkZXJzID0gYjY0LmluZGV4T2YoJz0nKTtcblx0XHRwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIHBsYWNlSG9sZGVycyA6IDA7XG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBbXTsvL25ldyBVaW50OEFycmF5KGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycyk7XG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAobG9va3VwLmluZGV4T2YoYjY0W2ldKSA8PCAxOCkgfCAobG9va3VwLmluZGV4T2YoYjY0W2kgKyAxXSkgPDwgMTIpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMl0pIDw8IDYpIHwgbG9va3VwLmluZGV4T2YoYjY0W2kgKyAzXSk7XG5cdFx0XHRhcnIucHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KTtcblx0XHRcdGFyci5wdXNoKCh0bXAgJiAweEZGMDApID4+IDgpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMikgfCAobG9va3VwLmluZGV4T2YoYjY0W2kgKyAxXSkgPj4gNCk7XG5cdFx0XHRhcnIucHVzaCh0bXAgJiAweEZGKTtcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMTApIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pIDw8IDQpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMl0pID4+IDIpO1xuXHRcdFx0YXJyLnB1c2goKHRtcCA+PiA4KSAmIDB4RkYpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFycjtcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aDtcblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl07XG5cdFx0fTtcblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pO1xuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKTtcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFt0ZW1wID4+IDJdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wIDw8IDQpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSAnPT0nO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSk7XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbdGVtcCA+PiAxMF07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPj4gNCkgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA8PCAyKSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gJz0nO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0bW9kdWxlLmV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheTtcblx0bW9kdWxlLmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjQ7XG59KCkpO1xuIiwidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG52YXIgUmVzcG9uc2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG59O1xuXG5SZXNwb25zZS5wcm90b3R5cGUgPSBuZXcgU3RyZWFtO1xuXG52YXIgY2FwYWJsZSA9IHtcbiAgICBzdHJlYW1pbmcgOiB0cnVlLFxuICAgIHN0YXR1czIgOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMgKHJlcykge1xuICAgIHZhciBsaW5lcyA9IHJlcy5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS5zcGxpdCgvXFxyP1xcbi8pO1xuICAgIHZhciBoZWFkZXJzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICBpZiAobGluZSA9PT0gJycpIGNvbnRpbnVlO1xuICAgICAgICBcbiAgICAgICAgdmFyIG0gPSBsaW5lLm1hdGNoKC9eKFteOl0rKTpcXHMqKC4qKS8pO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IG1bMV0udG9Mb3dlckNhc2UoKSwgdmFsdWUgPSBtWzJdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaGVhZGVyc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGhlYWRlcnNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1trZXldLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1trZXldID0gWyBoZWFkZXJzW2tleV0sIHZhbHVlIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWFkZXJzW2xpbmVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cblxuUmVzcG9uc2UucHJvdG90eXBlLmdldFJlc3BvbnNlID0gZnVuY3Rpb24gKHhocikge1xuICAgIHZhciByZXNwVHlwZSA9IFN0cmluZyh4aHIucmVzcG9uc2VUeXBlKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChyZXNwVHlwZSA9PT0gJ2Jsb2InKSByZXR1cm4geGhyLnJlc3BvbnNlQmxvYiB8fCB4aHIucmVzcG9uc2U7XG4gICAgaWYgKHJlc3BUeXBlID09PSAnYXJyYXlidWZmZXInKSByZXR1cm4geGhyLnJlc3BvbnNlO1xuICAgIHJldHVybiB4aHIucmVzcG9uc2VUZXh0O1xufVxuXG5SZXNwb25zZS5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xufTtcblxuUmVzcG9uc2UucHJvdG90eXBlLmhhbmRsZSA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICBpZiAocmVzLnJlYWR5U3RhdGUgPT09IDIgJiYgY2FwYWJsZS5zdGF0dXMyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXJzKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2FwYWJsZS5zdGF0dXMyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChjYXBhYmxlLnN0YXR1czIpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChjYXBhYmxlLnN0cmVhbWluZyAmJiByZXMucmVhZHlTdGF0ZSA9PT0gMykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVycyhyZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7fVxuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXREYXRhKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2FwYWJsZS5zdHJlYW1pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChyZXMucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbWl0RGF0YShyZXMpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJlcy5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHRoaXMuZ2V0UmVzcG9uc2UocmVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB0aGlzLmVtaXQoJ2VuZCcpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgIH1cbn07XG5cblJlc3BvbnNlLnByb3RvdHlwZS5fZW1pdERhdGEgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgdmFyIHJlc3BCb2R5ID0gdGhpcy5nZXRSZXNwb25zZShyZXMpO1xuICAgIGlmIChyZXNwQm9keS50b1N0cmluZygpLm1hdGNoKC9BcnJheUJ1ZmZlci8pKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIG5ldyBVaW50OEFycmF5KHJlc3BCb2R5LCB0aGlzLm9mZnNldCkpO1xuICAgICAgICB0aGlzLm9mZnNldCA9IHJlc3BCb2R5LmJ5dGVMZW5ndGg7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlc3BCb2R5Lmxlbmd0aCA+IHRoaXMub2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHJlc3BCb2R5LnNsaWNlKHRoaXMub2Zmc2V0KSk7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gcmVzcEJvZHkubGVuZ3RoO1xuICAgIH1cbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJyk7IiwiLyohXG4qIFRvYmkgLSBDb29raWVKYXJcbiogQ29weXJpZ2h0KGMpIDIwMTAgTGVhcm5Cb29zdCA8ZGV2QGxlYXJuYm9vc3QuY29tPlxuKiBNSVQgTGljZW5zZWRcbiovXG5cbi8qKlxuKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuKi9cblxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG4vKipcbiogSW5pdGlhbGl6ZSBhIG5ldyBgQ29va2llSmFyYC5cbipcbiogQGFwaSBwcml2YXRlXG4qL1xuXG52YXIgQ29va2llSmFyID0gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQ29va2llSmFyKCkge1xuICB0aGlzLmNvb2tpZXMgPSBbXTtcbn07XG5cbi8qKlxuKiBBZGQgdGhlIGdpdmVuIGBjb29raWVgIHRvIHRoZSBqYXIuXG4qXG4qIEBwYXJhbSB7Q29va2llfSBjb29raWVcbiogQGFwaSBwcml2YXRlXG4qL1xuXG5Db29raWVKYXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGNvb2tpZSl7XG4gIHRoaXMuY29va2llcyA9IHRoaXMuY29va2llcy5maWx0ZXIoZnVuY3Rpb24oYyl7XG4gICAgLy8gQXZvaWQgZHVwbGljYXRpb24gKHNhbWUgcGF0aCwgc2FtZSBuYW1lKVxuICAgIHJldHVybiAhKGMubmFtZSA9PSBjb29raWUubmFtZSAmJiBjLnBhdGggPT0gY29va2llLnBhdGgpO1xuICB9KTtcbiAgdGhpcy5jb29raWVzLnB1c2goY29va2llKTtcbn07XG5cbi8qKlxuKiBHZXQgY29va2llcyBmb3IgdGhlIGdpdmVuIGByZXFgLlxuKlxuKiBAcGFyYW0ge0luY29taW5nUmVxdWVzdH0gcmVxXG4qIEByZXR1cm4ge0FycmF5fVxuKiBAYXBpIHByaXZhdGVcbiovXG5cbkNvb2tpZUphci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocmVxKXtcbiAgdmFyIHBhdGggPSB1cmwucGFyc2UocmVxLnVybCkucGF0aG5hbWVcbiAgICAsIG5vdyA9IG5ldyBEYXRlXG4gICAgLCBzcGVjaWZpY2l0eSA9IHt9O1xuICByZXR1cm4gdGhpcy5jb29raWVzLmZpbHRlcihmdW5jdGlvbihjb29raWUpe1xuICAgIGlmICgwID09IHBhdGguaW5kZXhPZihjb29raWUucGF0aCkgJiYgbm93IDwgY29va2llLmV4cGlyZXNcbiAgICAgICYmIGNvb2tpZS5wYXRoLmxlbmd0aCA+IChzcGVjaWZpY2l0eVtjb29raWUubmFtZV0gfHwgMCkpXG4gICAgICByZXR1cm4gc3BlY2lmaWNpdHlbY29va2llLm5hbWVdID0gY29va2llLnBhdGgubGVuZ3RoO1xuICB9KTtcbn07XG5cbi8qKlxuKiBSZXR1cm4gQ29va2llIHN0cmluZyBmb3IgdGhlIGdpdmVuIGByZXFgLlxuKlxuKiBAcGFyYW0ge0luY29taW5nUmVxdWVzdH0gcmVxXG4qIEByZXR1cm4ge1N0cmluZ31cbiogQGFwaSBwcml2YXRlXG4qL1xuXG5Db29raWVKYXIucHJvdG90eXBlLmNvb2tpZVN0cmluZyA9IGZ1bmN0aW9uKHJlcSl7XG4gIHZhciBjb29raWVzID0gdGhpcy5nZXQocmVxKTtcbiAgaWYgKGNvb2tpZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNvb2tpZXMubWFwKGZ1bmN0aW9uKGNvb2tpZSl7XG4gICAgICByZXR1cm4gY29va2llLm5hbWUgKyAnPScgKyBjb29raWUudmFsdWU7XG4gICAgfSkuam9pbignOyAnKTtcbiAgfVxufTtcbiIsIi8qIENhdXNlIGJyb3dzZXJpZnkgdG8gYnVuZGxlIFNBWCBwYXJzZXJzOiAqL1xuLy9yZXF1aXJlKCcuL3NheF9lYXN5c2F4Jyk7XG4vL3JlcXVpcmUoJy4vc2F4X3NheGpzJyk7XG5yZXF1aXJlKCcuL3NheF9sdHgnKTtcblxuLyogU0hJTSAqL1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2luZGV4Jyk7IiwidmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIENvbm5lY3Rpb24gPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24nKTtcbnZhciBCT1NIID0gcmVxdWlyZSgnLi9ib3NoJyk7XG52YXIgV2ViU29ja2V0cyA9IHJlcXVpcmUoJy4vd2Vic29ja2V0cycpO1xudmFyIEpJRCA9IHJlcXVpcmUoJy4vamlkJykuSklEO1xudmFyIHRscyA9IHJlcXVpcmUoJ3RscycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIFNSViA9IHJlcXVpcmUoJy4vc3J2Jyk7XG5cbmZ1bmN0aW9uIFNlc3Npb24ob3B0cykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIGlmICh0eXBlb2Ygb3B0cy5qaWQgPT0gJ3N0cmluZycpXG4gICAgICAgIHRoaXMuamlkID0gbmV3IEpJRChvcHRzLmppZCk7XG4gICAgZWxzZVxuICAgICAgICB0aGlzLmppZCA9IG9wdHMuamlkO1xuICAgIHRoaXMucGFzc3dvcmQgPSBvcHRzLnBhc3N3b3JkO1xuICAgIHRoaXMucHJlZmVycmVkU2FzbE1lY2hhbmlzbSA9IG9wdHMucHJlZmVycmVkU2FzbE1lY2hhbmlzbTtcbiAgICB0aGlzLmF2YWlsYWJsZVNhc2xNZWNoYW5pc21zID0gW107XG4gICAgdGhpcy5hcGlfa2V5ID0gb3B0cy5hcGlfa2V5O1xuICAgIHRoaXMuYWNjZXNzX3Rva2VuID0gb3B0cy5hY2Nlc3NfdG9rZW47XG4gICAgdGhpcy5vYXV0aDJfdG9rZW4gPSBvcHRzLm9hdXRoMl90b2tlbjtcbiAgICB0aGlzLm9hdXRoMl9hdXRoID0gb3B0cy5vYXV0aDJfYXV0aDtcbiAgICB0aGlzLnJlZ2lzdGVyID0gb3B0cy5yZWdpc3RlcjtcbiAgICBpZiAodHlwZW9mIG9wdHMuYWN0QXMgPT0gJ3N0cmluZycpIFxuICAgIFx0dGhpcy5hY3RBcyA9IG5ldyBKSUQob3B0cy5hY3RBcyk7XG4gICAgZWxzZVxuICAgICAgICB0aGlzLmFjdEFzID0gb3B0cy5hY3RBcztcbiAgICBkZWxldGUgdGhpcy5kaWRfYmluZDtcbiAgICBkZWxldGUgdGhpcy5kaWRfc2Vzc2lvbjtcblxuICAgIGlmIChvcHRzLndlYnNvY2tldHNVUkwpIHtcblx0dGhpcy5jb25uZWN0aW9uID0gbmV3IFdlYlNvY2tldHMuV1NDb25uZWN0aW9uKG9wdHMud2Vic29ja2V0c1VSTCk7XG5cdHRoaXMuY29ubmVjdGlvbi5vbignY29ubmVjdGVkJywgZnVuY3Rpb24oKSB7XG5cdCAgICBpZiAoc2VsZi5jb25uZWN0aW9uLnN0YXJ0U3RyZWFtKVxuXHRcdHNlbGYuY29ubmVjdGlvbi5zdGFydFN0cmVhbSgpO1xuXHR9KTtcbiAgICB9IGVsc2UgaWYgKG9wdHMuYm9zaFVSTCkge1xuXHR0aGlzLmNvbm5lY3Rpb24gPSBuZXcgQk9TSC5CT1NIQ29ubmVjdGlvbih7XG5cdCAgICBqaWQ6IHRoaXMuamlkLFxuXHQgICAgYm9zaFVSTDogb3B0cy5ib3NoVVJMXG5cdH0pO1xuICAgIH0gZWxzZSB7XG5cdHRoaXMuY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uLkNvbm5lY3Rpb24oe1xuXHQgICAgeG1sbnM6IHsgJyc6IG9wdHMueG1sbnMgfSxcblx0ICAgIHN0cmVhbUF0dHJzOiB7XG5cdFx0dmVyc2lvbjogXCIxLjBcIixcblx0XHR0bzogdGhpcy5qaWQuZG9tYWluXG5cdCAgICB9XG5cdH0pO1xuXHR2YXIgY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgaWYgKG9wdHMuaG9zdCkge1xuICAgIFx0ICAgIHNlbGYuY29ubmVjdGlvbi5vbignY29ubmVjdCcsIGZ1bmN0aW9uKCkge1xuICAgIFx0ICAgICAgICBpZiAoc2VsZi5jb25uZWN0aW9uLnN0YXJ0U3RyZWFtKVxuICAgIFx0XHQgICAgICAgIHNlbGYuY29ubmVjdGlvbi5zdGFydFN0cmVhbSgpO1xuICAgIFx0ICAgIH0pO1xuXG5cdCAgICAgICAgaWYgKG9wdHMubGVnYWN5U1NMKSB7XG5cdCAgICAgICAgICAgIHNlbGYuY29ubmVjdGlvbi5hbGxvd1RMUyA9IGZhbHNlO1xuXHQgICAgICAgICAgICBzZWxmLmNvbm5lY3Rpb24uc29ja2V0ID0gdGxzLmNvbm5lY3Qob3B0cy5wb3J0IHx8IDUyMjMsIG9wdHMuaG9zdCwgb3B0cy5jcmVkZW50aWFscyB8fCB7fSwgZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBzZWxmLmNvbm5lY3Rpb24uc2V0dXBTdHJlYW0oKTtcblx0ICAgICAgICAgICAgICAgIHNlbGYuY29ubmVjdGlvbi5zdGFydFBhcnNlcigpO1xuICAgICAgICAgICAgXHQgICAgc2VsZi5jb25uZWN0aW9uLmVtaXQoJ2Nvbm5lY3QnKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgaWYgKG9wdHMuY3JlZGVudGlhbHMpIHtcblx0ICAgICAgICAgICAgICAgIHNlbGYuY29ubmVjdGlvbi5jcmVkZW50aWFscyA9IGNyeXB0by5jcmVhdGVDcmVkZW50aWFscyhvcHRzLmNyZWRlbnRpYWxzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBzZWxmLmNvbm5lY3Rpb24uc29ja2V0Lm9uKFwiY29ubmVjdFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29ubmVjdGlvbi5lbWl0KCdjb25uZWN0JylcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25uZWN0aW9uLnNvY2tldC5jb25uZWN0KG9wdHMucG9ydCB8fCA1MjIyLCBvcHRzLmhvc3QpO1xuICAgIFx0XHR9XG5cdCAgICB9IGVsc2UgaWYgKCFTUlYpIHtcblx0XHQgICAgdGhyb3cgXCJDYW5ub3QgbG9hZCBTUlZcIjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgICAgaWYgKG9wdHMubGVnYWN5U1NMKSB7XG5cdCAgICAgICAgICAgIHRocm93IFwiTGVnYWN5U1NMIG1vZGUgZG9lcyBub3Qgc3VwcG9ydCBETlMgbG9va3Vwc1wiO1xuXHQgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdHMuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbm5lY3Rpb24uY3JlZGVudGlhbHMgPSBjcnlwdG8uY3JlYXRlQ3JlZGVudGlhbHMob3B0cy5jcmVkZW50aWFscyk7XG4gICAgICAgICAgICB9XG5cdCAgICAgICAgXG5cdFx0ICAgIHZhciBhdHRlbXB0ID0gU1JWLmNvbm5lY3Qoc2VsZi5jb25uZWN0aW9uLnNvY2tldCxcblx0XHQgICAgICAgIFsnX3htcHAtY2xpZW50Ll90Y3AnXSwgc2VsZi5qaWQuZG9tYWluLCA1MjIyKTtcblx0XHQgICAgYXR0ZW1wdC5hZGRMaXN0ZW5lcignY29ubmVjdCcsIGZ1bmN0aW9uKCkge1xuXHRcdCAgICBpZiAoc2VsZi5jb25uZWN0aW9uLnN0YXJ0U3RyZWFtKVxuXHRcdFx0ICAgIHNlbGYuY29ubmVjdGlvbi5zdGFydFN0cmVhbSgpO1xuXHRcdH0pO1xuXHRcdGF0dGVtcHQuYWRkTGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24oZSkge1xuXHRcdCAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZSk7XG5cdFx0fSk7XG5cdCAgICB9XG5cdH07XG5cdGlmIChvcHRzLnJlY29ubmVjdClcblx0ICAgIHNlbGYucmVjb25uZWN0ID0gY29ubmVjdDtcblx0Y29ubmVjdCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbm5lY3Rpb24uYWRkTGlzdGVuZXIoJ3N0YW56YScsIHRoaXMub25TdGFuemEuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5jb25uZWN0aW9uLmFkZExpc3RlbmVyKCdkcmFpbicsIHRoaXMuZW1pdC5iaW5kKHRoaXMsICdkcmFpbicpKTtcblxuICAgIHRoaXMuY29ubmVjdGlvbi5hZGRMaXN0ZW5lcignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnZW5kJyk7XG4gICAgfSk7XG4gICAgdGhpcy5jb25uZWN0aW9uLmFkZExpc3RlbmVyKCdjbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJyk7XG4gICAgfSk7XG59XG5cbnV0aWwuaW5oZXJpdHMoU2Vzc2lvbiwgRXZlbnRFbWl0dGVyKTtcbmV4cG9ydHMuU2Vzc2lvbiA9IFNlc3Npb247XG5cblxuU2Vzc2lvbi5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uICYmIHRoaXMuY29ubmVjdGlvbi5wYXVzZSlcblx0dGhpcy5jb25uZWN0aW9uLnBhdXNlKCk7XG59O1xuXG5TZXNzaW9uLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uICYmIHRoaXMuY29ubmVjdGlvbi5yZXN1bWUpXG5cdHRoaXMuY29ubmVjdGlvbi5yZXN1bWUoKTtcbn07XG5cblNlc3Npb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihzdGFuemEpIHtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uKVxuXHR0aGlzLmNvbm5lY3Rpb24uc2VuZChzdGFuemEucm9vdCgpKTtcbn07XG5cblNlc3Npb24ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmNvbm5lY3Rpb24pXG5cdHRoaXMuY29ubmVjdGlvbi5lbmQoKTtcbn07XG5cblNlc3Npb24ucHJvdG90eXBlLm9uU3RhbnphID0gZnVuY3Rpb24oc3RhbnphKSB7XG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5cbmNvbnN0IFNUQVRFX1RFWFQgPSAwLFxuICAgIFNUQVRFX0lHTk9SRV9UQUcgPSAxLFxuICAgIFNUQVRFX1RBR19OQU1FID0gMixcbiAgICBTVEFURV9UQUcgPSAzLFxuICAgIFNUQVRFX0FUVFJfTkFNRSA9IDQsXG4gICAgU1RBVEVfQVRUUl9FUSA9IDUsXG4gICAgU1RBVEVfQVRUUl9RVU9UID0gNixcbiAgICBTVEFURV9BVFRSX1ZBTFVFID0gNztcblxudmFyIFJFX1RBR19OQU1FID0gL15bXlxcc1xcLz5dKyQvLFxuICAgIFJFX0FUVFJfTkFNRSA9IC9eW15cXHM9XSskLztcblxudmFyIFNheEx0eCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gU2F4THR4KCkge1xuICAgIGV2ZW50cy5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHZhciBzdGF0ZSA9IFNUQVRFX1RFWFQsIHJlbWFpbmRlcjtcbiAgICB2YXIgdGFnTmFtZSwgYXR0cnMsIGVuZFRhZywgc2VsZkNsb3NpbmcsIGF0dHJRdW90ZTtcbiAgICB2YXIgcmVjb3JkU3RhcnQgPSAwO1xuXG4gICAgdGhpcy53cml0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0aWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJylcblx0ICAgIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBwb3MgPSAwXG4gICAgICAgIHZhciBhdHRyTmFtZVxuXG5cdC8qIEFueXRoaW5nIGZyb20gcHJldmlvdXMgd3JpdGUoKT8gKi9cblx0aWYgKHJlbWFpbmRlcikge1xuXHQgICAgZGF0YSA9IHJlbWFpbmRlciArIGRhdGE7XG5cdCAgICBwb3MgKz0gcmVtYWluZGVyLmxlbmd0aDtcblx0ICAgIGRlbGV0ZSByZW1haW5kZXI7XG5cdH1cblxuXHRmdW5jdGlvbiBlbmRSZWNvcmRpbmcoKSB7XG5cdCAgICBpZiAodHlwZW9mIHJlY29yZFN0YXJ0ID09PSAnbnVtYmVyJykge1xuXHRcdHZhciByZWNvcmRlZCA9IGRhdGEuc2xpY2UocmVjb3JkU3RhcnQsIHBvcyk7XG5cdFx0cmVjb3JkU3RhcnQgPSB1bmRlZmluZWQ7XG5cdFx0cmV0dXJuIHJlY29yZGVkO1xuXHQgICAgfVxuXHR9XG5cblx0Zm9yKDsgcG9zIDwgZGF0YS5sZW5ndGg7IHBvcysrKSB7XG5cdCAgICB2YXIgYyA9IGRhdGEuY2hhckNvZGVBdChwb3MpO1xuXHQgICAgLy9jb25zb2xlLmxvZyhcInN0YXRlXCIsIHN0YXRlLCBcImNcIiwgYywgZGF0YVtwb3NdKTtcblx0ICAgIHN3aXRjaChzdGF0ZSkge1xuXHQgICAgY2FzZSBTVEFURV9URVhUOlxuXHRcdGlmIChjID09PSA2MCAvKiA8ICovKSB7XG5cdFx0ICAgIHZhciB0ZXh0ID0gZW5kUmVjb3JkaW5nKCk7XG5cdFx0ICAgIGlmICh0ZXh0KVxuXHRcdFx0dGhpcy5lbWl0KCd0ZXh0JywgdW5lc2NhcGVYbWwodGV4dCkpO1xuXHRcdCAgICBzdGF0ZSA9IFNUQVRFX1RBR19OQU1FO1xuXHRcdCAgICByZWNvcmRTdGFydCA9IHBvcyArIDE7XG5cdFx0ICAgIGF0dHJzID0ge307XG5cdFx0fVxuXHRcdGJyZWFrO1xuXHQgICAgY2FzZSBTVEFURV9UQUdfTkFNRTpcblx0XHRpZiAoYyA9PT0gNDcgLyogLyAqLyAmJiByZWNvcmRTdGFydCA9PT0gcG9zKSB7XG5cdFx0ICAgIHJlY29yZFN0YXJ0ID0gcG9zICsgMTtcblx0XHQgICAgZW5kVGFnID0gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKGMgPT09IDMzIC8qICEgKi8gfHwgYyA9PT0gNjMgLyogPyAqLykge1xuXHRcdCAgICByZWNvcmRTdGFydCA9IHVuZGVmaW5lZDtcblx0XHQgICAgc3RhdGUgPSBTVEFURV9JR05PUkVfVEFHO1xuXHRcdH0gZWxzZSBpZiAoYyA8PSAzMiB8fCBjID09PSA0NyAvKiAvICovIHx8IGMgPT09IDYyIC8qID4gKi8pIHtcblx0XHQgICAgdGFnTmFtZSA9IGVuZFJlY29yZGluZygpO1xuXHRcdCAgICBwb3MtLTtcblx0XHQgICAgc3RhdGUgPSBTVEFURV9UQUc7XG5cdFx0fVxuXHRcdGJyZWFrO1xuXHQgICAgY2FzZSBTVEFURV9JR05PUkVfVEFHOlxuXHRcdGlmIChjID09PSA2MiAvKiA+ICovKSB7XG5cdFx0ICAgIHN0YXRlID0gU1RBVEVfVEVYVDtcblx0XHR9XG5cdFx0YnJlYWs7XG5cdCAgICBjYXNlIFNUQVRFX1RBRzpcblx0XHRpZiAoYyA9PT0gNjIgLyogPiAqLykge1xuXHRcdCAgICBpZiAoIWVuZFRhZykge1xuXHRcdFx0dGhpcy5lbWl0KCdzdGFydEVsZW1lbnQnLCB0YWdOYW1lLCBhdHRycyk7XG5cdFx0XHRpZiAoc2VsZkNsb3NpbmcpXG5cdFx0XHQgICAgdGhpcy5lbWl0KCdlbmRFbGVtZW50JywgdGFnTmFtZSk7XG5cdFx0ICAgIH0gZWxzZVxuXHRcdFx0dGhpcy5lbWl0KCdlbmRFbGVtZW50JywgdGFnTmFtZSk7XG5cdFx0ICAgIHRhZ05hbWUgPSB1bmRlZmluZWQ7XG5cdFx0ICAgIGF0dHJzID0gdW5kZWZpbmVkO1xuXHRcdCAgICBlbmRUYWcgPSB1bmRlZmluZWQ7XG5cdFx0ICAgIHNlbGZDbG9zaW5nID0gdW5kZWZpbmVkO1xuXHRcdCAgICBzdGF0ZSA9IFNUQVRFX1RFWFQ7XG5cdFx0ICAgIHJlY29yZFN0YXJ0ID0gcG9zICsgMTtcblx0XHR9IGVsc2UgaWYgKGMgPT09IDQ3IC8qIC8gKi8pIHtcblx0XHQgICAgc2VsZkNsb3NpbmcgPSB0cnVlO1xuXHRcdH0gZWxzZSBpZiAoYyA+IDMyKSB7XG5cdFx0ICAgIHJlY29yZFN0YXJ0ID0gcG9zO1xuXHRcdCAgICBzdGF0ZSA9IFNUQVRFX0FUVFJfTkFNRTtcblx0XHR9XG5cdFx0YnJlYWs7XG5cdCAgICBjYXNlIFNUQVRFX0FUVFJfTkFNRTpcblx0XHRpZiAoYyA8PSAzMiB8fCBjID09PSA2MSAvKiA9ICovKSB7XG5cdFx0ICAgIGF0dHJOYW1lID0gZW5kUmVjb3JkaW5nKCk7XG5cdFx0ICAgIHBvcy0tO1xuXHRcdCAgICBzdGF0ZSA9IFNUQVRFX0FUVFJfRVE7XG5cdFx0fVxuXHRcdGJyZWFrO1xuXHQgICAgY2FzZSBTVEFURV9BVFRSX0VROlxuXHRcdGlmIChjID09PSA2MSAvKiA9ICovKSB7XG5cdFx0ICAgIHN0YXRlID0gU1RBVEVfQVRUUl9RVU9UO1xuXHRcdH1cblx0XHRicmVhaztcblx0ICAgIGNhc2UgU1RBVEVfQVRUUl9RVU9UOlxuXHRcdGlmIChjID09PSAzNCAvKiBcIiAqLyB8fCBjID09PSAzOSAvKiAnICovKSB7XG5cdFx0ICAgIGF0dHJRdW90ZSA9IGM7XG5cdFx0ICAgIHN0YXRlID0gU1RBVEVfQVRUUl9WQUxVRTtcblx0XHQgICAgcmVjb3JkU3RhcnQgPSBwb3MgKyAxO1xuXHRcdH1cblx0XHRicmVhaztcblx0ICAgIGNhc2UgU1RBVEVfQVRUUl9WQUxVRTpcblx0XHRpZiAoYyA9PT0gYXR0clF1b3RlKSB7XG5cdFx0ICAgIHZhciB2YWx1ZSA9IHVuZXNjYXBlWG1sKGVuZFJlY29yZGluZygpKTtcblx0XHQgICAgYXR0cnNbYXR0ck5hbWVdID0gdmFsdWU7XG5cdFx0ICAgIGF0dHJOYW1lID0gdW5kZWZpbmVkO1xuXHRcdCAgICBzdGF0ZSA9IFNUQVRFX1RBRztcblx0XHR9XG5cdFx0YnJlYWs7XG5cdCAgICB9XG5cdH1cblxuXHRpZiAodHlwZW9mIHJlY29yZFN0YXJ0ID09PSAnbnVtYmVyJyAmJlxuXHQgICAgcmVjb3JkU3RhcnQgPD0gZGF0YS5sZW5ndGgpIHtcblxuXHQgICAgcmVtYWluZGVyID0gZGF0YS5zbGljZShyZWNvcmRTdGFydCk7XG5cdCAgICByZWNvcmRTdGFydCA9IDA7XG5cdH1cbiAgICB9O1xuXG4gICAgLyp2YXIgb3JpZ0VtaXQgPSB0aGlzLmVtaXQ7XG4gICAgdGhpcy5lbWl0ID0gZnVuY3Rpb24oKSB7XG5cdGNvbnNvbGUubG9nKCdsdHgnLCBhcmd1bWVudHMpO1xuXHRvcmlnRW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07Ki9cbn07XG51dGlsLmluaGVyaXRzKFNheEx0eCwgZXZlbnRzLkV2ZW50RW1pdHRlcik7XG5cblxuU2F4THR4LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYgKGRhdGEpXG5cdHRoaXMud3JpdGUoZGF0YSk7XG5cbiAgICAvKiBVaCwgeWVhaCAqL1xuICAgIHRoaXMud3JpdGUgPSBmdW5jdGlvbigpIHtcbiAgICB9O1xufTtcblxuZnVuY3Rpb24gdW5lc2NhcGVYbWwocykge1xuICAgIHJldHVybiBzLlxuICAgICAgICByZXBsYWNlKC9cXCZhbXA7L2csICcmJykuXG4gICAgICAgIHJlcGxhY2UoL1xcJmx0Oy9nLCAnPCcpLlxuICAgICAgICByZXBsYWNlKC9cXCZndDsvZywgJz4nKS5cbiAgICAgICAgcmVwbGFjZSgvXFwmcXVvdDsvZywgJ1wiJykuXG4gICAgICAgIHJlcGxhY2UoL1xcJmFwb3M7L2csICdcXCcnKTtcbn1cbiIsIihmdW5jdGlvbigpe3ZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbnZhciBSZXNwb25zZSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UnKTtcbnZhciBjb25jYXRTdHJlYW0gPSByZXF1aXJlKCdjb25jYXQtc3RyZWFtJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxuXG52YXIgUmVxdWVzdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHhociwgcGFyYW1zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIHNlbGYueGhyID0geGhyO1xuICAgIHNlbGYuYm9keSA9IGNvbmNhdFN0cmVhbSgpXG4gICAgXG4gICAgdmFyIHVyaSA9IHBhcmFtcy5ob3N0XG4gICAgICAgICsgKHBhcmFtcy5wb3J0ID8gJzonICsgcGFyYW1zLnBvcnQgOiAnJylcbiAgICAgICAgKyAocGFyYW1zLnBhdGggfHwgJy8nKVxuICAgIDtcbiAgICBcbiAgICB4aHIub3BlbihcbiAgICAgICAgcGFyYW1zLm1ldGhvZCB8fCAnR0VUJyxcbiAgICAgICAgKHBhcmFtcy5zY2hlbWUgfHwgJ2h0dHAnKSArICc6Ly8nICsgdXJpLFxuICAgICAgICB0cnVlXG4gICAgKTtcbiAgICBcbiAgICBpZiAocGFyYW1zLmhlYWRlcnMpIHtcbiAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKHBhcmFtcy5oZWFkZXJzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICghc2VsZi5pc1NhZmVSZXF1ZXN0SGVhZGVyKGtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFyYW1zLmhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZVtqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlKVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChwYXJhbXMuYXV0aCkge1xuICAgICAgICAvL2Jhc2ljIGF1dGhcbiAgICAgICAgdGhpcy5zZXRIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArIG5ldyBCdWZmZXIocGFyYW1zLmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IG5ldyBSZXNwb25zZTtcbiAgICByZXMub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJyk7XG4gICAgfSk7XG4gICAgXG4gICAgcmVzLm9uKCdyZWFkeScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdyZXNwb25zZScsIHJlcyk7XG4gICAgfSk7XG4gICAgXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzLmhhbmRsZSh4aHIpO1xuICAgIH07XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZSA9IG5ldyBTdHJlYW07XG5cblJlcXVlc3QucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgfVxufTtcblxuUmVxdWVzdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocykge1xuICAgIHRoaXMuYm9keS53cml0ZShzKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAocykge1xuICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScpO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKHMpIHtcbiAgICBpZiAocyAhPT0gdW5kZWZpbmVkKSB0aGlzLmJvZHkud3JpdGUocyk7XG4gICAgdGhpcy5ib2R5LmVuZCgpXG4gICAgdGhpcy54aHIuc2VuZCh0aGlzLmJvZHkuZ2V0Qm9keSgpKTtcbn07XG5cbi8vIFRha2VuIGZyb20gaHR0cDovL2R4ci5tb3ppbGxhLm9yZy9tb3ppbGxhL21vemlsbGEtY2VudHJhbC9jb250ZW50L2Jhc2Uvc3JjL25zWE1MSHR0cFJlcXVlc3QuY3BwLmh0bWxcblJlcXVlc3QudW5zYWZlSGVhZGVycyA9IFtcbiAgICBcImFjY2VwdC1jaGFyc2V0XCIsXG4gICAgXCJhY2NlcHQtZW5jb2RpbmdcIixcbiAgICBcImFjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVyc1wiLFxuICAgIFwiYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2RcIixcbiAgICBcImNvbm5lY3Rpb25cIixcbiAgICBcImNvbnRlbnQtbGVuZ3RoXCIsXG4gICAgXCJjb29raWVcIixcbiAgICBcImNvb2tpZTJcIixcbiAgICBcImNvbnRlbnQtdHJhbnNmZXItZW5jb2RpbmdcIixcbiAgICBcImRhdGVcIixcbiAgICBcImV4cGVjdFwiLFxuICAgIFwiaG9zdFwiLFxuICAgIFwia2VlcC1hbGl2ZVwiLFxuICAgIFwib3JpZ2luXCIsXG4gICAgXCJyZWZlcmVyXCIsXG4gICAgXCJ0ZVwiLFxuICAgIFwidHJhaWxlclwiLFxuICAgIFwidHJhbnNmZXItZW5jb2RpbmdcIixcbiAgICBcInVwZ3JhZGVcIixcbiAgICBcInVzZXItYWdlbnRcIixcbiAgICBcInZpYVwiXG5dO1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5pc1NhZmVSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24gKGhlYWRlck5hbWUpIHtcbiAgICBpZiAoIWhlYWRlck5hbWUpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gaW5kZXhPZihSZXF1ZXN0LnVuc2FmZUhlYWRlcnMsIGhlYWRlck5hbWUudG9Mb3dlckNhc2UoKSkgPT09IC0xO1xufTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICByZXR1cm4ga2V5cztcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBpbmRleE9mID0gZnVuY3Rpb24gKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHJldHVybiB4cy5pbmRleE9mKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcblxufSkoKSIsInZhciBuZXQgPSByZXF1aXJlKCduZXQnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBsdHggPSByZXF1aXJlKCdsdHgnKTtcbnZhciBTdHJlYW1QYXJzZXIgPSByZXF1aXJlKCcuL3N0cmVhbV9wYXJzZXInKTtcbnZhciBzdGFydHRscyA9IHJlcXVpcmUoJy4uL3N0YXJ0dGxzJyk7XG5cbnZhciBOU19YTVBQX1RMUyA9IGV4cG9ydHMuTlNfWE1QUF9UTFMgPSAndXJuOmlldGY6cGFyYW1zOnhtbDpuczp4bXBwLXRscyc7XG52YXIgTlNfU1RSRUFNID0gZXhwb3J0cy5OU19TVFJFQU0gPSAnaHR0cDovL2V0aGVyeC5qYWJiZXIub3JnL3N0cmVhbXMnO1xudmFyIE5TX1hNUFBfU1RSRUFNUyA9ICd1cm46aWV0ZjpwYXJhbXM6eG1sOm5zOnhtcHAtc3RyZWFtcyc7XG5cbi8qKlxuIEJhc2UgY2xhc3MgZm9yIGNvbm5lY3Rpb24tYmFzZWQgc3RyZWFtcyAoVENQKS5cblxuIFRoZSBzb2NrZXQgcGFyYW1ldGVyIGlzIG9wdGlvbmFsIGZvciBpbmNvbWluZyBjb25uZWN0aW9ucy5cbiovXG5cbnZhciBNQVhfUkVDT05ORUNUX0RFTEFZID0gMzAgKiAxMDAwO1xuXG5cbmZ1bmN0aW9uIENvbm5lY3Rpb24ob3B0cykge1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5zdHJlYW1BdHRycyA9IChvcHRzICYmIG9wdHMuc3RyZWFtQXR0cnMpIHx8IHt9O1xuICAgIHRoaXMueG1sbnMgPSAob3B0cyAmJiBvcHRzLnhtbG5zKSB8fCB7fTtcbiAgICB0aGlzLnhtbG5zLnN0cmVhbSA9IE5TX1NUUkVBTTtcblxuICAgIHRoaXMuc29ja2V0ID0gKG9wdHMgJiYgb3B0cy5zb2NrZXQpIHx8IG5ldyBuZXQuU29ja2V0KCk7XG4gICAgdGhpcy5yZWNvbm5lY3REZWxheSA9IDA7XG5cbiAgICB0aGlzLnNldHVwU3RyZWFtKCk7XG4gICAgaWYgKHRoaXMuc29ja2V0LnJlYWRhYmxlKVxuXHR0aGlzLnN0YXJ0UGFyc2VyKCk7XG4gICAgZWxzZSB7XG5cdHZhciB0aGF0ID0gdGhpcztcblx0dGhpcy5zb2NrZXQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbigpIHtcblx0ICAgIHRoYXQuc3RhcnRQYXJzZXIoKTtcblx0ICAgIHRoYXQuZW1pdCgnY29ubmVjdCcpO1xuXHR9KTtcbiAgICB9XG5cbiAgICB0aGlzLm1peGlucyA9IFtdO1xufVxuXG51dGlsLmluaGVyaXRzKENvbm5lY3Rpb24sIEV2ZW50RW1pdHRlcik7XG5leHBvcnRzLkNvbm5lY3Rpb24gPSBDb25uZWN0aW9uO1xuXG4vLyBEZWZhdWx0c1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuYWxsb3dUTFMgPSB0cnVlO1xuXG4vKipcbiBVc2VkIGJ5IGJvdGggdGhlIGNvbnN0cnVjdG9yIGFuZCBieSByZWluaXRpYWxpemF0aW9uIGluIHNldFNlY3VyZSgpLlxuKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnNldHVwU3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5zb2NrZXQuYWRkTGlzdGVuZXIoJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHNlbGYub25EYXRhKGRhdGEpO1xuICAgIH0pO1xuICAgIHRoaXMuc29ja2V0LmFkZExpc3RlbmVyKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5vbkVuZCgpO1xuICAgIH0pO1xuICAgIHRoaXMuc29ja2V0LmFkZExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uKCkge1xuXHQvKiB1bmhhbmRsZWQgZXJyb3JzIG1heSB0aHJvdyB1cCBpbiBub2RlLCBwcmV2ZW50aW5nIGEgcmVjb25uZWN0ICovXG4gICAgICAgIHNlbGYub25FbmQoKTtcbiAgICB9KTtcbiAgICB0aGlzLnNvY2tldC5hZGRMaXN0ZW5lcignY2xvc2UnLCBmdW5jdGlvbigpIHtcblx0c2VsZi5vbkNsb3NlKCk7XG4gICAgfSk7XG4gICAgdmFyIHByb3h5RXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBzZWxmLnNvY2tldC5hZGRMaXN0ZW5lcihldmVudCwgZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdCAgICBhcmdzLnVuc2hpZnQoZXZlbnQpO1xuXHQgICAgc2VsZi5lbWl0LmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHByb3h5RXZlbnQoJ2RhdGEnKTsgIC8vIGxldCB0aGVtIHNuaWZmIHVucGFyc2VkIFhNTFxuICAgIHByb3h5RXZlbnQoJ2RyYWluJyk7XG4gICAgLy9wcm94eUV2ZW50KCdjbG9zZScpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBvcHRpbWl6ZWQgZm9yIGNvbnRpbnVvdXMgVENQIHN0cmVhbXMuIElmIHlvdXIgXCJzb2NrZXRcIlxuICAgICAqIGFjdHVhbGx5IHRyYW5zcG9ydHMgZnJhbWVzIChXZWJTb2NrZXRzKSBhbmQgeW91IGNhbid0IGhhdmVcbiAgICAgKiBzdGFuemFzIHNwbGl0IGFjcm9zcyB0aG9zZSwgdXNlOlxuICAgICAqICAgICBjYihlbC50b1N0cmluZygpKTtcbiAgICAgKi9cbiAgICBpZiAoIXRoaXMuc29ja2V0LnNlcmlhbGl6ZVN0YW56YSkge1xuICAgICAgICB0aGlzLnNvY2tldC5zZXJpYWxpemVTdGFuemEgPSBmdW5jdGlvbihlbCwgY2IpIHtcbiAgICAgICAgICAgIC8vIENvbnRpbnVvdXNseSB3cml0ZSBvdXRcbiAgICAgICAgICAgIGVsLndyaXRlKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICBjYihzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbn07XG5cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zb2NrZXQucGF1c2UpXG5cdHRoaXMuc29ja2V0LnBhdXNlKCk7XG59O1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zb2NrZXQucmVzdW1lKVxuXHR0aGlzLnNvY2tldC5yZXN1bWUoKTtcbn07XG5cbi8qKiBDbGltYnMgdGhlIHN0YW56YSB1cCBpZiBhIGNoaWxkIHdhcyBwYXNzZWQsXG4gICAgYnV0IHlvdSBjYW4gc2VuZCBzdHJpbmdzIGFuZCBidWZmZXJzIHRvby5cblxuICAgIFJldHVybnMgd2hldGhlciB0aGUgc29ja2V0IGZsdXNoZWQgZGF0YS5cbiovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oc3RhbnphKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBmbHVzaGVkID0gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuc29ja2V0KSB7XG4gICAgICAgIHJldHVybjsgLy8gRG9oIVxuICAgIH1cbiAgICBpZiAoIXRoaXMuc29ja2V0LndyaXRhYmxlKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmVuZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHN0YW56YS5yb290KSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMucm1YbWxucyhzdGFuemEucm9vdCgpKTtcbiAgICAgICAgdGhpcy5zb2NrZXQuc2VyaWFsaXplU3RhbnphKGVsLCBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICBmbHVzaGVkID0gc2VsZi5zb2NrZXQud3JpdGUocyk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZsdXNoZWQgPSB0aGlzLnNvY2tldC53cml0ZShzdGFuemEpO1xuICAgIH1cbiAgICByZXR1cm4gZmx1c2hlZDtcbn07XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnN0YXJ0UGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMucGFyc2VyID0gbmV3IFN0cmVhbVBhcnNlci5TdHJlYW1QYXJzZXIodGhpcy5tYXhTdGFuemFTaXplKTtcblxuICAgIHRoaXMucGFyc2VyLmFkZExpc3RlbmVyKCdzdHJlYW1TdGFydCcsIGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgICAgIC8qIFdlIG5lZWQgdGhvc2UgeG1sbnMgb2Z0ZW4sIHN0b3JlIHRoZW0gZXh0cmEgKi9cbiAgICAgICAgc2VsZi5zdHJlYW1Oc0F0dHJzID0ge307XG4gICAgICAgIGZvcih2YXIgayBpbiBhdHRycykge1xuICAgICAgICBpZiAoayA9PSAneG1sbnMnIHx8XG4gICAgICAgICAgICBrLnN1YnN0cigwLCA2KSA9PSAneG1sbnM6JylcbiAgICAgICAgICAgICAgICBzZWxmLnN0cmVhbU5zQXR0cnNba10gPSBhdHRyc1trXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIE5vdGlmeSBpbiBjYXNlIHdlIGRvbid0IHdhaXQgZm9yIDxzdHJlYW06ZmVhdHVyZXMvPlxuICAgICAgICAgICAoQ29tcG9uZW50IG9yIG5vbi0xLjAgc3RyZWFtcylcbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuZW1pdCgnc3RyZWFtU3RhcnQnLCBhdHRycyk7XG4gICAgfSk7XG4gICAgdGhpcy5wYXJzZXIuYWRkTGlzdGVuZXIoJ3N0YW56YScsIGZ1bmN0aW9uKHN0YW56YSkge1xuICAgICAgICBzZWxmLm9uU3RhbnphKHNlbGYuYWRkU3RyZWFtTnMoc3RhbnphKSk7XG4gICAgfSk7XG4gICAgdGhpcy5wYXJzZXIuYWRkTGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmVycm9yKGUuY29uZGl0aW9uIHx8ICdpbnRlcm5hbC1zZXJ2ZXItZXJyb3InLCBlLm1lc3NhZ2UpO1xuICAgIH0pO1xuICAgIHRoaXMucGFyc2VyLmFkZExpc3RlbmVyKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5zdG9wUGFyc2VyKCk7XG4gICAgICAgIHNlbGYuZW5kKCk7XG4gICAgfSk7XG59O1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zdG9wUGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gICAgLyogTm8gbW9yZSBldmVudHMsIHBsZWFzZSAobWF5IGhhcHBlbiBob3dldmVyKSAqL1xuICAgIGlmKHRoaXMucGFyc2VyKSB7XG4gICAgICAgIC8qIEdldCBHQydlZCAqL1xuICAgICAgICBkZWxldGUgdGhpcy5wYXJzZXI7XG4gICAgfVxufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuc3RhcnRTdHJlYW0gPSBmdW5jdGlvbigpIHtcbiAgICAvKiByZXNldCByZWNvbm5lY3QgZGVsYXkgKi9cbiAgICB0aGlzLnJlY29ubmVjdERlbGF5ID0gMDtcbiAgICBcbiAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICBmb3IodmFyIGsgaW4gdGhpcy54bWxucykge1xuICAgICAgICBpZiAodGhpcy54bWxucy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgaWYgKCFrKVxuICAgICAgICAgICAgICAgIGF0dHJzLnhtbG5zID0gdGhpcy54bWxuc1trXTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhdHRyc1sneG1sbnM6JyArIGtdID0gdGhpcy54bWxuc1trXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IoayBpbiB0aGlzLnN0cmVhbUF0dHJzKSB7XG5cdGlmICh0aGlzLnN0cmVhbUF0dHJzLmhhc093blByb3BlcnR5KGspKVxuXHQgICAgYXR0cnNba10gPSB0aGlzLnN0cmVhbUF0dHJzW2tdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0cmVhbVRvKSB7IC8vIGluIGNhc2Ugb2YgYSBjb21wb25lbnQgY29ubmVjdGluZ1xuICAgICAgICBhdHRycy50byA9IHRoaXMuc3RyZWFtVG87XG4gICAgfVxuXG4gICAgdmFyIGVsID0gbmV3IGx0eC5FbGVtZW50KCdzdHJlYW06c3RyZWFtJywgYXR0cnMpO1xuICAgIC8vIG1ha2UgaXQgbm9uLWVtcHR5IHRvIGN1dCB0aGUgY2xvc2luZyB0YWdcbiAgICBlbC50KCcgJyk7XG4gICAgdmFyIHMgPSBlbC50b1N0cmluZygpO1xuICAgIHRoaXMuc2VuZChzLnN1YnN0cigwLCBzLmluZGV4T2YoJyA8L3N0cmVhbTpzdHJlYW0+JykpKTtcblxuICAgIHRoaXMuc3RyZWFtT3BlbmVkID0gdHJ1ZTtcbn07XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAodGhpcy5wYXJzZXIpXG4gICAgICAgIHRoaXMucGFyc2VyLndyaXRlKGRhdGEpO1xufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0U2VjdXJlID0gZnVuY3Rpb24oY3JlZGVudGlhbHMsIGlzU2VydmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gUmVtb3ZlIG9sZCBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLnNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKTtcbiAgICAvLyByZXRhaW4gc29ja2V0ICdlbmQnIGxpc3RlbmVycyBiZWNhdXNlIHNzbCBsYXllciBkb2Vzbid0IHN1cHBvcnQgaXRcbiAgICB0aGlzLnNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RyYWluJyk7XG4gICAgdGhpcy5zb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpO1xuICAgIC8vIHJlbW92ZSBpZGxlX3RpbWVvdXRcbiAgICBpZiAodGhpcy5zb2NrZXQuY2xlYXJUaW1lcilcblx0dGhpcy5zb2NrZXQuY2xlYXJUaW1lcigpO1xuXG4gICAgdGhpcy5zdG9wUGFyc2VyKCk7XG4gICAgdmFyIGN0ID0gc3RhcnR0bHModGhpcy5zb2NrZXQsIGNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMsIGlzU2VydmVyLCBmdW5jdGlvbigpIHtcblx0c2VsZi5pc1NlY3VyZSA9IHRydWU7XG5cdHNlbGYuc3RhcnRQYXJzZXIoKTtcblx0aWYgKCFpc1NlcnZlcilcblx0ICAgIC8vIENsaWVudHMgc3RhcnQgPHN0cmVhbTpzdHJlYW0+LCBzZXJ2ZXJzIHJlcGx5XG5cdCAgICBzZWxmLnN0YXJ0U3RyZWFtKCk7XG4gICAgfSk7XG4gICAgY3Qub24oJ2Nsb3NlJywgZnVuY3Rpb24oKSB7XG5cdHNlbGYub25DbG9zZSgpO1xuXHRzZWxmLmlzU2VjdXJlID0gZmFsc2U7XG4gICAgfSk7XG5cbiAgICAvLyBUaGUgc29ja2V0IGlzIG5vdyB0aGUgY2xlYXJ0ZXh0IHN0cmVhbVxuICAgIHRoaXMuc29ja2V0ID0gY3Q7XG5cbiAgICAvLyBBdHRhY2ggbmV3IGxpc3RlbmVycyBvbiB0aGUgY2xlYXJ0ZXh0IHN0cmVhbVxuICAgIHRoaXMuc2V0dXBTdHJlYW0oKTtcbn07XG5cbi8qKlxuICogVGhpcyBpcyBub3QgYW4gZXZlbnQgbGlzdGVuZXIsIGJ1dCB0YWtlcyBjYXJlIG9mIHRoZSBUTFMgaGFuZHNoYWtlXG4gKiBiZWZvcmUgJ3N0YW56YScgZXZlbnRzIGFyZSBlbWl0dGVkIHRvIHRoZSBkZXJpdmVkIGNsYXNzZXMuXG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLm9uU3RhbnphID0gZnVuY3Rpb24oc3RhbnphKSB7XG4gICAgaWYgKHN0YW56YS5pcygnZXJyb3InLCBOU19TVFJFQU0pKSB7XG4gICAgICAgIC8qIFRPRE86IGV4dHJhY3QgZXJyb3IgdGV4dCAqL1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgc3RhbnphKTtcbiAgICB9IGVsc2UgaWYgKHN0YW56YS5pcygnZmVhdHVyZXMnLCBOU19TVFJFQU0pICYmXG4gICAgICAgICAgICAgICB0aGlzLmFsbG93VExTICYmXG5cdCAgICAgICAhdGhpcy5pc1NlY3VyZSAmJlxuICAgICAgICAgICAgICAgc3RhbnphLmdldENoaWxkKCdzdGFydHRscycsIE5TX1hNUFBfVExTKSkge1xuICAgICAgICAvKiBTaWduYWwgd2lsbGluZ25lc3MgdG8gcGVyZm9ybSBUTFMgaGFuZHNoYWtlICovXG4gICAgICAgIHRoaXMuc2VuZChuZXcgbHR4LkVsZW1lbnQoJ3N0YXJ0dGxzJywgeyB4bWxuczogTlNfWE1QUF9UTFMgfSkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hbGxvd1RMUyAmJlxuICAgICAgICAgICAgICAgc3RhbnphLmlzKCdwcm9jZWVkJywgTlNfWE1QUF9UTFMpKSB7XG4gICAgICAgIC8qIFNlcnZlciBpcyB3YWl0aW5nIGZvciBUTFMgaGFuZHNoYWtlICovXG4gICAgICAgIHRoaXMuc2V0U2VjdXJlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbWl0KCdzdGFuemEnLCBzdGFuemEpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQWRkIHN0cmVhbSB4bWxucyB0byBhIHN0YW56YVxuICpcbiAqIERvZXMgbm90IGFkZCBvdXIgZGVmYXVsdCB4bWxucyBhcyBpdCBpcyBkaWZmZXJlbnQgZm9yXG4gKiBDMlMvUzJTL0NvbXBvbmVudCBjb25uZWN0aW9ucy5cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtTnMgPSBmdW5jdGlvbihzdGFuemEpIHtcbiAgICBmb3IodmFyIGF0dHIgaW4gdGhpcy5zdHJlYW1Oc0F0dHJzKSB7XG4gICAgICAgIGlmICghc3RhbnphLmF0dHJzW2F0dHJdICYmXG5cdCAgICAhKGF0dHIgPT09ICd4bWxucycgJiZcblx0ICAgICAgdGhpcy5zdHJlYW1Oc0F0dHJzW2F0dHJdID09PSB0aGlzLnhtbG5zWycnXSkpXG4gICAgICAgICAgICBzdGFuemEuYXR0cnNbYXR0cl0gPSB0aGlzLnN0cmVhbU5zQXR0cnNbYXR0cl07XG4gICAgfVxuICAgIHJldHVybiBzdGFuemE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzdXBlcmZsdW91cyB4bWxucyB0aGF0IHdlcmUgYWxlYWR5IGRlY2xhcmVkIGluXG4gKiBvdXIgPHN0cmVhbTpzdHJlYW0+XG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnJtWG1sbnMgPSBmdW5jdGlvbihzdGFuemEpIHtcbiAgICBmb3IodmFyIHByZWZpeCBpbiB0aGlzLnhtbG5zKSB7XG4gICAgICAgIHZhciBhdHRyID0gcHJlZml4ID8gJ3htbG5zOicrcHJlZml4IDogJ3htbG5zJztcbiAgICAgICAgaWYgKHN0YW56YS5hdHRyc1thdHRyXSA9PSB0aGlzLnhtbG5zW3ByZWZpeF0pXG4gICAgICAgICAgICBkZWxldGUgc3RhbnphLmF0dHJzW2F0dHJdO1xuICAgIH1cbiAgICByZXR1cm4gc3RhbnphO1xufTtcblxuXG4vKipcbiAqIENvbm5lY3Rpb24gaGFzIGJlZW4gZW5kZWQgYnkgcmVtb3RlLCB3ZSB3aWxsIG5vdCBnZXQgYW55IGluY29taW5nXG4gKiAnZGF0YScgZXZlbnRzLiBBbHRlcm5hdGl2ZWx5LCB1c2VkIGZvciAnZXJyb3InIGV2ZW50LlxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3RvcFBhcnNlcigpO1xuICAgIGlmICh0aGlzLnNvY2tldClcbiAgICAgICAgdGhpcy5zb2NrZXQuZW5kKCk7XG59O1xuXG4vKipcbiAqIFhNUFAtc3R5bGUgZW5kIGNvbm5lY3Rpb24gZm9yIHVzZXJcbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc29ja2V0LndyaXRhYmxlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0cmVhbU9wZW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQud3JpdGUoJzwvc3RyZWFtOnN0cmVhbT4nKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0cmVhbU9wZW5lZDtcblx0ICAgIC8qIHdhaXQgZm9yIGJlaW5nIGNhbGxlZCBhZ2FpbiB1cG9uICdlbmQnIGZyb20gb3RoZXIgc2lkZSAqL1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnNvY2tldClcblx0LyogQSByZWNvbm5lY3QgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHNjaGVkdWxlZCAqL1xuXHRyZXR1cm47XG5cbiAgICBkZWxldGUgdGhpcy5zb2NrZXQ7XG4gICAgaWYgKHRoaXMucmVjb25uZWN0KSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0ICAgIHNlbGYuc29ja2V0ID0gbmV3IG5ldC5TdHJlYW0oKTtcblx0ICAgIHNlbGYuc2V0dXBTdHJlYW0oKTtcblx0ICAgIHNlbGYucmVjb25uZWN0KCk7XG5cdH0sIHRoaXMucmVjb25uZWN0RGVsYXkpO1xuXHRjb25zb2xlLmxvZyhcIlJlY29ubmVjdCBpblwiLCB0aGlzLnJlY29ubmVjdERlbGF5KTtcblx0dGhpcy5yZWNvbm5lY3REZWxheSArPSBNYXRoLmNlaWwoTWF0aC5yYW5kb20oKSAqIDIwMDApO1xuXHRpZiAodGhpcy5yZWNvbm5lY3REZWxheSA+IE1BWF9SRUNPTk5FQ1RfREVMQVkpXG5cdCAgICB0aGlzLnJlY29ubmVjdERlbGF5ID0gTUFYX1JFQ09OTkVDVF9ERUxBWTtcbiAgICB9IGVsc2Uge1xuXHR0aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFbmQgY29ubmVjdGlvbiB3aXRoIHN0cmVhbSBlcnJvci5cbiAqIEVtaXRzICdlcnJvcicgZXZlbnQgdG9vLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb25kaXRpb24gWE1QUCBlcnJvciBjb25kaXRpb24sIHNlZSBSRkMzOTIwIDQuNy4zLiBEZWZpbmVkIENvbmRpdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IE9wdGlvbmFsIGVycm9yIG1lc3NhZ2VcbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKG1lc3NhZ2UpKTtcblxuICAgIGlmICghdGhpcy5zb2NrZXQgfHwgIXRoaXMuc29ja2V0LndyaXRhYmxlKVxuICAgICAgICByZXR1cm47XG5cbiAgICBpZighdGhpcy5zdHJlYW1PcGVuZWQpXG4gICAgICAgIHRoaXMuc3RhcnRTdHJlYW0oKTsgLyogUkZDIDM5MjAsIDQuNy4xIHN0cmVhbS1sZXZlbCBlcnJvcnMgcnVsZXMgKi9cblxuICAgIHZhciBlID0gbmV3IGx0eC5FbGVtZW50KCdzdHJlYW06ZXJyb3InKTtcbiAgICBlLmMoY29uZGl0aW9uLCB7IHhtbG5zOiBOU19YTVBQX1NUUkVBTVMgfSk7XG4gICAgaWYgKG1lc3NhZ2UpXG4gICAgICAgIGUuYygndGV4dCcsIHsgeG1sbnM6IE5TX1hNUFBfU1RSRUFNUyxcbiAgICAgICAgICAgICAgICAgICAgICAneG1sOmxhbmcnOiAnZW4nIH0pLlxuICAgICAgICB0KG1lc3NhZ2UpO1xuXG4gICAgdGhpcy5zZW5kKGUpO1xuICAgIHRoaXMuZW5kKCk7XG59O1xuIiwiKGZ1bmN0aW9uKCl7dmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBTZXNzaW9uID0gcmVxdWlyZSgnLi9zZXNzaW9uJykuU2Vzc2lvbjtcbnZhciBDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uJyk7XG52YXIgSklEID0gcmVxdWlyZSgnLi9qaWQnKS5KSUQ7XG52YXIgbHR4ID0gcmVxdWlyZSgnbHR4Jyk7XG52YXIgc2FzbCA9IHJlcXVpcmUoJy4vc2FzbCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG50cnkge1xuICAgIHZhciBTUlYgPSByZXF1aXJlKCcuL3NydicpO1xufSBjYXRjaCAoZSkgeyB9XG5cbnZhciBOU19DTElFTlQgPSAnamFiYmVyOmNsaWVudCc7XG52YXIgTlNfUkVHSVNURVIgPSAnamFiYmVyOmlxOnJlZ2lzdGVyJztcbnZhciBOU19YTVBQX1NBU0wgPSAndXJuOmlldGY6cGFyYW1zOnhtbDpuczp4bXBwLXNhc2wnO1xudmFyIE5TX1hNUFBfQklORCA9ICd1cm46aWV0ZjpwYXJhbXM6eG1sOm5zOnhtcHAtYmluZCc7XG52YXIgTlNfWE1QUF9TRVNTSU9OID0gJ3VybjppZXRmOnBhcmFtczp4bWw6bnM6eG1wcC1zZXNzaW9uJztcblxudmFyIFNUQVRFX1BSRUFVVEggPSAwLFxuICAgIFNUQVRFX0FVVEggPSAxLFxuICAgIFNUQVRFX0FVVEhFRCA9IDIsXG4gICAgU1RBVEVfQklORCA9IDMsXG4gICAgU1RBVEVfU0VTU0lPTiA9IDQsXG4gICAgU1RBVEVfT05MSU5FID0gNTtcbnZhciBJUUlEX1NFU1NJT04gPSAnc2VzcycsXG4gICAgSVFJRF9CSU5EID0gJ2JpbmQnO1xuXG4vKipcbiAqIHBhcmFtcyBvYmplY3Q6XG4gKiAgIGppZDogU3RyaW5nIChyZXF1aXJlZClcbiAqICAgcGFzc3dvcmQ6IFN0cmluZyAocmVxdWlyZWQpXG4gKiAgIGhvc3Q6IFN0cmluZyAob3B0aW9uYWwpXG4gKiAgIHBvcnQ6IE51bWJlciAob3B0aW9uYWwpXG4gKiAgIHJlY29ubmVjdDogQm9vbGVhbiAob3B0aW9uYWwpXG4gKiAgIHJlZ2lzdGVyOiBCb29sZWFuIChvcHRpb24pIC0gcmVnaXN0ZXIgYWNjb3VudCBiZWZvcmUgYXV0aGVudGljYXRpb25cbiAqICAgbGVnYWN5U1NMOiBCb29sZWFuIChvcHRpb25hbCkgLSBjb25uZWN0IHRvIHRoZSBsZWdhY3kgU1NMIHBvcnQsIHJlcXVpcmVzIGF0IGxlYXN0IHRoZSBob3N0IHRvIGJlIHNwZWNpZmllZFxuICogICBjcmVkZW50aWFsczogRGljdGlvbmFyeSAob3B0aW9uYWwpIC0gVExTIG9yIFNTTCBrZXkgYW5kIGNlcnRpZmljYXRlIGNyZWRlbnRpYWxzXG4gKiAgIGFjdEFzOiBTdHJpbmcgKG9wdGlvbmFsKSAtIGlmIGFkbWluIHVzZXIgYWN0IG9uIGJlaGFsZiBvZiBhbm90aGVyIHVzZXIgKGp1c3QgdXNlcilcbiAqXG4gKiBFeGFtcGxlczpcbiAqICAgdmFyIGNsID0gbmV3IHhtcHAuQ2xpZW50KHtcbiAqICAgICAgIGppZDogXCJtZUBleGFtcGxlLmNvbVwiLFxuICogICAgICAgcGFzc3dvcmQ6IFwic2VjcmV0XCJcbiAqICAgfSk7XG4gKiAgIHZhciBhY2Vib28gPSBuZXcgeG1wcC5DbGllbnQoe1xuICogICAgICAgamlkOiAnLScgKyBmYlVJRCArICdAY2hhdC5mYWNlYm9vay5jb20nLFxuICogICAgICAgYXBpX2tleTogJzU0MzIxJywgLy8gYXBpIGtleSBvZiB5b3VyIGZhY2Vib29rIGFwcFxuICogICAgICAgYWNjZXNzX3Rva2VuOiAnYWJjZGVmZycsIC8vIHVzZXIgYWNjZXNzIHRva2VuXG4gKiAgICAgICBob3N0OiAnY2hhdC5mYWNlYm9vay5jb20nXG4gKiAgIH0pO1xuICogICB2YXIgZ3RhbGsgPSBuZXcgeG1wcC5DbGllbnQoe1xuICogICAgICAgamlkOiAnbWVAZ21haWwuY29tJyxcbiAqICAgICAgIG9hdXRoMl90b2tlbjogJ3h4eHgueHh4eHh4eHh4eHgnLCAvLyBmcm9tIE9BdXRoMlxuICogICAgICAgb2F1dGgyX2F1dGg6ICdodHRwOi8vd3d3Lmdvb2dsZS5jb20vdGFsay9wcm90b2NvbC9hdXRoJyxcbiAqICAgICAgIGhvc3Q6ICd0YWxrLmdvb2dsZS5jb20nXG4gKiAgIH0pO1xuICpcbiAqIEV4YW1wbGUgU0FTTCBFWFRFUk5BTDpcbiAqIFxuICogdmFyIG15Q3JlZGVudGlhbHMgPSB7IFxuICogICAvLyBUaGVzZSBhcmUgbmVjZXNzYXJ5IG9ubHkgaWYgdXNpbmcgdGhlIGNsaWVudCBjZXJ0aWZpY2F0ZSBhdXRoZW50aWNhdGlvblxuICogICBrZXk6IGZzLnJlYWRGaWxlU3luYygna2V5LnBlbScpLFxuICogICBjZXJ0OiBmcy5yZWFkRmlsZVN5bmMoJ2NlcnQucGVtJyksXG4gKiAgIC8vIHBhc3NwaHJhc2U6ICdvcHRpb25hbCdcbiAqIH07XG4gKiB2YXIgY2wgPSBuZXcgeG1wcENsaWVudCh7amlkOiBcIm1lQGV4YW1wbGUuY29tXCIsIGNyZWRlbnRpYWxzOiBteUNyZWRlbnRpYWxzIH0pOyBcbiBcbiAqL1xuZnVuY3Rpb24gQ2xpZW50KG9wdHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBvcHRzLnhtbG5zID0gTlNfQ0xJRU5UO1xuICAgIHNlbGYuc3RhdGUgPSBTVEFURV9QUkVBVVRIO1xuICAgIGRlbGV0ZSBzZWxmLmRpZF9iaW5kO1xuICAgIGRlbGV0ZSBzZWxmLmRpZF9zZXNzaW9uO1xuXG4gICAgU2Vzc2lvbi5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgaWYgKG9wdHMuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhpcy5wcmVmZXJyZWRTYXNsTWVjaGFuaXNtID0gJ0VYVEVSTkFMJztcbiAgICAgICAgdGhpcy5hdmFpbGFibGVTYXNsTWVjaGFuaXNtcyA9IFsgc2FzbC5FeHRlcm5hbCBdO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QUkVBVVRIO1xuICAgIHRoaXMuYWRkTGlzdGVuZXIoJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLnN0YXRlID0gU1RBVEVfUFJFQVVUSDtcbiAgICAgICAgc2VsZi5lbWl0KCdvZmZsaW5lJyk7XG4gICAgfSk7XG4gICAgdGhpcy5vbignY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5zdGF0ZSA9IFNUQVRFX1BSRUFVVEg7XG4gICAgfSk7XG59XG5cbnV0aWwuaW5oZXJpdHMoQ2xpZW50LCBTZXNzaW9uKTtcbmV4cG9ydHMuQ2xpZW50ID0gQ2xpZW50O1xuXG5DbGllbnQucHJvdG90eXBlLm9uU3RhbnphID0gZnVuY3Rpb24oc3RhbnphKSB7XG4gICAgLyogQWN0dWFsbHksIHdlIHNob3VsZG4ndCB3YWl0IGZvciA8c3RyZWFtOmZlYXR1cmVzLz4gaWZcbiAgICAgICB0aGlzLnN0cmVhbUF0dHJzLnZlcnNpb24gaXMgbWlzc2luZywgYnV0IHdobyB1c2VzIHByZS1YTVBQLTEuMFxuICAgICAgIHRoZXNlIGRheXMgYW55d2F5PyAqL1xuICAgIGlmICh0aGlzLnN0YXRlICE9IFNUQVRFX09OTElORSAmJlxuICAgICAgICBzdGFuemEuaXMoJ2ZlYXR1cmVzJywgQ29ubmVjdGlvbi5OU19TVFJFQU0pKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtRmVhdHVyZXMgPSBzdGFuemE7XG4gICAgICAgIHRoaXMudXNlRmVhdHVyZXMoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT0gU1RBVEVfQVVUSCkge1xuICAgICAgICBpZiAoc3RhbnphLmlzKCdjaGFsbGVuZ2UnLCBOU19YTVBQX1NBU0wpKSB7XG4gICAgICAgICAgICB2YXIgY2hhbGxlbmdlTXNnID0gZGVjb2RlNjQoc3RhbnphLmdldFRleHQoKSk7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VNc2cgPSBlbmNvZGU2NCh0aGlzLm1lY2guY2hhbGxlbmdlKGNoYWxsZW5nZU1zZykpO1xuICAgICAgICAgICAgdGhpcy5zZW5kKG5ldyBsdHguRWxlbWVudCgncmVzcG9uc2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHhtbG5zOiBOU19YTVBQX1NBU0xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudChyZXNwb25zZU1zZykpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YW56YS5pcygnc3VjY2VzcycsIE5TX1hNUFBfU0FTTCkpIHtcbiAgICAgICAgICAgIHRoaXMubWVjaCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfQVVUSEVEO1xuXHQgICAgaWYgKHRoaXMuY29ubmVjdGlvbi5zdGFydFBhcnNlcilcblx0XHR0aGlzLmNvbm5lY3Rpb24uc3RhcnRQYXJzZXIoKTtcblx0ICAgIGlmICh0aGlzLmNvbm5lY3Rpb24uc3RhcnRTdHJlYW0pXG5cdFx0dGhpcy5jb25uZWN0aW9uLnN0YXJ0U3RyZWFtKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgJ1hNUFAgYXV0aGVudGljYXRpb24gZmFpbHVyZScpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX0JJTkQgJiZcbiAgICAgICAgICAgICAgIHN0YW56YS5pcygnaXEnKSAmJlxuICAgICAgICAgICAgICAgc3RhbnphLmF0dHJzLmlkID09IElRSURfQklORCkge1xuICAgICAgICBpZiAoc3RhbnphLmF0dHJzLnR5cGUgPT0gJ3Jlc3VsdCcpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9BVVRIRUQ7XG4gICAgICAgICAgICB0aGlzLmRpZF9iaW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgdmFyIGJpbmRFbCA9IHN0YW56YS5nZXRDaGlsZCgnYmluZCcsIE5TX1hNUFBfQklORCk7XG4gICAgICAgICAgICBpZiAoYmluZEVsICYmIGJpbmRFbC5nZXRDaGlsZCgnamlkJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmppZCA9IG5ldyBKSUQoYmluZEVsLmdldENoaWxkKCdqaWQnKS5nZXRUZXh0KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBubyBzdHJlYW0gcmVzdGFydCwgYnV0IG5leHQgZmVhdHVyZSAqL1xuICAgICAgICAgICAgdGhpcy51c2VGZWF0dXJlcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsICdDYW5ub3QgYmluZCByZXNvdXJjZScpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX1NFU1NJT04gJiZcbiAgICAgICAgICAgICAgIHN0YW56YS5pcygnaXEnKSAmJlxuICAgICAgICAgICAgICAgc3RhbnphLmF0dHJzLmlkID09IElRSURfU0VTU0lPTikge1xuICAgICAgICBpZiAoc3RhbnphLmF0dHJzLnR5cGUgPT0gJ3Jlc3VsdCcpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9BVVRIRUQ7XG4gICAgICAgICAgICB0aGlzLmRpZF9zZXNzaW9uID0gdHJ1ZTtcblxuICAgICAgICAgICAgLyogbm8gc3RyZWFtIHJlc3RhcnQsIGJ1dCBuZXh0IGZlYXR1cmUgKG1vc3QgcHJvYmFibHlcbiAgICAgICAgICAgICAgIHdlJ2xsIGdvIG9ubGluZSBuZXh0KSAqL1xuICAgICAgICAgICAgdGhpcy51c2VGZWF0dXJlcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsICdDYW5ub3QgYmluZCByZXNvdXJjZScpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGFuemEubmFtZSA9PSAnc3RyZWFtOmVycm9yJykge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgc3RhbnphKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT0gU1RBVEVfT05MSU5FKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnc3RhbnphJywgc3RhbnphKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEVpdGhlciB3ZSBqdXN0IHJlY2VpdmVkIDxzdHJlYW06ZmVhdHVyZXMvPiwgb3Igd2UganVzdCBlbmFibGVkIGFcbiAqIGZlYXR1cmUgYW5kIGFyZSBsb29raW5nIGZvciB0aGUgbmV4dC5cbiAqL1xuQ2xpZW50LnByb3RvdHlwZS51c2VGZWF0dXJlcyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX1BSRUFVVEggJiZcbiAgICAgICAgdGhpcy5yZWdpc3Rlcikge1xuXHRkZWxldGUgdGhpcy5yZWdpc3Rlcjtcblx0dGhpcy5kb1JlZ2lzdGVyKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX1BSRUFVVEggJiZcbiAgICAgICAgdGhpcy5zdHJlYW1GZWF0dXJlcy5nZXRDaGlsZCgnbWVjaGFuaXNtcycsIE5TX1hNUFBfU0FTTCkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0FVVEg7XG5cdHZhciBvZmZlcmVkTWVjaHMgPSB0aGlzLnN0cmVhbUZlYXR1cmVzLlxuICAgICAgICAgICAgZ2V0Q2hpbGQoJ21lY2hhbmlzbXMnLCBOU19YTVBQX1NBU0wpLlxuICAgICAgICAgICAgZ2V0Q2hpbGRyZW4oJ21lY2hhbmlzbScsIE5TX1hNUFBfU0FTTCkuXG4gICAgICAgICAgICBtYXAoZnVuY3Rpb24oZWwpIHsgcmV0dXJuIGVsLmdldFRleHQoKTsgfSk7XG4gICAgICAgIHRoaXMubWVjaCA9IHNhc2wuc2VsZWN0TWVjaGFuaXNtKFxuICAgICAgICAgICAgb2ZmZXJlZE1lY2hzLFxuICAgICAgICAgICAgdGhpcy5wcmVmZXJyZWRTYXNsTWVjaGFuaXNtLFxuICAgICAgICAgICAgdGhpcy5hdmFpbGFibGVTYXNsTWVjaGFuaXNtcyk7XG4gICAgICAgIGlmICh0aGlzLm1lY2gpIHtcbiAgICAgICAgICAgIHRoaXMubWVjaC5hdXRoemlkID0gdGhpcy5qaWQuYmFyZSgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLm1lY2guYXV0aGNpZCA9IHRoaXMuamlkLnVzZXI7XG4gICAgICAgICAgICB0aGlzLm1lY2gucGFzc3dvcmQgPSB0aGlzLnBhc3N3b3JkO1xuICAgICAgICAgICAgdGhpcy5tZWNoLmFwaV9rZXkgPSB0aGlzLmFwaV9rZXk7XG4gICAgICAgICAgICB0aGlzLm1lY2guYWNjZXNzX3Rva2VuID0gdGhpcy5hY2Nlc3NfdG9rZW47XG4gICAgICAgICAgICB0aGlzLm1lY2gub2F1dGgyX3Rva2VuID0gdGhpcy5vYXV0aDJfdG9rZW47XG4gICAgICAgICAgICB0aGlzLm1lY2gub2F1dGgyX2F1dGggPSB0aGlzLm9hdXRoMl9hdXRoO1xuICAgICAgICAgICAgdGhpcy5tZWNoLnJlYWxtID0gdGhpcy5qaWQuZG9tYWluOyAgLy8gYW55dGhpbmc/XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RBcykgdGhpcy5tZWNoLmFjdEFzID0gdGhpcy5hY3RBcy51c2VyO1xuICAgICAgICAgICAgdGhpcy5tZWNoLmRpZ2VzdF91cmkgPSBcInhtcHAvXCIgKyB0aGlzLmppZC5kb21haW47XG4gICAgICAgICAgICB2YXIgYXV0aE1zZyA9IGVuY29kZTY0KHRoaXMubWVjaC5hdXRoKCkpO1xuICAgICAgICAgICAgdmFyIGF0dHJzID0gdGhpcy5tZWNoLmF1dGhBdHRycygpO1xuICAgICAgICAgICAgYXR0cnMueG1sbnMgPSBOU19YTVBQX1NBU0w7XG4gICAgICAgICAgICBhdHRycy5tZWNoYW5pc20gPSB0aGlzLm1lY2gubmFtZTtcbiAgICAgICAgICAgIHRoaXMuc2VuZChuZXcgbHR4LkVsZW1lbnQoJ2F1dGgnLCBhdHRycykuXG5cdFx0ICAgICAgdChhdXRoTXNnKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgJ05vIHVzYWJsZSBTQVNMIG1lY2hhbmlzbScpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09IFNUQVRFX0FVVEhFRCAmJlxuICAgICAgICAgICAgICAgIXRoaXMuZGlkX2JpbmQgJiZcbiAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtRmVhdHVyZXMuZ2V0Q2hpbGQoJ2JpbmQnLCBOU19YTVBQX0JJTkQpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9CSU5EO1xuICAgICAgICB2YXIgYmluZEVsID0gbmV3IGx0eC5FbGVtZW50KCdpcScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBJUUlEX0JJTkRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jKCdiaW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgeG1sbnM6IE5TX1hNUFBfQklORFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmppZC5yZXNvdXJjZSlcbiAgICAgICAgICAgIGJpbmRFbC5jKCdyZXNvdXJjZScpLnQodGhpcy5qaWQucmVzb3VyY2UpO1xuICAgICAgICB0aGlzLnNlbmQoYmluZEVsKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT0gU1RBVEVfQVVUSEVEICYmXG4gICAgICAgICAgICAgICAhdGhpcy5kaWRfc2Vzc2lvbiAmJlxuICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1GZWF0dXJlcy5nZXRDaGlsZCgnc2Vzc2lvbicsIE5TX1hNUFBfU0VTU0lPTikpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1NFU1NJT047XG4gICAgICAgIHRoaXMuc2VuZChuZXcgbHR4LkVsZW1lbnQoJ2lxJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGU6ICdzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IHRoaXMuamlkLmRvbWFpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBJUUlEX1NFU1NJT05cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jKCdzZXNzaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgeG1sbnM6IE5TX1hNUFBfU0VTU0lPTlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PSBTVEFURV9BVVRIRUQpIHtcbiAgICAgICAgLyogT2ssIHdlJ3JlIGF1dGhlbnRpY2F0ZWQgYW5kIGFsbCBmZWF0dXJlcyBoYXZlIGJlZW5cbiAgICAgICAgICAgcHJvY2Vzc2VkICovXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9PTkxJTkU7XG4gICAgICAgIHRoaXMuZW1pdCgnb25saW5lJyk7XG4gICAgfVxufTtcblxuQ2xpZW50LnByb3RvdHlwZS5kb1JlZ2lzdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlkID0gXCJyZWdpc3RlclwiICsgTWF0aC5jZWlsKE1hdGgucmFuZG9tKCkgKiA5OTk5OSk7XG4gICAgdmFyIGlxID0gbmV3IGx0eC5FbGVtZW50KCdpcScsIHsgdHlwZTogJ3NldCcsXG5cdFx0XHRcdCAgICAgaWQ6IGlkLFxuXHRcdFx0XHQgICAgIHRvOiB0aGlzLmppZC5kb21haW5cblx0XHRcdFx0ICAgfSkuXG5cdGMoJ3F1ZXJ5JywgeyB4bWxuczogTlNfUkVHSVNURVIgfSkuXG5cdGMoJ3VzZXJuYW1lJykudCh0aGlzLmppZC51c2VyKS51cCgpLlxuXHRjKCdwYXNzd29yZCcpLnQodGhpcy5wYXNzd29yZCk7XG4gICAgdGhpcy5zZW5kKGlxKTtcblxuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgb25SZXBseSA9IGZ1bmN0aW9uKHJlcGx5KSB7XG5cdGlmIChyZXBseS5pcygnaXEnKSAmJiByZXBseS5hdHRycy5pZCA9PT0gaWQpIHtcblx0ICAgIHRoYXQucmVtb3ZlTGlzdGVuZXIoJ3N0YW56YScsIG9uUmVwbHkpO1xuXG5cdCAgICBpZiAocmVwbHkuYXR0cnMudHlwZSA9PT0gJ3Jlc3VsdCcpIHtcblx0XHQvKiBSZWdpc3RyYXRpb24gc3VjY2Vzc2Z1bCwgcHJvY2VlZCB0byBhdXRoICovXG5cdFx0dGhhdC51c2VGZWF0dXJlcygpO1xuXHQgICAgfSBlbHNlIHtcblx0XHR0aGF0LmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKFwiUmVnaXN0cmF0aW9uIGVycm9yXCIpKTtcblx0ICAgIH1cblx0fVxuICAgIH07XG4gICAgdGhpcy5vbignc3RhbnphJywgb25SZXBseSk7XG59O1xuXG5DbGllbnQucHJvdG90eXBlLnJlZ2lzdGVyU2FzbE1lY2hhbmlzbSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSA6IFtdO1xuICAgIHRoaXMuYXZhaWxhYmxlU2FzbE1lY2hhbmlzbXMgPSB0aGlzLmF2YWlsYWJsZVNhc2xNZWNoYW5pc21zLmNvbmNhdChhcmdzKTtcbn07XG5cbnZhciBkZWNvZGU2NCwgZW5jb2RlNjQsIEJ1ZmZlcjtcbmlmICh0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRlY29kZTY0ID0gZnVuY3Rpb24oZW5jb2RlZCkge1xuXHRyZXR1cm4gYXRvYihlbmNvZGVkKTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4gICAgZGVjb2RlNjQgPSBmdW5jdGlvbihlbmNvZGVkKSB7XG5cdHJldHVybiAobmV3IEJ1ZmZlcihlbmNvZGVkLCAnYmFzZTY0JykpLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgfTtcbn1cbmlmICh0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVuY29kZTY0ID0gZnVuY3Rpb24oZGVjb2RlZCkge1xuXHRyZXR1cm4gYnRvYShkZWNvZGVkKTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4gICAgZW5jb2RlNjQgPSBmdW5jdGlvbihkZWNvZGVkKSB7XG5cdHJldHVybiAobmV3IEJ1ZmZlcihkZWNvZGVkLCAndXRmOCcpKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfTtcbn1cblxufSkoKSIsInZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGx0eCA9IHJlcXVpcmUoJ2x0eCcpO1xuXG5mdW5jdGlvbiBTdGFuemEobmFtZSwgYXR0cnMpIHtcbiAgICBsdHguRWxlbWVudC5jYWxsKHRoaXMsIG5hbWUsIGF0dHJzKTtcbn1cbnV0aWwuaW5oZXJpdHMoU3RhbnphLCBsdHguRWxlbWVudCk7XG5cbi8qKlxuICogQ29tbW9uIGF0dHJpYnV0ZSBnZXR0ZXJzL3NldHRlcnMgZm9yIGFsbCBzdGFuemFzXG4gKi9cblxuU3RhbnphLnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKCdmcm9tJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cnMuZnJvbTtcbn0pO1xuU3RhbnphLnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKCdmcm9tJywgZnVuY3Rpb24oZnJvbSkge1xuICAgIHRoaXMuYXR0cnMuZnJvbSA9IGZyb207XG59KTtcblxuU3RhbnphLnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKCd0bycsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJzLnRvO1xufSk7XG5TdGFuemEucHJvdG90eXBlLl9fZGVmaW5lU2V0dGVyX18oJ3RvJywgZnVuY3Rpb24odG8pIHtcbiAgICB0aGlzLmF0dHJzLnRvID0gdG87XG59KTtcblxuU3RhbnphLnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKCdpZCcsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJzLmlkO1xufSk7XG5TdGFuemEucHJvdG90eXBlLl9fZGVmaW5lU2V0dGVyX18oJ2lkJywgZnVuY3Rpb24oaWQpIHtcbiAgICB0aGlzLmF0dHJzLmlkID0gaWQ7XG59KTtcblxuU3RhbnphLnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKCd0eXBlJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cnMudHlwZTtcbn0pO1xuU3RhbnphLnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKCd0eXBlJywgZnVuY3Rpb24odHlwZSkge1xuICAgIHRoaXMuYXR0cnMudHlwZSA9IHR5cGU7XG59KTtcblxuXG4vKipcbiAqIFN0YW56YSBraW5kc1xuICovXG5cbmZ1bmN0aW9uIE1lc3NhZ2UoYXR0cnMpIHtcbiAgICBTdGFuemEuY2FsbCh0aGlzLCAnbWVzc2FnZScsIGF0dHJzKTtcbn1cbnV0aWwuaW5oZXJpdHMoTWVzc2FnZSwgU3RhbnphKTtcblxuZnVuY3Rpb24gUHJlc2VuY2UoYXR0cnMpIHtcbiAgICBTdGFuemEuY2FsbCh0aGlzLCAncHJlc2VuY2UnLCBhdHRycyk7XG59XG51dGlsLmluaGVyaXRzKFByZXNlbmNlLCBTdGFuemEpO1xuXG5mdW5jdGlvbiBJcShhdHRycykge1xuICAgIFN0YW56YS5jYWxsKHRoaXMsICdpcScsIGF0dHJzKTtcbn1cbnV0aWwuaW5oZXJpdHMoSXEsIFN0YW56YSk7XG5cbmV4cG9ydHMuU3RhbnphID0gU3RhbnphO1xuZXhwb3J0cy5NZXNzYWdlID0gTWVzc2FnZTtcbmV4cG9ydHMuUHJlc2VuY2UgPSBQcmVzZW5jZTtcbmV4cG9ydHMuSXEgPSBJcTtcbiIsIihmdW5jdGlvbihCdWZmZXIpe3ZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcblxuZnVuY3Rpb24gQ29uY2F0U3RyZWFtKGNiKSB7XG4gIHN0cmVhbS5TdHJlYW0uY2FsbCh0aGlzKVxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZVxuICBpZiAoY2IpIHRoaXMuY2IgPSBjYlxuICB0aGlzLmJvZHkgPSBbXVxuICBpZiAodGhpcy5jYikgdGhpcy5vbignZXJyb3InLCBjYilcbn1cblxudXRpbC5pbmhlcml0cyhDb25jYXRTdHJlYW0sIHN0cmVhbS5TdHJlYW0pXG5cbkNvbmNhdFN0cmVhbS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihjaHVuaykge1xuICB0aGlzLmJvZHkucHVzaChjaHVuaylcbn1cblxuQ29uY2F0U3RyZWFtLnByb3RvdHlwZS5hcnJheUNvbmNhdCA9IGZ1bmN0aW9uKGFycnMpIHtcbiAgaWYgKGFycnMubGVuZ3RoID09PSAwKSByZXR1cm4gW11cbiAgaWYgKGFycnMubGVuZ3RoID09PSAxKSByZXR1cm4gYXJyc1swXVxuICByZXR1cm4gYXJycy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuY29uY2F0KGIpIH0pXG59XG5cbkNvbmNhdFN0cmVhbS5wcm90b3R5cGUuaXNBcnJheSA9IGZ1bmN0aW9uKGFycikge1xuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYXJyKVxuICB2YXIgaXNUeXBlZEFycmF5ID0gYXJyLnRvU3RyaW5nKCkubWF0Y2goL0FycmF5LylcbiAgcmV0dXJuIGlzQXJyYXkgfHwgaXNUeXBlZEFycmF5XG59XG5cbkNvbmNhdFN0cmVhbS5wcm90b3R5cGUuZ2V0Qm9keSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYm9keS5sZW5ndGggPT09IDApIHJldHVyblxuICBpZiAodHlwZW9mKHRoaXMuYm9keVswXSkgPT09IFwic3RyaW5nXCIpIHJldHVybiB0aGlzLmJvZHkuam9pbignJylcbiAgaWYgKHRoaXMuaXNBcnJheSh0aGlzLmJvZHlbMF0pKSByZXR1cm4gdGhpcy5hcnJheUNvbmNhdCh0aGlzLmJvZHkpXG4gIGlmICh0eXBlb2YoQnVmZmVyKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBCdWZmZXIuaXNCdWZmZXIodGhpcy5ib2R5WzBdKSkge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KHRoaXMuYm9keSlcbiAgfVxuICByZXR1cm4gdGhpcy5ib2R5XG59XG5cbkNvbmNhdFN0cmVhbS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNiKSB0aGlzLmNiKGZhbHNlLCB0aGlzLmdldEJvZHkoKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjYikge1xuICByZXR1cm4gbmV3IENvbmNhdFN0cmVhbShjYilcbn1cblxubW9kdWxlLmV4cG9ydHMuQ29uY2F0U3RyZWFtID0gQ29uY2F0U3RyZWFtXG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfYnVmZmVyXCIpLkJ1ZmZlcikiLCJ2YXIgZWxlbWVudCA9IHJlcXVpcmUoJy4vZWxlbWVudCcpO1xudmFyIHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpO1xuXG4vKipcbiAqIFRoZSBvbmx5IChyZWxldmFudCkgZGF0YSBzdHJ1Y3R1cmVcbiAqL1xuZXhwb3J0cy5FbGVtZW50ID0gZWxlbWVudC5FbGVtZW50O1xuLyoqXG4gKiBIZWxwZXJcbiAqL1xuZXhwb3J0cy5lc2NhcGVYbWwgPSBlbGVtZW50LmVzY2FwZVhtbDtcblxuLyoqXG4gKiBET00gcGFyc2VyIGludGVyZmFjZVxuICovXG5leHBvcnRzLnBhcnNlID0gcGFyc2UucGFyc2U7XG5leHBvcnRzLlBhcnNlciA9IHBhcnNlLlBhcnNlcjtcbi8qKlxuICogU0FYIHBhcnNlciBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0cy5hdmFpbGFibGVTYXhQYXJzZXJzID0gcGFyc2UuYXZhaWxhYmxlU2F4UGFyc2VycztcbmV4cG9ydHMuYmVzdFNheFBhcnNlciA9IHBhcnNlLmJlc3RTYXhQYXJzZXI7XG4iLCIoZnVuY3Rpb24ocHJvY2Vzcyl7LypnbG9iYWwgc2V0SW1tZWRpYXRlOiBmYWxzZSwgc2V0VGltZW91dDogZmFsc2UsIGNvbnNvbGU6IGZhbHNlICovXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGFzeW5jID0ge307XG5cbiAgICAvLyBnbG9iYWwgb24gdGhlIHNlcnZlciwgd2luZG93IGluIHRoZSBicm93c2VyXG4gICAgdmFyIHJvb3QsIHByZXZpb3VzX2FzeW5jO1xuXG4gICAgcm9vdCA9IHRoaXM7XG4gICAgaWYgKHJvb3QgIT0gbnVsbCkge1xuICAgICAgcHJldmlvdXNfYXN5bmMgPSByb290LmFzeW5jO1xuICAgIH1cblxuICAgIGFzeW5jLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJvb3QuYXN5bmMgPSBwcmV2aW91c19hc3luYztcbiAgICAgICAgcmV0dXJuIGFzeW5jO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvbmx5X29uY2UoZm4pIHtcbiAgICAgICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFjayB3YXMgYWxyZWFkeSBjYWxsZWQuXCIpO1xuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZuLmFwcGx5KHJvb3QsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy8vIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJsaXR5IGZ1bmN0aW9ucyAvLy8vXG5cbiAgICB2YXIgX2VhY2ggPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvcikge1xuICAgICAgICBpZiAoYXJyLmZvckVhY2gpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIuZm9yRWFjaChpdGVyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGFycltpXSwgaSwgYXJyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgX21hcCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yKSB7XG4gICAgICAgIGlmIChhcnIubWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLm1hcChpdGVyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCwgaSwgYSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZXJhdG9yKHgsIGksIGEpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG5cbiAgICB2YXIgX3JlZHVjZSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtZW1vKSB7XG4gICAgICAgIGlmIChhcnIucmVkdWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLnJlZHVjZShpdGVyYXRvciwgbWVtbyk7XG4gICAgICAgIH1cbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCwgaSwgYSkge1xuICAgICAgICAgICAgbWVtbyA9IGl0ZXJhdG9yKG1lbW8sIHgsIGksIGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcblxuICAgIHZhciBfa2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9O1xuXG4gICAgLy8vLyBleHBvcnRlZCBhc3luYyBtb2R1bGUgZnVuY3Rpb25zIC8vLy9cblxuICAgIC8vLy8gbmV4dFRpY2sgaW1wbGVtZW50YXRpb24gd2l0aCBicm93c2VyLWNvbXBhdGlibGUgZmFsbGJhY2sgLy8vL1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgIShwcm9jZXNzLm5leHRUaWNrKSkge1xuICAgICAgICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgYSBkaXJlY3QgYWxpYXMgZm9yIElFMTAgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGFzeW5jLm5leHRUaWNrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3luYy5uZXh0VGljayA9IHByb2Nlc3MubmV4dFRpY2s7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYy5lYWNoID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICghYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gICAgICAgIF9lYWNoKGFyciwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIG9ubHlfb25jZShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuZm9yRWFjaCA9IGFzeW5jLmVhY2g7XG5cbiAgICBhc3luYy5lYWNoU2VyaWVzID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICghYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gICAgICAgIHZhciBpdGVyYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaXRlcmF0b3IoYXJyW2NvbXBsZXRlZF0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpdGVyYXRlKCk7XG4gICAgfTtcbiAgICBhc3luYy5mb3JFYWNoU2VyaWVzID0gYXN5bmMuZWFjaFNlcmllcztcblxuICAgIGFzeW5jLmVhY2hMaW1pdCA9IGZ1bmN0aW9uIChhcnIsIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZuID0gX2VhY2hMaW1pdChsaW1pdCk7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIFthcnIsIGl0ZXJhdG9yLCBjYWxsYmFja10pO1xuICAgIH07XG4gICAgYXN5bmMuZm9yRWFjaExpbWl0ID0gYXN5bmMuZWFjaExpbWl0O1xuXG4gICAgdmFyIF9lYWNoTGltaXQgPSBmdW5jdGlvbiAobGltaXQpIHtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgaWYgKCFhcnIubGVuZ3RoIHx8IGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ZWQgPSAwO1xuICAgICAgICAgICAgdmFyIHJ1bm5pbmcgPSAwO1xuXG4gICAgICAgICAgICAoZnVuY3Rpb24gcmVwbGVuaXNoICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHJ1bm5pbmcgPCBsaW1pdCAmJiBzdGFydGVkIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IoYXJyW3N0YXJ0ZWQgLSAxXSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxlbmlzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG5cbiAgICB2YXIgZG9QYXJhbGxlbCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFthc3luYy5lYWNoXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIGRvUGFyYWxsZWxMaW1pdCA9IGZ1bmN0aW9uKGxpbWl0LCBmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFtfZWFjaExpbWl0KGxpbWl0KV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBkb1NlcmllcyA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFthc3luYy5lYWNoU2VyaWVzXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG5cblxuICAgIHZhciBfYXN5bmNNYXAgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGksIHZhbHVlOiB4fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKGVyciwgdikge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbeC5pbmRleF0gPSB2O1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5tYXAgPSBkb1BhcmFsbGVsKF9hc3luY01hcCk7XG4gICAgYXN5bmMubWFwU2VyaWVzID0gZG9TZXJpZXMoX2FzeW5jTWFwKTtcbiAgICBhc3luYy5tYXBMaW1pdCA9IGZ1bmN0aW9uIChhcnIsIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9tYXBMaW1pdChsaW1pdCkoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICB2YXIgX21hcExpbWl0ID0gZnVuY3Rpb24obGltaXQpIHtcbiAgICAgICAgcmV0dXJuIGRvUGFyYWxsZWxMaW1pdChsaW1pdCwgX2FzeW5jTWFwKTtcbiAgICB9O1xuXG4gICAgLy8gcmVkdWNlIG9ubHkgaGFzIGEgc2VyaWVzIHZlcnNpb24sIGFzIGRvaW5nIHJlZHVjZSBpbiBwYXJhbGxlbCB3b24ndFxuICAgIC8vIHdvcmsgaW4gbWFueSBzaXR1YXRpb25zLlxuICAgIGFzeW5jLnJlZHVjZSA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBhc3luYy5lYWNoU2VyaWVzKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihtZW1vLCB4LCBmdW5jdGlvbiAoZXJyLCB2KSB7XG4gICAgICAgICAgICAgICAgbWVtbyA9IHY7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIG1lbW8pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGluamVjdCBhbGlhc1xuICAgIGFzeW5jLmluamVjdCA9IGFzeW5jLnJlZHVjZTtcbiAgICAvLyBmb2xkbCBhbGlhc1xuICAgIGFzeW5jLmZvbGRsID0gYXN5bmMucmVkdWNlO1xuXG4gICAgYXN5bmMucmVkdWNlUmlnaHQgPSBmdW5jdGlvbiAoYXJyLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJldmVyc2VkID0gX21hcChhcnIsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSkucmV2ZXJzZSgpO1xuICAgICAgICBhc3luYy5yZWR1Y2UocmV2ZXJzZWQsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvLyBmb2xkciBhbGlhc1xuICAgIGFzeW5jLmZvbGRyID0gYXN5bmMucmVkdWNlUmlnaHQ7XG5cbiAgICB2YXIgX2ZpbHRlciA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhfbWFwKHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLmZpbHRlciA9IGRvUGFyYWxsZWwoX2ZpbHRlcik7XG4gICAgYXN5bmMuZmlsdGVyU2VyaWVzID0gZG9TZXJpZXMoX2ZpbHRlcik7XG4gICAgLy8gc2VsZWN0IGFsaWFzXG4gICAgYXN5bmMuc2VsZWN0ID0gYXN5bmMuZmlsdGVyO1xuICAgIGFzeW5jLnNlbGVjdFNlcmllcyA9IGFzeW5jLmZpbHRlclNlcmllcztcblxuICAgIHZhciBfcmVqZWN0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgYXJyID0gX21hcChhcnIsIGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpLCB2YWx1ZTogeH07XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhfbWFwKHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLnJlamVjdCA9IGRvUGFyYWxsZWwoX3JlamVjdCk7XG4gICAgYXN5bmMucmVqZWN0U2VyaWVzID0gZG9TZXJpZXMoX3JlamVjdCk7XG5cbiAgICB2YXIgX2RldGVjdCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIG1haW5fY2FsbGJhY2spIHtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKHgpO1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBtYWluX2NhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuZGV0ZWN0ID0gZG9QYXJhbGxlbChfZGV0ZWN0KTtcbiAgICBhc3luYy5kZXRlY3RTZXJpZXMgPSBkb1NlcmllcyhfZGV0ZWN0KTtcblxuICAgIGFzeW5jLnNvbWUgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xuICAgICAgICBhc3luYy5lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBtYWluX2NhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBhbnkgYWxpYXNcbiAgICBhc3luYy5hbnkgPSBhc3luYy5zb21lO1xuXG4gICAgYXN5bmMuZXZlcnkgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xuICAgICAgICBhc3luYy5lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gYWxsIGFsaWFzXG4gICAgYXN5bmMuYWxsID0gYXN5bmMuZXZlcnk7XG5cbiAgICBhc3luYy5zb3J0QnkgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgYXN5bmMubWFwKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAoZXJyLCBjcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHt2YWx1ZTogeCwgY3JpdGVyaWE6IGNyaXRlcmlhfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWEsIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgX21hcChyZXN1bHRzLnNvcnQoZm4pLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy5hdXRvID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICB2YXIga2V5cyA9IF9rZXlzKHRhc2tzKTtcbiAgICAgICAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcblxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gW107XG4gICAgICAgIHZhciBhZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnVuc2hpZnQoZm4pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXSA9PT0gZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRhc2tDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9lYWNoKGxpc3RlbmVycy5zbGljZSgwKSwgZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGFkZExpc3RlbmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfa2V5cyhyZXN1bHRzKS5sZW5ndGggPT09IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2VhY2goa2V5cywgZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gKHRhc2tzW2tdIGluc3RhbmNlb2YgRnVuY3Rpb24pID8gW3Rhc2tzW2tdXTogdGFza3Nba107XG4gICAgICAgICAgICB2YXIgdGFza0NhbGxiYWNrID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2FmZVJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgX2VhY2goX2tleXMocmVzdWx0cyksIGZ1bmN0aW9uKHJrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW3JrZXldID0gcmVzdWx0c1tya2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBzYWZlUmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3Agc3Vic2VxdWVudCBlcnJvcnMgaGl0dGluZyBjYWxsYmFjayBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSh0YXNrQ29tcGxldGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcmVxdWlyZXMgPSB0YXNrLnNsaWNlKDAsIE1hdGguYWJzKHRhc2subGVuZ3RoIC0gMSkpIHx8IFtdO1xuICAgICAgICAgICAgdmFyIHJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVkdWNlKHJlcXVpcmVzLCBmdW5jdGlvbiAoYSwgeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGEgJiYgcmVzdWx0cy5oYXNPd25Qcm9wZXJ0eSh4KSk7XG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSkgJiYgIXJlc3VsdHMuaGFzT3duUHJvcGVydHkoayk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlYWR5KCkpIHtcbiAgICAgICAgICAgICAgICB0YXNrW3Rhc2subGVuZ3RoIC0gMV0odGFza0NhbGxiYWNrLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tbdGFzay5sZW5ndGggLSAxXSh0YXNrQ2FsbGJhY2ssIHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy53YXRlcmZhbGwgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICh0YXNrcy5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpIHtcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byB3YXRlcmZhbGwgbXVzdCBiZSBhbiBhcnJheSBvZiBmdW5jdGlvbnMnKTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdyYXBJdGVyYXRvciA9IGZ1bmN0aW9uIChpdGVyYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKHdyYXBJdGVyYXRvcihuZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgd3JhcEl0ZXJhdG9yKGFzeW5jLml0ZXJhdG9yKHRhc2tzKSkoKTtcbiAgICB9O1xuXG4gICAgdmFyIF9wYXJhbGxlbCA9IGZ1bmN0aW9uKGVhY2hmbiwgdGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICh0YXNrcy5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgIGVhY2hmbi5tYXAodGFza3MsIGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCwgZXJyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgIGVhY2hmbi5lYWNoKF9rZXlzKHRhc2tzKSwgZnVuY3Rpb24gKGssIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGFza3Nba10oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMucGFyYWxsZWwgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9wYXJhbGxlbCh7IG1hcDogYXN5bmMubWFwLCBlYWNoOiBhc3luYy5lYWNoIH0sIHRhc2tzLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnBhcmFsbGVsTGltaXQgPSBmdW5jdGlvbih0YXNrcywgbGltaXQsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9wYXJhbGxlbCh7IG1hcDogX21hcExpbWl0KGxpbWl0KSwgZWFjaDogX2VhY2hMaW1pdChsaW1pdCkgfSwgdGFza3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuc2VyaWVzID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAodGFza3MuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICBhc3luYy5tYXBTZXJpZXModGFza3MsIGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCwgZXJyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoX2tleXModGFza3MpLCBmdW5jdGlvbiAoaywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0YXNrc1trXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5pdGVyYXRvciA9IGZ1bmN0aW9uICh0YXNrcykge1xuICAgICAgICB2YXIgbWFrZUNhbGxiYWNrID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrc1tpbmRleF0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLm5leHQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmbi5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXggPCB0YXNrcy5sZW5ndGggLSAxKSA/IG1ha2VDYWxsYmFjayhpbmRleCArIDEpOiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1ha2VDYWxsYmFjaygwKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuYXBwbHkgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KFxuICAgICAgICAgICAgICAgIG51bGwsIGFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgX2NvbmNhdCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByID0gW107XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYikge1xuICAgICAgICAgICAgZm4oeCwgZnVuY3Rpb24gKGVyciwgeSkge1xuICAgICAgICAgICAgICAgIHIgPSByLmNvbmNhdCh5IHx8IFtdKTtcbiAgICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuY29uY2F0ID0gZG9QYXJhbGxlbChfY29uY2F0KTtcbiAgICBhc3luYy5jb25jYXRTZXJpZXMgPSBkb1NlcmllcyhfY29uY2F0KTtcblxuICAgIGFzeW5jLndoaWxzdCA9IGZ1bmN0aW9uICh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRlc3QoKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzeW5jLndoaWxzdCh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLmRvV2hpbHN0ID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjaykge1xuICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGVzdCgpKSB7XG4gICAgICAgICAgICAgICAgYXN5bmMuZG9XaGlsc3QoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy51bnRpbCA9IGZ1bmN0aW9uICh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0ZXN0KCkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3luYy51bnRpbCh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLmRvVW50aWwgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGVzdCgpKSB7XG4gICAgICAgICAgICAgICAgYXN5bmMuZG9VbnRpbChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLnF1ZXVlID0gZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGNvbmN1cnJlbmN5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBfaW5zZXJ0KHEsIGRhdGEsIHBvcywgY2FsbGJhY2spIHtcbiAgICAgICAgICBpZihkYXRhLmNvbnN0cnVjdG9yICE9PSBBcnJheSkge1xuICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfZWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XG4gICAgICAgICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG51bGxcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICAgICAgcS50YXNrcy51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHEudGFza3MucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChxLnNhdHVyYXRlZCAmJiBxLnRhc2tzLmxlbmd0aCA9PT0gY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgIHEuc2F0dXJhdGVkKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHEucHJvY2Vzcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd29ya2VycyA9IDA7XG4gICAgICAgIHZhciBxID0ge1xuICAgICAgICAgICAgdGFza3M6IFtdLFxuICAgICAgICAgICAgY29uY3VycmVuY3k6IGNvbmN1cnJlbmN5LFxuICAgICAgICAgICAgc2F0dXJhdGVkOiBudWxsLFxuICAgICAgICAgICAgZW1wdHk6IG51bGwsXG4gICAgICAgICAgICBkcmFpbjogbnVsbCxcbiAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zaGlmdDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgdHJ1ZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAod29ya2VycyA8IHEuY29uY3VycmVuY3kgJiYgcS50YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhc2sgPSBxLnRhc2tzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxLmVtcHR5ICYmIHEudGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd29ya2VycyArPSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlcnMgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXNrLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5jYWxsYmFjay5hcHBseSh0YXNrLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEuZHJhaW4gJiYgcS50YXNrcy5sZW5ndGggKyB3b3JrZXJzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcS5wcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYiA9IG9ubHlfb25jZShuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyKHRhc2suZGF0YSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcS50YXNrcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3b3JrZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcTtcbiAgICB9O1xuXG4gICAgYXN5bmMuY2FyZ28gPSBmdW5jdGlvbiAod29ya2VyLCBwYXlsb2FkKSB7XG4gICAgICAgIHZhciB3b3JraW5nICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgdGFza3MgICAgICAgPSBbXTtcblxuICAgICAgICB2YXIgY2FyZ28gPSB7XG4gICAgICAgICAgICB0YXNrczogdGFza3MsXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICAgICAgc2F0dXJhdGVkOiBudWxsLFxuICAgICAgICAgICAgZW1wdHk6IG51bGwsXG4gICAgICAgICAgICBkcmFpbjogbnVsbCxcbiAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmKGRhdGEuY29uc3RydWN0b3IgIT09IEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9lYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcmdvLnNhdHVyYXRlZCAmJiB0YXNrcy5sZW5ndGggPT09IHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmdvLnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGNhcmdvLnByb2Nlc3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIHByb2Nlc3MoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtpbmcpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGNhcmdvLmRyYWluKSBjYXJnby5kcmFpbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRzID0gdHlwZW9mIHBheWxvYWQgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0YXNrcy5zcGxpY2UoMCwgcGF5bG9hZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRhc2tzLnNwbGljZSgwKTtcblxuICAgICAgICAgICAgICAgIHZhciBkcyA9IF9tYXAodHMsIGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLmRhdGE7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZihjYXJnby5lbXB0eSkgY2FyZ28uZW1wdHkoKTtcbiAgICAgICAgICAgICAgICB3b3JraW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3b3JrZXIoZHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICBfZWFjaCh0cywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jYWxsYmFjay5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXNrcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3b3JraW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2FyZ287XG4gICAgfTtcblxuICAgIHZhciBfY29uc29sZV9mbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uc29sZVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2VhY2goYXJncywgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlW25hbWVdKHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSkpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgYXN5bmMubG9nID0gX2NvbnNvbGVfZm4oJ2xvZycpO1xuICAgIGFzeW5jLmRpciA9IF9jb25zb2xlX2ZuKCdkaXInKTtcbiAgICAvKmFzeW5jLmluZm8gPSBfY29uc29sZV9mbignaW5mbycpO1xuICAgIGFzeW5jLndhcm4gPSBfY29uc29sZV9mbignd2FybicpO1xuICAgIGFzeW5jLmVycm9yID0gX2NvbnNvbGVfZm4oJ2Vycm9yJyk7Ki9cblxuICAgIGFzeW5jLm1lbW9pemUgPSBmdW5jdGlvbiAoZm4sIGhhc2hlcikge1xuICAgICAgICB2YXIgbWVtbyA9IHt9O1xuICAgICAgICB2YXIgcXVldWVzID0ge307XG4gICAgICAgIGhhc2hlciA9IGhhc2hlciB8fCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKGtleSBpbiBtZW1vKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgbWVtb1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSBpbiBxdWV1ZXMpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZXNba2V5XS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXVlc1trZXldID0gW2NhbGxiYWNrXTtcbiAgICAgICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChbZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBtZW1vW2tleV0gPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxID0gcXVldWVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWV1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBxLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgIHFbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG1lbW9pemVkLm1lbW8gPSBtZW1vO1xuICAgICAgICBtZW1vaXplZC51bm1lbW9pemVkID0gZm47XG4gICAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9O1xuXG4gICAgYXN5bmMudW5tZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKGZuLnVubWVtb2l6ZWQgfHwgZm4pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBhc3luYy50aW1lcyA9IGZ1bmN0aW9uIChjb3VudCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjb3VudGVyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY291bnRlci5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3luYy5tYXAoY291bnRlciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMudGltZXNTZXJpZXMgPSBmdW5jdGlvbiAoY291bnQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgY291bnRlciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ZXIucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN5bmMubWFwU2VyaWVzKGNvdW50ZXIsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLmNvbXBvc2UgPSBmdW5jdGlvbiAoLyogZnVuY3Rpb25zLi4uICovKSB7XG4gICAgICAgIHZhciBmbnMgPSBBcnJheS5wcm90b3R5cGUucmV2ZXJzZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgYXN5bmMucmVkdWNlKGZucywgYXJncywgZnVuY3Rpb24gKG5ld2FyZ3MsIGZuLCBjYikge1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIG5ld2FyZ3MuY29uY2F0KFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNiKGVyciwgbmV4dGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1dKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhhdCwgW2Vycl0uY29uY2F0KHJlc3VsdHMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgX2FwcGx5RWFjaCA9IGZ1bmN0aW9uIChlYWNoZm4sIGZucyAvKmFyZ3MuLi4qLykge1xuICAgICAgICB2YXIgZ28gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIGVhY2hmbihmbnMsIGZ1bmN0aW9uIChmbiwgY2IpIHtcbiAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzLmNvbmNhdChbY2JdKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgICAgIHJldHVybiBnby5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnbztcbiAgICAgICAgfVxuICAgIH07XG4gICAgYXN5bmMuYXBwbHlFYWNoID0gZG9QYXJhbGxlbChfYXBwbHlFYWNoKTtcbiAgICBhc3luYy5hcHBseUVhY2hTZXJpZXMgPSBkb1NlcmllcyhfYXBwbHlFYWNoKTtcblxuICAgIGFzeW5jLmZvcmV2ZXIgPSBmdW5jdGlvbiAoZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGZ1bmN0aW9uIG5leHQoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbihuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgfTtcblxuICAgIC8vIEFNRCAvIFJlcXVpcmVKU1xuICAgIGlmICh0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzeW5jO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gTm9kZS5qc1xuICAgIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gYXN5bmM7XG4gICAgfVxuICAgIC8vIGluY2x1ZGVkIGRpcmVjdGx5IHZpYSA8c2NyaXB0PiB0YWdcbiAgICBlbHNlIHtcbiAgICAgICAgcm9vdC5hc3luYyA9IGFzeW5jO1xuICAgIH1cblxufSgpKTtcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpKSIsIihmdW5jdGlvbihwcm9jZXNzLEJ1ZmZlcil7dmFyIENvbWJpbmVkU3RyZWFtID0gcmVxdWlyZSgnY29tYmluZWQtc3RyZWFtJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xudmFyIHBhcnNlVXJsID0gcmVxdWlyZSgndXJsJykucGFyc2U7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIG1pbWUgPSByZXF1aXJlKCdtaW1lJyk7XG52YXIgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcm1EYXRhO1xuZnVuY3Rpb24gRm9ybURhdGEoKSB7XG4gIHRoaXMuX292ZXJoZWFkTGVuZ3RoID0gMDtcbiAgdGhpcy5fdmFsdWVMZW5ndGggPSAwO1xuICB0aGlzLl9sZW5ndGhSZXRyaWV2ZXJzID0gW107XG5cbiAgQ29tYmluZWRTdHJlYW0uY2FsbCh0aGlzKTtcbn1cbnV0aWwuaW5oZXJpdHMoRm9ybURhdGEsIENvbWJpbmVkU3RyZWFtKTtcblxuRm9ybURhdGEuTElORV9CUkVBSyA9ICdcXHJcXG4nO1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oZmllbGQsIHZhbHVlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBhcHBlbmQgPSBDb21iaW5lZFN0cmVhbS5wcm90b3R5cGUuYXBwZW5kLmJpbmQodGhpcyk7XG5cbiAgLy8gYWxsIHRoYXQgc3RyZWFteSBidXNpbmVzcyBjYW4ndCBoYW5kbGUgbnVtYmVyc1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB2YWx1ZSA9ICcnK3ZhbHVlO1xuXG4gIHZhciBoZWFkZXIgPSB0aGlzLl9tdWx0aVBhcnRIZWFkZXIoZmllbGQsIHZhbHVlLCBvcHRpb25zKTtcbiAgdmFyIGZvb3RlciA9IHRoaXMuX211bHRpUGFydEZvb3RlcihmaWVsZCwgdmFsdWUsIG9wdGlvbnMpO1xuXG4gIGFwcGVuZChoZWFkZXIpO1xuICBhcHBlbmQodmFsdWUpO1xuICBhcHBlbmQoZm9vdGVyKTtcblxuICAvLyBwYXNzIGFsb25nIG9wdGlvbnMua25vd25MZW5ndGhcbiAgdGhpcy5fdHJhY2tMZW5ndGgoaGVhZGVyLCB2YWx1ZSwgb3B0aW9ucyk7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX3RyYWNrTGVuZ3RoID0gZnVuY3Rpb24oaGVhZGVyLCB2YWx1ZSwgb3B0aW9ucykge1xuICB2YXIgdmFsdWVMZW5ndGggPSAwO1xuXG4gIC8vIHVzZWQgdy8gdHJhY2tMZW5ndGhTeW5jKCksIHdoZW4gbGVuZ3RoIGlzIGtub3duLlxuICAvLyBlLmcuIGZvciBzdHJlYW1pbmcgZGlyZWN0bHkgZnJvbSBhIHJlbW90ZSBzZXJ2ZXIsXG4gIC8vIHcvIGEga25vd24gZmlsZSBhIHNpemUsIGFuZCBub3Qgd2FudGluZyB0byB3YWl0IGZvclxuICAvLyBpbmNvbWluZyBmaWxlIHRvIGZpbmlzaCB0byBnZXQgaXRzIHNpemUuXG4gIGlmIChvcHRpb25zLmtub3duTGVuZ3RoICE9IG51bGwpIHtcbiAgICB2YWx1ZUxlbmd0aCArPSArb3B0aW9ucy5rbm93bkxlbmd0aDtcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xuICB9XG5cbiAgdGhpcy5fdmFsdWVMZW5ndGggKz0gdmFsdWVMZW5ndGg7XG5cbiAgLy8gQGNoZWNrIHdoeSBhZGQgQ1JMRj8gZG9lcyB0aGlzIGFjY291bnQgZm9yIGN1c3RvbS9tdWx0aXBsZSBDUkxGcz9cbiAgdGhpcy5fb3ZlcmhlYWRMZW5ndGggKz1cbiAgICBCdWZmZXIuYnl0ZUxlbmd0aChoZWFkZXIpICtcbiAgICArIEZvcm1EYXRhLkxJTkVfQlJFQUsubGVuZ3RoO1xuXG4gIC8vIGVtcHR5IG9yIGVpdGhlciBkb2Vzbid0IGhhdmUgcGF0aCBvciBub3QgYW4gaHR0cCByZXNwb25zZVxuICBpZiAoIXZhbHVlIHx8ICggIXZhbHVlLnBhdGggJiYgISh2YWx1ZS5yZWFkYWJsZSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnaHR0cFZlcnNpb24nKSkgKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2xlbmd0aFJldHJpZXZlcnMucHVzaChmdW5jdGlvbihuZXh0KSB7XG5cbiAgICAvLyBkbyB3ZSBhbHJlYWR5IGtub3cgdGhlIHNpemU/XG4gICAgLy8gMCBhZGRpdGlvbmFsIGxlYXZlcyB2YWx1ZSBmcm9tIGdldFN5bmNMZW5ndGgoKVxuICAgIGlmIChvcHRpb25zLmtub3duTGVuZ3RoICE9IG51bGwpIHtcbiAgICAgIG5leHQobnVsbCwgMCk7XG5cbiAgICAvLyBjaGVjayBpZiBpdCdzIGxvY2FsIGZpbGVcbiAgICB9IGVsc2UgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KCdmZCcpKSB7XG4gICAgICBmcy5zdGF0KHZhbHVlLnBhdGgsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgbmV4dChlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQobnVsbCwgc3RhdC5zaXplKTtcbiAgICAgIH0pO1xuXG4gICAgLy8gb3IgaHR0cCByZXNwb25zZVxuICAgIH0gZWxzZSBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ2h0dHBWZXJzaW9uJykpIHtcbiAgICAgIG5leHQobnVsbCwgK3ZhbHVlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pO1xuXG4gICAgLy8gb3IgcmVxdWVzdCBzdHJlYW0gaHR0cDovL2dpdGh1Yi5jb20vbWlrZWFsL3JlcXVlc3RcbiAgICB9IGVsc2UgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KCdodHRwTW9kdWxlJykpIHtcbiAgICAgIC8vIHdhaXQgdGlsbCByZXNwb25zZSBjb21lIGJhY2tcbiAgICAgIHZhbHVlLm9uKCdyZXNwb25zZScsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhbHVlLnBhdXNlKCk7XG4gICAgICAgIG5leHQobnVsbCwgK3Jlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pO1xuICAgICAgfSk7XG4gICAgICB2YWx1ZS5yZXN1bWUoKTtcblxuICAgIC8vIHNvbWV0aGluZyBlbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQoJ1Vua25vd24gc3RyZWFtJyk7XG4gICAgfVxuICB9KTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fbXVsdGlQYXJ0SGVhZGVyID0gZnVuY3Rpb24oZmllbGQsIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciBib3VuZGFyeSA9IHRoaXMuZ2V0Qm91bmRhcnkoKTtcbiAgdmFyIGhlYWRlciA9ICcnO1xuXG4gIC8vIGN1c3RvbSBoZWFkZXIgc3BlY2lmaWVkIChhcyBzdHJpbmcpP1xuICAvLyBpdCBiZWNvbWVzIHJlc3BvbnNpYmxlIGZvciBib3VuZGFyeVxuICAvLyAoZS5nLiB0byBoYW5kbGUgZXh0cmEgQ1JMRnMgb24gLk5FVCBzZXJ2ZXJzKVxuICBpZiAob3B0aW9ucy5oZWFkZXIgIT0gbnVsbCkge1xuICAgIGhlYWRlciA9IG9wdGlvbnMuaGVhZGVyO1xuICB9IGVsc2Uge1xuICAgIGhlYWRlciArPSAnLS0nICsgYm91bmRhcnkgKyBGb3JtRGF0YS5MSU5FX0JSRUFLICtcbiAgICAgICdDb250ZW50LURpc3Bvc2l0aW9uOiBmb3JtLWRhdGE7IG5hbWU9XCInICsgZmllbGQgKyAnXCInO1xuXG4gICAgLy8gZnMtIGFuZCByZXF1ZXN0LSBzdHJlYW1zIGhhdmUgcGF0aCBwcm9wZXJ0eVxuICAgIC8vIG9yIHVzZSBjdXN0b20gZmlsZW5hbWUgYW5kL29yIGNvbnRlbnRUeXBlXG4gICAgLy8gVE9ETzogVXNlIHJlcXVlc3QncyByZXNwb25zZSBtaW1lLXR5cGVcbiAgICBpZiAob3B0aW9ucy5maWxlbmFtZSB8fCB2YWx1ZS5wYXRoKSB7XG4gICAgICBoZWFkZXIgKz1cbiAgICAgICAgJzsgZmlsZW5hbWU9XCInICsgcGF0aC5iYXNlbmFtZShvcHRpb25zLmZpbGVuYW1lIHx8IHZhbHVlLnBhdGgpICsgJ1wiJyArIEZvcm1EYXRhLkxJTkVfQlJFQUsgK1xuICAgICAgICAnQ29udGVudC1UeXBlOiAnICsgIChvcHRpb25zLmNvbnRlbnRUeXBlIHx8IG1pbWUubG9va3VwKG9wdGlvbnMuZmlsZW5hbWUgfHwgdmFsdWUucGF0aCkpO1xuXG4gICAgLy8gaHR0cCByZXNwb25zZSBoYXMgbm90XG4gICAgfSBlbHNlIGlmICh2YWx1ZS5yZWFkYWJsZSAmJiB2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnaHR0cFZlcnNpb24nKSkge1xuICAgICAgaGVhZGVyICs9XG4gICAgICAgICc7IGZpbGVuYW1lPVwiJyArIHBhdGguYmFzZW5hbWUodmFsdWUuY2xpZW50Ll9odHRwTWVzc2FnZS5wYXRoKSArICdcIicgKyBGb3JtRGF0YS5MSU5FX0JSRUFLICtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZTogJyArIHZhbHVlLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuICAgIH1cblxuICAgIGhlYWRlciArPSBGb3JtRGF0YS5MSU5FX0JSRUFLICsgRm9ybURhdGEuTElORV9CUkVBSztcbiAgfVxuXG4gIHJldHVybiBoZWFkZXI7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX211bHRpUGFydEZvb3RlciA9IGZ1bmN0aW9uKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24obmV4dCkge1xuICAgIHZhciBmb290ZXIgPSBGb3JtRGF0YS5MSU5FX0JSRUFLO1xuXG4gICAgdmFyIGxhc3RQYXJ0ID0gKHRoaXMuX3N0cmVhbXMubGVuZ3RoID09PSAwKTtcbiAgICBpZiAobGFzdFBhcnQpIHtcbiAgICAgIGZvb3RlciArPSB0aGlzLl9sYXN0Qm91bmRhcnkoKTtcbiAgICB9XG5cbiAgICBuZXh0KGZvb3Rlcik7XG4gIH0uYmluZCh0aGlzKTtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5fbGFzdEJvdW5kYXJ5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnLS0nICsgdGhpcy5nZXRCb3VuZGFyeSgpICsgJy0tJztcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5nZXRIZWFkZXJzID0gZnVuY3Rpb24odXNlckhlYWRlcnMpIHtcbiAgdmFyIGZvcm1IZWFkZXJzID0ge1xuICAgICdjb250ZW50LXR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9JyArIHRoaXMuZ2V0Qm91bmRhcnkoKVxuICB9O1xuXG4gIGZvciAodmFyIGhlYWRlciBpbiB1c2VySGVhZGVycykge1xuICAgIGZvcm1IZWFkZXJzW2hlYWRlci50b0xvd2VyQ2FzZSgpXSA9IHVzZXJIZWFkZXJzW2hlYWRlcl07XG4gIH1cblxuICByZXR1cm4gZm9ybUhlYWRlcnM7XG59XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5nZXRDdXN0b21IZWFkZXJzID0gZnVuY3Rpb24oY29udGVudFR5cGUpIHtcbiAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlID8gY29udGVudFR5cGUgOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSc7XG5cbiAgICB2YXIgZm9ybUhlYWRlcnMgPSB7XG4gICAgICAgICdjb250ZW50LXR5cGUnOiBjb250ZW50VHlwZSArICc7IGJvdW5kYXJ5PScgKyB0aGlzLmdldEJvdW5kYXJ5KCksXG4gICAgICAgICdjb250ZW50LWxlbmd0aCc6IHRoaXMuZ2V0TGVuZ3RoU3luYygpXG4gICAgfTtcblxuICAgIHJldHVybiBmb3JtSGVhZGVycztcbn1cblxuRm9ybURhdGEucHJvdG90eXBlLmdldEJvdW5kYXJ5ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fYm91bmRhcnkpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZUJvdW5kYXJ5KCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fYm91bmRhcnk7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuX2dlbmVyYXRlQm91bmRhcnkgPSBmdW5jdGlvbigpIHtcbiAgLy8gVGhpcyBnZW5lcmF0ZXMgYSA1MCBjaGFyYWN0ZXIgYm91bmRhcnkgc2ltaWxhciB0byB0aG9zZSB1c2VkIGJ5IEZpcmVmb3guXG4gIC8vIFRoZXkgYXJlIG9wdGltaXplZCBmb3IgYm95ZXItbW9vcmUgcGFyc2luZy5cbiAgdmFyIGJvdW5kYXJ5ID0gJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gICAgYm91bmRhcnkgKz0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApLnRvU3RyaW5nKDE2KTtcbiAgfVxuXG4gIHRoaXMuX2JvdW5kYXJ5ID0gYm91bmRhcnk7XG59O1xuXG5Gb3JtRGF0YS5wcm90b3R5cGUuZ2V0TGVuZ3RoU3luYyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBrbm93bkxlbmd0aCA9IHRoaXMuX292ZXJoZWFkTGVuZ3RoICsgdGhpcy5fdmFsdWVMZW5ndGg7XG5cbiAgICBpZiAodGhpcy5fc3RyZWFtcy5sZW5ndGgpIHtcbiAgICAgICAga25vd25MZW5ndGggKz0gdGhpcy5fbGFzdEJvdW5kYXJ5KCkubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBrbm93bkxlbmd0aDtcbn07XG5cbkZvcm1EYXRhLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbihjYikge1xuICB2YXIga25vd25MZW5ndGggPSB0aGlzLl9vdmVyaGVhZExlbmd0aCArIHRoaXMuX3ZhbHVlTGVuZ3RoO1xuXG4gIGlmICh0aGlzLl9zdHJlYW1zLmxlbmd0aCkge1xuICAgIGtub3duTGVuZ3RoICs9IHRoaXMuX2xhc3RCb3VuZGFyeSgpLmxlbmd0aDtcbiAgfVxuXG4gIGlmICghdGhpcy5fbGVuZ3RoUmV0cmlldmVycy5sZW5ndGgpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLmJpbmQodGhpcywgbnVsbCwga25vd25MZW5ndGgpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBhc3luYy5wYXJhbGxlbCh0aGlzLl9sZW5ndGhSZXRyaWV2ZXJzLCBmdW5jdGlvbihlcnIsIHZhbHVlcykge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNiKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgICBrbm93bkxlbmd0aCArPSBsZW5ndGg7XG4gICAgfSk7XG5cbiAgICBjYihudWxsLCBrbm93bkxlbmd0aCk7XG4gIH0pO1xufTtcblxuRm9ybURhdGEucHJvdG90eXBlLnN1Ym1pdCA9IGZ1bmN0aW9uKHBhcmFtcywgY2IpIHtcbiAgdGhpcy5nZXRMZW5ndGgoZnVuY3Rpb24oZXJyLCBsZW5ndGgpIHtcblxuICAgIHZhciByZXF1ZXN0XG4gICAgICAsIG9wdGlvbnNcbiAgICAgICwgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgbWV0aG9kIDogJ3Bvc3QnLFxuICAgICAgICAgIHBvcnQgICA6IDgwLFxuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0SGVhZGVycyh7J0NvbnRlbnQtTGVuZ3RoJzogbGVuZ3RofSlcbiAgICAgIH07XG5cbiAgICAvLyBwYXJzZSBwcm92aWRlZCB1cmwgaWYgaXQncyBzdHJpbmdcbiAgICAvLyBvciB0cmVhdCBpdCBhcyBvcHRpb25zIG9iamVjdFxuICAgIGlmICh0eXBlb2YgcGFyYW1zID09ICdzdHJpbmcnKSB7XG4gICAgICBwYXJhbXMgPSBwYXJzZVVybChwYXJhbXMpO1xuXG4gICAgICBvcHRpb25zID0gcG9wdWxhdGUoe1xuICAgICAgICBwb3J0OiBwYXJhbXMucG9ydCxcbiAgICAgICAgcGF0aDogcGFyYW1zLnBhdGhuYW1lLFxuICAgICAgICBob3N0OiBwYXJhbXMuaG9zdG5hbWVcbiAgICAgIH0sIGRlZmF1bHRzKTtcbiAgICB9XG4gICAgZWxzZSAvLyB1c2UgY3VzdG9tIHBhcmFtc1xuICAgIHtcbiAgICAgIG9wdGlvbnMgPSBwb3B1bGF0ZShwYXJhbXMsIGRlZmF1bHRzKTtcbiAgICB9XG5cbiAgICAvLyBodHRwcyBpZiBzcGVjaWZpZWQsIGZhbGxiYWNrIHRvIGh0dHAgaW4gYW55IG90aGVyIGNhc2VcbiAgICBpZiAocGFyYW1zLnByb3RvY29sID09ICdodHRwczonKSB7XG4gICAgICAvLyBvdmVycmlkZSBkZWZhdWx0IHBvcnRcbiAgICAgIGlmICghcGFyYW1zLnBvcnQpIG9wdGlvbnMucG9ydCA9IDQ0MztcbiAgICAgIHJlcXVlc3QgPSBodHRwcy5yZXF1ZXN0KG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0ID0gaHR0cC5yZXF1ZXN0KG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHRoaXMucGlwZShyZXF1ZXN0KTtcbiAgICBpZiAoY2IpIHtcbiAgICAgIHJlcXVlc3Qub24oJ2Vycm9yJywgY2IpO1xuICAgICAgcmVxdWVzdC5vbigncmVzcG9uc2UnLCBjYi5iaW5kKHRoaXMsIG51bGwpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbi8qXG4gKiBTYW50YSdzIGxpdHRsZSBoZWxwZXJzXG4gKi9cblxuLy8gcG9wdWxhdGVzIG1pc3NpbmcgdmFsdWVzXG5mdW5jdGlvbiBwb3B1bGF0ZShkc3QsIHNyYykge1xuICBmb3IgKHZhciBwcm9wIGluIHNyYykge1xuICAgIGlmICghZHN0W3Byb3BdKSBkc3RbcHJvcF0gPSBzcmNbcHJvcF07XG4gIH1cbiAgcmV0dXJuIGRzdDtcbn1cblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpLHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfYnVmZmVyXCIpLkJ1ZmZlcikiLCIvKipcbiAqIFRoaXMgY2hlYXAgcmVwbGljYSBvZiBET00vQnVpbGRlciBwdXRzIG1lIHRvIHNoYW1lIDotKVxuICpcbiAqIEF0dHJpYnV0ZXMgYXJlIGluIHRoZSBlbGVtZW50LmF0dHJzIG9iamVjdC4gQ2hpbGRyZW4gaXMgYSBsaXN0IG9mXG4gKiBlaXRoZXIgb3RoZXIgRWxlbWVudHMgb3IgU3RyaW5ncyBmb3IgdGV4dCBjb250ZW50LlxuICoqL1xuZnVuY3Rpb24gRWxlbWVudChuYW1lLCBhdHRycykge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuYXR0cnMgPSBhdHRycyB8fCB7fTtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG59XG5cbi8qKiogQWNjZXNzb3JzICoqKi9cblxuLyoqXG4gKiBpZiAoZWxlbWVudC5pcygnbWVzc2FnZScsICdqYWJiZXI6Y2xpZW50JykpIC4uLlxuICoqL1xuRWxlbWVudC5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbihuYW1lLCB4bWxucykge1xuICAgIHJldHVybiB0aGlzLmdldE5hbWUoKSA9PSBuYW1lICYmXG4gICAgICAgICgheG1sbnMgfHwgdGhpcy5nZXROUygpID09IHhtbG5zKTtcbn07XG5cbi8qIHdpdGhvdXQgcHJlZml4ICovXG5FbGVtZW50LnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubmFtZS5pbmRleE9mKFwiOlwiKSA+PSAwKVxuICAgICAgICByZXR1cm4gdGhpcy5uYW1lLnN1YnN0cih0aGlzLm5hbWUuaW5kZXhPZihcIjpcIikgKyAxKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG59O1xuXG4vKipcbiAqIHJldHJpZXZlcyB0aGUgbmFtZXNwYWNlIG9mIHRoZSBjdXJyZW50IGVsZW1lbnQsIHVwd2FyZHMgcmVjdXJzaXZlbHlcbiAqKi9cbkVsZW1lbnQucHJvdG90eXBlLmdldE5TID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubmFtZS5pbmRleE9mKFwiOlwiKSA+PSAwKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSB0aGlzLm5hbWUuc3Vic3RyKDAsIHRoaXMubmFtZS5pbmRleE9mKFwiOlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmROUyhwcmVmaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmROUygpO1xuICAgIH1cbn07XG5cbi8qKlxuICogZmluZCB0aGUgbmFtZXNwYWNlIHRvIHRoZSBnaXZlbiBwcmVmaXgsIHVwd2FyZHMgcmVjdXJzaXZlbHlcbiAqKi9cbkVsZW1lbnQucHJvdG90eXBlLmZpbmROUyA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIGlmICghcHJlZml4KSB7XG4gICAgICAgIC8qIGRlZmF1bHQgbmFtZXNwYWNlICovXG4gICAgICAgIGlmICh0aGlzLmF0dHJzLnhtbG5zKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnMueG1sbnM7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmZpbmROUygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIHByZWZpeGVkIG5hbWVzcGFjZSAqL1xuICAgICAgICB2YXIgYXR0ciA9ICd4bWxuczonICsgcHJlZml4O1xuICAgICAgICBpZiAodGhpcy5hdHRyc1thdHRyXSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJzW2F0dHJdO1xuICAgICAgICBlbHNlIGlmICh0aGlzLnBhcmVudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5maW5kTlMocHJlZml4KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIHhtbG5zIGNhbiBiZSBudWxsXG4gKiovXG5FbGVtZW50LnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uKG5hbWUsIHhtbG5zKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2hpbGRyZW4obmFtZSwgeG1sbnMpWzBdO1xufTtcblxuLyoqXG4gKiB4bWxucyBjYW4gYmUgbnVsbFxuICoqL1xuRWxlbWVudC5wcm90b3R5cGUuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbihuYW1lLCB4bWxucykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoY2hpbGQuZ2V0TmFtZSAmJlxuICAgICAgICAgICAgY2hpbGQuZ2V0TmFtZSgpID09IG5hbWUgJiZcbiAgICAgICAgICAgICgheG1sbnMgfHwgY2hpbGQuZ2V0TlMoKSA9PSB4bWxucykpXG4gICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIHhtbG5zIGFuZCByZWN1cnNpdmUgY2FuIGJlIG51bGxcbiAqKi9cbkVsZW1lbnQucHJvdG90eXBlLmdldENoaWxkQnlBdHRyID0gZnVuY3Rpb24oYXR0ciwgdmFsLCB4bWxucywgcmVjdXJzaXZlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2hpbGRyZW5CeUF0dHIoYXR0ciwgdmFsLCB4bWxucywgcmVjdXJzaXZlKVswXTtcbn07XG5cbi8qKlxuICogeG1sbnMgYW5kIHJlY3Vyc2l2ZSBjYW4gYmUgbnVsbFxuICoqL1xuRWxlbWVudC5wcm90b3R5cGUuZ2V0Q2hpbGRyZW5CeUF0dHIgPSBmdW5jdGlvbihhdHRyLCB2YWwsIHhtbG5zLCByZWN1cnNpdmUpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGNoaWxkLmF0dHJzICYmXG4gICAgICAgICAgICBjaGlsZC5hdHRyc1thdHRyXSA9PSB2YWwgJiZcbiAgICAgICAgICAgICgheG1sbnMgfHwgY2hpbGQuZ2V0TlMoKSA9PSB4bWxucykpXG4gICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgIGlmIChyZWN1cnNpdmUgJiYgY2hpbGQuZ2V0Q2hpbGRyZW5CeUF0dHIpXG4gICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZC5nZXRDaGlsZHJlbkJ5QXR0cihhdHRyLCB2YWwsIHhtbG5zLCB0cnVlKSk7XG4gICAgfVxuICAgIGlmIChyZWN1cnNpdmUpIHJlc3VsdCA9IFtdLmNvbmNhdC5hcHBseShbXSwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuRWxlbWVudC5wcm90b3R5cGUuZ2V0Q2hpbGRyZW5CeUZpbHRlciA9IGZ1bmN0aW9uKGZpbHRlciwgcmVjdXJzaXZlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChmaWx0ZXIoY2hpbGQpKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICBpZiAocmVjdXJzaXZlICYmIGNoaWxkLmdldENoaWxkcmVuQnlGaWx0ZXIpe1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQuZ2V0Q2hpbGRyZW5CeUZpbHRlcihmaWx0ZXIsIHRydWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVjdXJzaXZlKXtcbiAgICAgIHJlc3VsdCA9IFtdLmNvbmNhdC5hcHBseShbXSwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkVsZW1lbnQucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGV4dCA9IFwiXCI7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXVxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHRleHQgKz0gY2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xufTtcblxuRWxlbWVudC5wcm90b3R5cGUuZ2V0Q2hpbGRUZXh0ID0gZnVuY3Rpb24obmFtZSwgeG1sbnMpIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLmdldENoaWxkKG5hbWUsIHhtbG5zKTtcbiAgICByZXR1cm4gY2hpbGQgPyBjaGlsZC5nZXRUZXh0KCkgOiBudWxsO1xufTtcblxuLyoqKiBCdWlsZGVyICoqKi9cblxuLyoqIHJldHVybnMgdXBwZXJtb3N0IHBhcmVudCAqL1xuRWxlbWVudC5wcm90b3R5cGUucm9vdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnBhcmVudClcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnJvb3QoKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB0aGlzO1xufTtcbkVsZW1lbnQucHJvdG90eXBlLnRyZWUgPSBFbGVtZW50LnByb3RvdHlwZS5yb290O1xuXG4vKioganVzdCBwYXJlbnQgb3IgaXRzZWxmICovXG5FbGVtZW50LnByb3RvdHlwZS51cCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnBhcmVudClcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiogY3JlYXRlIGNoaWxkIG5vZGUgYW5kIHJldHVybiBpdCAqL1xuRWxlbWVudC5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJzKSB7XG4gICAgcmV0dXJuIHRoaXMuY25vZGUobmV3IEVsZW1lbnQobmFtZSwgYXR0cnMpKTtcbn07XG5cbkVsZW1lbnQucHJvdG90eXBlLmNub2RlID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgcmV0dXJuIGNoaWxkO1xufTtcblxuLyoqIGFkZCB0ZXh0IG5vZGUgYW5kIHJldHVybiBlbGVtZW50ICovXG5FbGVtZW50LnByb3RvdHlwZS50ID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaCh0ZXh0KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKiogTWFuaXB1bGF0aW9uICoqKi9cblxuLyoqXG4gKiBFaXRoZXI6XG4gKiAgIGVsLnJlbW92ZShjaGlsZEVsKTtcbiAqICAgZWwucmVtb3ZlKCdhdXRob3InLCAndXJuOi4uLicpO1xuICovXG5FbGVtZW50LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihlbCwgeG1sbnMpIHtcbiAgICB2YXIgZmlsdGVyO1xuICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG5cdC8qIDFzdCBwYXJhbWV0ZXIgaXMgdGFnIG5hbWUgKi9cblx0ZmlsdGVyID0gZnVuY3Rpb24oY2hpbGQpIHtcblx0ICAgIHJldHVybiAhKGNoaWxkLmlzICYmXG5cdFx0ICAgICBjaGlsZC5pcyhlbCwgeG1sbnMpKTtcblx0fTtcbiAgICB9IGVsc2Uge1xuXHQvKiAxc3QgcGFyYW1ldGVyIGlzIGVsZW1lbnQgKi9cblx0ZmlsdGVyID0gZnVuY3Rpb24oY2hpbGQpIHtcblx0ICAgIHJldHVybiBjaGlsZCAhPT0gZWw7XG5cdH07XG4gICAgfVxuXG4gICAgdGhpcy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uZmlsdGVyKGZpbHRlcik7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVG8gdXNlIGluIGNhc2UgeW91IHdhbnQgdGhlIHNhbWUgWE1MIGRhdGEgZm9yIHNlcGFyYXRlIHVzZXMuXG4gKiBQbGVhc2UgcmVmcmFpbiBmcm9tIHRoaXMgcHJhY3Rpc2UgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91IGFyZVxuICogZG9pbmcuIEJ1aWxkaW5nIFhNTCB3aXRoIGx0eCBpcyBlYXN5IVxuICovXG5FbGVtZW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjbG9uZSA9IG5ldyBFbGVtZW50KHRoaXMubmFtZSwge30pO1xuICAgIGZvcih2YXIgayBpbiB0aGlzLmF0dHJzKSB7XG5cdGlmICh0aGlzLmF0dHJzLmhhc093blByb3BlcnR5KGspKVxuXHQgICAgY2xvbmUuYXR0cnNba10gPSB0aGlzLmF0dHJzW2tdO1xuICAgIH1cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuXHRjbG9uZS5jbm9kZShjaGlsZC5jbG9uZSA/IGNoaWxkLmNsb25lKCkgOiBjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbn07XG5cbkVsZW1lbnQucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICBpZih2YWwgJiYgdGhpcy5jaGlsZHJlbi5sZW5ndGggPT0gMSl7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5bMF0gPSB2YWw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRUZXh0KCk7XG59O1xuXG5FbGVtZW50LnByb3RvdHlwZS5hdHRyID0gZnVuY3Rpb24oYXR0ciwgdmFsKSB7XG4gICAgaWYgKCEodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsID09PSBudWxsKSkge1xuICAgICAgICBpZighdGhpcy5hdHRycyl7XG4gICAgICAgICAgdGhpcy5hdHRycyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXR0cnNbYXR0cl0gPSB2YWw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hdHRyc1thdHRyXTtcbn07XG5cbi8qKiogU2VyaWFsaXphdGlvbiAqKiovXG5cbkVsZW1lbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHMgPSBcIlwiO1xuICAgIHRoaXMud3JpdGUoZnVuY3Rpb24oYykge1xuICAgICAgICBzICs9IGM7XG4gICAgfSk7XG4gICAgcmV0dXJuIHM7XG59O1xuXG5FbGVtZW50LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHdyaXRlcikge1xuICAgIHdyaXRlcihcIjxcIik7XG4gICAgd3JpdGVyKHRoaXMubmFtZSk7XG4gICAgZm9yKHZhciBrIGluIHRoaXMuYXR0cnMpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLmF0dHJzW2tdO1xuXHRpZiAodiB8fCB2ID09PSAnJyB8fCB2ID09PSAwKSB7XG5cdCAgICB3cml0ZXIoXCIgXCIpO1xuICAgICAgICAgICAgd3JpdGVyKGspO1xuICAgICAgICAgICAgd3JpdGVyKFwiPVxcXCJcIik7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgIT0gJ3N0cmluZycpXG5cdFx0diA9IHYudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHdyaXRlcihlc2NhcGVYbWwodikpO1xuICAgICAgICAgICAgd3JpdGVyKFwiXFxcIlwiKTtcblx0fVxuICAgIH1cbiAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT0gMCkge1xuICAgICAgICB3cml0ZXIoXCIvPlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZXIoXCI+XCIpO1xuXHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcblx0ICAgIC8qIFNraXAgbnVsbC91bmRlZmluZWQgKi9cblx0ICAgIGlmIChjaGlsZCB8fCBjaGlsZCA9PT0gMCkge1xuXHRcdGlmIChjaGlsZC53cml0ZSlcblx0XHQgICAgY2hpbGQud3JpdGUod3JpdGVyKTtcblx0XHRlbHNlIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnKVxuXHRcdFx0d3JpdGVyKGVzY2FwZVhtbFRleHQoY2hpbGQpKTtcblx0XHRlbHNlIGlmIChjaGlsZC50b1N0cmluZylcblx0XHRcdHdyaXRlcihlc2NhcGVYbWxUZXh0KGNoaWxkLnRvU3RyaW5nKCkpKTtcblx0ICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIoXCI8L1wiKTtcbiAgICAgICAgd3JpdGVyKHRoaXMubmFtZSk7XG4gICAgICAgIHdyaXRlcihcIj5cIik7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZXNjYXBlWG1sKHMpIHtcbiAgICByZXR1cm4gcy5cbiAgICAgICAgcmVwbGFjZSgvXFwmL2csICcmYW1wOycpLlxuICAgICAgICByZXBsYWNlKC88L2csICcmbHQ7JykuXG4gICAgICAgIHJlcGxhY2UoLz4vZywgJyZndDsnKS5cbiAgICAgICAgcmVwbGFjZSgvXCIvZywgJyZxdW90OycpLlxuICAgICAgICByZXBsYWNlKC8nL2csICcmYXBvczsnKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlWG1sVGV4dChzKSB7XG4gICAgcmV0dXJuIHMuXG4gICAgICAgIHJlcGxhY2UoL1xcJi9nLCAnJmFtcDsnKS5cbiAgICAgICAgcmVwbGFjZSgvPC9nLCAnJmx0OycpLlxuICAgICAgICByZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG59XG5cbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLmVzY2FwZVhtbCA9IGVzY2FwZVhtbDtcbiIsIi8vIENvcHlyaWdodCAyMDEyIEpveWVudCwgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuXG5cbi8vLy0tLSBHbG9iYWxzXG5cbnZhciBBbGdvcml0aG1zID0ge1xuICAncnNhLXNoYTEnOiB0cnVlLFxuICAncnNhLXNoYTI1Nic6IHRydWUsXG4gICdyc2Etc2hhNTEyJzogdHJ1ZSxcbiAgJ2RzYS1zaGExJzogdHJ1ZSxcbiAgJ2htYWMtc2hhMSc6IHRydWUsXG4gICdobWFjLXNoYTI1Nic6IHRydWUsXG4gICdobWFjLXNoYTUxMic6IHRydWVcbn07XG5cbnZhciBTdGF0ZSA9IHtcbiAgTmV3OiAwLFxuICBQYXJhbXM6IDFcbn07XG5cbnZhciBQYXJhbXNTdGF0ZSA9IHtcbiAgTmFtZTogMCxcbiAgUXVvdGU6IDEsXG4gIFZhbHVlOiAyLFxuICBDb21tYTogM1xufTtcblxuXG5cbi8vLy0tLSBTcGVjaWZpYyBFcnJvcnNcblxuZnVuY3Rpb24gSHR0cFNpZ25hdHVyZUVycm9yKG1lc3NhZ2UsIGNhbGxlcikge1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgY2FsbGVyIHx8IEh0dHBTaWduYXR1cmVFcnJvcik7XG5cbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5uYW1lID0gY2FsbGVyLm5hbWU7XG59XG51dGlsLmluaGVyaXRzKEh0dHBTaWduYXR1cmVFcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiBFeHBpcmVkUmVxdWVzdEVycm9yKG1lc3NhZ2UpIHtcbiAgSHR0cFNpZ25hdHVyZUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSwgRXhwaXJlZFJlcXVlc3RFcnJvcik7XG59XG51dGlsLmluaGVyaXRzKEV4cGlyZWRSZXF1ZXN0RXJyb3IsIEh0dHBTaWduYXR1cmVFcnJvcik7XG5cblxuZnVuY3Rpb24gSW52YWxpZEhlYWRlckVycm9yKG1lc3NhZ2UpIHtcbiAgSHR0cFNpZ25hdHVyZUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSwgSW52YWxpZEhlYWRlckVycm9yKTtcbn1cbnV0aWwuaW5oZXJpdHMoSW52YWxpZEhlYWRlckVycm9yLCBIdHRwU2lnbmF0dXJlRXJyb3IpO1xuXG5cbmZ1bmN0aW9uIEludmFsaWRQYXJhbXNFcnJvcihtZXNzYWdlKSB7XG4gIEh0dHBTaWduYXR1cmVFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UsIEludmFsaWRQYXJhbXNFcnJvcik7XG59XG51dGlsLmluaGVyaXRzKEludmFsaWRQYXJhbXNFcnJvciwgSHR0cFNpZ25hdHVyZUVycm9yKTtcblxuXG5mdW5jdGlvbiBNaXNzaW5nSGVhZGVyRXJyb3IobWVzc2FnZSkge1xuICBIdHRwU2lnbmF0dXJlRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlLCBNaXNzaW5nSGVhZGVyRXJyb3IpO1xufVxudXRpbC5pbmhlcml0cyhNaXNzaW5nSGVhZGVyRXJyb3IsIEh0dHBTaWduYXR1cmVFcnJvcik7XG5cblxuXG4vLy8tLS0gRXhwb3J0ZWQgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlICdBdXRob3JpemF0aW9uJyBoZWFkZXIgb3V0IG9mIGFuIGh0dHAuU2VydmVyUmVxdWVzdCBvYmplY3QuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIEFQSSB3aWxsIGZ1bGx5IHZhbGlkYXRlIHRoZSBBdXRob3JpemF0aW9uIGhlYWRlciwgYW5kIHRocm93XG4gICAqIG9uIGFueSBlcnJvci4gIEl0IHdpbGwgbm90IGhvd2V2ZXIgY2hlY2sgdGhlIHNpZ25hdHVyZSwgb3IgdGhlIGtleUlkIGZvcm1hdFxuICAgKiBhcyB0aG9zZSBhcmUgc3BlY2lmaWMgdG8geW91ciBlbnZpcm9ubWVudC4gIFlvdSBjYW4gdXNlIHRoZSBvcHRpb25zIG9iamVjdFxuICAgKiB0byBwYXNzIGluIGV4dHJhIGNvbnN0cmFpbnRzLlxuICAgKlxuICAgKiBBcyBhIHJlc3BvbnNlIG9iamVjdCB5b3UgY2FuIGV4cGVjdCB0aGlzOlxuICAgKlxuICAgKiAgICAge1xuICAgKiAgICAgICBcInNjaGVtZVwiOiBcIlNpZ25hdHVyZVwiLFxuICAgKiAgICAgICBcInBhcmFtc1wiOiB7XG4gICAqICAgICAgICAgXCJrZXlJZFwiOiBcImZvb1wiLFxuICAgKiAgICAgICAgIFwiYWxnb3JpdGhtXCI6IFwicnNhLXNoYTI1NlwiLFxuICAgKiAgICAgICAgIFwiaGVhZGVyc1wiOiBbXG4gICAqICAgICAgICAgICBcImRhdGVcIiBvciBcIngtZGF0ZVwiLFxuICAgKiAgICAgICAgICAgXCJjb250ZW50LW1kNVwiXG4gICAqICAgICAgICAgXSxcbiAgICogICAgICAgICBcInNpZ25hdHVyZVwiOiBcImJhc2U2NFwiXG4gICAqICAgICAgIH0sXG4gICAqICAgICAgIFwic2lnbmluZ1N0cmluZ1wiOiBcInJlYWR5IHRvIGJlIHBhc3NlZCB0byBjcnlwdG8udmVyaWZ5KClcIlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCBhbiBodHRwLlNlcnZlclJlcXVlc3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHdpdGg6XG4gICAqICAgICAgICAgICAgICAgICAgIC0gY2xvY2tTa2V3OiBhbGxvd2VkIGNsb2NrIHNrZXcgaW4gc2Vjb25kcyAoZGVmYXVsdCAzMDApLlxuICAgKiAgICAgICAgICAgICAgICAgICAtIGhlYWRlcnM6IHJlcXVpcmVkIGhlYWRlciBuYW1lcyAoZGVmOiBkYXRlIG9yIHgtZGF0ZSlcbiAgICogICAgICAgICAgICAgICAgICAgLSBhbGdvcml0aG1zOiBhbGdvcml0aG1zIHRvIHN1cHBvcnQgKGRlZmF1bHQ6IGFsbCkuXG4gICAqIEByZXR1cm4ge09iamVjdH0gcGFyc2VkIG91dCBvYmplY3QgKHNlZSBhYm92ZSkuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gb24gaW52YWxpZCBpbnB1dC5cbiAgICogQHRocm93cyB7SW52YWxpZEhlYWRlckVycm9yfSBvbiBhbiBpbnZhbGlkIEF1dGhvcml6YXRpb24gaGVhZGVyIGVycm9yLlxuICAgKiBAdGhyb3dzIHtJbnZhbGlkUGFyYW1zRXJyb3J9IGlmIHRoZSBwYXJhbXMgaW4gdGhlIHNjaGVtZSBhcmUgaW52YWxpZC5cbiAgICogQHRocm93cyB7TWlzc2luZ0hlYWRlckVycm9yfSBpZiB0aGUgcGFyYW1zIGluZGljYXRlIGEgaGVhZGVyIG5vdCBwcmVzZW50LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVpdGhlciBpbiB0aGUgcmVxdWVzdCBoZWFkZXJzIGZyb20gdGhlIHBhcmFtcyxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBub3QgaW4gdGhlIHBhcmFtcyBmcm9tIGEgcmVxdWlyZWQgaGVhZGVyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gb3B0aW9ucy5cbiAgICogQHRocm93cyB7RXhwaXJlZFJlcXVlc3RFcnJvcn0gaWYgdGhlIHZhbHVlIG9mIGRhdGUgb3IgeC1kYXRlIGV4Y2VlZHMgc2tldy5cbiAgICovXG4gIHBhcnNlUmVxdWVzdDogZnVuY3Rpb24gcGFyc2VSZXF1ZXN0KHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnQub2JqZWN0KHJlcXVlc3QsICdyZXF1ZXN0Jyk7XG4gICAgYXNzZXJ0Lm9iamVjdChyZXF1ZXN0LmhlYWRlcnMsICdyZXF1ZXN0LmhlYWRlcnMnKTtcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhlYWRlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy5oZWFkZXJzID0gW3JlcXVlc3QuaGVhZGVyc1sneC1kYXRlJ10gPyAneC1kYXRlJyA6ICdkYXRlJ107XG4gICAgfVxuICAgIGFzc2VydC5vYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKTtcbiAgICBhc3NlcnQuYXJyYXlPZlN0cmluZyhvcHRpb25zLmhlYWRlcnMsICdvcHRpb25zLmhlYWRlcnMnKTtcbiAgICBhc3NlcnQub3B0aW9uYWxOdW1iZXIob3B0aW9ucy5jbG9ja1NrZXcsICdvcHRpb25zLmNsb2NrU2tldycpO1xuXG4gICAgaWYgKCFyZXF1ZXN0LmhlYWRlcnMuYXV0aG9yaXphdGlvbilcbiAgICAgIHRocm93IG5ldyBNaXNzaW5nSGVhZGVyRXJyb3IoJ25vIGF1dGhvcml6YXRpb24gaGVhZGVyIHByZXNlbnQgaW4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0aGUgcmVxdWVzdCcpO1xuXG4gICAgb3B0aW9ucy5jbG9ja1NrZXcgPSBvcHRpb25zLmNsb2NrU2tldyB8fCAzMDA7XG5cblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgc3RhdGUgPSBTdGF0ZS5OZXc7XG4gICAgdmFyIHN1YnN0YXRlID0gUGFyYW1zU3RhdGUuTmFtZTtcbiAgICB2YXIgdG1wTmFtZSA9ICcnO1xuICAgIHZhciB0bXBWYWx1ZSA9ICcnO1xuXG4gICAgdmFyIHBhcnNlZCA9IHtcbiAgICAgIHNjaGVtZTogJycsXG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgc2lnbmluZ1N0cmluZzogJycsXG5cbiAgICAgIGdldCBhbGdvcml0aG0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5hbGdvcml0aG0udG9VcHBlckNhc2UoKTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCBrZXlJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLmtleUlkO1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIHZhciBhdXRoeiA9IHJlcXVlc3QuaGVhZGVycy5hdXRob3JpemF0aW9uO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhdXRoei5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBhdXRoei5jaGFyQXQoaSk7XG5cbiAgICAgIHN3aXRjaCAoTnVtYmVyKHN0YXRlKSkge1xuXG4gICAgICBjYXNlIFN0YXRlLk5ldzpcbiAgICAgICAgaWYgKGMgIT09ICcgJykgcGFyc2VkLnNjaGVtZSArPSBjO1xuICAgICAgICBlbHNlIHN0YXRlID0gU3RhdGUuUGFyYW1zO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTdGF0ZS5QYXJhbXM6XG4gICAgICAgIHN3aXRjaCAoTnVtYmVyKHN1YnN0YXRlKSkge1xuXG4gICAgICAgIGNhc2UgUGFyYW1zU3RhdGUuTmFtZTpcbiAgICAgICAgICB2YXIgY29kZSA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAvLyByZXN0cmljdGVkIG5hbWUgb2YgQS1aIC8gYS16XG4gICAgICAgICAgaWYgKChjb2RlID49IDB4NDEgJiYgY29kZSA8PSAweDVhKSB8fCAvLyBBLVpcbiAgICAgICAgICAgICAgKGNvZGUgPj0gMHg2MSAmJiBjb2RlIDw9IDB4N2EpKSB7IC8vIGEtelxuICAgICAgICAgICAgdG1wTmFtZSArPSBjO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz0nKSB7XG4gICAgICAgICAgICBpZiAodG1wTmFtZS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ2JhZCBwYXJhbSBmb3JtYXQnKTtcbiAgICAgICAgICAgIHN1YnN0YXRlID0gUGFyYW1zU3RhdGUuUXVvdGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ2JhZCBwYXJhbSBmb3JtYXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXJhbXNTdGF0ZS5RdW90ZTpcbiAgICAgICAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICAgICAgdG1wVmFsdWUgPSAnJztcbiAgICAgICAgICAgIHN1YnN0YXRlID0gUGFyYW1zU3RhdGUuVmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ2JhZCBwYXJhbSBmb3JtYXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXJhbXNTdGF0ZS5WYWx1ZTpcbiAgICAgICAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICAgICAgcGFyc2VkLnBhcmFtc1t0bXBOYW1lXSA9IHRtcFZhbHVlO1xuICAgICAgICAgICAgc3Vic3RhdGUgPSBQYXJhbXNTdGF0ZS5Db21tYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG1wVmFsdWUgKz0gYztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXJhbXNTdGF0ZS5Db21tYTpcbiAgICAgICAgICBpZiAoYyA9PT0gJywnKSB7XG4gICAgICAgICAgICB0bXBOYW1lID0gJyc7XG4gICAgICAgICAgICBzdWJzdGF0ZSA9IFBhcmFtc1N0YXRlLk5hbWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ2JhZCBwYXJhbSBmb3JtYXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3Vic3RhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnN0YXRlJyk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoIXBhcnNlZC5wYXJhbXMuaGVhZGVycyB8fCBwYXJzZWQucGFyYW1zLmhlYWRlcnMgPT09ICcnKSB7XG4gICAgICBpZiAocmVxdWVzdC5oZWFkZXJzWyd4LWRhdGUnXSkge1xuICAgICAgICBwYXJzZWQucGFyYW1zLmhlYWRlcnMgPSBbJ3gtZGF0ZSddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkLnBhcmFtcy5oZWFkZXJzID0gWydkYXRlJ107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZC5wYXJhbXMuaGVhZGVycyA9IHBhcnNlZC5wYXJhbXMuaGVhZGVycy5zcGxpdCgnICcpO1xuICAgIH1cblxuICAgIC8vIE1pbmltYWxseSB2YWxpZGF0ZSB0aGUgcGFyc2VkIG9iamVjdFxuICAgIGlmICghcGFyc2VkLnNjaGVtZSB8fCBwYXJzZWQuc2NoZW1lICE9PSAnU2lnbmF0dXJlJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ3NjaGVtZSB3YXMgbm90IFwiU2lnbmF0dXJlXCInKTtcblxuICAgIGlmICghcGFyc2VkLnBhcmFtcy5rZXlJZClcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkSGVhZGVyRXJyb3IoJ2tleUlkIHdhcyBub3Qgc3BlY2lmaWVkJyk7XG5cbiAgICBpZiAoIXBhcnNlZC5wYXJhbXMuYWxnb3JpdGhtKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRIZWFkZXJFcnJvcignYWxnb3JpdGhtIHdhcyBub3Qgc3BlY2lmaWVkJyk7XG5cbiAgICBpZiAoIXBhcnNlZC5wYXJhbXMuc2lnbmF0dXJlKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRIZWFkZXJFcnJvcignc2lnbmF0dXJlIHdhcyBub3Qgc3BlY2lmaWVkJyk7XG5cbiAgICAvLyBDaGVjayB0aGUgYWxnb3JpdGhtIGFnYWluc3QgdGhlIG9mZmljaWFsIGxpc3RcbiAgICBwYXJzZWQucGFyYW1zLmFsZ29yaXRobSA9IHBhcnNlZC5wYXJhbXMuYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCFBbGdvcml0aG1zW3BhcnNlZC5wYXJhbXMuYWxnb3JpdGhtXSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUGFyYW1zRXJyb3IocGFyc2VkLnBhcmFtcy5hbGdvcml0aG0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGlzIG5vdCBzdXBwb3J0ZWQnKTtcblxuICAgIC8vIEJ1aWxkIHRoZSBzaWduaW5nU3RyaW5nXG4gICAgZm9yIChpID0gMDsgaSA8IHBhcnNlZC5wYXJhbXMuaGVhZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGggPSBwYXJzZWQucGFyYW1zLmhlYWRlcnNbaV0udG9Mb3dlckNhc2UoKTtcbiAgICAgIHBhcnNlZC5wYXJhbXMuaGVhZGVyc1tpXSA9IGg7XG5cbiAgICAgIGlmIChoICE9PSAncmVxdWVzdC1saW5lJykge1xuICAgICAgICB2YXIgdmFsdWUgPSByZXF1ZXN0LmhlYWRlcnNbaF07XG4gICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdIZWFkZXJFcnJvcihoICsgJyB3YXMgbm90IGluIHRoZSByZXF1ZXN0Jyk7XG4gICAgICAgIHBhcnNlZC5zaWduaW5nU3RyaW5nICs9IGggKyAnOiAnICsgdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWQuc2lnbmluZ1N0cmluZyArPVxuICAgICAgICAgIHJlcXVlc3QubWV0aG9kICsgJyAnICsgcmVxdWVzdC51cmwgKyAnIEhUVFAvJyArIHJlcXVlc3QuaHR0cFZlcnNpb247XG4gICAgICB9XG5cbiAgICAgIGlmICgoaSArIDEpIDwgcGFyc2VkLnBhcmFtcy5oZWFkZXJzLmxlbmd0aClcbiAgICAgICAgcGFyc2VkLnNpZ25pbmdTdHJpbmcgKz0gJ1xcbic7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgYWdhaW5zdCB0aGUgY29uc3RyYWludHNcbiAgICB2YXIgZGF0ZTtcbiAgICBpZiAocmVxdWVzdC5oZWFkZXJzLmRhdGUgfHwgcmVxdWVzdC5oZWFkZXJzWyd4LWRhdGUnXSkge1xuICAgICAgICBpZiAocmVxdWVzdC5oZWFkZXJzWyd4LWRhdGUnXSkge1xuICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShyZXF1ZXN0LmhlYWRlcnNbJ3gtZGF0ZSddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRlID0gbmV3IERhdGUocmVxdWVzdC5oZWFkZXJzLmRhdGUpO1xuICAgICAgICB9XG4gICAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgIHZhciBza2V3ID0gTWF0aC5hYnMobm93LmdldFRpbWUoKSAtIGRhdGUuZ2V0VGltZSgpKTtcblxuICAgICAgaWYgKHNrZXcgPiBvcHRpb25zLmNsb2NrU2tldyAqIDEwMDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEV4cGlyZWRSZXF1ZXN0RXJyb3IoJ2Nsb2NrIHNrZXcgb2YgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChza2V3IC8gMTAwMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncyB3YXMgZ3JlYXRlciB0aGFuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNsb2NrU2tldyArICdzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3B0aW9ucy5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhkcikge1xuICAgICAgLy8gUmVtZW1iZXIgdGhhdCB3ZSBhbHJlYWR5IGNoZWNrZWQgYW55IGhlYWRlcnMgaW4gdGhlIHBhcmFtc1xuICAgICAgLy8gd2VyZSBpbiB0aGUgcmVxdWVzdCwgc28gaWYgdGhpcyBwYXNzZXMgd2UncmUgZ29vZC5cbiAgICAgIGlmIChwYXJzZWQucGFyYW1zLmhlYWRlcnMuaW5kZXhPZihoZHIpIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdIZWFkZXJFcnJvcihoZHIgKyAnIHdhcyBub3QgYSBzaWduZWQgaGVhZGVyJyk7XG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5hbGdvcml0aG1zKSB7XG4gICAgICBpZiAob3B0aW9ucy5hbGdvcml0aG1zLmluZGV4T2YocGFyc2VkLnBhcmFtcy5hbGdvcml0aG0pID09PSAtMSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQYXJhbXNFcnJvcihwYXJzZWQucGFyYW1zLmFsZ29yaXRobSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBpcyBub3QgYSBzdXBwb3J0ZWQgYWxnb3JpdGhtJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG59O1xuIiwiLy8gQ29weXJpZ2h0IDIwMTIgSm95ZW50LCBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0LXBsdXMnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuXG52YXIgc3ByaW50ZiA9IHJlcXVpcmUoJ3V0aWwnKS5mb3JtYXQ7XG5cblxuXG4vLy8tLS0gR2xvYmFsc1xuXG52YXIgQWxnb3JpdGhtcyA9IHtcbiAgJ3JzYS1zaGExJzogdHJ1ZSxcbiAgJ3JzYS1zaGEyNTYnOiB0cnVlLFxuICAncnNhLXNoYTUxMic6IHRydWUsXG4gICdkc2Etc2hhMSc6IHRydWUsXG4gICdobWFjLXNoYTEnOiB0cnVlLFxuICAnaG1hYy1zaGEyNTYnOiB0cnVlLFxuICAnaG1hYy1zaGE1MTInOiB0cnVlXG59O1xuXG52YXIgQXV0aG9yaXphdGlvbiA9XG4gICdTaWduYXR1cmUga2V5SWQ9XCIlc1wiLGFsZ29yaXRobT1cIiVzXCIsaGVhZGVycz1cIiVzXCIsc2lnbmF0dXJlPVwiJXNcIic7XG5cblxuXG4vLy8tLS0gU3BlY2lmaWMgRXJyb3JzXG5cbmZ1bmN0aW9uIE1pc3NpbmdIZWFkZXJFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5uYW1lID0gJ01pc3NpbmdIZWFkZXJFcnJvcic7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcbn1cbk1pc3NpbmdIZWFkZXJFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblxuXG5mdW5jdGlvbiBJbnZhbGlkQWxnb3JpdGhtRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkQWxnb3JpdGhtRXJyb3InO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG59XG5JbnZhbGlkQWxnb3JpdGhtRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cblxuXG4vLy8tLS0gSW50ZXJuYWwgRnVuY3Rpb25zXG5cbmZ1bmN0aW9uIF9wYWQodmFsKSB7XG4gIGlmIChwYXJzZUludCh2YWwsIDEwKSA8IDEwKSB7XG4gICAgdmFsID0gJzAnICsgdmFsO1xuICB9XG4gIHJldHVybiB2YWw7XG59XG5cblxuZnVuY3Rpb24gX3JmYzExMjMoKSB7XG4gIHZhciBkYXRlID0gbmV3IERhdGUoKTtcblxuICB2YXIgbW9udGhzID0gWydKYW4nLFxuICAgICAgICAgICAgICAgICdGZWInLFxuICAgICAgICAgICAgICAgICdNYXInLFxuICAgICAgICAgICAgICAgICdBcHInLFxuICAgICAgICAgICAgICAgICdNYXknLFxuICAgICAgICAgICAgICAgICdKdW4nLFxuICAgICAgICAgICAgICAgICdKdWwnLFxuICAgICAgICAgICAgICAgICdBdWcnLFxuICAgICAgICAgICAgICAgICdTZXAnLFxuICAgICAgICAgICAgICAgICdPY3QnLFxuICAgICAgICAgICAgICAgICdOb3YnLFxuICAgICAgICAgICAgICAgICdEZWMnXTtcbiAgdmFyIGRheXMgPSBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddO1xuICByZXR1cm4gZGF5c1tkYXRlLmdldFVUQ0RheSgpXSArICcsICcgK1xuICAgIF9wYWQoZGF0ZS5nZXRVVENEYXRlKCkpICsgJyAnICtcbiAgICBtb250aHNbZGF0ZS5nZXRVVENNb250aCgpXSArICcgJyArXG4gICAgZGF0ZS5nZXRVVENGdWxsWWVhcigpICsgJyAnICtcbiAgICBfcGFkKGRhdGUuZ2V0VVRDSG91cnMoKSkgKyAnOicgK1xuICAgIF9wYWQoZGF0ZS5nZXRVVENNaW51dGVzKCkpICsgJzonICtcbiAgICBfcGFkKGRhdGUuZ2V0VVRDU2Vjb25kcygpKSArXG4gICAgJyBHTVQnO1xufVxuXG5cblxuLy8vLS0tIEV4cG9ydGVkIEFQSVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKipcbiAgICogQWRkcyBhbiAnQXV0aG9yaXphdGlvbicgaGVhZGVyIHRvIGFuIGh0dHAuQ2xpZW50UmVxdWVzdCBvYmplY3QuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIEFQSSB3aWxsIGFkZCBhIERhdGUgaGVhZGVyIGlmIGl0J3Mgbm90IGFscmVhZHkgc2V0LiBBbnlcbiAgICogb3RoZXIgaGVhZGVycyBpbiB0aGUgb3B0aW9ucy5oZWFkZXJzIGFycmF5IE1VU1QgYmUgcHJlc2VudCwgb3IgdGhpc1xuICAgKiB3aWxsIHRocm93LlxuICAgKlxuICAgKiBZb3Ugc2hvdWxkbid0IG5lZWQgdG8gY2hlY2sgdGhlIHJldHVybiB0eXBlOyBpdCdzIGp1c3QgdGhlcmUgaWYgeW91IHdhbnRcbiAgICogdG8gYmUgcGVkYW50aWMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0IGFuIGluc3RhbmNlIG9mIGh0dHAuQ2xpZW50UmVxdWVzdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgc2lnbmluZyBwYXJhbWV0ZXJzIG9iamVjdDpcbiAgICogICAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBrZXlJZCByZXF1aXJlZC5cbiAgICogICAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBrZXkgcmVxdWlyZWQgKGVpdGhlciBhIFBFTSBvciBITUFDIGtleSkuXG4gICAqICAgICAgICAgICAgICAgICAgIC0ge0FycmF5fSBoZWFkZXJzIG9wdGlvbmFsOyBkZWZhdWx0cyB0byBbJ2RhdGUnXS5cbiAgICogICAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBhbGdvcml0aG0gb3B0aW9uYWw7IGRlZmF1bHRzIHRvICdyc2Etc2hhMjU2Jy5cbiAgICogICAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBodHRwVmVyc2lvbiBvcHRpb25hbDsgZGVmYXVsdHMgdG8gJzEuMScuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgQXV0aG9yaXphdGlvbiAoYW5kIG9wdGlvbmFsbHkgRGF0ZSkgd2VyZSBhZGRlZC5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBvbiBiYWQgcGFyYW1ldGVyIHR5cGVzIChpbnB1dCkuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRBbGdvcml0aG1FcnJvcn0gaWYgYWxnb3JpdGhtIHdhcyBiYWQuXG4gICAqIEB0aHJvd3Mge01pc3NpbmdIZWFkZXJFcnJvcn0gaWYgYSBoZWFkZXIgdG8gYmUgc2lnbmVkIHdhcyBzcGVjaWZpZWQgYnV0XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzIG5vdCBwcmVzZW50LlxuICAgKi9cbiAgc2lnblJlcXVlc3Q6IGZ1bmN0aW9uIHNpZ25SZXF1ZXN0KHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICBhc3NlcnQub2JqZWN0KHJlcXVlc3QsICdyZXF1ZXN0Jyk7XG4gICAgYXNzZXJ0Lm9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpO1xuICAgIGFzc2VydC5vcHRpb25hbFN0cmluZyhvcHRpb25zLmFsZ29yaXRobSwgJ29wdGlvbnMuYWxnb3JpdGhtJyk7XG4gICAgYXNzZXJ0LnN0cmluZyhvcHRpb25zLmtleUlkLCAnb3B0aW9ucy5rZXlJZCcpO1xuICAgIGFzc2VydC5vcHRpb25hbEFycmF5T2ZTdHJpbmcob3B0aW9ucy5oZWFkZXJzLCAnb3B0aW9ucy5oZWFkZXJzJyk7XG4gICAgYXNzZXJ0Lm9wdGlvbmFsU3RyaW5nKG9wdGlvbnMuaHR0cFZlcnNpb24sICdvcHRpb25zLmh0dHBWZXJzaW9uJyk7XG5cbiAgICBpZiAoIXJlcXVlc3QuZ2V0SGVhZGVyKCdEYXRlJykpXG4gICAgICByZXF1ZXN0LnNldEhlYWRlcignRGF0ZScsIF9yZmMxMTIzKCkpO1xuICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKVxuICAgICAgb3B0aW9ucy5oZWFkZXJzID0gWydkYXRlJ107XG4gICAgaWYgKCFvcHRpb25zLmFsZ29yaXRobSlcbiAgICAgIG9wdGlvbnMuYWxnb3JpdGhtID0gJ3JzYS1zaGEyNTYnO1xuICAgIGlmICghb3B0aW9ucy5odHRwVmVyc2lvbilcbiAgICAgIG9wdGlvbnMuaHR0cFZlcnNpb24gPSAnMS4xJztcblxuICAgIG9wdGlvbnMuYWxnb3JpdGhtID0gb3B0aW9ucy5hbGdvcml0aG0udG9Mb3dlckNhc2UoKTtcblxuICAgIGlmICghQWxnb3JpdGhtc1tvcHRpb25zLmFsZ29yaXRobV0pXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKG9wdGlvbnMuYWxnb3JpdGhtICsgJyBpcyBub3Qgc3VwcG9ydGVkJyk7XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgc3RyaW5nVG9TaWduID0gJyc7XG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMuaGVhZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiAob3B0aW9ucy5oZWFkZXJzW2ldKSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuaGVhZGVycyBtdXN0IGJlIGFuIGFycmF5IG9mIFN0cmluZ3MnKTtcblxuICAgICAgdmFyIGggPSBvcHRpb25zLmhlYWRlcnNbaV0udG9Mb3dlckNhc2UoKTtcblxuICAgICAgaWYgKGggIT09ICdyZXF1ZXN0LWxpbmUnKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlcXVlc3QuZ2V0SGVhZGVyKGgpO1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdIZWFkZXJFcnJvcihoICsgJyB3YXMgbm90IGluIHRoZSByZXF1ZXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaW5nVG9TaWduICs9IGggKyAnOiAnICsgdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9XG4gICAgICAgIHN0cmluZ1RvU2lnbiArPVxuICAgICAgICAgIHJlcXVlc3QubWV0aG9kICsgJyAnICsgcmVxdWVzdC5wYXRoICsgJyBIVFRQLycgKyBvcHRpb25zLmh0dHBWZXJzaW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGkgKyAxKSA8IG9wdGlvbnMuaGVhZGVycy5sZW5ndGgpXG4gICAgICAgIHN0cmluZ1RvU2lnbiArPSAnXFxuJztcbiAgICB9XG5cbiAgICB2YXIgYWxnID0gb3B0aW9ucy5hbGdvcml0aG0ubWF0Y2goLyhobWFjfHJzYSktKFxcdyspLyk7XG4gICAgdmFyIHNpZ25hdHVyZTtcbiAgICBpZiAoYWxnWzFdID09PSAnaG1hYycpIHtcbiAgICAgIHZhciBobWFjID0gY3J5cHRvLmNyZWF0ZUhtYWMoYWxnWzJdLnRvVXBwZXJDYXNlKCksIG9wdGlvbnMua2V5KTtcbiAgICAgIGhtYWMudXBkYXRlKHN0cmluZ1RvU2lnbik7XG4gICAgICBzaWduYXR1cmUgPSBobWFjLmRpZ2VzdCgnYmFzZTY0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzaWduZXIgPSBjcnlwdG8uY3JlYXRlU2lnbihvcHRpb25zLmFsZ29yaXRobS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgIHNpZ25lci51cGRhdGUoc3RyaW5nVG9TaWduKTtcbiAgICAgIHNpZ25hdHVyZSA9IHNpZ25lci5zaWduKG9wdGlvbnMua2V5LCAnYmFzZTY0Jyk7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5zZXRIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCBzcHJpbnRmKEF1dGhvcml6YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMua2V5SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYWxnb3JpdGhtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMuam9pbignICcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUpKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbn07XG4iLCIoZnVuY3Rpb24oQnVmZmVyKXsvLyBDb3B5cmlnaHQgMjAxMiBKb3llbnQsIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG52YXIgYXNuMSA9IHJlcXVpcmUoJ2FzbjEnKTtcbnZhciBjdHlwZSA9IHJlcXVpcmUoJ2N0eXBlJyk7XG5cblxuXG4vLy8tLS0gSGVscGVyc1xuXG5mdW5jdGlvbiByZWFkTmV4dChidWZmZXIsIG9mZnNldCkge1xuICB2YXIgbGVuID0gY3R5cGUucnVpbnQzMihidWZmZXIsICdiaWcnLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcblxuICB2YXIgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgbGVuO1xuXG4gIHJldHVybiB7XG4gICAgZGF0YTogYnVmZmVyLnNsaWNlKG9mZnNldCwgbmV3T2Zmc2V0KSxcbiAgICBvZmZzZXQ6IG5ld09mZnNldFxuICB9O1xufVxuXG5cbmZ1bmN0aW9uIHdyaXRlSW50KHdyaXRlciwgYnVmZmVyKSB7XG4gIHdyaXRlci53cml0ZUJ5dGUoMHgwMik7IC8vIEFTTjEuSW50ZWdlclxuICB3cml0ZXIud3JpdGVMZW5ndGgoYnVmZmVyLmxlbmd0aCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspXG4gICAgd3JpdGVyLndyaXRlQnl0ZShidWZmZXJbaV0pO1xuXG4gIHJldHVybiB3cml0ZXI7XG59XG5cblxuZnVuY3Rpb24gcnNhVG9QRU0oa2V5KSB7XG4gIHZhciBidWZmZXI7XG4gIHZhciBkZXI7XG4gIHZhciBleHBvbmVudDtcbiAgdmFyIGk7XG4gIHZhciBtb2R1bHVzO1xuICB2YXIgbmV3S2V5ID0gJyc7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgdHlwZTtcbiAgdmFyIHRtcDtcblxuICB0cnkge1xuICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXIoa2V5LnNwbGl0KCcgJylbMV0sICdiYXNlNjQnKTtcblxuICAgIHRtcCA9IHJlYWROZXh0KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICB0eXBlID0gdG1wLmRhdGEudG9TdHJpbmcoKTtcbiAgICBvZmZzZXQgPSB0bXAub2Zmc2V0O1xuXG4gICAgaWYgKHR5cGUgIT09ICdzc2gtcnNhJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzc2gga2V5IHR5cGU6ICcgKyB0eXBlKTtcblxuICAgIHRtcCA9IHJlYWROZXh0KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBleHBvbmVudCA9IHRtcC5kYXRhO1xuICAgIG9mZnNldCA9IHRtcC5vZmZzZXQ7XG5cbiAgICB0bXAgPSByZWFkTmV4dChidWZmZXIsIG9mZnNldCk7XG4gICAgbW9kdWx1cyA9IHRtcC5kYXRhO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNzaCBrZXk6ICcgKyBrZXkpO1xuICB9XG5cbiAgLy8gREVSIGlzIGEgc3Vic2V0IG9mIEJFUlxuICBkZXIgPSBuZXcgYXNuMS5CZXJXcml0ZXIoKTtcblxuICBkZXIuc3RhcnRTZXF1ZW5jZSgpO1xuXG4gIGRlci5zdGFydFNlcXVlbmNlKCk7XG4gIGRlci53cml0ZU9JRCgnMS4yLjg0MC4xMTM1NDkuMS4xLjEnKTtcbiAgZGVyLndyaXRlTnVsbCgpO1xuICBkZXIuZW5kU2VxdWVuY2UoKTtcblxuICBkZXIuc3RhcnRTZXF1ZW5jZSgweDAzKTsgLy8gYml0IHN0cmluZ1xuICBkZXIud3JpdGVCeXRlKDB4MDApO1xuXG4gIC8vIEFjdHVhbCBrZXlcbiAgZGVyLnN0YXJ0U2VxdWVuY2UoKTtcbiAgd3JpdGVJbnQoZGVyLCBtb2R1bHVzKTtcbiAgd3JpdGVJbnQoZGVyLCBleHBvbmVudCk7XG4gIGRlci5lbmRTZXF1ZW5jZSgpO1xuXG4gIC8vIGJpdCBzdHJpbmdcbiAgZGVyLmVuZFNlcXVlbmNlKCk7XG5cbiAgZGVyLmVuZFNlcXVlbmNlKCk7XG5cbiAgdG1wID0gZGVyLmJ1ZmZlci50b1N0cmluZygnYmFzZTY0Jyk7XG4gIGZvciAoaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgJSA2NCkgPT09IDApXG4gICAgICBuZXdLZXkgKz0gJ1xcbic7XG4gICAgbmV3S2V5ICs9IHRtcC5jaGFyQXQoaSk7XG4gIH1cblxuICBpZiAoIS9cXFxcbiQvLnRlc3QobmV3S2V5KSlcbiAgICBuZXdLZXkgKz0gJ1xcbic7XG5cbiAgcmV0dXJuICctLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLScgKyBuZXdLZXkgKyAnLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXFxuJztcbn1cblxuXG5mdW5jdGlvbiBkc2FUb1BFTShrZXkpIHtcbiAgdmFyIGJ1ZmZlcjtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIHZhciB0bXA7XG4gIHZhciBkZXI7XG4gIHZhciBuZXdLZXkgPSAnJztcblxuICB2YXIgdHlwZTtcbiAgdmFyIHA7XG4gIHZhciBxO1xuICB2YXIgZztcbiAgdmFyIHk7XG5cbiAgdHJ5IHtcbiAgICBidWZmZXIgPSBuZXcgQnVmZmVyKGtleS5zcGxpdCgnICcpWzFdLCAnYmFzZTY0Jyk7XG5cbiAgICB0bXAgPSByZWFkTmV4dChidWZmZXIsIG9mZnNldCk7XG4gICAgdHlwZSA9IHRtcC5kYXRhLnRvU3RyaW5nKCk7XG4gICAgb2Zmc2V0ID0gdG1wLm9mZnNldDtcblxuICAgIC8qIEpTU1RZTEVEICovXG4gICAgaWYgKCEvXnNzaC1kc1thc10uKi8udGVzdCh0eXBlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzc2gga2V5IHR5cGU6ICcgKyB0eXBlKTtcblxuICAgIHRtcCA9IHJlYWROZXh0KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBwID0gdG1wLmRhdGE7XG4gICAgb2Zmc2V0ID0gdG1wLm9mZnNldDtcblxuICAgIHRtcCA9IHJlYWROZXh0KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBxID0gdG1wLmRhdGE7XG4gICAgb2Zmc2V0ID0gdG1wLm9mZnNldDtcblxuICAgIHRtcCA9IHJlYWROZXh0KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBnID0gdG1wLmRhdGE7XG4gICAgb2Zmc2V0ID0gdG1wLm9mZnNldDtcblxuICAgIHRtcCA9IHJlYWROZXh0KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICB5ID0gdG1wLmRhdGE7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmxvZyhlLnN0YWNrKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3NoIGtleTogJyArIGtleSk7XG4gIH1cblxuICAvLyBERVIgaXMgYSBzdWJzZXQgb2YgQkVSXG4gIGRlciA9IG5ldyBhc24xLkJlcldyaXRlcigpO1xuXG4gIGRlci5zdGFydFNlcXVlbmNlKCk7XG5cbiAgZGVyLnN0YXJ0U2VxdWVuY2UoKTtcbiAgZGVyLndyaXRlT0lEKCcxLjIuODQwLjEwMDQwLjQuMScpO1xuXG4gIGRlci5zdGFydFNlcXVlbmNlKCk7XG4gIHdyaXRlSW50KGRlciwgcCk7XG4gIHdyaXRlSW50KGRlciwgcSk7XG4gIHdyaXRlSW50KGRlciwgZyk7XG4gIGRlci5lbmRTZXF1ZW5jZSgpO1xuXG4gIGRlci5lbmRTZXF1ZW5jZSgpO1xuXG4gIGRlci5zdGFydFNlcXVlbmNlKDB4MDMpOyAvLyBiaXQgc3RyaW5nXG4gIGRlci53cml0ZUJ5dGUoMHgwMCk7XG4gIHdyaXRlSW50KGRlciwgeSk7XG4gIGRlci5lbmRTZXF1ZW5jZSgpO1xuXG4gIGRlci5lbmRTZXF1ZW5jZSgpO1xuXG4gIHRtcCA9IGRlci5idWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcC5sZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSAlIDY0KSA9PT0gMClcbiAgICAgIG5ld0tleSArPSAnXFxuJztcbiAgICBuZXdLZXkgKz0gdG1wLmNoYXJBdChpKTtcbiAgfVxuXG4gIGlmICghL1xcXFxuJC8udGVzdChuZXdLZXkpKVxuICAgIG5ld0tleSArPSAnXFxuJztcblxuICByZXR1cm4gJy0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tJyArIG5ld0tleSArICctLS0tLUVORCBQVUJMSUMgS0VZLS0tLS1cXG4nO1xufVxuXG5cbi8vLy0tLSBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIE9wZW5TU0ggcHVibGljIGtleSAocnNhIG9ubHkpIHRvIGEgUEtDUyM4IFBFTSBmaWxlLlxuICAgKlxuICAgKiBUaGUgaW50ZW50IG9mIHRoaXMgbW9kdWxlIGlzIHRvIGludGVyb3BlcmF0ZSB3aXRoIE9wZW5TU0wgb25seSxcbiAgICogc3BlY2lmaWNhbGx5IHRoZSBub2RlIGNyeXB0byBtb2R1bGUncyBgdmVyaWZ5YCBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgYW4gT3BlblNTSCBwdWJsaWMga2V5LlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFBFTSBlbmNvZGVkIGZvcm0gb2YgdGhlIFJTQSBwdWJsaWMga2V5LlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IG9uIGJhZCBpbnB1dC5cbiAgICogQHRocm93cyB7RXJyb3J9IG9uIGludmFsaWQgc3NoIGtleSBmb3JtYXR0ZWQgZGF0YS5cbiAgICovXG4gIHNzaEtleVRvUEVNOiBmdW5jdGlvbiBzc2hLZXlUb1BFTShrZXkpIHtcbiAgICBhc3NlcnQuc3RyaW5nKGtleSwgJ3NzaF9rZXknKTtcblxuICAgIC8qIEpTU1RZTEVEICovXG4gICAgaWYgKC9ec3NoLXJzYS4qLy50ZXN0KGtleSkpXG4gICAgICByZXR1cm4gcnNhVG9QRU0oa2V5KTtcblxuICAgIC8qIEpTU1RZTEVEICovXG4gICAgaWYgKC9ec3NoLWRzW2FzXS4qLy50ZXN0KGtleSkpXG4gICAgICByZXR1cm4gZHNhVG9QRU0oa2V5KTtcblxuICAgIHRocm93IG5ldyBFcnJvcignT25seSBSU0EgYW5kIERTQSBwdWJsaWMga2V5cyBhcmUgYWxsb3dlZCcpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBPcGVuU1NIIGZpbmdlcnByaW50IGZyb20gYW4gc3NoIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgYW4gT3BlblNTSCBwdWJsaWMga2V5LlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGtleSBmaW5nZXJwcmludC5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBvbiBiYWQgaW5wdXQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB3aGF0IHlvdSBwYXNzZWQgZG9lc24ndCBsb29rIGxpa2UgYW4gc3NoIHB1YmxpYyBrZXkuXG4gICAqL1xuICBmaW5nZXJwcmludDogZnVuY3Rpb24gZmluZ2VycHJpbnQoa2V5KSB7XG4gICAgYXNzZXJ0LnN0cmluZyhrZXksICdzc2hfa2V5Jyk7XG5cbiAgICB2YXIgcGllY2VzID0ga2V5LnNwbGl0KCcgJyk7XG4gICAgaWYgKCFwaWVjZXMgfHwgIXBpZWNlcy5sZW5ndGggfHwgcGllY2VzLmxlbmd0aCA8IDIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3NoIGtleScpO1xuXG4gICAgdmFyIGRhdGEgPSBuZXcgQnVmZmVyKHBpZWNlc1sxXSwgJ2Jhc2U2NCcpO1xuXG4gICAgdmFyIGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnbWQ1Jyk7XG4gICAgaGFzaC51cGRhdGUoZGF0YSk7XG4gICAgdmFyIGRpZ2VzdCA9IGhhc2guZGlnZXN0KCdoZXgnKTtcblxuICAgIHZhciBmcCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlnZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSAmJiBpICUgMiA9PT0gMClcbiAgICAgICAgZnAgKz0gJzonO1xuXG4gICAgICBmcCArPSBkaWdlc3RbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZwO1xuICB9XG5cblxufTtcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9idWZmZXJcIikuQnVmZmVyKSIsIi8vIENvcHlyaWdodCAyMDExIEpveWVudCwgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cblxuXG4vLy8tLS0gRXhwb3J0ZWQgQVBJXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qKlxuICAgKiBTaW1wbHkgd3JhcHMgdXAgdGhlIG5vZGUgY3J5cHRvIG9wZXJhdGlvbnMgZm9yIHlvdSwgYW5kIHJldHVybnNcbiAgICogdHJ1ZSBvciBmYWxzZS4gIFlvdSBhcmUgZXhwZWN0ZWQgdG8gcGFzcyBpbiBhbiBvYmplY3QgdGhhdCB3YXNcbiAgICogcmV0dXJuZWQgZnJvbSBgcGFyc2UoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJzZWRTaWduYXR1cmUgdGhlIG9iamVjdCB5b3UgZ290IGZyb20gYHBhcnNlYC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBlaXRoZXIgYW4gUlNBIHByaXZhdGUga2V5IFBFTSBvciBITUFDIHNlY3JldC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHlvdSBwYXNzIGluIGJhZCBhcmd1bWVudHMuXG4gICAqL1xuICB2ZXJpZnlTaWduYXR1cmU6IGZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZShwYXJzZWRTaWduYXR1cmUsIGtleSkge1xuICAgIGFzc2VydC5vYmplY3QocGFyc2VkU2lnbmF0dXJlLCAncGFyc2VkU2lnbmF0dXJlJyk7XG4gICAgYXNzZXJ0LnN0cmluZyhrZXksICdrZXknKTtcblxuICAgIHZhciBhbGcgPSBwYXJzZWRTaWduYXR1cmUuYWxnb3JpdGhtLm1hdGNoKC8oSE1BQ3xSU0F8RFNBKS0oXFx3KykvKTtcbiAgICBpZiAoIWFsZyB8fCBhbGcubGVuZ3RoICE9PSAzKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyc2VkU2lnbmF0dXJlOiB1bnN1cHBvcnRlZCBhbGdvcml0aG0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFNpZ25hdHVyZS5hbGdvcml0aG0pO1xuXG4gICAgaWYgKGFsZ1sxXSA9PT0gJ0hNQUMnKSB7XG4gICAgICB2YXIgaG1hYyA9IGNyeXB0by5jcmVhdGVIbWFjKGFsZ1syXS50b1VwcGVyQ2FzZSgpLCBrZXkpO1xuICAgICAgaG1hYy51cGRhdGUocGFyc2VkU2lnbmF0dXJlLnNpZ25pbmdTdHJpbmcpO1xuICAgICAgcmV0dXJuIChobWFjLmRpZ2VzdCgnYmFzZTY0JykgPT09IHBhcnNlZFNpZ25hdHVyZS5wYXJhbXMuc2lnbmF0dXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZlcmlmeSA9IGNyeXB0by5jcmVhdGVWZXJpZnkoYWxnWzBdKTtcbiAgICAgIHZlcmlmeS51cGRhdGUocGFyc2VkU2lnbmF0dXJlLnNpZ25pbmdTdHJpbmcpO1xuICAgICAgcmV0dXJuIHZlcmlmeS52ZXJpZnkoa2V5LCBwYXJzZWRTaWduYXR1cmUucGFyYW1zLnNpZ25hdHVyZSwgJ2Jhc2U2NCcpO1xuICAgIH1cbiAgfVxuXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGx0eCA9IHJlcXVpcmUoJ2x0eCcpO1xudmFyIFN0YW56YSA9IHJlcXVpcmUoJy4vc3RhbnphJykuU3RhbnphO1xuXG4vKipcbiAqIFJlY29nbml6ZXMgPHN0cmVhbTpzdHJlYW0+IGFuZCBjb2xsZWN0cyBzdGFuemFzOyB1c2VkIGZvciBvcmRpbmFyeVxuICogVENQIHN0cmVhbXMgYW5kIFdlYnNvY2tldHMuXG4gKlxuICogQVBJOiB3cml0ZShkYXRhKSAmIGVuZChkYXRhKVxuICogRXZlbnRzOiBzdHJlYW1TdGFydCwgc3RhbnphLCBlbmQsIGVycm9yXG4gKi9cbmZ1bmN0aW9uIFN0cmVhbVBhcnNlcihtYXhTdGFuemFTaXplKSB7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5wYXJzZXIgPSBuZXcgbHR4LmJlc3RTYXhQYXJzZXIoKTtcblxuICAgIC8qIENvdW50IHRyYWZmaWMgZm9yIGVudGlyZSBsaWZlLXRpbWUgKi9cbiAgICB0aGlzLmJ5dGVzUGFyc2VkID0gMDtcbiAgICB0aGlzLm1heFN0YW56YVNpemUgPSBtYXhTdGFuemFTaXplO1xuICAgIC8qIFdpbGwgYmUgcmVzZXQgdXBvbiBmaXJzdCBzdGFuemEsIGJ1dCBlbmZvcmNlIG1heFN0YW56YVNpemUgdW50aWwgaXQgaXMgcGFyc2VkICovXG4gICAgdGhpcy5ieXRlc1BhcnNlZE9uU3RhbnphQmVnaW4gPSAwO1xuXG4gICAgdGhpcy5wYXJzZXIuYWRkTGlzdGVuZXIoJ3N0YXJ0RWxlbWVudCcsIGZ1bmN0aW9uKG5hbWUsIGF0dHJzKSB7XG4gICAgICAgIC8vIFRPRE86IHJlZnVzZSBhbnl0aGluZyBidXQgPHN0cmVhbTpzdHJlYW0+XG4gICAgICAgIGlmICghc2VsZi5lbGVtZW50ICYmIG5hbWUgPT0gJ3N0cmVhbTpzdHJlYW0nKSB7XG4gICAgICAgICAgICBzZWxmLmVtaXQoJ3N0cmVhbVN0YXJ0JywgYXR0cnMpO1xuICAgICAgICB9IGVsc2Uge1xuXHQgICAgdmFyIGNoaWxkO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvKiBBIG5ldyBzdGFuemEgKi9cblx0XHRjaGlsZCA9IG5ldyBTdGFuemEobmFtZSwgYXR0cnMpO1xuICAgICAgICAgICAgICAgIHNlbGYuZWxlbWVudCA9IGNoaWxkO1xuXHRcdC8qIEZvciBtYXhTdGFuemFTaXplIGVuZm9yY2VtZW50ICovXG4gICAgICAgICAgICAgICAgc2VsZi5ieXRlc1BhcnNlZE9uU3RhbnphQmVnaW4gPSBzZWxmLmJ5dGVzUGFyc2VkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBBIGNoaWxkIGVsZW1lbnQgb2YgYSBzdGFuemEgKi9cblx0XHRjaGlsZCA9IG5ldyBsdHguRWxlbWVudChuYW1lLCBhdHRycyk7XG4gICAgICAgICAgICAgICAgc2VsZi5lbGVtZW50ID0gc2VsZi5lbGVtZW50LmNub2RlKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5wYXJzZXIuYWRkTGlzdGVuZXIoJ2VuZEVsZW1lbnQnLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmICghc2VsZi5lbGVtZW50ICYmIG5hbWUgPT0gJ3N0cmVhbTpzdHJlYW0nKSB7XG4gICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGYuZWxlbWVudCAmJiBuYW1lID09IHNlbGYuZWxlbWVudC5uYW1lKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5lbGVtZW50LnBhcmVudClcbiAgICAgICAgICAgICAgICBzZWxmLmVsZW1lbnQgPSBzZWxmLmVsZW1lbnQucGFyZW50O1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogU3RhbnphIGNvbXBsZXRlICovXG4gICAgICAgICAgICAgICAgc2VsZi5lbWl0KCdzdGFuemEnLCBzZWxmLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLmVsZW1lbnQ7XG5cdFx0LyogbWF4U3RhbnphU2l6ZSBkb2Vzbid0IGFwcGx5IHVudGlsIG5leHQgc3RhcnRFbGVtZW50ICovXG4gICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYuYnl0ZXNQYXJzZWRPblN0YW56YUJlZ2luO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lcnJvcigneG1sLW5vdC13ZWxsLWZvcm1lZCcsICdYTUwgcGFyc2UgZXJyb3InKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHRoaXMucGFyc2VyLmFkZExpc3RlbmVyKCd0ZXh0JywgZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIGlmIChzZWxmLmVsZW1lbnQpXG4gICAgICAgICAgICBzZWxmLmVsZW1lbnQudChzdHIpO1xuICAgIH0pO1xuICAgIFxuICAgIHRoaXMucGFyc2VyLmFkZExpc3RlbmVyKCdlbnRpdHlEZWNsJywgZnVuY3Rpb24oKSB7XG5cdC8qIEVudGl0eSBkZWNsYXJhdGlvbnMgYXJlIGZvcmJpZGRlbiBpbiBYTVBQLiBXZSBtdXN0IGFib3J0IHRvXG5cdCAqIGF2b2lkIGEgYmlsbGlvbiBsYXVnaHMuXG5cdCAqL1xuXHRzZWxmLmVycm9yKCd4bWwtbm90LXdlbGwtZm9ybWVkJywgJ05vIGVudGl0eSBkZWNsYXJhdGlvbnMgYWxsb3dlZCcpO1xuXHRzZWxmLmVuZCgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5wYXJzZXIuYWRkTGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcblx0c2VsZi5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICB9KTtcbn1cbnV0aWwuaW5oZXJpdHMoU3RyZWFtUGFyc2VyLCBFdmVudEVtaXR0ZXIpO1xuZXhwb3J0cy5TdHJlYW1QYXJzZXIgPSBTdHJlYW1QYXJzZXI7XG5cblN0cmVhbVBhcnNlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgLyppZiAoL148c3RyZWFtOnN0cmVhbSBbXj5dK1xcLz4kLy50ZXN0KGRhdGEpKSB7XG5cdGRhdGEgPSBkYXRhLnJlcGxhY2UoL1xcLz4kLywgXCI+XCIpO1xuICAgIH0qL1xuICAgIGlmICh0aGlzLnBhcnNlcikge1xuXHQvKiBJZiBhIG1heFN0YW56YVNpemUgaXMgY29uZmlndXJlZCwgdGhlIGN1cnJlbnQgc3RhbnphIG11c3QgY29uc2lzdCBvbmx5IG9mIHRoaXMgbWFueSBieXRlcyAqL1xuICAgICAgICBpZiAodGhpcy5ieXRlc1BhcnNlZE9uU3RhbnphQmVnaW4gJiYgdGhpcy5tYXhTdGFuemFTaXplICYmXG4gICAgICAgICAgICB0aGlzLmJ5dGVzUGFyc2VkID4gdGhpcy5ieXRlc1BhcnNlZE9uU3RhbnphQmVnaW4gKyB0aGlzLm1heFN0YW56YVNpemUpIHtcblxuICAgICAgICAgICAgdGhpcy5lcnJvcigncG9saWN5LXZpb2xhdGlvbicsICdNYXhpbXVtIHN0YW56YSBzaXplIGV4Y2VlZGVkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ieXRlc1BhcnNlZCArPSBkYXRhLmxlbmd0aDtcblxuICAgICAgICB0aGlzLnBhcnNlci53cml0ZShkYXRhKTtcbiAgICB9XG59O1xuXG5TdHJlYW1QYXJzZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICB0aGlzLndyaXRlKGRhdGEpO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLnBhcnNlcjtcbiAgICB0aGlzLmVtaXQoJ2VuZCcpO1xufTtcblxuU3RyZWFtUGFyc2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGUuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlKTtcbn07XG4iLCIoZnVuY3Rpb24ocHJvY2Vzcyl7dmFyIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuLyoqXG4gKiBXaGF0J3MgYXZhaWxhYmxlIGZvciBjbGllbnQtc2lkZSBhdXRoZW50aWNhdGlvbiAoQ2xpZW50KVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IG1lY2hzIFNlcnZlci1vZmZlcmVkIFNBU0wgbWVjaGFuaXNtIG5hbWVzXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdE1lY2hhbmlzbShvZmZlcmVkTWVjaHMsIHByZWZlcnJlZE1lY2gsIGF2YWlsYWJsZU1lY2gpIHtcbiAgICB2YXIgbWVjaENsYXNzZXMgPSBbWE9BdXRoMiwgWEZhY2Vib29rUGxhdGZvcm0sIERpZ2VzdE1ENSxcblx0XHQgICAgICAgUGxhaW4sIEFub255bW91c107XG4gICAgdmFyIGJ5TmFtZSA9IHt9O1xuICAgIHZhciBtZWNoO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGF2YWlsYWJsZU1lY2gpKSB7XG4gICAgICAgIG1lY2hDbGFzc2VzID0gbWVjaENsYXNzZXMuY29uY2F0KGF2YWlsYWJsZU1lY2gpO1xuICAgIH1cbiAgICBtZWNoQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uKG1lY2hDbGFzcykge1xuXHRieU5hbWVbbWVjaENsYXNzLnByb3RvdHlwZS5uYW1lXSA9IG1lY2hDbGFzcztcbiAgICB9KTtcbiAgICAvKiBBbnkgcHJlZmVycmVkPyAqL1xuICAgIGlmIChieU5hbWVbcHJlZmVycmVkTWVjaF0pIHtcblx0bWVjaCA9IGJ5TmFtZVtwcmVmZXJyZWRNZWNoXTtcbiAgICB9XG4gICAgLyogQnkgcHJpb3JpdHkgKi9cbiAgICBtZWNoQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uKG1lY2hDbGFzcykge1xuXHRpZiAoIW1lY2ggJiZcblx0ICAgIG9mZmVyZWRNZWNocy5pbmRleE9mKG1lY2hDbGFzcy5wcm90b3R5cGUubmFtZSkgPj0gMClcblx0ICAgIG1lY2ggPSBtZWNoQ2xhc3M7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWVjaCA/IG5ldyBtZWNoKCkgOiBudWxsO1xufVxuXG5leHBvcnRzLnNlbGVjdE1lY2hhbmlzbSA9IHNlbGVjdE1lY2hhbmlzbTtcblxuLyoqXG4gKiBXaGF0J3MgYXZhaWxhYmxlIGZvciBzZXJ2ZXItc2lkZSBhdXRoZW50aWNhdGlvbiAoQzJTKVxuICovXG5mdW5jdGlvbiBhdmFpbGFibGVNZWNoYW5pc21zKGF2YWlsYWJsZU1lY2gpIHtcbiAgICB2YXIgbWVjaGFuaXNtcyA9IFtuZXcgUGxhaW4oKV07XG4gICAgaWYgKGF2YWlsYWJsZU1lY2gpIHtcbiAgICAgICAgbWVjaGFuaXNtcyA9IG1lY2hhbmlzbXMuY29uY2F0KGF2YWlsYWJsZU1lY2gpO1xuICAgIH1cbiAgICByZXR1cm4gbWVjaGFuaXNtcztcbn1cbmV4cG9ydHMuYXZhaWxhYmxlTWVjaGFuaXNtcyA9IGF2YWlsYWJsZU1lY2hhbmlzbXM7XG5cbi8vIE1lY2hhbmlzbXNcbmZ1bmN0aW9uIE1lY2hhbmlzbSgpIHtcbn1cbnV0aWwuaW5oZXJpdHMoTWVjaGFuaXNtLCBFdmVudEVtaXR0ZXIpO1xuTWVjaGFuaXNtLnByb3RvdHlwZS5hdXRoQXR0cnMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge307XG59O1xuXG5mdW5jdGlvbiBQbGFpbigpIHtcbn1cbnV0aWwuaW5oZXJpdHMoUGxhaW4sIE1lY2hhbmlzbSk7XG5QbGFpbi5wcm90b3R5cGUubmFtZSA9IFwiUExBSU5cIjtcblBsYWluLnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXV0aHppZCArIFwiXFwwXCIgK1xuICAgICAgICB0aGlzLmF1dGhjaWQgKyBcIlxcMFwiICtcbiAgICAgICAgdGhpcy5wYXNzd29yZDtcbn07XG5QbGFpbi5wcm90b3R5cGUuYXV0aFNlcnZlciA9IGZ1bmN0aW9uKGF1dGgsIGNsaWVudCkge1xuICAgIHZhciBwYXJhbXMgPSBhdXRoLnNwbGl0KFwiXFx4MDBcIik7XG4gICAgdGhpcy51c2VybmFtZSA9IHBhcmFtc1sxXTtcbiAgICBjbGllbnQuYXV0aGVudGljYXRlKHRoaXMudXNlcm5hbWUsIHBhcmFtc1syXSk7XG59O1xuXG5mdW5jdGlvbiBYT0F1dGgyKCkge1xufVxudXRpbC5pbmhlcml0cyhYT0F1dGgyLCBNZWNoYW5pc20pO1xuWE9BdXRoMi5wcm90b3R5cGUubmFtZSA9IFwiWC1PQVVUSDJcIjtcblhPQXV0aDIucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJcXDBcIiArIHRoaXMuYXV0aHppZCArIFwiXFwwXCIgKyB0aGlzLm9hdXRoMl90b2tlbjtcbn07XG5YT0F1dGgyLnByb3RvdHlwZS5hdXRoU2VydmVyID0gZnVuY3Rpb24oYXV0aCwgY2xpZW50KSB7XG4gICAgdmFyIHBhcmFtcyA9IGF1dGguc3BsaXQoXCJcXHgwMFwiKTtcbiAgICB0aGlzLnVzZXJuYW1lID0gcGFyYW1zWzFdO1xuICAgIGNsaWVudC5hdXRoZW50aWNhdGUodGhpcy51c2VybmFtZSwgcGFyYW1zWzJdKTtcbn07XG5YT0F1dGgyLnByb3RvdHlwZS5hdXRoQXR0cnMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geyBcImF1dGg6c2VydmljZVwiOiBcIm9hdXRoMlwiLFxuXHQgICAgIFwieG1sbnM6YXV0aFwiOiB0aGlzLm9hdXRoMl9hdXRoXG4gICAgfTtcbn07XG5cbmZ1bmN0aW9uIFhGYWNlYm9va1BsYXRmb3JtKCkge1xufVxudXRpbC5pbmhlcml0cyhYRmFjZWJvb2tQbGF0Zm9ybSwgTWVjaGFuaXNtKTtcblhGYWNlYm9va1BsYXRmb3JtLnByb3RvdHlwZS5uYW1lID0gXCJYLUZBQ0VCT09LLVBMQVRGT1JNXCI7XG5YRmFjZWJvb2tQbGF0Zm9ybS5wcm90b3R5cGUuYXV0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIlwiO1xufTtcblhGYWNlYm9va1BsYXRmb3JtLnByb3RvdHlwZS5jaGFsbGVuZ2UgPSBmdW5jdGlvbihzKSB7XG4gICAgdmFyIGRpY3QgPSBxdWVyeXN0cmluZy5wYXJzZShzKTtcblxuICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgYXBpX2tleTogdGhpcy5hcGlfa2V5LFxuICAgICAgICBjYWxsX2lkOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgICAgbWV0aG9kOiBkaWN0Lm1ldGhvZCxcbiAgICAgICAgbm9uY2U6IGRpY3Qubm9uY2UsXG4gICAgICAgIGFjY2Vzc190b2tlbjogdGhpcy5hY2Nlc3NfdG9rZW4sXG4gICAgICAgIHY6IFwiMS4wXCJcbiAgICB9O1xuXG4gICAgcmV0dXJuIHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShyZXNwb25zZSk7XG59O1xuXG5mdW5jdGlvbiBBbm9ueW1vdXMoKSB7XG59XG51dGlsLmluaGVyaXRzKEFub255bW91cywgTWVjaGFuaXNtKTtcbkFub255bW91cy5wcm90b3R5cGUubmFtZSA9IFwiQU5PTllNT1VTXCI7XG5Bbm9ueW1vdXMucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hdXRoemlkO1xufTtcblxuZnVuY3Rpb24gRXh0ZXJuYWwoKSB7XG59XG51dGlsLmluaGVyaXRzKEV4dGVybmFsLCBNZWNoYW5pc20pO1xuRXh0ZXJuYWwucHJvdG90eXBlLm5hbWUgPSBcIkVYVEVSTkFMXCI7XG5FeHRlcm5hbC5wcm90b3R5cGUuYXV0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybih0aGlzLmF1dGh6aWQpO1xufTtcblxuZXhwb3J0cy5FeHRlcm5hbCA9IEV4dGVybmFsO1xuXG5mdW5jdGlvbiBEaWdlc3RNRDUoKSB7XG4gICAgdGhpcy5ub25jZV9jb3VudCA9IDA7XG4gICAgdGhpcy5jbm9uY2UgPSBnZW5lcmF0ZU5vbmNlKCk7XG59XG51dGlsLmluaGVyaXRzKERpZ2VzdE1ENSwgTWVjaGFuaXNtKTtcbkRpZ2VzdE1ENS5wcm90b3R5cGUubmFtZSA9IFwiRElHRVNULU1ENVwiO1xuRGlnZXN0TUQ1LnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiXCI7XG59O1xuRGlnZXN0TUQ1LnByb3RvdHlwZS5nZXROQyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiByanVzdCh0aGlzLm5vbmNlX2NvdW50LnRvU3RyaW5nKCksIDgsICcwJyk7XG59O1xuRGlnZXN0TUQ1LnByb3RvdHlwZS5yZXNwb25zZVZhbHVlID0gZnVuY3Rpb24ocykge1xuICAgIHZhciBkaWN0ID0gcGFyc2VEaWN0KHMpO1xuICAgIGlmIChkaWN0LnJlYWxtKVxuICAgICAgICB0aGlzLnJlYWxtID0gZGljdC5yZWFsbTtcblxuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAoZGljdC5ub25jZSAmJiBkaWN0LnFvcCkge1xuICAgICAgICB0aGlzLm5vbmNlX2NvdW50Kys7XG4gICAgICAgIHZhciBhMSA9IG1kNSh0aGlzLmF1dGhjaWQgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsbSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLnBhc3N3b3JkKSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICBkaWN0Lm5vbmNlICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgIHRoaXMuY25vbmNlO1xuICAgICAgICBpZiAodGhpcy5hY3RBcykgYTEgKz0gXCI6XCIgKyB0aGlzLmFjdEFzXG5cbiAgICAgICAgdmFyIGEyID0gXCJBVVRIRU5USUNBVEU6XCIgKyB0aGlzLmRpZ2VzdF91cmk7XG4gICAgICAgIGlmIChkaWN0LnFvcCA9PSAnYXV0aC1pbnQnIHx8IGRpY3QucW9wID09ICdhdXRoLWNvbmYnKVxuICAgICAgICAgICAgYTIgKz0gXCI6MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcblxuICAgICAgICB2YWx1ZSA9IG1kNV9oZXgobWQ1X2hleChhMSkgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZGljdC5ub25jZSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldE5DKCkgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbm9uY2UgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZGljdC5xb3AgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbWQ1X2hleChhMikpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG5EaWdlc3RNRDUucHJvdG90eXBlLmNoYWxsZW5nZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgZGljdCA9IHBhcnNlRGljdChzKTtcbiAgICBpZiAoZGljdC5yZWFsbSlcbiAgICAgICAgdGhpcy5yZWFsbSA9IGRpY3QucmVhbG07XG5cbiAgICB2YXIgcmVzcG9uc2U7XG4gICAgaWYgKGRpY3Qubm9uY2UgJiYgZGljdC5xb3ApIHtcbiAgICAgICAgdmFyIHJlc3BvbnNlVmFsdWUgPSB0aGlzLnJlc3BvbnNlVmFsdWUocyk7XG4gICAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgdXNlcm5hbWU6IHRoaXMuYXV0aGNpZCxcbiAgICAgICAgICAgIHJlYWxtOiB0aGlzLnJlYWxtLFxuICAgICAgICAgICAgbm9uY2U6IGRpY3Qubm9uY2UsXG4gICAgICAgICAgICBjbm9uY2U6IHRoaXMuY25vbmNlLFxuICAgICAgICAgICAgbmM6IHRoaXMuZ2V0TkMoKSxcbiAgICAgICAgICAgIHFvcDogZGljdC5xb3AsXG4gICAgICAgICAgICAnZGlnZXN0LXVyaSc6IHRoaXMuZGlnZXN0X3VyaSxcbiAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZVZhbHVlLFxuICAgICAgICAgICAgY2hhcnNldDogJ3V0Zi04J1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5hY3RBcykgcmVzcG9uc2VbJ2F1dGh6aWQnXSA9IHRoaXMuYWN0QXNcbiAgICB9IGVsc2UgaWYgKGRpY3QucnNwYXV0aCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZURpY3QocmVzcG9uc2UpO1xufTtcbkRpZ2VzdE1ENS5wcm90b3R5cGUuc2VydmVyQ2hhbGxlbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRpY3QgPSB7fTtcbiAgICBkaWN0LnJlYWxtID0gXCJcIjtcbiAgICB0aGlzLm5vbmNlID0gZGljdC5ub25jZSA9IGdlbmVyYXRlTm9uY2UoKTtcbiAgICBkaWN0LnFvcCA9IFwiYXV0aFwiO1xuICAgIHRoaXMuY2hhcnNldCA9IGRpY3QuY2hhcnNldCA9IFwidXRmLThcIjtcbiAgICBkaWN0LmFsZ29yaXRobSA9IFwibWQ1LXNlc3NcIjtcbiAgICByZXR1cm4gZW5jb2RlRGljdChkaWN0KTtcbn07XG5cbi8vIFVzZWQgb24gdGhlIHNlcnZlciB0byBjaGVjayBmb3IgYXV0aCFcbkRpZ2VzdE1ENS5wcm90b3R5cGUucmVzcG9uc2UgPSBmdW5jdGlvbihzKSB7XG4gICAgdmFyIGRpY3QgPSBwYXJzZURpY3Qocyk7XG4gICAgdGhpcy5hdXRoY2lkID0gZGljdC51c2VybmFtZTtcbiAgICBpZihkaWN0Lm5vbmNlICE9IHRoaXMubm9uY2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZighZGljdC5jbm9uY2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmNub25jZSA9IGRpY3QuY25vbmNlO1xuICAgIGlmKHRoaXMuY2hhcnNldCAhPSBkaWN0LmNoYXJzZXQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnJlc3BvbnNlID0gZGljdC5yZXNwb25zZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogUGFyc2UgU0FTTCBzZXJpYWxpemF0aW9uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGljdChzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHdoaWxlIChzKSB7XG4gICAgICAgIHZhciBtO1xuICAgICAgICBpZigobSA9IC9eKC4rPyk9KC4qP1teXFxcXF0pLCguKikvLmV4ZWMocykpKSB7XG4gICAgICAgICAgICByZXN1bHRbbVsxXV0gPSBtWzJdLnJlcGxhY2UoL1xcXCIvZywgJycpO1xuICAgICAgICAgICAgcyA9IG1bM107XG4gICAgICAgIH0gZWxzZSBpZiAoKG0gPSAvXiguKz8pPSguKz8pLCguKikvLmV4ZWMocykpKSB7XG4gICAgICAgICAgICByZXN1bHRbbVsxXV0gPSBtWzJdO1xuICAgICAgICAgICAgcyA9IG1bM107XG4gICAgICAgIH0gZWxzZSBpZiAoKG0gPSAvXiguKz8pPVwiKC4qP1teXFxcXF0pXCIkLy5leGVjKHMpKSkge1xuICAgICAgICAgICAgcmVzdWx0W21bMV1dID0gbVsyXTtcbiAgICAgICAgICAgIHMgPSBtWzNdO1xuICAgICAgICB9IGVsc2UgaWYgKChtID0gL14oLis/KT0oLis/KSQvLmV4ZWMocykpKSB7XG4gICAgICAgICAgICByZXN1bHRbbVsxXV0gPSBtWzJdO1xuICAgICAgICAgICAgcyA9IG1bM107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFNBU0wgc2VyaWFsaXphdGlvblxuICovXG5mdW5jdGlvbiBlbmNvZGVEaWN0KGRpY3QpIHtcbiAgICB2YXIgcyA9IFwiXCI7XG4gICAgZm9yKGsgaW4gZGljdCkge1xuICAgICAgICB2YXIgdiA9IGRpY3Rba107XG4gICAgICAgIGlmICh2KVxuICAgICAgICAgICAgcyArPSAnLCcgKyBrICsgJz1cIicgKyB2ICsgJ1wiJztcbiAgICB9XG4gICAgcmV0dXJuIHMuc3Vic3RyKDEpOyAgLy8gd2l0aG91dCBmaXJzdCAnLCdcbn1cblxuLyoqXG4gKiBSaWdodC1qdXN0aWZ5IGEgc3RyaW5nLFxuICogZWcuIHBhZCB3aXRoIDBzXG4gKi9cbmZ1bmN0aW9uIHJqdXN0KHMsIHRhcmdldExlbiwgcGFkZGluZykge1xuICAgIHdoaWxlKHMubGVuZ3RoIDwgdGFyZ2V0TGVuKVxuICAgICAgICBzID0gcGFkZGluZyArIHM7XG4gICAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogSGFzaCBhIHN0cmluZ1xuICovXG52YXIgbWQ1LCBtZDVfaGV4O1xuaWYgKHByb2Nlc3MudGl0bGUgIT09ICdicm93c2VyJykge1xuICAgIHZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbiAgICBtZDUgPSBmdW5jdGlvbihzLCBlbmNvZGluZykge1xuXHR2YXIgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdtZDUnKTtcblx0aGFzaC51cGRhdGUocyk7XG5cdHJldHVybiBoYXNoLmRpZ2VzdChlbmNvZGluZyB8fCAnYmluYXJ5Jyk7XG4gICAgfTtcbiAgICBtZDVfaGV4ID0gZnVuY3Rpb24ocykge1xuXHRyZXR1cm4gbWQ1KHMsICdoZXgnKTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICB2YXIgbWQ1bGliID0gcmVxdWlyZSgnYmx1ZWltcC1tZDUnKS5tZDU7XG4gICAgY29uc29sZS5sb2coXCJtZDVsaWJcIixtZDVsaWIpO1xuICAgIG1kNSA9IGZ1bmN0aW9uKHMpIHtcblx0Y29uc29sZS5sb2coXCJtZDVcIiwgcywgbWQ1bGliKHMsIG51bGwsIHRydWUpKTtcblx0cmV0dXJuIG1kNWxpYihzLCBudWxsLCB0cnVlKTtcbiAgICB9O1xuICAgIG1kNV9oZXggPSBmdW5jdGlvbihzKSB7XG5cdGNvbnNvbGUubG9nKFwibWQ1X2hleFwiLCBzLCBtZDVsaWIocykpO1xuXHRyZXR1cm4gbWQ1bGliKHMpO1xuICAgIH07XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdHJpbmcgb2YgOCBkaWdpdHNcbiAqIChudW1iZXIgdXNlZCBvbmNlKVxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZU5vbmNlKCkge1xuICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCA4OyBpKyspXG4gICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDQ4ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jZWlsKE1hdGgucmFuZG9tKCkgKiAxMCkpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSkiLCIvLyBMb2FkIG1vZHVsZXNcclxuXHJcbnZhciBDcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcclxudmFyIFVybCA9IHJlcXVpcmUoJ3VybCcpO1xyXG52YXIgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcblxyXG5cclxuLy8gRGVjbGFyZSBpbnRlcm5hbHNcclxuXHJcbnZhciBpbnRlcm5hbHMgPSB7fTtcclxuXHJcblxyXG4vLyBNQUMgbm9ybWFsaXphdGlvbiBmb3JtYXQgdmVyc2lvblxyXG5cclxuZXhwb3J0cy5oZWFkZXJWZXJzaW9uID0gJzEnOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgY29tcGFyaXNvbiBvZiBtYWMgdmFsdWVzIGdlbmVyYXRlZCB3aXRoIGRpZmZlcmVudCBub3JtYWxpemVkIHN0cmluZyBmb3JtYXRzXHJcblxyXG5cclxuLy8gU3VwcG9ydGVkIEhNQUMgYWxnb3JpdGhtc1xyXG5cclxuZXhwb3J0cy5hbGdvcml0aG1zID0gWydzaGExJywgJ3NoYTI1NiddO1xyXG5cclxuXHJcbi8vIENhbGN1bGF0ZSB0aGUgcmVxdWVzdCBNQUNcclxuXHJcbi8qXHJcbiAgICB0eXBlOiAnaGVhZGVyJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnaGVhZGVyJywgJ2Jld2l0JywgJ3Jlc3BvbnNlJ1xyXG4gICAgY3JlZGVudGlhbHM6IHtcclxuICAgICAgICBrZXk6ICdhb2lqZWRvYWlqc2RsYWtzamRsJyxcclxuICAgICAgICBhbGdvcml0aG06ICdzaGEyNTYnICAgICAgICAgICAgICAgICAgICAgICAgIC8vICdzaGExJywgJ3NoYTI1NidcclxuICAgIH0sXHJcbiAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICByZXNvdXJjZTogJy9yZXNvdXJjZT9hPTEmYj0yJyxcclxuICAgICAgICBob3N0OiAnZXhhbXBsZS5jb20nLFxyXG4gICAgICAgIHBvcnQ6IDgwODAsXHJcbiAgICAgICAgdHM6IDEzNTc3MTgzODEwMzQsXHJcbiAgICAgICAgbm9uY2U6ICdkM2QzNDVmJyxcclxuICAgICAgICBoYXNoOiAnVTRNS0tTbWlWeGszN0pDQ3JBVklqVi9PaEIzeStOZHdvQ3I2UlNoYlZrRT0nLFxyXG4gICAgICAgIGV4dDogJ2FwcC1zcGVjaWZpYy1kYXRhJyxcclxuICAgICAgICBhcHA6ICdoZjQ4aGQ4M3F3a2onLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGxpY2F0aW9uIGlkIChPeilcclxuICAgICAgICBkbGc6ICdkOGRqd2VrZHM5Y2onICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGVnYXRlZCBieSBhcHBsaWNhdGlvbiBpZCAoT3opLCByZXF1aXJlcyBvcHRpb25zLmFwcFxyXG4gICAgfVxyXG4qL1xyXG5cclxuZXhwb3J0cy5jYWxjdWxhdGVNYWMgPSBmdW5jdGlvbiAodHlwZSwgY3JlZGVudGlhbHMsIG9wdGlvbnMpIHtcclxuXHJcbiAgICB2YXIgbm9ybWFsaXplZCA9IGV4cG9ydHMuZ2VuZXJhdGVOb3JtYWxpemVkU3RyaW5nKHR5cGUsIG9wdGlvbnMpO1xyXG5cclxuICAgIHZhciBobWFjID0gQ3J5cHRvLmNyZWF0ZUhtYWMoY3JlZGVudGlhbHMuYWxnb3JpdGhtLCBjcmVkZW50aWFscy5rZXkpLnVwZGF0ZShub3JtYWxpemVkKTtcclxuICAgIHZhciBkaWdlc3QgPSBobWFjLmRpZ2VzdCgnYmFzZTY0Jyk7XHJcbiAgICByZXR1cm4gZGlnZXN0O1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuZ2VuZXJhdGVOb3JtYWxpemVkU3RyaW5nID0gZnVuY3Rpb24gKHR5cGUsIG9wdGlvbnMpIHtcclxuXHJcbiAgICB2YXIgbm9ybWFsaXplZCA9ICdoYXdrLicgKyBleHBvcnRzLmhlYWRlclZlcnNpb24gKyAnLicgKyB0eXBlICsgJ1xcbicgK1xyXG4gICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnRzICsgJ1xcbicgK1xyXG4gICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm5vbmNlICsgJ1xcbicgK1xyXG4gICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1ldGhvZC50b1VwcGVyQ2FzZSgpICsgJ1xcbicgK1xyXG4gICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnJlc291cmNlICsgJ1xcbicgK1xyXG4gICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhvc3QudG9Mb3dlckNhc2UoKSArICdcXG4nICtcclxuICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wb3J0ICsgJ1xcbicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAob3B0aW9ucy5oYXNoIHx8ICcnKSArICdcXG4nO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmV4dCkge1xyXG4gICAgICAgIG5vcm1hbGl6ZWQgKz0gb3B0aW9ucy5leHQucmVwbGFjZSgnXFxcXCcsICdcXFxcXFxcXCcpLnJlcGxhY2UoJ1xcbicsICdcXFxcbicpO1xyXG4gICAgfVxyXG5cclxuICAgIG5vcm1hbGl6ZWQgKz0gJ1xcbic7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuYXBwKSB7XHJcbiAgICAgICAgbm9ybWFsaXplZCArPSBvcHRpb25zLmFwcCArICdcXG4nICtcclxuICAgICAgICAgICAgICAgICAgICAgIChvcHRpb25zLmRsZyB8fCAnJykgKyAnXFxuJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmNhbGN1bGF0ZVBheWxvYWRIYXNoID0gZnVuY3Rpb24gKHBheWxvYWQsIGFsZ29yaXRobSwgY29udGVudFR5cGUpIHtcclxuXHJcbiAgICB2YXIgaGFzaCA9IGV4cG9ydHMuaW5pdGlhbGl6ZVBheWxvYWRIYXNoKGFsZ29yaXRobSwgY29udGVudFR5cGUpO1xyXG4gICAgaGFzaC51cGRhdGUocGF5bG9hZCB8fCAnJyk7XHJcbiAgICByZXR1cm4gZXhwb3J0cy5maW5hbGl6ZVBheWxvYWRIYXNoKGhhc2gpO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuaW5pdGlhbGl6ZVBheWxvYWRIYXNoID0gZnVuY3Rpb24gKGFsZ29yaXRobSwgY29udGVudFR5cGUpIHtcclxuXHJcbiAgICB2YXIgaGFzaCA9IENyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobSk7XHJcbiAgICBoYXNoLnVwZGF0ZSgnaGF3ay4nICsgZXhwb3J0cy5oZWFkZXJWZXJzaW9uICsgJy5wYXlsb2FkXFxuJyk7XHJcbiAgICBoYXNoLnVwZGF0ZShVdGlscy5wYXJzZUNvbnRlbnRUeXBlKGNvbnRlbnRUeXBlKSArICdcXG4nKTtcclxuICAgIHJldHVybiBoYXNoO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuZmluYWxpemVQYXlsb2FkSGFzaCA9IGZ1bmN0aW9uIChoYXNoKSB7XHJcblxyXG4gICAgaGFzaC51cGRhdGUoJ1xcbicpO1xyXG4gICAgcmV0dXJuIGhhc2guZGlnZXN0KCdiYXNlNjQnKTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmNhbGN1bGF0ZVRzTWFjID0gZnVuY3Rpb24gKHRzLCBjcmVkZW50aWFscykge1xyXG5cclxuICAgIHZhciBobWFjID0gQ3J5cHRvLmNyZWF0ZUhtYWMoY3JlZGVudGlhbHMuYWxnb3JpdGhtLCBjcmVkZW50aWFscy5rZXkpO1xyXG4gICAgaG1hYy51cGRhdGUoJ2hhd2suJyArIGV4cG9ydHMuaGVhZGVyVmVyc2lvbiArICcudHNcXG4nICsgdHMgKyAnXFxuJyk7XHJcbiAgICByZXR1cm4gaG1hYy5kaWdlc3QoJ2Jhc2U2NCcpO1xyXG59O1xyXG5cclxuIiwiKGZ1bmN0aW9uKHByb2Nlc3MsQnVmZmVyKXsvLyBDb3B5cmlnaHQgKGMpIDIwMTIsIE1hcmsgQ2F2YWdlLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cblxuXG4vLy8tLS0gR2xvYmFsc1xuXG52YXIgTkRFQlVHID0gcHJvY2Vzcy5lbnYuTk9ERV9OREVCVUcgfHwgZmFsc2U7XG5cblxuXG4vLy8tLS0gTWVzc2FnZXNcblxudmFyIEFSUkFZX1RZUEVfUkVRVUlSRUQgPSAnJXMgKFslc10pIHJlcXVpcmVkJztcbnZhciBUWVBFX1JFUVVJUkVEID0gJyVzICglcykgaXMgcmVxdWlyZWQnO1xuXG5cblxuLy8vLS0tIEludGVybmFsXG5cbmZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyKSB7XG4gICAgICAgIHJldHVybiAoc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpKTtcbn1cblxuZnVuY3Rpb24gdW5jYXBpdGFsaXplKHN0cikge1xuICAgICAgICByZXR1cm4gKHN0ci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0ci5zbGljZSgxKSk7XG59XG5cbmZ1bmN0aW9uIF8oKSB7XG4gICAgICAgIHJldHVybiAodXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKSk7XG59XG5cblxuZnVuY3Rpb24gX2Fzc2VydChhcmcsIHR5cGUsIG5hbWUsIHN0YWNrRnVuYykge1xuICAgICAgICBpZiAoIU5ERUJVRykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lIHx8IHR5cGU7XG4gICAgICAgICAgICAgICAgc3RhY2tGdW5jID0gc3RhY2tGdW5jIHx8IF9hc3NlcnQuY2FsbGVyO1xuICAgICAgICAgICAgICAgIHZhciB0ID0gdHlwZW9mIChhcmcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHQgIT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBfKFRZUEVfUkVRVUlSRUQsIG5hbWUsIHR5cGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogJz09PScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tGdW5jXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbn1cblxuXG5cbi8vLy0tLSBBUElcblxuZnVuY3Rpb24gYXJyYXkoYXJyLCB0eXBlLCBuYW1lKSB7XG4gICAgICAgIGlmICghTkRFQlVHKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUgfHwgdHlwZTtcblxuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXyhBUlJBWV9UWVBFX1JFUVVJUkVELCBuYW1lLCB0eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB0eXBlb2YgKGFyciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ0FycmF5LmlzQXJyYXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja1N0YXJ0RnVuY3Rpb246IGFycmF5LmNhbGxlclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hc3NlcnQoYXJyW2ldLCB0eXBlLCBuYW1lLCBhcnJheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG59XG5cblxuZnVuY3Rpb24gYm9vbChhcmcsIG5hbWUpIHtcbiAgICAgICAgX2Fzc2VydChhcmcsICdib29sZWFuJywgbmFtZSwgYm9vbCk7XG59XG5cblxuZnVuY3Rpb24gYnVmZmVyKGFyZywgbmFtZSkge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhcmcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBfKFRZUEVfUkVRVUlSRUQsIG5hbWUsIHR5cGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB0eXBlb2YgKGFyZyksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ2J1ZmZlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ0J1ZmZlci5pc0J1ZmZlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFja1N0YXJ0RnVuY3Rpb246IGJ1ZmZlclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG59XG5cblxuZnVuY3Rpb24gZnVuYyhhcmcsIG5hbWUpIHtcbiAgICAgICAgX2Fzc2VydChhcmcsICdmdW5jdGlvbicsIG5hbWUpO1xufVxuXG5cbmZ1bmN0aW9uIG51bWJlcihhcmcsIG5hbWUpIHtcbiAgICAgICAgX2Fzc2VydChhcmcsICdudW1iZXInLCBuYW1lKTtcbn1cblxuXG5mdW5jdGlvbiBvYmplY3QoYXJnLCBuYW1lKSB7XG4gICAgICAgIF9hc3NlcnQoYXJnLCAnb2JqZWN0JywgbmFtZSk7XG59XG5cblxuZnVuY3Rpb24gc3RyZWFtKGFyZywgbmFtZSkge1xuICAgICAgICBpZiAoIShhcmcgaW5zdGFuY2VvZiBTdHJlYW0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBfKFRZUEVfUkVRVUlSRUQsIG5hbWUsIHR5cGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiB0eXBlb2YgKGFyZyksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogJ1N0cmVhbScsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ2luc3RhbmNlb2YnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBidWZmZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0cmluZyhhcmcsIG5hbWUpIHtcbiAgICAgICAgX2Fzc2VydChhcmcsICdzdHJpbmcnLCBuYW1lKTtcbn1cblxuXG5cbi8vLy0tLSBFeHBvcnRzXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBib29sOiBib29sLFxuICAgICAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICAgICAgZnVuYzogZnVuYyxcbiAgICAgICAgbnVtYmVyOiBudW1iZXIsXG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBzdHJlYW06IHN0cmVhbSxcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbn07XG5cblxuT2JqZWN0LmtleXMobW9kdWxlLmV4cG9ydHMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgaWYgKGsgPT09ICdidWZmZXInKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB2YXIgbmFtZSA9ICdhcnJheU9mJyArIGNhcGl0YWxpemUoayk7XG5cbiAgICAgICAgaWYgKGsgPT09ICdib29sJylcbiAgICAgICAgICAgICAgICBrID0gJ2Jvb2xlYW4nO1xuICAgICAgICBpZiAoayA9PT0gJ2Z1bmMnKVxuICAgICAgICAgICAgICAgIGsgPSAnZnVuY3Rpb24nO1xuICAgICAgICBtb2R1bGUuZXhwb3J0c1tuYW1lXSA9IGZ1bmN0aW9uIChhcmcsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBhcnJheShhcmcsIGssIG5hbWUpO1xuICAgICAgICB9O1xufSk7XG5cbk9iamVjdC5rZXlzKG1vZHVsZS5leHBvcnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHZhciBfbmFtZSA9ICdvcHRpb25hbCcgKyBjYXBpdGFsaXplKGspO1xuICAgICAgICB2YXIgcyA9IHVuY2FwaXRhbGl6ZShrLnJlcGxhY2UoJ2FycmF5T2YnLCAnJykpO1xuICAgICAgICBpZiAocyA9PT0gJ2Jvb2wnKVxuICAgICAgICAgICAgICAgIHMgPSAnYm9vbGVhbic7XG4gICAgICAgIGlmIChzID09PSAnZnVuYycpXG4gICAgICAgICAgICAgICAgcyA9ICdmdW5jdGlvbic7XG5cbiAgICAgICAgaWYgKGsuaW5kZXhPZignYXJyYXlPZicpICE9PSAtMSkge1xuICAgICAgICAgIG1vZHVsZS5leHBvcnRzW19uYW1lXSA9IGZ1bmN0aW9uIChhcmcsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghTkRFQlVHICYmIGFyZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5KGFyZywgcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2R1bGUuZXhwb3J0c1tfbmFtZV0gPSBmdW5jdGlvbiAoYXJnLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIU5ERUJVRyAmJiBhcmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfYXNzZXJ0KGFyZywgcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxufSk7XG5cblxuLy8gUmVleHBvcnQgYnVpbHQtaW4gYXNzZXJ0aW9uc1xuT2JqZWN0LmtleXMoYXNzZXJ0KS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmIChrID09PSAnQXNzZXJ0aW9uRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHNba10gPSBhc3NlcnRba107XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHNba10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFOREVCVUcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydFtrXS5hcHBseShhc3NlcnRba10sIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9O1xufSk7XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSxyZXF1aXJlKFwiX19icm93c2VyaWZ5X2J1ZmZlclwiKS5CdWZmZXIpIiwiLy8gRXhwb3J0IHN1Yi1tb2R1bGVzXHJcblxyXG5leHBvcnRzLmVycm9yID0gZXhwb3J0cy5FcnJvciA9IHJlcXVpcmUoJ2Jvb20nKTtcclxuZXhwb3J0cy5zbnRwID0gcmVxdWlyZSgnc250cCcpO1xyXG5leHBvcnRzLnNlcnZlciA9IHJlcXVpcmUoJy4vc2VydmVyJyk7XHJcbmV4cG9ydHMuY2xpZW50ID0gcmVxdWlyZSgnLi9jbGllbnQnKTtcclxuZXhwb3J0cy5jcnlwdG8gPSByZXF1aXJlKCcuL2NyeXB0bycpO1xyXG5leHBvcnRzLnV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG5cclxuZXhwb3J0cy51cmkgPSB7XHJcbiAgICBhdXRoZW50aWNhdGU6IGV4cG9ydHMuc2VydmVyLmF1dGhlbnRpY2F0ZUJld2l0LFxyXG4gICAgZ2V0QmV3aXQ6IGV4cG9ydHMuY2xpZW50LmdldEJld2l0XHJcbn07XHJcblxyXG5cclxuIiwiKGZ1bmN0aW9uKCl7LypcbiAqIEphdmFTY3JpcHQgTUQ1IDEuMC4xXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LU1ENVxuICpcbiAqIENvcHlyaWdodCAyMDExLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqIFxuICogQmFzZWQgb25cbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gKiBWZXJzaW9uIDIuMiBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDlcbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cbiAqL1xuXG4vKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG4vKmdsb2JhbCB1bmVzY2FwZSwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoJCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qXG4gICAgKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gICAgKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICAgICovXG4gICAgZnVuY3Rpb24gc2FmZV9hZGQoeCwgeSkge1xuICAgICAgICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpLFxuICAgICAgICAgICAgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gICAgICAgIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xuICAgIH1cblxuICAgIC8qXG4gICAgKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBiaXRfcm9sKG51bSwgY250KSB7XG4gICAgICAgIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIG1kNV9jbW4ocSwgYSwgYiwgeCwgcywgdCkge1xuICAgICAgICByZXR1cm4gc2FmZV9hZGQoYml0X3JvbChzYWZlX2FkZChzYWZlX2FkZChhLCBxKSwgc2FmZV9hZGQoeCwgdCkpLCBzKSwgYik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1kNV9mZihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgICAgIHJldHVybiBtZDVfY21uKChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWQ1X2dnKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICAgICAgcmV0dXJuIG1kNV9jbW4oKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZDVfaGgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgICAgICByZXR1cm4gbWQ1X2NtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZDVfaWkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgICAgICByZXR1cm4gbWQ1X2NtbihjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG4gICAgfVxuXG4gICAgLypcbiAgICAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGguXG4gICAgKi9cbiAgICBmdW5jdGlvbiBiaW5sX21kNSh4LCBsZW4pIHtcbiAgICAgICAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgICAgICAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAobGVuICUgMzIpO1xuICAgICAgICB4WygoKGxlbiArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBsZW47XG5cbiAgICAgICAgdmFyIGksIG9sZGEsIG9sZGIsIG9sZGMsIG9sZGQsXG4gICAgICAgICAgICBhID0gIDE3MzI1ODQxOTMsXG4gICAgICAgICAgICBiID0gLTI3MTczMzg3OSxcbiAgICAgICAgICAgIGMgPSAtMTczMjU4NDE5NCxcbiAgICAgICAgICAgIGQgPSAgMjcxNzMzODc4O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgICAgICAgb2xkYSA9IGE7XG4gICAgICAgICAgICBvbGRiID0gYjtcbiAgICAgICAgICAgIG9sZGMgPSBjO1xuICAgICAgICAgICAgb2xkZCA9IGQ7XG5cbiAgICAgICAgICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpXSwgICAgICAgNywgLTY4MDg3NjkzNik7XG4gICAgICAgICAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSArICAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgICAgICAgICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2kgKyAgMl0sIDE3LCAgNjA2MTA1ODE5KTtcbiAgICAgICAgICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpICsgIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgICAgICAgICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2kgKyAgNF0sICA3LCAtMTc2NDE4ODk3KTtcbiAgICAgICAgICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpICsgIDVdLCAxMiwgIDEyMDAwODA0MjYpO1xuICAgICAgICAgICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2kgKyAgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgICAgICAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSArICA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgICAgICAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSArICA4XSwgIDcsICAxNzcwMDM1NDE2KTtcbiAgICAgICAgICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpICsgIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xuICAgICAgICAgICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2kgKyAxMF0sIDE3LCAtNDIwNjMpO1xuICAgICAgICAgICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2kgKyAxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XG4gICAgICAgICAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSArIDEyXSwgIDcsICAxODA0NjAzNjgyKTtcbiAgICAgICAgICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpICsgMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICAgICAgICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgICAgICAgICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2kgKyAxNV0sIDIyLCAgMTIzNjUzNTMyOSk7XG5cbiAgICAgICAgICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpICsgIDFdLCAgNSwgLTE2NTc5NjUxMCk7XG4gICAgICAgICAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSArICA2XSwgIDksIC0xMDY5NTAxNjMyKTtcbiAgICAgICAgICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNCwgIDY0MzcxNzcxMyk7XG4gICAgICAgICAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaV0sICAgICAgMjAsIC0zNzM4OTczMDIpO1xuICAgICAgICAgICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2kgKyAgNV0sICA1LCAtNzAxNTU4NjkxKTtcbiAgICAgICAgICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpICsgMTBdLCAgOSwgIDM4MDE2MDgzKTtcbiAgICAgICAgICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgICAgICAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSArICA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgICAgICAgICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2kgKyAgOV0sICA1LCAgNTY4NDQ2NDM4KTtcbiAgICAgICAgICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpICsgMTRdLCAgOSwgLTEwMTk4MDM2OTApO1xuICAgICAgICAgICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2kgKyAgM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICAgICAgICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpICsgIDhdLCAyMCwgIDExNjM1MzE1MDEpO1xuICAgICAgICAgICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2kgKyAxM10sICA1LCAtMTQ0NDY4MTQ2Nyk7XG4gICAgICAgICAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSArICAyXSwgIDksIC01MTQwMzc4NCk7XG4gICAgICAgICAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSArICA3XSwgMTQsICAxNzM1MzI4NDczKTtcbiAgICAgICAgICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpICsgMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuXG4gICAgICAgICAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSArICA1XSwgIDQsIC0zNzg1NTgpO1xuICAgICAgICAgICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2kgKyAgOF0sIDExLCAtMjAyMjU3NDQ2Myk7XG4gICAgICAgICAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTYsICAxODM5MDMwNTYyKTtcbiAgICAgICAgICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpICsgMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICAgICAgICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpICsgIDFdLCAgNCwgLTE1MzA5OTIwNjApO1xuICAgICAgICAgICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2kgKyAgNF0sIDExLCAgMTI3Mjg5MzM1Myk7XG4gICAgICAgICAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSArICA3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgICAgICAgICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2kgKyAxMF0sIDIzLCAtMTA5NDczMDY0MCk7XG4gICAgICAgICAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgIDQsICA2ODEyNzkxNzQpO1xuICAgICAgICAgICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2ldLCAgICAgIDExLCAtMzU4NTM3MjIyKTtcbiAgICAgICAgICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpICsgIDNdLCAxNiwgLTcyMjUyMTk3OSk7XG4gICAgICAgICAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSArICA2XSwgMjMsICA3NjAyOTE4OSk7XG4gICAgICAgICAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSArICA5XSwgIDQsIC02NDAzNjQ0ODcpO1xuICAgICAgICAgICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2kgKyAxMl0sIDExLCAtNDIxODE1ODM1KTtcbiAgICAgICAgICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNiwgIDUzMDc0MjUyMCk7XG4gICAgICAgICAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSArICAyXSwgMjMsIC05OTUzMzg2NTEpO1xuXG4gICAgICAgICAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaV0sICAgICAgIDYsIC0xOTg2MzA4NDQpO1xuICAgICAgICAgICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2kgKyAgN10sIDEwLCAgMTEyNjg5MTQxNSk7XG4gICAgICAgICAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcbiAgICAgICAgICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpICsgIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICAgICAgICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpICsgMTJdLCAgNiwgIDE3MDA0ODU1NzEpO1xuICAgICAgICAgICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2kgKyAgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgICAgICAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICAgICAgICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpICsgIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xuICAgICAgICAgICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2kgKyAgOF0sICA2LCAgMTg3MzMxMzM1OSk7XG4gICAgICAgICAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSArIDE1XSwgMTAsIC0zMDYxMTc0NCk7XG4gICAgICAgICAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSArICA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcbiAgICAgICAgICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpICsgMTNdLCAyMSwgIDEzMDkxNTE2NDkpO1xuICAgICAgICAgICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2kgKyAgNF0sICA2LCAtMTQ1NTIzMDcwKTtcbiAgICAgICAgICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpICsgMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xuICAgICAgICAgICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2kgKyAgMl0sIDE1LCAgNzE4Nzg3MjU5KTtcbiAgICAgICAgICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpICsgIDldLCAyMSwgLTM0MzQ4NTU1MSk7XG5cbiAgICAgICAgICAgIGEgPSBzYWZlX2FkZChhLCBvbGRhKTtcbiAgICAgICAgICAgIGIgPSBzYWZlX2FkZChiLCBvbGRiKTtcbiAgICAgICAgICAgIGMgPSBzYWZlX2FkZChjLCBvbGRjKTtcbiAgICAgICAgICAgIGQgPSBzYWZlX2FkZChkLCBvbGRkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2EsIGIsIGMsIGRdO1xuICAgIH1cblxuICAgIC8qXG4gICAgKiBDb252ZXJ0IGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMgdG8gYSBzdHJpbmdcbiAgICAqL1xuICAgIGZ1bmN0aW9uIGJpbmwycnN0cihpbnB1dCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIG91dHB1dCA9ICcnO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoICogMzI7IGkgKz0gOCkge1xuICAgICAgICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGlucHV0W2kgPj4gNV0gPj4+IChpICUgMzIpKSAmIDB4RkYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgLypcbiAgICAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHNcbiAgICAqIENoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpZ2gtYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxuICAgICovXG4gICAgZnVuY3Rpb24gcnN0cjJiaW5sKGlucHV0KSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgb3V0cHV0ID0gW107XG4gICAgICAgIG91dHB1dFsoaW5wdXQubGVuZ3RoID4+IDIpIC0gMV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG91dHB1dFtpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCAqIDg7IGkgKz0gOCkge1xuICAgICAgICAgICAgb3V0cHV0W2kgPj4gNV0gfD0gKGlucHV0LmNoYXJDb2RlQXQoaSAvIDgpICYgMHhGRikgPDwgKGkgJSAzMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICAvKlxuICAgICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYSByYXcgc3RyaW5nXG4gICAgKi9cbiAgICBmdW5jdGlvbiByc3RyX21kNShzKSB7XG4gICAgICAgIHJldHVybiBiaW5sMnJzdHIoYmlubF9tZDUocnN0cjJiaW5sKHMpLCBzLmxlbmd0aCAqIDgpKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICogQ2FsY3VsYXRlIHRoZSBITUFDLU1ENSwgb2YgYSBrZXkgYW5kIHNvbWUgZGF0YSAocmF3IHN0cmluZ3MpXG4gICAgKi9cbiAgICBmdW5jdGlvbiByc3RyX2htYWNfbWQ1KGtleSwgZGF0YSkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGJrZXkgPSByc3RyMmJpbmwoa2V5KSxcbiAgICAgICAgICAgIGlwYWQgPSBbXSxcbiAgICAgICAgICAgIG9wYWQgPSBbXSxcbiAgICAgICAgICAgIGhhc2g7XG4gICAgICAgIGlwYWRbMTVdID0gb3BhZFsxNV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChia2V5Lmxlbmd0aCA+IDE2KSB7XG4gICAgICAgICAgICBia2V5ID0gYmlubF9tZDUoYmtleSwga2V5Lmxlbmd0aCAqIDgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpcGFkW2ldID0gYmtleVtpXSBeIDB4MzYzNjM2MzY7XG4gICAgICAgICAgICBvcGFkW2ldID0gYmtleVtpXSBeIDB4NUM1QzVDNUM7XG4gICAgICAgIH1cbiAgICAgICAgaGFzaCA9IGJpbmxfbWQ1KGlwYWQuY29uY2F0KHJzdHIyYmlubChkYXRhKSksIDUxMiArIGRhdGEubGVuZ3RoICogOCk7XG4gICAgICAgIHJldHVybiBiaW5sMnJzdHIoYmlubF9tZDUob3BhZC5jb25jYXQoaGFzaCksIDUxMiArIDEyOCkpO1xuICAgIH1cblxuICAgIC8qXG4gICAgKiBDb252ZXJ0IGEgcmF3IHN0cmluZyB0byBhIGhleCBzdHJpbmdcbiAgICAqL1xuICAgIGZ1bmN0aW9uIHJzdHIyaGV4KGlucHV0KSB7XG4gICAgICAgIHZhciBoZXhfdGFiID0gJzAxMjM0NTY3ODlhYmNkZWYnLFxuICAgICAgICAgICAgb3V0cHV0ID0gJycsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB4ID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIG91dHB1dCArPSBoZXhfdGFiLmNoYXJBdCgoeCA+Pj4gNCkgJiAweDBGKSArXG4gICAgICAgICAgICAgICAgaGV4X3RhYi5jaGFyQXQoeCAmIDB4MEYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgLypcbiAgICAqIEVuY29kZSBhIHN0cmluZyBhcyB1dGYtOFxuICAgICovXG4gICAgZnVuY3Rpb24gc3RyMnJzdHJfdXRmOChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAqIFRha2Ugc3RyaW5nIGFyZ3VtZW50cyBhbmQgcmV0dXJuIGVpdGhlciByYXcgb3IgaGV4IGVuY29kZWQgc3RyaW5nc1xuICAgICovXG4gICAgZnVuY3Rpb24gcmF3X21kNShzKSB7XG4gICAgICAgIHJldHVybiByc3RyX21kNShzdHIycnN0cl91dGY4KHMpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGV4X21kNShzKSB7XG4gICAgICAgIHJldHVybiByc3RyMmhleChyYXdfbWQ1KHMpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmF3X2htYWNfbWQ1KGssIGQpIHtcbiAgICAgICAgcmV0dXJuIHJzdHJfaG1hY19tZDUoc3RyMnJzdHJfdXRmOChrKSwgc3RyMnJzdHJfdXRmOChkKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhleF9obWFjX21kNShrLCBkKSB7XG4gICAgICAgIHJldHVybiByc3RyMmhleChyYXdfaG1hY19tZDUoaywgZCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1kNShzdHJpbmcsIGtleSwgcmF3KSB7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICBpZiAoIXJhdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhfbWQ1KHN0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmF3X21kNShzdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmF3KSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4X2htYWNfbWQ1KGtleSwgc3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmF3X2htYWNfbWQ1KGtleSwgc3RyaW5nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbWQ1O1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAkLm1kNSA9IG1kNTtcbiAgICB9XG59KHRoaXMpKTtcblxufSkoKSIsInZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5leHBvcnRzLmF2YWlsYWJsZVNheFBhcnNlcnMgPSBbXTtcbmV4cG9ydHMuYmVzdFNheFBhcnNlciA9IG51bGw7XG5bJy4vc2F4X2V4cGF0LmpzJywgJy4vc2F4X2x0eC5qcycsIC8qJy4vc2F4X2Vhc3lzYXguanMnLCAnLi9zYXhfbm9kZS14bWwuanMnLCovICcuL3NheF9zYXhqcy5qcyddLmZvckVhY2goZnVuY3Rpb24obW9kTmFtZSkge1xuICAgIHZhciBtb2Q7XG4gICAgdHJ5IHtcblx0bW9kID0gcmVxdWlyZShtb2ROYW1lKTtcbiAgICB9IGNhdGNoIChlKSB7XG5cdC8qIFNpbGVudGx5IG1pc3NpbmcgbGlicmFyaWVzIGRyb3A7IGZvciBkZWJ1Zzpcblx0Y29uc29sZS5lcnJvcihlLnN0YWNrIHx8IGUpO1xuXHQgKi9cbiAgICB9XG4gICAgaWYgKG1vZCkge1xuXHRleHBvcnRzLmF2YWlsYWJsZVNheFBhcnNlcnMucHVzaChtb2QpO1xuXHRpZiAoIWV4cG9ydHMuYmVzdFNheFBhcnNlcilcblx0ICAgIGV4cG9ydHMuYmVzdFNheFBhcnNlciA9IG1vZDtcbiAgICB9XG59KTtcbnZhciBlbGVtZW50ID0gcmVxdWlyZSgnLi9lbGVtZW50Jyk7XG5cbmV4cG9ydHMuUGFyc2VyID0gZnVuY3Rpb24oc2F4UGFyc2VyKSB7XG4gICAgZXZlbnRzLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgIHZhciBwYXJzZXJNb2QgPSBzYXhQYXJzZXIgfHwgZXhwb3J0cy5iZXN0U2F4UGFyc2VyO1xuICAgIGlmICghcGFyc2VyTW9kKVxuXHR0aHJvdyBuZXcgRXJyb3IoXCJObyBTQVggcGFyc2VyIGF2YWlsYWJsZVwiKTtcbiAgICB0aGlzLnBhcnNlciA9IG5ldyBwYXJzZXJNb2QoKTtcblxuICAgIHZhciBlbDtcbiAgICB0aGlzLnBhcnNlci5hZGRMaXN0ZW5lcignc3RhcnRFbGVtZW50JywgZnVuY3Rpb24obmFtZSwgYXR0cnMpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbmV3IGVsZW1lbnQuRWxlbWVudChuYW1lLCBhdHRycyk7XG4gICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgIGVsID0gY2hpbGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbCA9IGVsLmNub2RlKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucGFyc2VyLmFkZExpc3RlbmVyKCdlbmRFbGVtZW50JywgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICAvKiBFcnIgKi9cbiAgICAgICAgfSBlbHNlIGlmIChlbCAmJiBuYW1lID09IGVsLm5hbWUpIHtcbiAgICAgICAgICAgIGlmIChlbC5wYXJlbnQpXG4gICAgICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnQ7XG4gICAgICAgICAgICBlbHNlIGlmICghdGhhdC50cmVlKSB7XG4gICAgICAgICAgICAgICAgdGhhdC50cmVlID0gZWw7XG4gICAgICAgICAgICAgICAgZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnBhcnNlci5hZGRMaXN0ZW5lcigndGV4dCcsIGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBpZiAoZWwpXG4gICAgICAgICAgICBlbC50KHN0cik7XG4gICAgfSk7XG4gICAgdGhpcy5wYXJzZXIuYWRkTGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24oZSkge1xuXHR0aGF0LmVycm9yID0gZTtcblx0dGhhdC5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0pO1xufTtcbnV0aWwuaW5oZXJpdHMoZXhwb3J0cy5QYXJzZXIsIGV2ZW50cy5FdmVudEVtaXR0ZXIpO1xuXG5leHBvcnRzLlBhcnNlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdGhpcy5wYXJzZXIud3JpdGUoZGF0YSk7XG59O1xuXG5leHBvcnRzLlBhcnNlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHRoaXMucGFyc2VyLmVuZChkYXRhKTtcblxuICAgIGlmICghdGhpcy5lcnJvcikge1xuXHRpZiAodGhpcy50cmVlKVxuXHQgICAgdGhpcy5lbWl0KCd0cmVlJywgdGhpcy50cmVlKTtcblx0ZWxzZVxuXHQgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW5jb21wbGV0ZSBkb2N1bWVudCcpKTtcbiAgICB9XG59O1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24oZGF0YSwgc2F4UGFyc2VyKSB7XG4gICAgdmFyIHAgPSBuZXcgZXhwb3J0cy5QYXJzZXIoc2F4UGFyc2VyKTtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbCwgZXJyb3IgPSBudWxsO1xuXG4gICAgcC5vbigndHJlZScsIGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgICAgcmVzdWx0ID0gdHJlZTtcbiAgICB9KTtcbiAgICBwLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZXJyb3IgPSBlO1xuICAgIH0pO1xuXG4gICAgcC53cml0ZShkYXRhKTtcbiAgICBwLmVuZCgpO1xuXG4gICAgaWYgKGVycm9yKVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG59O1xuIiwiKGZ1bmN0aW9uKEJ1ZmZlcil7LypcbiAqIHJtIC0gRmViIDIwMTFcbiAqIGN0eXBlLmpzXG4gKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgYSBzaW1wbGUgYWJzdHJhY3Rpb24gdG93YXJkcyByZWFkaW5nIGFuZCB3cml0aW5nXG4gKiBkaWZmZXJlbnQgdHlwZXMgb2YgYmluYXJ5IGRhdGEuIEl0IGlzIGRlc2lnbmVkIHRvIHVzZSBjdGlvLmpzIGFuZCBwcm92aWRlIGFcbiAqIHJpY2hlciBhbmQgbW9yZSBleHByZXNzaXZlIEFQSSBvbiB0b3Agb2YgaXQuXG4gKlxuICogQnkgZGVmYXVsdCB3ZSBzdXBwb3J0IHRoZSBmb2xsb3dpbmcgYXMgYnVpbHQgaW4gYmFzaWMgdHlwZXM6XG4gKlx0aW50OF90XG4gKlx0aW50MTZfdFxuICpcdGludDMyX3RcbiAqXHR1aW50OF90XG4gKlx0dWludDE2X3RcbiAqXHR1aW50MzJfdFxuICpcdHVpbnQ2NF90XG4gKlx0ZmxvYXRcbiAqXHRkb3VibGVcbiAqXHRjaGFyXG4gKlx0Y2hhcltdXG4gKlxuICogRWFjaCB0eXBlIGlzIHJldHVybmVkIGFzIGEgTnVtYmVyLCB3aXRoIHRoZSBleGNlcHRpb24gb2YgY2hhciBhbmQgY2hhcltdXG4gKiB3aGljaCBhcmUgcmV0dXJuZWQgYXMgTm9kZSBCdWZmZXJzLiBBIGNoYXIgaXMgY29uc2lkZXJlZCBhIHVpbnQ4X3QuXG4gKlxuICogUmVxdWVzdHMgdG8gcmVhZCBhbmQgd3JpdGUgZGF0YSBhcmUgc3BlY2lmaWVkIGFzIGFuIGFycmF5IG9mIEpTT04gb2JqZWN0cy5cbiAqIFRoaXMgaXMgYWxzbyB0aGUgc2FtZSB3YXkgdGhhdCBvbmUgZGVjbGFyZXMgc3RydWN0cy4gRXZlbiBpZiBqdXN0IGEgc2luZ2xlXG4gKiB2YWx1ZSBpcyByZXF1ZXN0ZWQsIGl0IG11c3QgYmUgZG9uZSBhcyBhIHN0cnVjdC4gVGhlIGFycmF5IG9yZGVyIGRldGVybWluZXNcbiAqIHRoZSBvcmRlciB0aGF0IHdlIHRyeSBhbmQgcmVhZCB2YWx1ZXMuIEVhY2ggZW50cnkgaGFzIHRoZSBmb2xsb3dpbmcgZm9ybWF0XG4gKiB3aXRoIHZhbHVlcyBtYXJrZWQgd2l0aCBhICogYmVpbmcgb3B0aW9uYWwuXG4gKlxuICogeyBrZXk6IHsgdHlwZTogL3R5cGUvLCB2YWx1ZSo6IC92YWx1ZS8sIG9mZnNldCo6IC9vZmZzZXQvIH1cbiAqXG4gKiBJZiBvZmZzZXQgaXMgZGVmaW5lZCwgd2UgbHNlZWsob2Zmc2V0LCBTRUVLX1NFVCkgYmVmb3JlIHJlYWRpbmcgdGhlIG5leHRcbiAqIHZhbHVlLiBWYWx1ZSBpcyBkZWZpbmVkIHdoZW4gd2UncmUgd3JpdGluZyBvdXQgZGF0YSwgb3RoZXJ3aXNlIGl0J3MgaWdub3JlZC5cbiAqXG4gKi9cblxudmFyIG1vZF9jdGYgPSByZXF1aXJlKCcuL2N0Zi5qcycpO1xudmFyIG1vZF9jdGlvID0gcmVxdWlyZSgnLi9jdGlvLmpzJyk7XG52YXIgbW9kX2Fzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG4vKlxuICogVGhpcyBpcyB0aGUgc2V0IG9mIGJhc2ljIHR5cGVzIHRoYXQgd2Ugc3VwcG9ydC5cbiAqXG4gKlx0cmVhZFx0XHRUaGUgZnVuY3Rpb24gdG8gY2FsbCB0byByZWFkIGluIGEgdmFsdWUgZnJvbSBhIGJ1ZmZlclxuICpcbiAqXHR3cml0ZVx0XHRUaGUgZnVuY3Rpb24gdG8gY2FsbCB0byB3cml0ZSBhIHZhbHVlIHRvIGEgYnVmZmVyXG4gKlxuICovXG52YXIgZGVmdHlwZXMgPSB7XG4gICAgJ3VpbnQ4X3QnOiAgeyByZWFkOiBjdFJlYWRVaW50OCwgd3JpdGU6IGN0V3JpdGVVaW50OCB9LFxuICAgICd1aW50MTZfdCc6IHsgcmVhZDogY3RSZWFkVWludDE2LCB3cml0ZTogY3RXcml0ZVVpbnQxNiB9LFxuICAgICd1aW50MzJfdCc6IHsgcmVhZDogY3RSZWFkVWludDMyLCB3cml0ZTogY3RXcml0ZVVpbnQzMiB9LFxuICAgICd1aW50NjRfdCc6IHsgcmVhZDogY3RSZWFkVWludDY0LCB3cml0ZTogY3RXcml0ZVVpbnQ2NCB9LFxuICAgICdpbnQ4X3QnOiB7IHJlYWQ6IGN0UmVhZFNpbnQ4LCB3cml0ZTogY3RXcml0ZVNpbnQ4IH0sXG4gICAgJ2ludDE2X3QnOiB7IHJlYWQ6IGN0UmVhZFNpbnQxNiwgd3JpdGU6IGN0V3JpdGVTaW50MTYgfSxcbiAgICAnaW50MzJfdCc6IHsgcmVhZDogY3RSZWFkU2ludDMyLCB3cml0ZTogY3RXcml0ZVNpbnQzMiB9LFxuICAgICdpbnQ2NF90JzogeyByZWFkOiBjdFJlYWRTaW50NjQsIHdyaXRlOiBjdFdyaXRlU2ludDY0IH0sXG4gICAgJ2Zsb2F0JzogeyByZWFkOiBjdFJlYWRGbG9hdCwgd3JpdGU6IGN0V3JpdGVGbG9hdCB9LFxuICAgICdkb3VibGUnOiB7IHJlYWQ6IGN0UmVhZERvdWJsZSwgd3JpdGU6IGN0V3JpdGVEb3VibGUgfSxcbiAgICAnY2hhcic6IHsgcmVhZDogY3RSZWFkQ2hhciwgd3JpdGU6IGN0V3JpdGVDaGFyIH0sXG4gICAgJ2NoYXJbXSc6IHsgcmVhZDogY3RSZWFkQ2hhckFycmF5LCB3cml0ZTogY3RXcml0ZUNoYXJBcnJheSB9XG59O1xuXG4vKlxuICogVGhlIGZvbGxvd2luZyBhcmUgd3JhcHBlcnMgYXJvdW5kIHRoZSBDVHlwZSBJTyBsb3cgbGV2ZWwgQVBJLiBUaGV5IGVuY29kZVxuICoga25vd2xlZGdlIGFib3V0IHRoZSBzaXplIGFuZCByZXR1cm4gc29tZXRoaW5nIGluIHRoZSBleHBlY3RlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIGN0UmVhZFVpbnQ4KGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciB2YWwgPSBtb2RfY3Rpby5ydWludDgoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCk7XG5cdHJldHVybiAoeyB2YWx1ZTogdmFsLCBzaXplOiAxIH0pO1xufVxuXG5mdW5jdGlvbiBjdFJlYWRVaW50MTYoZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0dmFyIHZhbCA9IG1vZF9jdGlvLnJ1aW50MTYoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCk7XG5cdHJldHVybiAoeyB2YWx1ZTogdmFsLCBzaXplOiAyIH0pO1xufVxuXG5mdW5jdGlvbiBjdFJlYWRVaW50MzIoZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0dmFyIHZhbCA9IG1vZF9jdGlvLnJ1aW50MzIoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCk7XG5cdHJldHVybiAoeyB2YWx1ZTogdmFsLCBzaXplOiA0IH0pO1xufVxuXG5mdW5jdGlvbiBjdFJlYWRVaW50NjQoZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0dmFyIHZhbCA9IG1vZF9jdGlvLnJ1aW50NjQoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCk7XG5cdHJldHVybiAoeyB2YWx1ZTogdmFsLCBzaXplOiA4IH0pO1xufVxuXG5mdW5jdGlvbiBjdFJlYWRTaW50OChlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgdmFsID0gbW9kX2N0aW8ucnNpbnQ4KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpO1xuXHRyZXR1cm4gKHsgdmFsdWU6IHZhbCwgc2l6ZTogMSB9KTtcbn1cblxuZnVuY3Rpb24gY3RSZWFkU2ludDE2KGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciB2YWwgPSBtb2RfY3Rpby5yc2ludDE2KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpO1xuXHRyZXR1cm4gKHsgdmFsdWU6IHZhbCwgc2l6ZTogMiB9KTtcbn1cblxuZnVuY3Rpb24gY3RSZWFkU2ludDMyKGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciB2YWwgPSBtb2RfY3Rpby5yc2ludDMyKGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpO1xuXHRyZXR1cm4gKHsgdmFsdWU6IHZhbCwgc2l6ZTogNCB9KTtcbn1cblxuZnVuY3Rpb24gY3RSZWFkU2ludDY0KGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciB2YWwgPSBtb2RfY3Rpby5yc2ludDY0KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpO1xuXHRyZXR1cm4gKHsgdmFsdWU6IHZhbCwgc2l6ZTogOCB9KTtcbn1cblxuZnVuY3Rpb24gY3RSZWFkRmxvYXQoZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0dmFyIHZhbCA9IG1vZF9jdGlvLnJmbG9hdChidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KTtcblx0cmV0dXJuICh7IHZhbHVlOiB2YWwsIHNpemU6IDQgfSk7XG59XG5cbmZ1bmN0aW9uIGN0UmVhZERvdWJsZShlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgdmFsID0gbW9kX2N0aW8ucmRvdWJsZShidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KTtcblx0cmV0dXJuICh7IHZhbHVlOiB2YWwsIHNpemU6IDggfSk7XG59XG5cbi8qXG4gKiBSZWFkcyBhIHNpbmdsZSBjaGFyYWN0ZXIgaW50byBhIG5vZGUgYnVmZmVyXG4gKi9cbmZ1bmN0aW9uIGN0UmVhZENoYXIoZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0dmFyIHJlcyA9IG5ldyBCdWZmZXIoMSk7XG5cdHJlc1swXSA9IG1vZF9jdGlvLnJ1aW50OChidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KTtcblx0cmV0dXJuICh7IHZhbHVlOiByZXMsIHNpemU6IDEgfSk7XG59XG5cbmZ1bmN0aW9uIGN0UmVhZENoYXJBcnJheShsZW5ndGgsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciBpaTtcblx0dmFyIHJlcyA9IG5ldyBCdWZmZXIobGVuZ3RoKTtcblxuXHRmb3IgKGlpID0gMDsgaWkgPCBsZW5ndGg7IGlpKyspXG5cdFx0cmVzW2lpXSA9IG1vZF9jdGlvLnJ1aW50OChidWZmZXIsIGVuZGlhbiwgb2Zmc2V0ICsgaWkpO1xuXG5cdHJldHVybiAoeyB2YWx1ZTogcmVzLCBzaXplOiBsZW5ndGggfSk7XG59XG5cbmZ1bmN0aW9uIGN0V3JpdGVVaW50OCh2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0bW9kX2N0aW8ud3VpbnQ4KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0cmV0dXJuICgxKTtcbn1cblxuZnVuY3Rpb24gY3RXcml0ZVVpbnQxNih2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0bW9kX2N0aW8ud3VpbnQxNih2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG5cdHJldHVybiAoMik7XG59XG5cbmZ1bmN0aW9uIGN0V3JpdGVVaW50MzIodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdG1vZF9jdGlvLnd1aW50MzIodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHRyZXR1cm4gKDQpO1xufVxuXG5mdW5jdGlvbiBjdFdyaXRlVWludDY0KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHRtb2RfY3Rpby53dWludDY0KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0cmV0dXJuICg4KTtcbn1cblxuZnVuY3Rpb24gY3RXcml0ZVNpbnQ4KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHRtb2RfY3Rpby53c2ludDgodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHRyZXR1cm4gKDEpO1xufVxuXG5mdW5jdGlvbiBjdFdyaXRlU2ludDE2KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHRtb2RfY3Rpby53c2ludDE2KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0cmV0dXJuICgyKTtcbn1cblxuZnVuY3Rpb24gY3RXcml0ZVNpbnQzMih2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0bW9kX2N0aW8ud3NpbnQzMih2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG5cdHJldHVybiAoNCk7XG59XG5cbmZ1bmN0aW9uIGN0V3JpdGVTaW50NjQodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdG1vZF9jdGlvLndzaW50NjQodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHRyZXR1cm4gKDgpO1xufVxuXG5mdW5jdGlvbiBjdFdyaXRlRmxvYXQodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdG1vZF9jdGlvLndmbG9hdCh2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG5cdHJldHVybiAoNCk7XG59XG5cbmZ1bmN0aW9uIGN0V3JpdGVEb3VibGUodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdG1vZF9jdGlvLndkb3VibGUodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHRyZXR1cm4gKDgpO1xufVxuXG4vKlxuICogV3JpdGVzIGEgc2luZ2xlIGNoYXJhY3RlciBpbnRvIGEgbm9kZSBidWZmZXJcbiAqL1xuZnVuY3Rpb24gY3RXcml0ZUNoYXIodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdGlmICghKHZhbHVlIGluc3RhbmNlb2YgQnVmZmVyKSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCdJbnB1dCBtdXN0IGJlIGEgYnVmZmVyJykpO1xuXG5cdG1vZF9jdGlvLnJ1aW50OCh2YWx1ZVswXSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG5cdHJldHVybiAoMSk7XG59XG5cbi8qXG4gKiBXZSdyZSBnb2luZyB0byB3cml0ZSAwcyBpbnRvIHRoZSBidWZmZXIgaWYgdGhlIHN0cmluZyBpcyBzaG9ydGVyIHRoYW4gdGhlXG4gKiBsZW5ndGggb2YgdGhlIGFycmF5LlxuICovXG5mdW5jdGlvbiBjdFdyaXRlQ2hhckFycmF5KHZhbHVlLCBsZW5ndGgsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciBpaTtcblxuXHRpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEJ1ZmZlcikpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignSW5wdXQgbXVzdCBiZSBhIGJ1ZmZlcicpKTtcblxuXHRpZiAodmFsdWUubGVuZ3RoID4gbGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ3ZhbHVlIGxlbmd0aCBncmVhdGVyIHRoYW4gYXJyYXkgbGVuZ3RoJykpO1xuXG5cdGZvciAoaWkgPSAwOyBpaSA8IHZhbHVlLmxlbmd0aCAmJiBpaSA8IGxlbmd0aDsgaWkrKylcblx0XHRtb2RfY3Rpby53dWludDgodmFsdWVbaWldLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0ICsgaWkpO1xuXG5cdGZvciAoOyBpaSA8IGxlbmd0aDsgaWkrKylcblx0XHRtb2RfY3Rpby53dWludDgoMCwgZW5kaWFuLCBvZmZzZXQgKyBpaSk7XG5cblxuXHRyZXR1cm4gKGxlbmd0aCk7XG59XG5cbi8qXG4gKiBFYWNoIHBhcnNlciBoYXMgdGhlaXIgb3duIHNldCBvZiB0eXBlcy4gV2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCB0aGV5IGVhY2hcbiAqIGdldCB0aGVpciBvd24gY29weSBhcyB0aGV5IG1heSBuZWVkIHRvIG1vZGlmeSBpdC5cbiAqL1xuZnVuY3Rpb24gY3RHZXRCYXNpY1R5cGVzKClcbntcblx0dmFyIHJldCA9IHt9O1xuXHR2YXIga2V5O1xuXHRmb3IgKGtleSBpbiBkZWZ0eXBlcylcblx0XHRyZXRba2V5XSA9IGRlZnR5cGVzW2tleV07XG5cblx0cmV0dXJuIChyZXQpO1xufVxuXG4vKlxuICogR2l2ZW4gYSBzdHJpbmcgaW4gdGhlIGZvcm0gb2YgdHlwZVtsZW5ndGhdIHdlIHdhbnQgdG8gc3BsaXQgdGhpcyBpbnRvIGFuXG4gKiBvYmplY3QgdGhhdCBleHRyYWN0cyB0aGF0IGluZm9ybWF0aW9uLiBXZSB3YW50IHRvIG5vdGUgdGhhdCB3ZSBjb3VsZCBwb3NzaWJseVxuICogaGF2ZSBuZXN0ZWQgYXJyYXlzIHNvIHRoaXMgc2hvdWxkIG9ubHkgY2hlY2sgdGhlIGZ1cnRoZXN0IG9uZS4gSXQgbWF5IGFsc28gYmVcbiAqIHRoZSBjYXNlIHRoYXQgd2UgaGF2ZSBubyBbXSBwaWVjZXMsIGluIHdoaWNoIGNhc2Ugd2UganVzdCByZXR1cm4gdGhlIGN1cnJlbnRcbiAqIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGN0UGFyc2VUeXBlKHN0cilcbntcblx0dmFyIGJlZ0luZCwgZW5kSW5kO1xuXHR2YXIgdHlwZSwgbGVuO1xuXHRpZiAodHlwZW9mIChzdHIpICE9ICdzdHJpbmcnKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ3R5cGUgbXVzdCBiZSBhIEphdmFzY3JpcHQgc3RyaW5nJykpO1xuXG5cdGVuZEluZCA9IHN0ci5sYXN0SW5kZXhPZignXScpO1xuXHRpZiAoZW5kSW5kID09IC0xKSB7XG5cdFx0aWYgKHN0ci5sYXN0SW5kZXhPZignWycpICE9IC0xKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignZm91bmQgaW52YWxpZCB0eXBlIHdpdGggXFwnW1xcJyBidXQgJyArXG5cdFx0XHQgICAgJ25vIGNvcnJlc3BvbmRpbmcgXFwnXVxcJycpKTtcblxuXHRcdHJldHVybiAoeyB0eXBlOiBzdHIgfSk7XG5cdH1cblxuXHRiZWdJbmQgPSBzdHIubGFzdEluZGV4T2YoJ1snKTtcblx0aWYgKGJlZ0luZCA9PSAtMSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCdmb3VuZCBpbnZhbGlkIHR5cGUgd2l0aCBcXCddXFwnIGJ1dCAnICtcblx0XHQgICAgJ25vIGNvcnJlc3BvbmRpbmcgXFwnW1xcJycpKTtcblxuXHRpZiAoYmVnSW5kID49IGVuZEluZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtYWxmb3JtZWQgdHlwZSwgXFwnXVxcJyBhcHBlYXJzIGJlZm9yZSBcXCdbXFwnJykpO1xuXG5cdHR5cGUgPSBzdHIuc3Vic3RyaW5nKDAsIGJlZ0luZCk7XG5cdGxlbiA9IHN0ci5zdWJzdHJpbmcoYmVnSW5kICsgMSwgZW5kSW5kKTtcblxuXHRyZXR1cm4gKHsgdHlwZTogdHlwZSwgbGVuOiBsZW4gfSk7XG59XG5cbi8qXG4gKiBHaXZlbiBhIHJlcXVlc3QgdmFsaWRhdGUgdGhhdCBhbGwgb2YgdGhlIGZpZWxkcyBmb3IgaXQgYXJlIHZhbGlkIGFuZCBtYWtlXG4gKiBzZW5zZS4gVGhpcyBpbmNsdWRlcyB2ZXJpZnlpbmcgdGhlIGZvbGxvd2luZyBub3Rpb25zOlxuICogIC0gRWFjaCB0eXBlIHJlcXVlc3RlZCBpcyBwcmVzZW50IGluIHR5cGVzXG4gKiAgLSBPbmx5IGFsbG93IGEgbmFtZSBmb3IgYSBmaWVsZCB0byBiZSBzcGVjaWZpZWQgb25jZVxuICogIC0gSWYgYW4gYXJyYXkgaXMgc3BlY2lmaWVkLCB2YWxpZGF0ZSB0aGF0IHRoZSByZXF1ZXN0ZWQgZmllbGQgZXhpc3RzIGFuZFxuICogICAgY29tZXMgYmVmb3JlIGl0LlxuICogIC0gSWYgZmllbGRzIGlzIGRlZmluZWQsIGNoZWNrIHRoYXQgZWFjaCBlbnRyeSBoYXMgdGhlIG9jY3VycmVuY2Ugb2YgZmllbGRcbiAqL1xuZnVuY3Rpb24gY3RDaGVja1JlcShkZWYsIHR5cGVzLCBmaWVsZHMpXG57XG5cdHZhciBpaSwgamo7XG5cdHZhciByZXEsIGtleXMsIGtleTtcblx0dmFyIGZvdW5kID0ge307XG5cblx0aWYgKCEoZGVmIGluc3RhbmNlb2YgQXJyYXkpKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ2RlZmluaXRpb24gaXMgbm90IGFuIGFycmF5JykpO1xuXG5cdGlmIChkZWYubGVuZ3RoID09PSAwKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ2RlZmluaXRpb24gbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBlbGVtZW50JykpO1xuXG5cdGZvciAoaWkgPSAwOyBpaSA8IGRlZi5sZW5ndGg7IGlpKyspIHtcblx0XHRyZXEgPSBkZWZbaWldO1xuXHRcdGlmICghKHJlcSBpbnN0YW5jZW9mIE9iamVjdCkpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdkZWZpbml0aW9uIG11c3QgYmUgYW4gYXJyYXkgb2YnICtcblx0XHRcdCAgICAnb2JqZWN0cycpKTtcblxuXHRcdGtleXMgPSBPYmplY3Qua2V5cyhyZXEpO1xuXHRcdGlmIChrZXlzLmxlbmd0aCAhPSAxKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignZGVmaW5pdGlvbiBlbnRyeSBtdXN0IG9ubHkgaGF2ZSAnICtcblx0XHRcdCAgICAnb25lIGtleScpKTtcblxuXHRcdGlmIChrZXlzWzBdIGluIGZvdW5kKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignU3BlY2lmaWVkIG5hbWUgYWxyZWFkeSAnICtcblx0XHRcdCAgICAnc3BlY2lmaWVkOiAnICsga2V5c1swXSkpO1xuXG5cdFx0aWYgKCEoJ3R5cGUnIGluIHJlcVtrZXlzWzBdXSkpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHR5cGUgZGVmaW5pdGlvbicpKTtcblxuXHRcdGtleSA9IGN0UGFyc2VUeXBlKHJlcVtrZXlzWzBdXVsndHlwZSddKTtcblxuXHRcdC8qXG5cdFx0ICogV2UgbWF5IGhhdmUgbmVzdGVkIGFycmF5cywgd2UgbmVlZCB0byBjaGVjayB0aGUgdmFsaWRpdHkgb2Zcblx0XHQgKiB0aGUgdHlwZXMgdW50aWwgdGhlIGxlbiBmaWVsZCBpcyB1bmRlZmluZWQgaW4ga2V5LiBIb3dldmVyLFxuXHRcdCAqIGVhY2ggdGltZSBsZW4gaXMgZGVmaW5lZCB3ZSBuZWVkIHRvIHZlcmlmeSBpdCBpcyBlaXRoZXIgYW5cblx0XHQgKiBpbnRlZ2VyIG9yIGNvcnJlc3BvbmRzIHRvIGFuIGFscmVhZHkgc2VlbiBrZXkuXG5cdFx0ICovXG5cdFx0d2hpbGUgKGtleVsnbGVuJ10gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKGlzTmFOKHBhcnNlSW50KGtleVsnbGVuJ10sIDEwKSkpIHtcblx0XHRcdFx0aWYgKCEoa2V5WydsZW4nXSBpbiBmb3VuZCkpXG5cdFx0XHRcdFx0dGhyb3cgKG5ldyBFcnJvcignR2l2ZW4gYW4gYXJyYXkgJyArXG5cdFx0XHRcdFx0ICAgICdsZW5ndGggd2l0aG91dCBhIG1hdGNoaW5nIHR5cGUnKSk7XG5cblx0XHRcdH1cblxuXHRcdFx0a2V5ID0gY3RQYXJzZVR5cGUoa2V5Wyd0eXBlJ10pO1xuXHRcdH1cblxuXHRcdC8qIE5vdyB3ZSBjYW4gdmFsaWRhdGUgaWYgdGhlIHR5cGUgaXMgdmFsaWQgKi9cblx0XHRpZiAoIShrZXlbJ3R5cGUnXSBpbiB0eXBlcykpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCd0eXBlIG5vdCBmb3VuZCBvciB0eXBkZWZlZDogJyArXG5cdFx0XHQgICAga2V5Wyd0eXBlJ10pKTtcblxuXHRcdC8qIENoZWNrIGZvciBhbnkgcmVxdWlyZWQgZmllbGRzICovXG5cdFx0aWYgKGZpZWxkcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRmb3IgKGpqID0gMDsgamogPCBmaWVsZHMubGVuZ3RoOyBqaisrKSB7XG5cdFx0XHRcdGlmICghKGZpZWxkc1tqal0gaW4gcmVxW2tleXNbMF1dKSlcblx0XHRcdFx0XHR0aHJvdyAobmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkICcgK1xuXHRcdFx0XHRcdCAgICAnZmllbGQ6ICcgKyBmaWVsZHNbampdKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm91bmRba2V5c1swXV0gPSB0cnVlO1xuXHR9XG59XG5cblxuLypcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgcGFyc2VyLiBFYWNoIHBhcnNlciBoYXMgaXRzIG93biBzdG9yZSBvZlxuICogdHlwZWRlZnMgYW5kIGVuZGlhbm5lc3MuIENvbmYgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyByZXF1aXJlZFxuICogdmFsdWVzOlxuICpcbiAqXHRlbmRpYW5cdFx0RWl0aGVyICdiaWcnIG9yICdsaXR0bGUnIGRvIGRldGVybWluZSB0aGUgZW5kaWFubmVzcyB3ZVxuICpcdFx0XHR3YW50IHRvIHJlYWQgZnJvbSBvciB3cml0ZSB0by5cbiAqXG4gKiBBbmQgdGhlIGZvbGxvd2luZyBvcHRpb25hbCB2YWx1ZXM6XG4gKlxuICogXHRjaGFyLXR5cGVcdFZhbGlkIG9wdGlvbnMgaGVyZSBhcmUgdWludDggYW5kIGludDguIElmIHVpbnQ4IGlzXG4gKiBcdFx0XHRzcGVjaWZpZWQgdGhpcyBjaGFuZ2VzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGEgc2luZ2xlXG4gKiBcdFx0XHRjaGFyIGZyb20gYmVpbmcgYSBidWZmZXIgb2YgYSBzaW5nbGUgY2hhcmFjdGVyIHRvIGJlaW5nXG4gKiBcdFx0XHRhIHVpbnQ4X3QuIElmIGludDgsIGl0IGJlY29tZXMgYW4gaW50OF90IGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIENUeXBlUGFyc2VyKGNvbmYpXG57XG5cdGlmICghY29uZikgdGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBhcmd1bWVudCcpKTtcblxuXHRpZiAoISgnZW5kaWFuJyBpbiBjb25mKSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIGVuZGlhbiB2YWx1ZScpKTtcblxuXHRpZiAoY29uZlsnZW5kaWFuJ10gIT0gJ2JpZycgJiYgY29uZlsnZW5kaWFuJ10gIT0gJ2xpdHRsZScpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignSW52YWxpZCBlbmRpYW4gdHlwZScpKTtcblxuXHRpZiAoJ2NoYXItdHlwZScgaW4gY29uZiAmJiAoY29uZlsnY2hhci10eXBlJ10gIT0gJ3VpbnQ4JyAmJlxuXHQgICAgY29uZlsnY2hhci10eXBlJ10gIT0gJ2ludDgnKSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCdpbnZhbGlkIG9wdGlvbiBmb3IgY2hhci10eXBlOiAnICtcblx0XHQgICAgY29uZlsnY2hhci10eXBlJ10pKTtcblxuXHR0aGlzLmVuZGlhbiA9IGNvbmZbJ2VuZGlhbiddO1xuXHR0aGlzLnR5cGVzID0gY3RHZXRCYXNpY1R5cGVzKCk7XG5cblx0Lypcblx0ICogVGhlcmUgbWF5IGJlIGEgbW9yZSBncmFjZWZ1bCB3YXkgdG8gZG8gdGhpcywgYnV0IHRoaXMgd2lsbCBoYXZlIHRvXG5cdCAqIHNlcnZlLlxuXHQgKi9cblx0aWYgKCdjaGFyLXR5cGUnIGluIGNvbmYgJiYgY29uZlsnY2hhci10eXBlJ10gPT0gJ3VpbnQ4Jylcblx0XHR0aGlzLnR5cGVzWydjaGFyJ10gPSB0aGlzLnR5cGVzWyd1aW50OF90J107XG5cblx0aWYgKCdjaGFyLXR5cGUnIGluIGNvbmYgJiYgY29uZlsnY2hhci10eXBlJ10gPT0gJ2ludDgnKVxuXHRcdHRoaXMudHlwZXNbJ2NoYXInXSA9IHRoaXMudHlwZXNbJ2ludDhfdCddO1xufVxuXG4vKlxuICogU2V0cyB0aGUgY3VycmVudCBlbmRpYW4gdmFsdWUgZm9yIHRoZSBQYXJzZXIuIElmIHRoZSB2YWx1ZSBpcyBub3QgdmFsaWQsXG4gKiB0aHJvd3MgYW4gRXJyb3IuXG4gKlxuICpcdGVuZGlhblx0XHRFaXRoZXIgJ2JpZycgb3IgJ2xpdHRsZScgZG8gZGV0ZXJtaW5lIHRoZSBlbmRpYW5uZXNzIHdlXG4gKlx0XHRcdHdhbnQgdG8gcmVhZCBmcm9tIG9yIHdyaXRlIHRvLlxuICpcbiAqL1xuQ1R5cGVQYXJzZXIucHJvdG90eXBlLnNldEVuZGlhbiA9IGZ1bmN0aW9uIChlbmRpYW4pXG57XG5cdGlmIChlbmRpYW4gIT0gJ2JpZycgJiYgZW5kaWFuICE9ICdsaXR0bGUnKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ2ludmFsaWQgZW5kaWFuIHR5cGUsIG11c3QgYmUgYmlnIG9yICcgK1xuXHRcdCAgICAnbGl0dGxlJykpO1xuXG5cdHRoaXMuZW5kaWFuID0gZW5kaWFuO1xufTtcblxuLypcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGVuZGlhbiB2YWx1ZSBmb3IgdGhlIHBhcnNlci5cbiAqL1xuQ1R5cGVQYXJzZXIucHJvdG90eXBlLmdldEVuZGlhbiA9IGZ1bmN0aW9uICgpXG57XG5cdHJldHVybiAodGhpcy5lbmRpYW4pO1xufTtcblxuLypcbiAqIEEgdXNlciBoYXMgcmVxdWVzdGVkIHRvIGFkZCBhIHR5cGUsIGxldCB1cyBob25vciB0aGVpciByZXF1ZXN0LiBZZXQsIGlmIHRoZWlyXG4gKiByZXF1ZXN0IGRvdGggc3B1cm4gdXMsIHNlbmQgdGhlbSB1bnRvIHRoZSBIZWxscyB3aGljaCBEYW50ZSBkZXNjcmliZXMuXG4gKlxuICogXHRuYW1lXHRcdFRoZSBzdHJpbmcgZm9yIHRoZSB0eXBlIGRlZmluaXRpb24gd2UncmUgYWRkaW5nXG4gKlxuICpcdHZhbHVlXHRcdEVpdGhlciBhIHN0cmluZyB0aGF0IGlzIGEgdHlwZS9hcnJheSBuYW1lIG9yIGFuIG9iamVjdFxuICpcdFx0XHR0aGF0IGRlc2NyaWJlcyBhIHN0cnVjdC5cbiAqL1xuQ1R5cGVQYXJzZXIucHJvdG90eXBlLnR5cGVkZWYgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpXG57XG5cdHZhciB0eXBlO1xuXG5cdGlmIChuYW1lID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyAoRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgdHlwZWRlZiBhcmd1bWVudDogbmFtZScpKSk7XG5cblx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyAoRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgdHlwZWRlZiBhcmd1bWVudDogdmFsdWUnKSkpO1xuXG5cdGlmICh0eXBlb2YgKG5hbWUpICE9ICdzdHJpbmcnKVxuXHRcdHRocm93IChuZXcgKEVycm9yKCd0aGUgbmFtZSBvZiBhIHR5cGUgbXVzdCBiZSBhIHN0cmluZycpKSk7XG5cblx0dHlwZSA9IGN0UGFyc2VUeXBlKG5hbWUpO1xuXG5cdGlmICh0eXBlWydsZW4nXSAhPT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ0Nhbm5vdCBoYXZlIGFuIGFycmF5IGluIHRoZSB0eXBlZGVmIG5hbWUnKSk7XG5cblx0aWYgKG5hbWUgaW4gdGhpcy50eXBlcylcblx0XHR0aHJvdyAobmV3IEVycm9yKCd0eXBlZGVmIG5hbWUgYWxyZWFkeSBwcmVzZW50OiAnICsgbmFtZSkpO1xuXG5cdGlmICh0eXBlb2YgKHZhbHVlKSAhPSAnc3RyaW5nJyAmJiAhKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ3R5cGVkZWYgdmFsdWUgbXVzdCBlaXRoZXIgYmUgYSBzdHJpbmcgb3IgJyArXG5cdFx0ICAgICdzdHJ1Y3QnKSk7XG5cblx0aWYgKHR5cGVvZiAodmFsdWUpID09ICdzdHJpbmcnKSB7XG5cdFx0dHlwZSA9IGN0UGFyc2VUeXBlKHZhbHVlKTtcblx0XHRpZiAodHlwZVsnbGVuJ10gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKGlzTmFOKHBhcnNlSW50KHR5cGVbJ2xlbiddLCAxMCkpKVxuXHRcdFx0XHR0aHJvdyAobmV3IChFcnJvcigndHlwZWRlZiB2YWx1ZSBtdXN0IHVzZSAnICtcblx0XHRcdFx0ICAgICdmaXhlZCBzaXplIGFycmF5IHdoZW4gb3V0c2lkZSBvZiBhICcgK1xuXHRcdFx0XHQgICAgJ3N0cnVjdCcpKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy50eXBlc1tuYW1lXSA9IHZhbHVlO1xuXHR9IGVsc2Uge1xuXHRcdC8qIFdlIGhhdmUgYSBzdHJ1Y3QsIHZhbGlkYXRlIGl0ICovXG5cdFx0Y3RDaGVja1JlcSh2YWx1ZSwgdGhpcy50eXBlcyk7XG5cdFx0dGhpcy50eXBlc1tuYW1lXSA9IHZhbHVlO1xuXHR9XG59O1xuXG4vKlxuICogSW5jbHVkZSBhbGwgb2YgdGhlIHR5cGVkZWZzLCBidXQgbm9uZSBvZiB0aGUgYnVpbHQgaW4gdHlwZXMuIFRoaXMgc2hvdWxkIGJlXG4gKiB0cmVhdGVkIGFzIHJlYWQtb25seS5cbiAqL1xuQ1R5cGVQYXJzZXIucHJvdG90eXBlLmxzdHlwZXMgPSBmdW5jdGlvbiAoKVxue1xuXHR2YXIga2V5O1xuXHR2YXIgcmV0ID0ge307XG5cblx0Zm9yIChrZXkgaW4gdGhpcy50eXBlcykge1xuXHRcdGlmIChrZXkgaW4gZGVmdHlwZXMpXG5cdFx0XHRjb250aW51ZTtcblx0XHRyZXRba2V5XSA9IHRoaXMudHlwZXNba2V5XTtcblx0fVxuXG5cdHJldHVybiAocmV0KTtcbn07XG5cbi8qXG4gKiBHaXZlbiBhIHR5cGUgc3RyaW5nIHRoYXQgbWF5IGhhdmUgYXJyYXkgdHlwZXMgdGhhdCBhcmVuJ3QgbnVtYmVycywgdHJ5IGFuZFxuICogZmlsbCB0aGVtIGluIGZyb20gdGhlIHZhbHVlcyBvYmplY3QuIFRoZSBvYmplY3Qgc2hvdWxkIGJlIG9mIHRoZSBmb3JtYXQgd2hlcmVcbiAqIGluZGV4aW5nIGludG8gaXQgc2hvdWxkIHJldHVybiBhIG51bWJlciBmb3IgdGhhdCB0eXBlLlxuICpcbiAqXHRzdHJcdFx0VGhlIHR5cGUgc3RyaW5nXG4gKlxuICpcdHZhbHVlc1x0XHRBbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBmdWxmaWxsIHR5cGUgaW5mb3JtYXRpb25cbiAqL1xuZnVuY3Rpb24gY3RSZXNvbHZlQXJyYXkoc3RyLCB2YWx1ZXMpXG57XG5cdHZhciByZXQgPSAnJztcblx0dmFyIHR5cGUgPSBjdFBhcnNlVHlwZShzdHIpO1xuXG5cdHdoaWxlICh0eXBlWydsZW4nXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKGlzTmFOKHBhcnNlSW50KHR5cGVbJ2xlbiddLCAxMCkpKSB7XG5cdFx0XHRpZiAodHlwZW9mICh2YWx1ZXNbdHlwZVsnbGVuJ11dKSAhPSAnbnVtYmVyJylcblx0XHRcdFx0dGhyb3cgKG5ldyBFcnJvcignY2Fubm90IHNhd3AgaW4gbm9uLW51bWJlciAnICtcblx0XHRcdFx0ICAgICdmb3IgYXJyYXkgdmFsdWUnKSk7XG5cdFx0XHRyZXQgPSAnWycgKyB2YWx1ZXNbdHlwZVsnbGVuJ11dICsgJ10nICsgcmV0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXQgPSAnWycgKyB0eXBlWydsZW4nXSArICddJyArIHJldDtcblx0XHR9XG5cdFx0dHlwZSA9IGN0UGFyc2VUeXBlKHR5cGVbJ3R5cGUnXSk7XG5cdH1cblxuXHRyZXQgPSB0eXBlWyd0eXBlJ10gKyByZXQ7XG5cblx0cmV0dXJuIChyZXQpO1xufVxuXG4vKlxuICogW3ByaXZhdGVdIEVpdGhlciB0aGUgdHlwZWRlZiByZXNvbHZlcyB0byBhbm90aGVyIHR5cGUgc3RyaW5nIG9yIHRvIGEgc3RydWN0LlxuICogSWYgaXQgcmVzb2x2ZXMgdG8gYSBzdHJ1Y3QsIHdlIGp1c3QgcGFzcyBpdCBvZmYgdG8gcmVhZCBzdHJ1Y3QuIElmIG5vdCwgd2VcbiAqIGNhbiBqdXN0IHBhc3MgaXQgb2ZmIHRvIHJlYWQgZW50cnkuXG4gKi9cbkNUeXBlUGFyc2VyLnByb3RvdHlwZS5yZXNvbHZlVHlwZWRlZiA9IGZ1bmN0aW9uICh0eXBlLCBkaXNwYXRjaCwgYnVmZmVyLFxuICAgIG9mZnNldCwgdmFsdWUpXG57XG5cdHZhciBwdDtcblxuXHRtb2RfYXNzZXJ0Lm9rKHR5cGUgaW4gdGhpcy50eXBlcyk7XG5cdGlmICh0eXBlb2YgKHRoaXMudHlwZXNbdHlwZV0pID09ICdzdHJpbmcnKSB7XG5cdFx0cHQgPSBjdFBhcnNlVHlwZSh0aGlzLnR5cGVzW3R5cGVdKTtcblx0XHRpZiAoZGlzcGF0Y2ggPT0gJ3JlYWQnKVxuXHRcdFx0cmV0dXJuICh0aGlzLnJlYWRFbnRyeShwdCwgYnVmZmVyLCBvZmZzZXQpKTtcblx0XHRlbHNlIGlmIChkaXNwYXRjaCA9PSAnd3JpdGUnKVxuXHRcdFx0cmV0dXJuICh0aGlzLndyaXRlRW50cnkodmFsdWUsIHB0LCBidWZmZXIsIG9mZnNldCkpO1xuXHRcdGVsc2Vcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ2ludmFsaWQgZGlzcGF0Y2ggdHlwZSB0byAnICtcblx0XHRcdCAgICAncmVzb2x2ZVR5cGVkZWYnKSk7XG5cdH0gZWxzZSB7XG5cdFx0aWYgKGRpc3BhdGNoID09ICdyZWFkJylcblx0XHRcdHJldHVybiAodGhpcy5yZWFkU3RydWN0KHRoaXMudHlwZXNbdHlwZV0sIGJ1ZmZlcixcblx0XHRcdCAgICBvZmZzZXQpKTtcblx0XHRlbHNlIGlmIChkaXNwYXRjaCA9PSAnd3JpdGUnKVxuXHRcdFx0cmV0dXJuICh0aGlzLndyaXRlU3RydWN0KHZhbHVlLCB0aGlzLnR5cGVzW3R5cGVdLFxuXHRcdFx0ICAgIGJ1ZmZlciwgb2Zmc2V0KSk7XG5cdFx0ZWxzZVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignaW52YWxpZCBkaXNwYXRjaCB0eXBlIHRvICcgK1xuXHRcdFx0ICAgICdyZXNvbHZlVHlwZWRlZicpKTtcblx0fVxuXG59O1xuXG4vKlxuICogW3ByaXZhdGVdIFRyeSBhbmQgcmVhZCBpbiB0aGUgc3BlY2lmaWMgZW50cnkuXG4gKi9cbkNUeXBlUGFyc2VyLnByb3RvdHlwZS5yZWFkRW50cnkgPSBmdW5jdGlvbiAodHlwZSwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciBwYXJzZSwgbGVuO1xuXG5cdC8qXG5cdCAqIEJlY2F1c2Ugd2Ugd2FudCB0byBzcGVjaWFsIGNhc2UgY2hhcltdcyB0aGlzIGlzIHVuZm9ydHVuYXRlbHlcblx0ICogYSBiaXQgdWdsaWVyIHRoYW4gaXQgcmVhbGx5IHNob3VsZCBiZS4gV2Ugd2FudCB0byBzcGVjaWFsXG5cdCAqIGNhc2UgY2hhcltdcyBzbyB0aGF0IHdlIHJldHVybiBhIG5vZGUgYnVmZmVyLCB0aHVzIHRoZXkgYXJlIGFcblx0ICogZmlyc3QgY2xhc3MgdHlwZSB3aGVyZSBhcyBhbGwgb3RoZXIgYXJyYXlzIGp1c3QgY2FsbCBpbnRvIGFcblx0ICogZ2VuZXJpYyBhcnJheSByb3V0aW5lIHdoaWNoIGNhbGxzIHRoZWlyIGRhdGEtc3BlY2lmaWMgcm91dGluZVxuXHQgKiB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiB0aW1lcy5cblx0ICpcblx0ICogVGhlIHZhbGlkIGRpc3BhdGNoIG9wdGlvbnMgd2UgaGF2ZSBhcmU6XG5cdCAqICAtIEFycmF5IGFuZCBjaGFyID0+IGNoYXJbXSBoYW5kbGVyXG5cdCAqICAtIEdlbmVyaWMgYXJyYXkgaGFuZGxlclxuXHQgKiAgLSBHZW5lcmljIHR5cGVkZWYgaGFuZGxlclxuXHQgKiAgLSBCYXNpYyB0eXBlIGhhbmRsZXJcblx0ICovXG5cdGlmICh0eXBlWydsZW4nXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0bGVuID0gcGFyc2VJbnQodHlwZVsnbGVuJ10sIDEwKTtcblx0XHRpZiAoaXNOYU4obGVuKSlcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ3NvbWVob3cgZ290IGEgbm9uLW51bWVyaWMgbGVuZ3RoJykpO1xuXG5cdFx0aWYgKHR5cGVbJ3R5cGUnXSA9PSAnY2hhcicpXG5cdFx0XHRwYXJzZSA9IHRoaXMudHlwZXNbJ2NoYXJbXSddWydyZWFkJ10obGVuLFxuXHRcdFx0ICAgIHRoaXMuZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG5cdFx0ZWxzZVxuXHRcdFx0cGFyc2UgPSB0aGlzLnJlYWRBcnJheSh0eXBlWyd0eXBlJ10sXG5cdFx0XHQgICAgbGVuLCBidWZmZXIsIG9mZnNldCk7XG5cdH0gZWxzZSB7XG5cdFx0aWYgKHR5cGVbJ3R5cGUnXSBpbiBkZWZ0eXBlcylcblx0XHRcdHBhcnNlID0gdGhpcy50eXBlc1t0eXBlWyd0eXBlJ11dWydyZWFkJ10odGhpcy5lbmRpYW4sXG5cdFx0XHQgICAgYnVmZmVyLCBvZmZzZXQpO1xuXHRcdGVsc2Vcblx0XHRcdHBhcnNlID0gdGhpcy5yZXNvbHZlVHlwZWRlZih0eXBlWyd0eXBlJ10sICdyZWFkJyxcblx0XHRcdCAgICBidWZmZXIsIG9mZnNldCk7XG5cdH1cblxuXHRyZXR1cm4gKHBhcnNlKTtcbn07XG5cbi8qXG4gKiBbcHJpdmF0ZV0gUmVhZCBhbiBhcnJheSBvZiBkYXRhXG4gKi9cbkNUeXBlUGFyc2VyLnByb3RvdHlwZS5yZWFkQXJyYXkgPSBmdW5jdGlvbiAodHlwZSwgbGVuZ3RoLCBidWZmZXIsIG9mZnNldClcbntcblx0dmFyIGlpLCBlbnQsIHB0O1xuXHR2YXIgYmFzZU9mZnNldCA9IG9mZnNldDtcblx0dmFyIHJldCA9IG5ldyBBcnJheShsZW5ndGgpO1xuXHRwdCA9IGN0UGFyc2VUeXBlKHR5cGUpO1xuXG5cdGZvciAoaWkgPSAwOyBpaSA8IGxlbmd0aDsgaWkrKykge1xuXHRcdGVudCA9IHRoaXMucmVhZEVudHJ5KHB0LCBidWZmZXIsIG9mZnNldCk7XG5cdFx0b2Zmc2V0ICs9IGVudFsnc2l6ZSddO1xuXHRcdHJldFtpaV0gPSBlbnRbJ3ZhbHVlJ107XG5cdH1cblxuXHRyZXR1cm4gKHsgdmFsdWU6IHJldCwgc2l6ZTogb2Zmc2V0IC0gYmFzZU9mZnNldCB9KTtcbn07XG5cbi8qXG4gKiBbcHJpdmF0ZV0gUmVhZCBhIHNpbmdsZSBzdHJ1Y3QgaW4uXG4gKi9cbkNUeXBlUGFyc2VyLnByb3RvdHlwZS5yZWFkU3RydWN0ID0gZnVuY3Rpb24gKGRlZiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciBwYXJzZSwgaWksIHR5cGUsIGVudHJ5LCBrZXk7XG5cdHZhciBiYXNlT2Zmc2V0ID0gb2Zmc2V0O1xuXHR2YXIgcmV0ID0ge307XG5cblx0LyogV2FsayBpdCBhbmQgaGFuZGxlIGRvaW5nIHdoYXQncyBuZWNlc3NhcnkgKi9cblx0Zm9yIChpaSA9IDA7IGlpIDwgZGVmLmxlbmd0aDsgaWkrKykge1xuXHRcdGtleSA9IE9iamVjdC5rZXlzKGRlZltpaV0pWzBdO1xuXHRcdGVudHJ5ID0gZGVmW2lpXVtrZXldO1xuXG5cdFx0LyogUmVzb2x2ZSBhbGwgYXJyYXkgdmFsdWVzICovXG5cdFx0dHlwZSA9IGN0UGFyc2VUeXBlKGN0UmVzb2x2ZUFycmF5KGVudHJ5Wyd0eXBlJ10sIHJldCkpO1xuXG5cdFx0aWYgKCdvZmZzZXQnIGluIGVudHJ5KVxuXHRcdFx0b2Zmc2V0ID0gYmFzZU9mZnNldCArIGVudHJ5WydvZmZzZXQnXTtcblxuXHRcdHBhcnNlID0gdGhpcy5yZWFkRW50cnkodHlwZSwgYnVmZmVyLCBvZmZzZXQpO1xuXG5cdFx0b2Zmc2V0ICs9IHBhcnNlWydzaXplJ107XG5cdFx0cmV0W2tleV0gPSBwYXJzZVsndmFsdWUnXTtcblx0fVxuXG5cdHJldHVybiAoeyB2YWx1ZTogcmV0LCBzaXplOiAob2Zmc2V0LWJhc2VPZmZzZXQpfSk7XG59O1xuXG4vKlxuICogVGhpcyBpcyB3aGF0IHdlIHdlcmUgYm9ybiB0byBkby4gV2UgcmVhZCB0aGUgZGF0YSBmcm9tIGEgYnVmZmVyIGFuZCByZXR1cm4gaXRcbiAqIGluIGFuIG9iamVjdCB3aG9zZSBrZXlzIG1hdGNoIHRoZSB2YWx1ZXMgZnJvbSB0aGUgb2JqZWN0LlxuICpcbiAqXHRkZWZcdFx0VGhlIGFycmF5IGRlZmluaXRpb24gb2YgdGhlIGRhdGEgdG8gcmVhZCBpblxuICpcbiAqXHRidWZmZXJcdFx0VGhlIGJ1ZmZlciB0byByZWFkIGRhdGEgZnJvbVxuICpcbiAqXHRvZmZzZXRcdFx0VGhlIG9mZnNldCB0byBzdGFydCB3cml0aW5nIHRvXG4gKlxuICogUmV0dXJucyBhbiBvYmplY3Qgd2hlcmUgZWFjaCBrZXkgY29ycmVzcG9uZHMgdG8gYW4gZW50cnkgaW4gZGVmIGFuZCB0aGUgdmFsdWVcbiAqIGlzIHRoZSByZWFkIHZhbHVlLlxuICovXG5DVHlwZVBhcnNlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbiAoZGVmLCBidWZmZXIsIG9mZnNldClcbntcblx0LyogU2FuaXR5IGNoZWNrIGZvciBhcmd1bWVudHMgKi9cblx0aWYgKGRlZiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZGVmaW5pdGlvbiBmb3Igd2hhdCB3ZSBzaG91bGQgYmUnICtcblx0XHQgICAgJ3BhcnNpbmcnKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyIGZvciB3aGF0IHdlIHNob3VsZCBiZSAnICtcblx0XHQgICAgJ3BhcnNpbmcnKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0IGZvciB3aGF0IHdlIHNob3VsZCBiZSAnICtcblx0XHQgICAgJ3BhcnNpbmcnKSk7XG5cblx0LyogU2FuaXR5IGNoZWNrIHRoZSBvYmplY3QgZGVmaW5pdGlvbiAqL1xuXHRjdENoZWNrUmVxKGRlZiwgdGhpcy50eXBlcyk7XG5cblx0cmV0dXJuICh0aGlzLnJlYWRTdHJ1Y3QoZGVmLCBidWZmZXIsIG9mZnNldClbJ3ZhbHVlJ10pO1xufTtcblxuLypcbiAqIFtwcml2YXRlXSBXcml0ZSBvdXQgYW4gYXJyYXkgb2YgZGF0YVxuICovXG5DVHlwZVBhcnNlci5wcm90b3R5cGUud3JpdGVBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSwgbGVuZ3RoLCBidWZmZXIsXG4gICAgb2Zmc2V0KVxue1xuXHR2YXIgaWksIHB0O1xuXHR2YXIgYmFzZU9mZnNldCA9IG9mZnNldDtcblx0aWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignYXNrZWQgdG8gd3JpdGUgYW4gYXJyYXksIGJ1dCB2YWx1ZSBpcyBub3QgJyArXG5cdFx0ICAgICdhbiBhcnJheScpKTtcblxuXHRpZiAodmFsdWUubGVuZ3RoICE9IGxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdhc2tlZCB0byB3cml0ZSBhcnJheSBvZiBsZW5ndGggJyArIGxlbmd0aCArXG5cdFx0ICAgICcgYnV0IHRoYXQgZG9lcyBub3QgbWF0Y2ggdmFsdWUgbGVuZ3RoOiAnICsgdmFsdWUubGVuZ3RoKSk7XG5cblx0cHQgPSBjdFBhcnNlVHlwZSh0eXBlKTtcblx0Zm9yIChpaSA9IDA7IGlpIDwgbGVuZ3RoOyBpaSsrKVxuXHRcdG9mZnNldCArPSB0aGlzLndyaXRlRW50cnkodmFsdWVbaWldLCBwdCwgYnVmZmVyLCBvZmZzZXQpO1xuXG5cdHJldHVybiAob2Zmc2V0IC0gYmFzZU9mZnNldCk7XG59O1xuXG4vKlxuICogW3ByaXZhdGVdIFdyaXRlIHRoZSBzcGVjaWZpYyBlbnRyeVxuICovXG5DVHlwZVBhcnNlci5wcm90b3R5cGUud3JpdGVFbnRyeSA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciBsZW4sIHJldDtcblxuXHRpZiAodHlwZVsnbGVuJ10gIT09IHVuZGVmaW5lZCkge1xuXHRcdGxlbiA9IHBhcnNlSW50KHR5cGVbJ2xlbiddLCAxMCk7XG5cdFx0aWYgKGlzTmFOKGxlbikpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdzb21laG93IGdvdCBhIG5vbi1udW1lcmljIGxlbmd0aCcpKTtcblxuXHRcdGlmICh0eXBlWyd0eXBlJ10gPT0gJ2NoYXInKVxuXHRcdFx0cmV0ID0gdGhpcy50eXBlc1snY2hhcltdJ11bJ3dyaXRlJ10odmFsdWUsIGxlbixcblx0XHRcdCAgICB0aGlzLmVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHRcdGVsc2Vcblx0XHRcdHJldCA9IHRoaXMud3JpdGVBcnJheSh2YWx1ZSwgdHlwZVsndHlwZSddLFxuXHRcdFx0ICAgIGxlbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHR9IGVsc2Uge1xuXHRcdGlmICh0eXBlWyd0eXBlJ10gaW4gZGVmdHlwZXMpXG5cdFx0XHRyZXQgPSB0aGlzLnR5cGVzW3R5cGVbJ3R5cGUnXV1bJ3dyaXRlJ10odmFsdWUsXG5cdFx0XHQgICAgdGhpcy5lbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0XHRlbHNlXG5cdFx0XHRyZXQgPSB0aGlzLnJlc29sdmVUeXBlZGVmKHR5cGVbJ3R5cGUnXSwgJ3dyaXRlJyxcblx0XHRcdCAgICBidWZmZXIsIG9mZnNldCwgdmFsdWUpO1xuXHR9XG5cblx0cmV0dXJuIChyZXQpO1xufTtcblxuLypcbiAqIFtwcml2YXRlXSBXcml0ZSBhIHNpbmdsZSBzdHJ1Y3Qgb3V0LlxuICovXG5DVHlwZVBhcnNlci5wcm90b3R5cGUud3JpdGVTdHJ1Y3QgPSBmdW5jdGlvbiAodmFsdWUsIGRlZiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciBpaSwgZW50cnksIHR5cGUsIGtleTtcblx0dmFyIGJhc2VPZmZzZXQgPSBvZmZzZXQ7XG5cdHZhciB2YWxzID0ge307XG5cblx0Zm9yIChpaSA9IDA7IGlpIDwgZGVmLmxlbmd0aDsgaWkrKykge1xuXHRcdGtleSA9IE9iamVjdC5rZXlzKGRlZltpaV0pWzBdO1xuXHRcdGVudHJ5ID0gZGVmW2lpXVtrZXldO1xuXG5cdFx0dHlwZSA9IGN0UGFyc2VUeXBlKGN0UmVzb2x2ZUFycmF5KGVudHJ5Wyd0eXBlJ10sIHZhbHMpKTtcblxuXHRcdGlmICgnb2Zmc2V0JyBpbiBlbnRyeSlcblx0XHRcdG9mZnNldCA9IGJhc2VPZmZzZXQgKyBlbnRyeVsnb2Zmc2V0J107XG5cblx0XHRvZmZzZXQgKz0gdGhpcy53cml0ZUVudHJ5KHZhbHVlW2lpXSwgdHlwZSwgYnVmZmVyLCBvZmZzZXQpO1xuXHRcdC8qIE5vdyB0aGF0IHdlJ3ZlIHdyaXR0ZW4gaXQgb3V0LCB3ZSBjYW4gdXNlIGl0IGZvciBhcnJheXMgKi9cblx0XHR2YWxzW2tleV0gPSB2YWx1ZVtpaV07XG5cdH1cblxuXHRyZXR1cm4gKG9mZnNldCk7XG59O1xuXG4vKlxuICogVW5mb3J0dW5hdGVseSwgd2UncmUgc3R1Y2sgd2l0aCB0aGUgc2lucyBvZiBhbiBpbml0aWFsIHBvb3IgZGVzaWduLiBCZWNhdXNlXG4gKiBvZiB0aGF0LCB3ZSBhcmUgZ29pbmcgdG8gaGF2ZSB0byBzdXBwb3J0IHRoZSBvbGQgd2F5IG9mIHdyaXRpbmcgZGF0YSB2aWFcbiAqIHdyaXRlRGF0YS4gVGhlcmUgd2UgaW5zZXJ0IHRoZSB2YWx1ZXMgdGhhdCB5b3Ugd2FudCB0byB3cml0ZSBpbnRvIHRoZVxuICogZGVmaW5pdGlvbi4gQSBsaXR0bGUgYmFyb3F1ZS4gSW50ZXJuYWxseSwgd2UgdXNlIHRoZSBuZXcgbW9kZWwuIFNvIHdlIG5lZWQgdG9cbiAqIGp1c3QgZ2V0IHRob3NlIHZhbHVlcyBvdXQgb2YgdGhlcmUuIEJ1dCB0byBtYWludGFpbiB0aGUgcHJpbmNpcGxlIG9mIGxlYXN0XG4gKiBzdXJwcmlzZSwgd2UncmUgbm90IGdvaW5nIHRvIG1vZGlmeSB0aGUgaW5wdXQgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWVzKGRlZilcbntcblx0dmFyIGlpLCBvdXQsIGtleTtcblx0b3V0ID0gW107XG5cdGZvciAoaWkgPSAwOyBpaSA8IGRlZi5sZW5ndGg7IGlpKyspIHtcblx0XHRrZXkgPSBPYmplY3Qua2V5cyhkZWZbaWldKVswXTtcblx0XHRtb2RfYXNzZXJ0Lm9rKCd2YWx1ZScgaW4gZGVmW2lpXVtrZXldKTtcblx0XHRvdXQucHVzaChkZWZbaWldW2tleV1bJ3ZhbHVlJ10pO1xuXHR9XG5cblx0cmV0dXJuIChvdXQpO1xufVxuXG4vKlxuICogVGhpcyBpcyB0aGUgc2Vjb25kIGhhbGYgb2Ygd2hhdCB3ZSB3ZXJlIGJvcm4gdG8gZG8sIHdyaXRlIG91dCB0aGUgZGF0YVxuICogaXRzZWxmLiBIaXN0b3JpY2FsbHkgdGhpcyBmdW5jdGlvbiByZXF1aXJlZCB5b3UgdG8gcHV0IHlvdXIgdmFsdWVzIGluIHRoZVxuICogZGVmaW5pdGlvbiBzZWN0aW9uLiBUaGlzIHdhcyBub3QgdGhlIHNtYXJ0ZXN0IHRoaW5nIHRvIGRvIGFuZCBhIGJpdCBvZiBhblxuICogb3ZlcnNpZ2h0IHRvIGJlIGhvbmVzdC4gQXMgc3VjaCwgdGhpcyBmdW5jdGlvbiBub3cgdGFrZXMgYSB2YWx1ZXMgYXJndW1lbnQuXG4gKiBJZiB2YWx1ZXMgaXMgbm9uLW51bGwgYW5kIG5vbi11bmRlZmluZWQsIGl0IHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlXG4gKiB2YWx1ZXMuIFRoaXMgbWVhbnMgdGhhdCB0aGUgb2xkIG1ldGhvZCBpcyBzdGlsbCBzdXBwb3J0ZWQsIGJ1dCBpcyBubyBsb25nZXJcbiAqIGFjY2VwdGFibGUuXG4gKlxuICpcdGRlZlx0XHRUaGUgYXJyYXkgZGVmaW5pdGlvbiBvZiB0aGUgZGF0YSB0byB3cml0ZSBvdXQgd2l0aFxuICpcdFx0XHR2YWx1ZXNcbiAqXG4gKlx0YnVmZmVyXHRcdFRoZSBidWZmZXIgdG8gd3JpdGUgdG9cbiAqXG4gKlx0b2Zmc2V0XHRcdFRoZSBvZmZzZXQgaW4gdGhlIGJ1ZmZlciB0byB3cml0ZSB0b1xuICpcbiAqXHR2YWx1ZXNcdFx0QW4gYXJyYXkgb2YgdmFsdWVzIHRvIHdyaXRlLlxuICovXG5DVHlwZVBhcnNlci5wcm90b3R5cGUud3JpdGVEYXRhID0gZnVuY3Rpb24gKGRlZiwgYnVmZmVyLCBvZmZzZXQsIHZhbHVlcylcbntcblx0dmFyIGh2O1xuXG5cdGlmIChkZWYgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGRlZmluaXRpb24gZm9yIHdoYXQgd2Ugc2hvdWxkIGJlJyArXG5cdFx0ICAgICdwYXJzaW5nJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlciBmb3Igd2hhdCB3ZSBzaG91bGQgYmUgJyArXG5cdFx0ICAgICdwYXJzaW5nJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCBmb3Igd2hhdCB3ZSBzaG91bGQgYmUgJyArXG5cdFx0ICAgICdwYXJzaW5nJykpO1xuXG5cdGh2ID0gKHZhbHVlcyAhPSBudWxsICYmIHZhbHVlcyAhPSB1bmRlZmluZWQpO1xuXHRpZiAoaHYpIHtcblx0XHRpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSlcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgdmFsdWVzIGZvciB3cml0aW5nJykpO1xuXHRcdGN0Q2hlY2tSZXEoZGVmLCB0aGlzLnR5cGVzKTtcblx0fSBlbHNlIHtcblx0XHRjdENoZWNrUmVxKGRlZiwgdGhpcy50eXBlcywgWyAndmFsdWUnIF0pO1xuXHR9XG5cblx0dGhpcy53cml0ZVN0cnVjdChodiA/IHZhbHVlcyA6IGdldFZhbHVlcyhkZWYpLCBkZWYsIGJ1ZmZlciwgb2Zmc2V0KTtcbn07XG5cbi8qXG4gKiBGdW5jdGlvbnMgdG8gZ28gdG8gYW5kIGZyb20gNjQgYml0IG51bWJlcnMgaW4gYSB3YXkgdGhhdCBpcyBjb21wYXRpYmxlIHdpdGhcbiAqIEphdmFzY3JpcHQgbGltaXRhdGlvbnMuIFRoZXJlIGFyZSB0d28gc2V0cy4gT25lIHdoZXJlIHRoZSB1c2VyIGlzIG9rYXkgd2l0aFxuICogYW4gYXBwcm94aW1hdGlvbiBhbmQgb25lIHdoZXJlIHRoZXkgYXJlIGRlZmluaXRlbHkgbm90IG9rYXkgd2l0aCBhblxuICogYXBwcm94aW1hdGlvbi5cbiAqL1xuXG4vKlxuICogQXR0ZW1wdHMgdG8gY29udmVydCBhbiBhcnJheSBvZiB0d28gaW50ZWdlcnMgcmV0dXJuZWQgZnJvbSByc2ludDY0IC8gcnVpbnQ2NFxuICogaW50byBhbiBhYnNvbHV0ZSA2NCBiaXQgbnVtYmVyLiBJZiBob3dldmVyIHRoZSB2YWx1ZSB3b3VsZCBleGNlZWQgMl41MiB0aGlzXG4gKiB3aWxsIGluc3RlYWQgdGhyb3cgYW4gZXJyb3IuIFRoZSBtYW50aXNzYSBpbiBhIGRvdWJsZSBpcyBhIDUyIGJpdCBudW1iZXIgYW5kXG4gKiByYXRoZXIgdGhhbiBwb3RlbnRpYWxseSBnaXZlIHlvdSBhIHZhbHVlIHRoYXQgaXMgYW4gYXBwcm94aW1hdGlvbiB0aGlzIHdpbGxcbiAqIGVycm9yLiBJZiB5b3Ugd291bGQgcmF0aGVyIGFuIGFwcHJveGltYXRpb24sIHBsZWFzZSBzZWUgdG9BcHByb3g2NC5cbiAqXG4gKlx0dmFsXHRcdEFuIGFycmF5IG9mIHR3byAzMi1iaXQgaW50ZWdlcnNcbiAqL1xuZnVuY3Rpb24gdG9BYnM2NCh2YWwpXG57XG5cdGlmICh2YWwgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIGFyZzogdmFsdWUnKSk7XG5cblx0aWYgKCFBcnJheS5pc0FycmF5KHZhbCkpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcigndmFsdWUgbXVzdCBiZSBhbiBhcnJheScpKTtcblxuXHRpZiAodmFsLmxlbmd0aCAhPSAyKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ3ZhbHVlIG11c3QgYmUgYW4gYXJyYXkgb2YgbGVuZ3RoIDInKSk7XG5cblx0LyogV2UgaGF2ZSAyMCBiaXRzIHdvcnRoIG9mIHByZWNpc2lvbiBpbiB0aGlzIHJhbmdlICovXG5cdGlmICh2YWxbMF0gPj0gMHgxMDAwMDApXG5cdFx0dGhyb3cgKG5ldyBFcnJvcigndmFsdWUgd291bGQgYmVjb21lIGFwcHJveGltYXRlZCcpKTtcblxuXHRyZXR1cm4gKHZhbFswXSAqIE1hdGgucG93KDIsIDMyKSArIHZhbFsxXSk7XG59XG5cbi8qXG4gKiBXaWxsIHJldHVybiB0aGUgNjQgYml0IHZhbHVlIGFzIHJldHVybmVkIGluIGFuIGFycmF5IGZyb20gcnNpbnQ2NCAvIHJ1aW50NjRcbiAqIHRvIGEgdmFsdWUgYXMgY2xvc2UgYXMgaXQgY2FuLiBOb3RlIHRoYXQgSmF2YXNjcmlwdCBzdG9yZXMgYWxsIG51bWJlcnMgYXMgYVxuICogZG91YmxlIGFuZCB0aGUgbWFudGlzc2Egb25seSBoYXMgNTIgYml0cy4gVGh1cyB0aGlzIHZlcnNpb24gbWF5IGFwcHJveGltYXRlXG4gKiB0aGUgdmFsdWUuXG4gKlxuICpcdHZhbFx0XHRBbiBhcnJheSBvZiB0d28gMzItYml0IGludGVnZXJzXG4gKi9cbmZ1bmN0aW9uIHRvQXBwcm94NjQodmFsKVxue1xuXHRpZiAodmFsID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBhcmc6IHZhbHVlJykpO1xuXG5cdGlmICghQXJyYXkuaXNBcnJheSh2YWwpKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ3ZhbHVlIG11c3QgYmUgYW4gYXJyYXknKSk7XG5cblx0aWYgKHZhbC5sZW5ndGggIT0gMilcblx0XHR0aHJvdyAobmV3IEVycm9yKCd2YWx1ZSBtdXN0IGJlIGFuIGFycmF5IG9mIGxlbmd0aCAyJykpO1xuXG5cdHJldHVybiAoTWF0aC5wb3coMiwgMzIpICogdmFsWzBdICsgdmFsWzFdKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDVEYoanNvbiwgY29uZilcbntcblx0dmFyIGN0eXBlID0gbmV3IENUeXBlUGFyc2VyKGNvbmYpO1xuXHRtb2RfY3RmLmN0ZlBhcnNlSnNvbihqc29uLCBjdHlwZSk7XG5cblx0cmV0dXJuIChjdHlwZSk7XG59XG5cbi8qXG4gKiBFeHBvcnQgdGhlIGZldyB0aGluZ3Mgd2UgYWN0dWFsbHkgd2FudCB0by4gQ3VycmVudGx5IHRoaXMgaXMganVzdCB0aGUgQ1R5cGVcbiAqIFBhcnNlciBhbmQgY3Rpby5cbiAqL1xuZXhwb3J0cy5QYXJzZXIgPSBDVHlwZVBhcnNlcjtcbmV4cG9ydHMudG9BYnM2NCA9IHRvQWJzNjQ7XG5leHBvcnRzLnRvQXBwcm94NjQgPSB0b0FwcHJveDY0O1xuXG5leHBvcnRzLnBhcnNlQ1RGID0gcGFyc2VDVEY7XG5cbmV4cG9ydHMucnVpbnQ4ID0gbW9kX2N0aW8ucnVpbnQ4O1xuZXhwb3J0cy5ydWludDE2ID0gbW9kX2N0aW8ucnVpbnQxNjtcbmV4cG9ydHMucnVpbnQzMiA9IG1vZF9jdGlvLnJ1aW50MzI7XG5leHBvcnRzLnJ1aW50NjQgPSBtb2RfY3Rpby5ydWludDY0O1xuZXhwb3J0cy53dWludDggPSBtb2RfY3Rpby53dWludDg7XG5leHBvcnRzLnd1aW50MTYgPSBtb2RfY3Rpby53dWludDE2O1xuZXhwb3J0cy53dWludDMyID0gbW9kX2N0aW8ud3VpbnQzMjtcbmV4cG9ydHMud3VpbnQ2NCA9IG1vZF9jdGlvLnd1aW50NjQ7XG5cbmV4cG9ydHMucnNpbnQ4ID0gbW9kX2N0aW8ucnNpbnQ4O1xuZXhwb3J0cy5yc2ludDE2ID0gbW9kX2N0aW8ucnNpbnQxNjtcbmV4cG9ydHMucnNpbnQzMiA9IG1vZF9jdGlvLnJzaW50MzI7XG5leHBvcnRzLnJzaW50NjQgPSBtb2RfY3Rpby5yc2ludDY0O1xuZXhwb3J0cy53c2ludDggPSBtb2RfY3Rpby53c2ludDg7XG5leHBvcnRzLndzaW50MTYgPSBtb2RfY3Rpby53c2ludDE2O1xuZXhwb3J0cy53c2ludDMyID0gbW9kX2N0aW8ud3NpbnQzMjtcbmV4cG9ydHMud3NpbnQ2NCA9IG1vZF9jdGlvLndzaW50NjQ7XG5cbmV4cG9ydHMucmZsb2F0ID0gbW9kX2N0aW8ucmZsb2F0O1xuZXhwb3J0cy5yZG91YmxlID0gbW9kX2N0aW8ucmRvdWJsZTtcbmV4cG9ydHMud2Zsb2F0ID0gbW9kX2N0aW8ud2Zsb2F0O1xuZXhwb3J0cy53ZG91YmxlID0gbW9kX2N0aW8ud2RvdWJsZTtcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9idWZmZXJcIikuQnVmZmVyKSIsIi8vIENvcHlyaWdodCAyMDExIE1hcmsgQ2F2YWdlIDxtY2F2YWdlQGdtYWlsLmNvbT4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuLy8gSWYgeW91IGhhdmUgbm8gaWRlYSB3aGF0IEFTTi4xIG9yIEJFUiBpcywgc2VlIHRoaXM6XG4vLyBmdHA6Ly9mdHAucnNhLmNvbS9wdWIvcGtjcy9hc2NpaS9sYXltYW4uYXNjXG5cbnZhciBCZXIgPSByZXF1aXJlKCcuL2Jlci9pbmRleCcpO1xuXG5cblxuLy8vLS0tIEV4cG9ydGVkIEFQSVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBCZXI6IEJlcixcblxuICBCZXJSZWFkZXI6IEJlci5SZWFkZXIsXG5cbiAgQmVyV3JpdGVyOiBCZXIuV3JpdGVyXG5cbn07XG4iLCIvKlxuICogY3RmLmpzXG4gKlxuICogVW5kZXJzdGFuZCBhbmQgcGFyc2UgYWxsIG9mIHRoZSBkaWZmZXJlbnQgSlNPTiBmb3JtYXRzIG9mIENURiBkYXRhIGFuZFxuICogdHJhbnNsYXRlIHRoYXQgaW50byBhIHNlcmllcyBvZiBub2RlLWN0eXBlIGZyaWVuZGx5IHBpZWNlcy4gVGhlIHJlYXNvbiBmb3JcbiAqIHRoZSBhYnN0cmFjdGlvbiBpcyB0byBoYW5kbGUgZGlmZmVyZW50IGNoYW5nZXMgaW4gdGhlIGZpbGUgZm9ybWF0LlxuICpcbiAqIFdlIGhhdmUgdG8gYmUgY2FyZWZ1bCBoZXJlIHRoYXQgd2UgZG9uJ3QgZW5kIHVwIHVzaW5nIGEgbmFtZSB0aGF0IGlzIGFscmVhZHlcbiAqIGEgYnVpbHQgaW4gdHlwZS5cbiAqL1xudmFyIG1vZF9hc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBBU1NFUlQgPSBtb2RfYXNzZXJ0Lm9rO1xuXG52YXIgY3RmX3ZlcnNpb25zID0gWyAnMS4wJyBdO1xudmFyIGN0Zl9lbnRyaWVzID0gWyAnaW50ZWdlcicsICdmbG9hdCcsICd0eXBlZGVmJywgJ3N0cnVjdCcgXTtcbnZhciBjdGZfZGVmdHlwZXMgPSBbICdpbnQ4X3QnLCAndWludDhfdCcsICdpbnQxNl90JywgJ3VpbnQxNl90JywgJ2ludDMyX3QnLFxuICAgICd1aW50MzJfdCcsICdmbG9hdCcsICdkb3VibGUnIF07XG5cbmZ1bmN0aW9uIGN0ZlBhcnNlSW50ZWdlcihlbnRyeSwgY3R5cGUpXG57XG5cdHZhciBuYW1lLCBzaWduLCBsZW4sIHR5cGU7XG5cblx0bmFtZSA9IGVudHJ5WyduYW1lJ107XG5cdGlmICghKCdzaWduZWQnIGluIGVudHJ5WydpbnRlZ2VyJ10pKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ01hbGZvcm1lZCBDVEYgSlNPTjogaW50ZWdlciBtaXNzaW5nICcgK1xuXHRcdCAgICAnc2lnbmVkIHZhbHVlJykpO1xuXG5cblx0aWYgKCEoJ2xlbmd0aCcgaW4gZW50cnlbJ2ludGVnZXInXSkpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignTWFsZm9ybWVkIENURiBKU09OOiBpbnRlZ2VyIG1pc3NpbmcgJyArXG5cdFx0ICAgICdsZW5ndGggdmFsdWUnKSk7XG5cblx0c2lnbiA9IGVudHJ5WydpbnRlZ2VyJ11bJ3NpZ25lZCddO1xuXHRsZW4gPSBlbnRyeVsnaW50ZWdlciddWydsZW5ndGgnXTtcblx0dHlwZSA9IG51bGw7XG5cblx0aWYgKHNpZ24gJiYgbGVuID09IDEpXG5cdFx0dHlwZSA9ICdpbnQ4X3QnO1xuXHRlbHNlIGlmIChsZW4gPT0gMSlcblx0XHR0eXBlID0gJ3VpbnQ4X3QnO1xuXHRlbHNlIGlmIChzaWduICYmIGxlbiA9PSAyKVxuXHRcdHR5cGUgPSAnaW50MTZfdCc7XG5cdGVsc2UgaWYgKGxlbiA9PSAyKVxuXHRcdHR5cGUgPSAndWludDE2X3QnO1xuXHRlbHNlIGlmIChzaWduICYmIGxlbiA9PSA0KVxuXHRcdHR5cGUgPSAnaW50MzJfdCc7XG5cdGVsc2UgaWYgKGxlbiA9PSA0KVxuXHRcdHR5cGUgPSAndWludDMyX3QnO1xuXHRlbHNlIGlmIChzaWduICYmIGxlbiA9PSA4KVxuXHRcdHR5cGUgPSAnaW50NjRfdCc7XG5cdGVsc2UgaWYgKGxlbiA9PSA4KVxuXHRcdHR5cGUgPSAndWludDY0X3QnO1xuXG5cdGlmICh0eXBlID09PSBudWxsKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ01hbGZvcm1lZCBDVEYgSlNPTjogaW50ZWdlciBoYXMgJyArXG5cdFx0ICAgICd1bnN1cHBvcnRlZCBsZW5ndGggYW5kIHNpZ24gLSAnICsgbGVuICsgJy8nICsgc2lnbikpO1xuXG5cdC8qXG5cdCAqIFRoaXMgbWVhbnMgdGhhdCB0aGlzIGlzIHRoZSBzYW1lIGFzIG9uZSBvZiBvdXIgYnVpbHQgaW4gdHlwZXMuIElmXG5cdCAqIHRoYXQncyB0aGUgY2FzZSBkZWZpbmluZyBpdCB3b3VsZCBiZSBhbiBlcnJvci4gU28gaW5zdGVhZCBvZiB0cnlpbmdcblx0ICogdG8gdHlwZWRlZiBpdCwgd2UnbGwgcmV0dXJuIGhlcmUuXG5cdCAqL1xuXHRpZiAobmFtZSA9PSB0eXBlKVxuXHRcdHJldHVybjtcblxuXHRpZiAobmFtZSA9PSAnY2hhcicpIHtcblx0XHRBU1NFUlQodHlwZSA9PSAnaW50OF90Jyk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y3R5cGUudHlwZWRlZihuYW1lLCB0eXBlKTtcbn1cblxuZnVuY3Rpb24gY3RmUGFyc2VGbG9hdChlbnRyeSwgY3R5cGUpXG57XG5cdHZhciBuYW1lLCBsZW47XG5cblx0bmFtZSA9IGVudHJ5WyduYW1lJ107XG5cdGlmICghKCdsZW5ndGgnIGluIGVudHJ5WydmbG9hdCddKSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCdNYWxmb3JtZWQgQ1RGIEpTT046IGZsb2F0IG1pc3NpbmcgJyArXG5cdFx0ICAgICdsZW5ndGggdmFsdWUnKSk7XG5cblx0bGVuID0gZW50cnlbJ2Zsb2F0J11bJ2xlbmd0aCddO1xuXHRpZiAobGVuICE9IDQgJiYgbGVuICE9IDgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignTWFsZm9ybWVkIENURiBKU09OOiBmbG9hdCBoYXMgaW52YWxpZCAnICtcblx0XHQgICAgJ2xlbmd0aCB2YWx1ZScpKTtcblxuXHRpZiAobGVuID09IDQpIHtcblx0XHRpZiAobmFtZSA9PSAnZmxvYXQnKVxuXHRcdFx0cmV0dXJuO1xuXHRcdGN0eXBlLnR5cGVkZWYobmFtZSwgJ2Zsb2F0Jyk7XG5cdH0gZWxzZSBpZiAobGVuID09IDgpIHtcblx0XHRpZiAobmFtZSA9PSAnZG91YmxlJylcblx0XHRcdHJldHVybjtcblx0XHRjdHlwZS50eXBlZGVmKG5hbWUsICdkb3VibGUnKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjdGZQYXJzZVR5cGVkZWYoZW50cnksIGN0eXBlKVxue1xuXHR2YXIgbmFtZSwgdHlwZSwgaWk7XG5cblx0bmFtZSA9IGVudHJ5WyduYW1lJ107XG5cdGlmICh0eXBlb2YgKGVudHJ5Wyd0eXBlZGVmJ10pICE9ICdzdHJpbmcnKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ01hbGZvcm1lZCBDVEYgSlNPTjogdHlwZWRlZiB2YWx1ZSBpbiBub3QgJyArXG5cdFx0ICAgICdhIHN0cmluZycpKTtcblxuXHR0eXBlID0gZW50cnlbJ3R5cGVkZWYnXTtcblxuXHQvKlxuXHQgKiBXZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHdlJ3JlIG5vdCBsb29raW5nIGF0IHR5cGUgdGhhdCdzIG9uZSBvZiBvdXJcblx0ICogYnVpbHQgaW4gdHlwZXMuIFRyYWRpdGlvbmFsbHkgaW4gQyBhIHVpbnQzMl90IHdvdWxkIGJlIGEgdHlwZWRlZiB0b1xuXHQgKiBzb21lIGtpbmQgb2YgaW50ZWdlci4gSG93ZXZlciwgdGhvc2Ugc2l6ZSB0eXBlcyBhcmUgYnVpbHQgaW5zLlxuXHQgKi9cblx0Zm9yIChpaSA9IDA7IGlpIDwgY3RmX2RlZnR5cGVzLmxlbmd0aDsgaWkrKykge1xuXHRcdGlmIChuYW1lID09IGN0Zl9kZWZ0eXBlc1tpaV0pXG5cdFx0XHRyZXR1cm47XG5cdH1cblxuXHRjdHlwZS50eXBlZGVmKG5hbWUsIHR5cGUpO1xufVxuXG5mdW5jdGlvbiBjdGZQYXJzZVN0cnVjdChlbnRyeSwgY3R5cGUpXG57XG5cdHZhciBuYW1lLCB0eXBlLCBpaSwgdmFsLCBpbmRleCwgbWVtYmVyLCBwdXNoO1xuXG5cdG1lbWJlciA9IFtdO1xuXHRpZiAoIUFycmF5LmlzQXJyYXkoZW50cnlbJ3N0cnVjdCddKSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCdNYWxmb3JtZWQgQ1RGIEpTT046IHN0cnVjdCB2YWx1ZSBpcyBub3QgJyArXG5cdFx0ICAgICdhbiBhcnJheScpKTtcblxuXHRmb3IgKGlpID0gMDsgaWkgPCBlbnRyeVsnc3RydWN0J10ubGVuZ3RoOyBpaSsrKSB7XG5cdFx0dmFsID0gZW50cnlbJ3N0cnVjdCddW2lpXTtcblx0XHRpZiAoISgnbmFtZScgaW4gdmFsKSlcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ01hbGZvcm1lZCBDVEYgSlNPTjogc3RydWN0IG1lbWJlciAnICtcblx0XHRcdCAgICAnbWlzc2luZyBuYW1lJykpO1xuXG5cdFx0aWYgKCEoJ3R5cGUnIGluIHZhbCkpXG5cdFx0XHR0aHJvdyAobmV3IEVycm9yKCdNYWxmb3JtZWQgQ1RGIEpTT046IHN0cnVjdCBtZW1iZXIgJyArXG5cdFx0XHQgICAgJ21pc3NpbmcgdHlwZScpKTtcblxuXHRcdGlmICh0eXBlb2YgKHZhbFsnbmFtZSddKSAhPSAnc3RyaW5nJylcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ01hbGZvcm1lZCBDVEYgSlNPTjogc3RydWN0IG1lbWJlciAnICtcblx0XHRcdCAgICAnbmFtZSBpc25cXCd0IGEgc3RyaW5nJykpO1xuXG5cdFx0aWYgKHR5cGVvZiAodmFsWyd0eXBlJ10pICE9ICdzdHJpbmcnKVxuXHRcdFx0dGhyb3cgKG5ldyBFcnJvcignTWFsZm9ybWVkIENURiBKU09OOiBzdHJ1Y3QgbWVtYmVyICcgK1xuXHRcdFx0ICAgICd0eXBlIGlzblxcJ3QgYSBzdHJpbmcnKSk7XG5cblx0XHQvKlxuXHRcdCAqIENURiB2ZXJzaW9uIDIgc3BlY2lmaWVzIGFycmF5IG5hbWVzIGFzIDx0eXBlPiBbPG51bT5dIHdoZXJlXG5cdFx0ICogYXMgbm9kZS1jdHlwZSBkb2VzIHRoaXMgYXMgPHR5cGU+WzxudW0+XS5cblx0XHQgKi9cblx0XHRuYW1lID0gdmFsWyduYW1lJ107XG5cdFx0dHlwZSA9IHZhbFsndHlwZSddO1xuXHRcdGluZGV4ID0gdHlwZS5pbmRleE9mKCcgWycpO1xuXHRcdGlmIChpbmRleCAhPSAtMSkge1xuXHRcdFx0dHlwZSA9IHR5cGUuc3Vic3RyaW5nKDAsIGluZGV4KSArXG5cdFx0XHQgICAgdHlwZS5zdWJzdHJpbmcoaW5kZXggKyAxLCB0eXBlLmxlbmd0aCk7XG5cdFx0fVxuXHRcdHB1c2ggPSB7fTtcblx0XHRwdXNoW25hbWVdID0geyAndHlwZSc6IHR5cGUgfTtcblx0XHRtZW1iZXIucHVzaChwdXNoKTtcblx0fVxuXG5cdG5hbWUgPSBlbnRyeVsnbmFtZSddO1xuXHRjdHlwZS50eXBlZGVmKG5hbWUsIG1lbWJlcik7XG59XG5cbmZ1bmN0aW9uIGN0ZlBhcnNlRW50cnkoZW50cnksIGN0eXBlKVxue1xuXHR2YXIgaWksIGZvdW5kO1xuXG5cdGlmICghKCduYW1lJyBpbiBlbnRyeSkpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignTWFsZm9ybWVkIENURiBKU09OOiBlbnRyeSBtaXNzaW5nIFwibmFtZVwiICcgK1xuXHRcdCAgICAnc2VjdGlvbicpKTtcblxuXHRmb3IgKGlpID0gMDsgaWkgPCBjdGZfZW50cmllcy5sZW5ndGg7IGlpKyspIHtcblx0XHRpZiAoY3RmX2VudHJpZXNbaWldIGluIGVudHJ5KVxuXHRcdFx0Zm91bmQrKztcblx0fVxuXG5cdGlmIChmb3VuZCA9PT0gMClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdNYWxmb3JtZWQgQ1RGIEpTT046IGZvdW5kIG5vIGVudHJpZXMnKSk7XG5cblx0aWYgKGZvdW5kID49IDIpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignTWFsZm9ybWVkIENURiBKU09OOiBmb3VuZCBtb3JlIHRoYW4gb25lICcgK1xuXHRcdCAgICAnZW50cnknKSk7XG5cblx0aWYgKCdpbnRlZ2VyJyBpbiBlbnRyeSkge1xuXHRcdGN0ZlBhcnNlSW50ZWdlcihlbnRyeSwgY3R5cGUpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICgnZmxvYXQnIGluIGVudHJ5KSB7XG5cdFx0Y3RmUGFyc2VGbG9hdChlbnRyeSwgY3R5cGUpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICgndHlwZWRlZicgaW4gZW50cnkpIHtcblx0XHRjdGZQYXJzZVR5cGVkZWYoZW50cnksIGN0eXBlKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoJ3N0cnVjdCcgaW4gZW50cnkpIHtcblx0XHRjdGZQYXJzZVN0cnVjdChlbnRyeSwgY3R5cGUpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdEFTU0VSVChmYWxzZSwgJ3Nob3VsZG5cXCd0IHJlYWNoIGhlcmUnKTtcbn1cblxuZnVuY3Rpb24gY3RmUGFyc2VKc29uKGpzb24sIGN0eXBlKVxue1xuXHR2YXIgdmVyc2lvbiwgaWk7XG5cblx0QVNTRVJUKGpzb24pO1xuXHRBU1NFUlQoY3R5cGUpO1xuXHRpZiAoISgnbWV0YWRhdGEnIGluIGpzb24pKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ0ludmFsaWQgQ1RGIEpTT046IG1pc3NpbmcgbWV0YWRhdGEgc2VjdGlvbicpKTtcblxuXHRpZiAoISgnY3RmMmpzb25fdmVyc2lvbicgaW4ganNvblsnbWV0YWRhdGEnXSkpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignSW52YWxpZCBDVEYgSlNPTjogbWlzc2luZyBjdGYyanNvbl92ZXJzaW9uJykpO1xuXG5cdHZlcnNpb24gPSBqc29uWydtZXRhZGF0YSddWydjdGYyanNvbl92ZXJzaW9uJ107XG5cdGZvciAoaWkgPSAwOyBpaSA8IGN0Zl92ZXJzaW9ucy5sZW5ndGg7IGlpKyspIHtcblx0XHRpZiAoY3RmX3ZlcnNpb25zW2lpXSA9PSB2ZXJzaW9uKVxuXHRcdFx0YnJlYWs7XG5cdH1cblxuXHRpZiAoaWkgPT0gY3RmX3ZlcnNpb25zLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdVbnN1cG9ydGVkIGN0ZjJqc29uX3ZlcnNpb246ICcgKyB2ZXJzaW9uKSk7XG5cblx0aWYgKCEoJ2RhdGEnIGluIGpzb24pKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ0ludmFsaWQgQ1RGIEpTT046IG1pc3NpbmcgZGF0YSBzZWN0aW9uJykpO1xuXG5cdGlmICghQXJyYXkuaXNBcnJheShqc29uWydkYXRhJ10pKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ01hbGZvcm1lZCBDVEYgSlNPTjogZGF0YSBzZWN0aW9uIGlzIG5vdCAnICtcblx0XHQgICAgJ2FuIGFycmF5JykpO1xuXG5cdGZvciAoaWkgPSAwOyBpaSA8IGpzb25bJ2RhdGEnXS5sZW5ndGg7IGlpKyspXG5cdFx0Y3RmUGFyc2VFbnRyeShqc29uWydkYXRhJ11baWldLCBjdHlwZSk7XG59XG5cbmV4cG9ydHMuY3RmUGFyc2VKc29uID0gY3RmUGFyc2VKc29uO1xuIiwiLypcbiAqIHJtIC0gRmViIDIwMTFcbiAqIGN0aW8uanM6XG4gKlxuICogQSBzaW1wbGUgd2F5IHRvIHJlYWQgYW5kIHdyaXRlIHNpbXBsZSBjdHlwZXMuIE9mIGNvdXJzZSwgYXMgeW91J2xsIGZpbmQgdGhlXG4gKiBjb2RlIGlzbid0IGFzIHNpbXBsZSBhcyBpdCBtaWdodCBhcHBlYXIuIFRoZSBmb2xsb3dpbmcgdHlwZXMgYXJlIGN1cnJlbnRseVxuICogc3VwcG9ydGVkIGluIGJpZyBhbmQgbGl0dGxlIGVuZGlhbiBmb3JtYXRzOlxuICpcbiAqIFx0dWludDhfdFx0XHRcdGludDhfdFxuICogXHR1aW50MTZfdFx0XHRpbnQxNl90XG4gKiBcdHVpbnQzMl90XHRcdGludDMyX3RcbiAqXHRmbG9hdCAoc2luZ2xlIHByZWNpc2lvbiBJRUVFIDc1NClcbiAqXHRkb3VibGUgKGRvdWJsZSBwcmVjaXNpb24gSUVFRSA3NTQpXG4gKlxuICogVGhpcyBpcyBkZXNpZ25lZCB0byB3b3JrIGluIE5vZGUgYW5kIHY4LiBJdCBtYXkgaW4gZmFjdCB3b3JrIGluIG90aGVyXG4gKiBKYXZhc2NyaXB0IGludGVycHJldGVycyAodGhhdCdkIGJlIHByZXR0eSBuZWF0KSwgYnV0IGl0IGhhc24ndCBiZWVuIHRlc3RlZC5cbiAqIElmIHlvdSBmaW5kIHRoYXQgaXQgZG9lcyBpbiBmYWN0IHdvcmssIHRoYXQncyBwcmV0dHkgY29vbC4gVHJ5IGFuZCBwYXNzIHdvcmRcbiAqIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGF1dGhvci5cbiAqXG4gKiBOb3RlIHRvIHRoZSByZWFkZXI6IElmIHlvdSdyZSB0YWJzdG9wIGlzbid0IHNldCB0byA4LCBwYXJ0cyBvZiB0aGlzIG1heSBsb29rXG4gKiB3ZWlyZC5cbiAqL1xuXG4vKlxuICogTnVtYmVycyBpbiBKYXZhc2NyaXB0IGhhdmUgYSBzZWNyZXQ6IGFsbCBudW1iZXJzIG11c3QgYmUgcmVwcmVzZW50ZWQgd2l0aCBhblxuICogSUVFRS03NTQgZG91YmxlLiBUaGUgZG91YmxlIGhhcyBhIG1hbnRpc3NhIHdpdGggYSBsZW5ndGggb2YgNTIgYml0cyB3aXRoIGFuXG4gKiBpbXBsaWNpdCBvbmUuIFRodXMgdGhlIHJhbmdlIG9mIGludGVnZXJzIHRoYXQgY2FuIGJlIHJlcHJlc2VudGVkIGlzIGxpbWl0ZWRcbiAqIHRvIHRoZSBzaXplIG9mIHRoZSBtYW50aXNzYSwgdGhpcyBtYWtlcyByZWFkaW5nIGFuZCB3cml0aW5nIDY0LWJpdCBpbnRlZ2Vyc1xuICogZGlmZmljdWx0LCBidXQgZmFyIGZyb20gaW1wb3NzaWJsZS5cbiAqXG4gKiBBbm90aGVyIHNpZGUgZWZmZWN0IG9mIHRoaXMgcmVwcmVzZW50YXRpb24gaXMgd2hhdCBoYXBwZW5zIHdoZW4geW91IHVzZSB0aGVcbiAqIGJpdHdpc2Ugb3BlcmF0b3JzLCBpLmUuIHNoaWZ0IGxlZnQsIHNoaWZ0IHJpZ2h0LCBhbmQsIG9yLCBldGMuIEluIEphdmFzY3JpcHQsXG4gKiBlYWNoIG9wZXJhbmQgYW5kIHRoZSByZXN1bHQgaXMgY2FzdCB0byBhIHNpZ25lZCAzMi1iaXQgbnVtYmVyLiBIb3dldmVyLCBpblxuICogdGhlIGNhc2Ugb2YgPj4+IHRoZSB2YWx1ZXMgYXJlIGNhc3QgdG8gYW4gdW5zaWduZWQgbnVtYmVyLlxuICovXG5cbi8qXG4gKiBBIHJlbWluZGVyIG9uIGVuZGlhbiByZWxhdGVkIGlzc3VlczpcbiAqXG4gKiBCaWcgRW5kaWFuOiBNU0IgLT4gRmlyc3QgYnl0ZVxuICogTGl0dGxlIEVuZGlhbjogTVNCLT5MYXN0IGJ5dGVcbiAqL1xudmFyIG1vZF9hc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxuLypcbiAqIEFuIDggYml0IHVuc2lnbmVkIGludGVnZXIgaW52b2x2ZXMgZG9pbmcgbm8gc2lnbmlmaWNhbnQgd29yay5cbiAqL1xuZnVuY3Rpb24gcnVpbnQ4KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpXG57XG5cdGlmIChlbmRpYW4gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGVuZGlhbicpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXInKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0JykpO1xuXG5cdGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpKTtcblxuXHRyZXR1cm4gKGJ1ZmZlcltvZmZzZXRdKTtcbn1cblxuLypcbiAqIEZvciAxNiBiaXQgdW5zaWduZWQgbnVtYmVycyB3ZSBjYW4gZG8gYWxsIHRoZSBjYXN0aW5nIHRoYXQgd2Ugd2FudCB0byBkby5cbiAqL1xuZnVuY3Rpb24gcmdpbnQxNihidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KVxue1xuXHR2YXIgdmFsID0gMDtcblxuXHRpZiAoZW5kaWFuID09ICdiaWcnKSB7XG5cdFx0dmFsID0gYnVmZmVyW29mZnNldF0gPDwgODtcblx0XHR2YWwgfD0gIGJ1ZmZlcltvZmZzZXQrMV07XG5cdH0gZWxzZSB7XG5cdFx0dmFsID0gYnVmZmVyW29mZnNldF07XG5cdFx0dmFsIHw9IGJ1ZmZlcltvZmZzZXQrMV0gPDwgODtcblx0fVxuXG5cdHJldHVybiAodmFsKTtcblxufVxuXG5mdW5jdGlvbiBydWludDE2KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpXG57XG5cdGlmIChlbmRpYW4gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGVuZGlhbicpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXInKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0JykpO1xuXG5cdGlmIChvZmZzZXQgKyAxID49IGJ1ZmZlci5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKSk7XG5cblx0cmV0dXJuIChyZ2ludDE2KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpKTtcbn1cblxuLypcbiAqIEJlY2F1c2UgbW9zdCBiaXRzaGlmdGluZyBpcyBkb25lIHVzaW5nIHNpZ25lZCBudW1iZXJzLCBpZiB3ZSB3b3VsZCBnbyBpbnRvXG4gKiB0aGUgcmVhbG0gd2hlcmUgd2UgdXNlIHRoYXQgMzJuZCBiaXQsIHdlJ2xsIGVuZCB1cCBnb2luZyBpbnRvIHRoZSBuZWdhdGl2ZVxuICogcmFuZ2UuIGkuZS46XG4gKiA+IDIwMCA8PCAyNFxuICogLTkzOTUyNDA5NlxuICpcbiAqIE5vdCB0aGUgdmFsdWUgeW91J2QgZXhwZWN0LiBUbyB3b3JrIGFyb3VuZCB0aGlzLCB3ZSBlbmQgdXAgaGF2aW5nIHRvIGRvIHNvbWVcbiAqIGFidXNlIG9mIHRoZSBKYXZhU2NyaXB0IHN0YW5kYXJkLiBpbiB0aGlzIGNhc2UsIHdlIGtub3cgdGhhdCBhID4+PiBzaGlmdCBpc1xuICogZGVmaW5lZCB0byBjYXN0IG91ciB2YWx1ZSB0byBhbiAqdW5zaWduZWQqIDMyLWJpdCBudW1iZXIuIEJlY2F1c2Ugb2YgdGhhdCwgd2VcbiAqIHVzZSB0aGF0IGluc3RlYWQgdG8gc2F2ZSB1cyBzb21lIGFkZGl0aW9uYWwgbWF0aCwgdGhvdWdoIGl0IGRvZXMgZmVlbCBhXG4gKiBsaXR0bGUgd2VpcmQgYW5kIGl0IGlzbid0IG9idmlvdXMgYXMgdG8gd2h5IHlvdSB3b3VsIGR3YW50IHRvIGRvIHRoaXMgYXRcbiAqIGZpcnN0LlxuICovXG5mdW5jdGlvbiByZ2ludDMyKGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpXG57XG5cdHZhciB2YWwgPSAwO1xuXG5cdGlmIChlbmRpYW4gPT0gJ2JpZycpIHtcblx0XHR2YWwgPSBidWZmZXJbb2Zmc2V0KzFdIDw8IDE2O1xuXHRcdHZhbCB8PSBidWZmZXJbb2Zmc2V0KzJdIDw8IDg7XG5cdFx0dmFsIHw9IGJ1ZmZlcltvZmZzZXQrM107XG5cdFx0dmFsID0gdmFsICsgKGJ1ZmZlcltvZmZzZXRdIDw8IDI0ID4+PiAwKTtcblx0fSBlbHNlIHtcblx0XHR2YWwgPSBidWZmZXJbb2Zmc2V0KzJdIDw8IDE2O1xuXHRcdHZhbCB8PSBidWZmZXJbb2Zmc2V0KzFdIDw8IDg7XG5cdFx0dmFsIHw9IGJ1ZmZlcltvZmZzZXRdO1xuXHRcdHZhbCA9IHZhbCArIChidWZmZXJbb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApO1xuXHR9XG5cblx0cmV0dXJuICh2YWwpO1xufVxuXG5mdW5jdGlvbiBydWludDMyKGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpXG57XG5cdGlmIChlbmRpYW4gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGVuZGlhbicpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXInKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0JykpO1xuXG5cdGlmIChvZmZzZXQgKyAzID49IGJ1ZmZlci5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKSk7XG5cblx0cmV0dXJuIChyZ2ludDMyKGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpKTtcbn1cblxuLypcbiAqIFJlYWRzIGEgNjQtYml0IHVuc2lnbmVkIG51bWJlci4gVGhlIGFzdHVlIG9ic2VydmVyIHdpbGwgbm90ZSB0aGF0IHRoaXNcbiAqIGRvZXNuJ3QgcXVpdGUgd29yay4gSmF2YXNjcmlwdCBoYXMgY2hvc2VuIHRvIG9ubHkgaGF2ZSBudW1iZXJzIHRoYXQgY2FuIGJlXG4gKiByZXByZXNlbnRlZCBieSBhIGRvdWJsZS4gQSBkb3VibGUgb25seSBoYXMgNTIgYml0cyBvZiBtYW50aXNzYSB3aXRoIGFuXG4gKiBpbXBsaWNpdCAxLCB0aHVzIHdlIGhhdmUgdXAgdG8gNTMgYml0cyB0byByZXByZXNlbnQgYW4gaW50ZWdlci4gSG93ZXZlciwgMl41M1xuICogZG9lc24ndCBxdWl0ZSBnaXZlIHVzIHdoYXQgd2Ugd2FudC4gSXNuJ3QgNTMgYml0cyBlbm91Z2ggZm9yIGFueW9uZT8gV2hhdFxuICogY291bGQgeW91IGhhdmUgcG9zc2libHkgd2FudGVkIHRvIHJlcHJlc2VudCB0aGF0IHdhcyBsYXJnZXIgdGhhbiB0aGF0PyBPaCxcbiAqIG1heWJlIGEgc2l6ZT8gWW91IG1lYW4gd2UgYnlwYXNzZWQgdGhlIDQgR0IgbGltaXQgb24gZmlsZSBzaXplcywgd2hlbiBkaWRcbiAqIHRoYXQgaGFwcGVuP1xuICpcbiAqIFRvIGdldCBhcm91bmQgdGhpcyBlZ3JlZ2lvdXMgbGFuZ3VhZ2UgaXNzdWUsIHdlJ3JlIGdvaW5nIHRvIGluc3RlYWQgY29uc3RydWN0XG4gKiBhbiBhcnJheSBvZiB0d28gMzIgYml0IHVuc2lnbmVkIGludGVnZXJzLiBXaGVyZSBhcnJbMF0gPDwgMzIgKyBhcnJbMV0gd291bGRcbiAqIGdpdmUgdGhlIGFjdHVhbCBudW1iZXIuIEhvd2V2ZXIsIG5vdGUgdGhhdCB0aGUgYWJvdmUgY29kZSBwcm9iYWJseSB3b24ndFxuICogcHJvZHVjZSB0aGUgZGVzaXJlZCByZXN1bHRzIGJlY2F1c2Ugb2YgdGhlIHdheSBKYXZhc2NyaXB0IG51bWJlcnMgYXJlXG4gKiBkb3VibGVzLlxuICovXG5mdW5jdGlvbiByZ2ludDY0KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpXG57XG5cdHZhciB2YWwgPSBuZXcgQXJyYXkoMik7XG5cblx0aWYgKGVuZGlhbiA9PSAnYmlnJykge1xuXHRcdHZhbFswXSA9IHJ1aW50MzIoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCk7XG5cdFx0dmFsWzFdID0gcnVpbnQzMihidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KzQpO1xuXHR9IGVsc2Uge1xuXHRcdHZhbFswXSA9IHJ1aW50MzIoYnVmZmVyLCBlbmRpYW4sIG9mZnNldCs0KTtcblx0XHR2YWxbMV0gPSBydWludDMyKGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpO1xuXHR9XG5cblx0cmV0dXJuICh2YWwpO1xufVxuXG5mdW5jdGlvbiBydWludDY0KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpXG57XG5cdGlmIChlbmRpYW4gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGVuZGlhbicpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXInKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0JykpO1xuXG5cdGlmIChvZmZzZXQgKyA3ID49IGJ1ZmZlci5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKSk7XG5cblx0cmV0dXJuIChyZ2ludDY0KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpKTtcbn1cblxuXG4vKlxuICogU2lnbmVkIGludGVnZXIgdHlwZXMsIHlheSB0ZWFtISBBIHJlbWluZGVyIG9uIGhvdyB0d28ncyBjb21wbGVtZW50IGFjdHVhbGx5XG4gKiB3b3Jrcy4gVGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbmVkIGJpdCwgaS5lLiB0ZWxscyB1cyB3aGV0aGVyIG9yIG5vdCB0aGVcbiAqIG51bWJlciBzaG91bGQgYmUgcG9zaXRpdmUgb3IgbmVnYXRpdmUuIElmIHRoZSB0d28ncyBjb21wbGVtZW50IHZhbHVlIGlzXG4gKiBwb3NpdGl2ZSwgdGhlbiB3ZSdyZSBkb25lLCBhcyBpdCdzIGVxdWl2YWxlbnQgdG8gdGhlIHVuc2lnbmVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIE5vdyBpZiB0aGUgbnVtYmVyIGlzIHBvc2l0aXZlLCB5b3UncmUgcHJldHR5IG11Y2ggZG9uZSwgeW91IGNhbiBqdXN0IGxldmVyYWdlXG4gKiB0aGUgdW5zaWduZWQgdHJhbnNsYXRpb25zIGFuZCByZXR1cm4gdGhvc2UuIFVuZm9ydHVuYXRlbHksIG5lZ2F0aXZlIG51bWJlcnNcbiAqIGFyZW4ndCBxdWl0ZSB0aGF0IHN0cmFpZ2h0Zm9yd2FyZC5cbiAqXG4gKiBBdCBmaXJzdCBnbGFuY2UsIG9uZSBtaWdodCBiZSBpbmNsaW5lZCB0byB1c2UgdGhlIHRyYWRpdGlvbmFsIGZvcm11bGEgdG9cbiAqIHRyYW5zbGF0ZSBiaW5hcnkgbnVtYmVycyBiZXR3ZWVuIHRoZSBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzIGluIHR3bydzXG4gKiBjb21wbGVtZW50LiAoVGhvdWdoIGl0IGRvZXNuJ3QgcXVpdGUgd29yayBmb3IgdGhlIG1vc3QgbmVnYXRpdmUgdmFsdWUpXG4gKiBNYWlubHk6XG4gKiAgLSBpbnZlcnQgYWxsIHRoZSBiaXRzXG4gKiAgLSBhZGQgb25lIHRvIHRoZSByZXN1bHRcbiAqXG4gKiBPZiBjb3Vyc2UsIHRoaXMgZG9lc24ndCBxdWl0ZSB3b3JrIGluIEphdmFzY3JpcHQuIFRha2UgZm9yIGV4YW1wbGUgdGhlIHZhbHVlXG4gKiBvZiAtMTI4LiBUaGlzIGNvdWxkIGJlIHJlcHJlc2VudGVkIGluIDE2IGJpdHMgKGJpZy1lbmRpYW4pIGFzIDB4ZmY4MC4gQnV0IG9mXG4gKiBjb3Vyc2UsIEphdmFzY3JpcHQgd2lsbCBkbyB0aGUgZm9sbG93aW5nOlxuICpcbiAqID4gfjB4ZmY4MFxuICogLTY1NDA5XG4gKlxuICogV2hvaCB0aGVyZSwgSmF2YXNjcmlwdCwgdGhhdCdzIG5vdCBxdWl0ZSByaWdodC4gQnV0IHdhaXQsIGFjY29yZGluZyB0b1xuICogSmF2YXNjcmlwdCB0aGF0J3MgcGVyZmVjdGx5IGNvcnJlY3QuIFdoZW4gSmF2YXNjcmlwdCBlbmRzIHVwIHNlZWluZyB0aGVcbiAqIGNvbnN0YW50IDB4ZmY4MCwgaXQgaGFzIG5vIG5vdGlvbiB0aGF0IGl0IGlzIGFjdHVhbGx5IGEgc2lnbmVkIG51bWJlci4gSXRcbiAqIGFzc3VtZXMgdGhhdCB3ZSd2ZSBpbnB1dCB0aGUgdW5zaWduZWQgdmFsdWUgMHhmZjgwLiBUaHVzLCB3aGVuIGl0IGRvZXMgdGhlXG4gKiBiaW5hcnkgbmVnYXRpb24sIGl0IGNhc3RzIGl0IGludG8gYSBzaWduZWQgdmFsdWUsIChwb3NpdGl2ZSAweGZmODApLiBUaGVuXG4gKiB3aGVuIHlvdSBwZXJmb3JtIGJpbmFyeSBuZWdhdGlvbiBvbiB0aGF0LCBpdCB0dXJucyBpdCBpbnRvIGEgbmVnYXRpdmUgbnVtYmVyLlxuICpcbiAqIEluc3RlYWQsIHdlJ3JlIGdvaW5nIHRvIGhhdmUgdG8gdXNlIHRoZSBmb2xsb3dpbmcgZ2VuZXJhbCBmb3JtdWxhLCB0aGF0IHdvcmtzXG4gKiBpbiBhIHJhdGhlciBKYXZhc2NyaXB0IGZyaWVuZGx5IHdheS4gSSdtIGdsYWQgd2UgZG9uJ3Qgc3VwcG9ydCB0aGlzIGtpbmQgb2ZcbiAqIHdlaXJkIG51bWJlcmluZyBzY2hlbWUgaW4gdGhlIGtlcm5lbC5cbiAqXG4gKiAoQklULU1BWCAtICh1bnNpZ25lZCl2YWwgKyAxKSAqIC0xXG4gKlxuICogVGhlIGFzdHV0ZSBvYnNlcnZlciwgbWF5IHRoaW5rIHRoYXQgdGhpcyBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIDgtYml0IG51bWJlcnNcbiAqIChyZWFsbHkgaXQgaXNuJ3QgbmVjZXNzYXJ5IGZvciB0aGVtKS4gSG93ZXZlciwgd2hlbiB5b3UgZ2V0IDE2LWJpdCBudW1iZXJzLFxuICogeW91IGRvLiBMZXQncyBnbyBiYWNrIHRvIG91ciBwcmlvciBleGFtcGxlIGFuZCBzZWUgaG93IHRoaXMgd2lsbCBsb29rOlxuICpcbiAqICgweGZmZmYgLSAweGZmODAgKyAxKSAqIC0xXG4gKiAoMHgwMDdmICsgMSkgKiAtMVxuICogKDB4MDA4MCkgKiAtMVxuICpcbiAqIERvaW5nIGl0IHRoaXMgd2F5IGVuZHMgdXAgYWxsb3dpbmcgdXMgdG8gdHJlYXQgaXQgYXBwcm9wcmlhdGVseSBpblxuICogSmF2YXNjcmlwdC4gU2lnaCwgdGhhdCdzIHJlYWxseSBxdWl0ZSB1Z2x5IGZvciB3aGF0IHNob3VsZCBqdXN0IGJlIGEgZmV3IGJpdFxuICogc2hpZnRzLCB+IGFuZCAmLlxuICovXG5cbi8qXG4gKiBFbmRpYW5uZXNzIGRvZXNuJ3QgbWF0dGVyIGZvciA4LWJpdCBzaWduZWQgdmFsdWVzLiBXZSBjb3VsZCBpbiBmYWN0IG9wdGltaXplXG4gKiB0aGlzIGNhc2UgYmVjYXVzZSB0aGUgbW9yZSB0cmFkaXRpb25hbCBtZXRob2RzIHdvcmssIGJ1dCBmb3IgY29uc2lzdGVuY3ksXG4gKiB3ZSdsbCBrZWVwIGRvaW5nIHRoaXMgdGhlIHNhbWUgd2F5LlxuICovXG5mdW5jdGlvbiByc2ludDgoYnVmZmVyLCBlbmRpYW4sIG9mZnNldClcbntcblx0dmFyIG5lZztcblxuXHRpZiAoZW5kaWFuID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBlbmRpYW4nKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCcpKTtcblxuXHRpZiAob2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKSk7XG5cblx0bmVnID0gYnVmZmVyW29mZnNldF0gJiAweDgwO1xuXHRpZiAoIW5lZylcblx0XHRyZXR1cm4gKGJ1ZmZlcltvZmZzZXRdKTtcblxuXHRyZXR1cm4gKCgweGZmIC0gYnVmZmVyW29mZnNldF0gKyAxKSAqIC0xKTtcbn1cblxuLypcbiAqIFRoZSAxNi1iaXQgdmVyc2lvbiByZXF1aXJlcyBhIGJpdCBtb3JlIGVmZm9ydC4gSW4gdGhpcyBjYXNlLCB3ZSBjYW4gbGV2ZXJhZ2VcbiAqIG91ciB1bnNpZ25lZCBjb2RlIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZSB3ZSB3YW50IHRvIHJldHVybi5cbiAqL1xuZnVuY3Rpb24gcnNpbnQxNihidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KVxue1xuXHR2YXIgbmVnLCB2YWw7XG5cblx0aWYgKGVuZGlhbiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZW5kaWFuJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlcicpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQnKSk7XG5cblx0aWYgKG9mZnNldCArIDEgPj0gYnVmZmVyLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpKTtcblxuXHR2YWwgPSByZ2ludDE2KGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpO1xuXHRuZWcgPSB2YWwgJiAweDgwMDA7XG5cdGlmICghbmVnKVxuXHRcdHJldHVybiAodmFsKTtcblxuXHRyZXR1cm4gKCgweGZmZmYgLSB2YWwgKyAxKSAqIC0xKTtcbn1cblxuLypcbiAqIFdlIHJlYWxseSBzaG91bGRuJ3QgbGV2ZXJhZ2Ugb3VyIDMyLWJpdCBjb2RlIGhlcmUgYW5kIGluc3RlYWQgdXRpbGl6ZSB0aGVcbiAqIGZhY3QgdGhhdCB3ZSBrbm93IHRoYXQgc2luY2UgdGhlc2UgYXJlIHNpZ25lZCBudW1iZXJzLCB3ZSBjYW4gZG8gYWxsIHRoZVxuICogc2hpZnRpbmcgYW5kIGJpbmFyeSBhbmRpbmcgdG8gZ2VuZXJhdGUgdGhlIDMyLWJpdCBudW1iZXIuIEJ1dCwgZm9yXG4gKiBjb25zaXN0ZW5jeSB3ZSdsbCBkbyB0aGUgc2FtZS4gSWYgd2Ugd2FudCB0byBkbyBvdGhlcndpc2UsIHdlIHNob3VsZCBpbnN0ZWFkXG4gKiBtYWtlIHRoZSAzMiBiaXQgdW5zaWduZWQgY29kZSBkbyB0aGUgb3B0aW1pemF0aW9uLiBCdXQgYXMgbG9uZyBhcyB0aGVyZVxuICogYXJlbid0IGZsb2F0cyBzZWNyZXRseSB1bmRlciB0aGUgaG9vZCBmb3IgdGhhdCwgd2UgL3Nob3VsZC8gYmUgb2theS5cbiAqL1xuZnVuY3Rpb24gcnNpbnQzMihidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KVxue1xuXHR2YXIgbmVnLCB2YWw7XG5cblx0aWYgKGVuZGlhbiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZW5kaWFuJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlcicpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQnKSk7XG5cblx0aWYgKG9mZnNldCArIDMgPj0gYnVmZmVyLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpKTtcblxuXHR2YWwgPSByZ2ludDMyKGJ1ZmZlciwgZW5kaWFuLCBvZmZzZXQpO1xuXHRuZWcgPSB2YWwgJiAweDgwMDAwMDAwO1xuXHRpZiAoIW5lZylcblx0XHRyZXR1cm4gKHZhbCk7XG5cblx0cmV0dXJuICgoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTEpO1xufVxuXG4vKlxuICogVGhlIHNpZ25lZCB2ZXJzaW9uIG9mIHRoaXMgY29kZSBzdWZmZXJzIGZyb20gYWxsIG9mIHRoZSBzYW1lIHByb2JsZW1zIG9mIHRoZVxuICogb3RoZXIgNjQgYml0IHZlcnNpb24uXG4gKi9cbmZ1bmN0aW9uIHJzaW50NjQoYnVmZmVyLCBlbmRpYW4sIG9mZnNldClcbntcblx0dmFyIG5lZywgdmFsO1xuXG5cdGlmIChlbmRpYW4gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGVuZGlhbicpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXInKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0JykpO1xuXG5cdGlmIChvZmZzZXQgKyAzID49IGJ1ZmZlci5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKSk7XG5cblx0dmFsID0gcmdpbnQ2NChidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KTtcblx0bmVnID0gdmFsWzBdICYgMHg4MDAwMDAwMDtcblxuXHRpZiAoIW5lZylcblx0XHRyZXR1cm4gKHZhbCk7XG5cblx0dmFsWzBdID0gKDB4ZmZmZmZmZmYgLSB2YWxbMF0pICogLTE7XG5cdHZhbFsxXSA9ICgweGZmZmZmZmZmIC0gdmFsWzFdICsgMSkgKiAtMTtcblxuXHQvKlxuXHQgKiBJZiB3ZSBoYWQgdGhlIGtleSAweDgwMDAwMDAwMDAwMDAwMDAsIHRoYXQgd291bGQgbGVhdmUgdGhlIGxvd2VyIDMyXG5cdCAqIGJpdHMgYXMgMHhmZmZmZmZmZiwgaG93ZXZlciwgc2luY2Ugd2UncmUgZ29pbnQgdG8gYWRkIG9uZSwgdGhhdCB3b3VsZFxuXHQgKiBhY3R1YWxseSBsZWF2ZSB0aGUgbG93ZXIgMzItYml0cyBhcyAweDEwMDAwMDAwMCwgd2hpY2ggd291bGQgYnJlYWtcblx0ICogb3VyIGFiaWxpdHkgdG8gd3JpdGUgYmFjayBhIHZhbHVlIHRoYXQgd2UgcmVjZWl2ZWQuIFRvIHdvcmsgYXJvdW5kXG5cdCAqIHRoaXMsIGlmIHdlIGFjdHVhbGx5IGdldCB0aGF0IHZhbHVlLCB3ZSdyZSBnb2luZyB0byBidW1wIHRoZSB1cHBlclxuXHQgKiBwb3J0aW9uIGJ5IDEgYW5kIHNldCB0aGlzIHRvIHplcm8uXG5cdCAqL1xuXHRtb2RfYXNzZXJ0Lm9rKHZhbFsxXSA8PSAweDEwMDAwMDAwMCk7XG5cdGlmICh2YWxbMV0gPT0gLTB4MTAwMDAwMDAwKSB7XG5cdFx0dmFsWzFdID0gMDtcblx0XHR2YWxbMF0tLTtcblx0fVxuXG5cdHJldHVybiAodmFsKTtcbn1cblxuLypcbiAqIFdlIG5vdyBtb3ZlIG9udG8gSUVFRSA3NTQ6IFRoZSB0cmFkaXRpb25hbCBmb3JtIGZvciBmbG9hdGluZyBwb2ludCBudW1iZXJzXG4gKiBhbmQgd2hhdCBpcyBzZWNyZXRseSBoaWRpbmcgYXQgdGhlIGhlYXJ0IG9mIGV2ZXJ5dGhpbmcgaW4gdGhpcy4gSSByZWFsbHkgaG9wZVxuICogdGhhdCBzb21lb25lIGlzIGFjdHVhbGx5IHVzaW5nIHRoaXMsIGFzIG90aGVyd2lzZSwgdGhpcyBlZmZvcnQgaXMgcHJvYmFibHlcbiAqIGdvaW5nIHRvIGJlIG1vcmUgd2FzdGVkLlxuICpcbiAqIE9uZSBtaWdodCBiZSB0ZW1wdGVkIHRvIHVzZSBwYXJzZUZsb2F0IGhlcmUsIGJ1dCB0aGF0IHdvdWxkbid0IHdvcmsgYXQgYWxsXG4gKiBmb3Igc2V2ZXJhbCByZWFzb25zLiBNb3N0bHkgZHVlIHRvIHRoZSB3YXkgZmxvYXRzIGFjdHVhbGx5IHdvcmssIGFuZFxuICogcGFyc2VGbG9hdCBvbmx5IGFjdHVhbGx5IHdvcmtzIGluIGJhc2UgMTAuIEkgZG9uJ3Qgc2VlIGJhc2UgMTAgYW55d2hlcmUgbmVhclxuICogdGhpcyBmaWxlLlxuICpcbiAqIEluIHRoaXMgY2FzZSB3ZSdsbCBpbXBsZW1lbnQgdGhlIHNpbmdsZSBhbmQgZG91YmxlIHByZWNpc2lvbiB2ZXJzaW9ucy4gVGhlXG4gKiBxdWFkcnVwbGUgcHJlY2lzaW9uLCB3aGlsZSBwcm9iYWJseSB1c2VmdWwsIHdvdWxkbid0IHJlYWxseSBiZSBhY2NlcHRlZCBieVxuICogSmF2YXNjcmlwdCwgc28gbGV0J3Mgbm90IGV2ZW4gd2FzdGUgb3VyIHRpbWUuXG4gKlxuICogU28gbGV0J3MgcmV2aWV3IGhvdyB0aGlzIGZvcm1hdCBsb29rcyBsaWtlLiBBIHNpbmdsZSBwcmVjaXNpb24gdmFsdWUgaXMgMzJcbiAqIGJpdHMgYW5kIGhhcyB0aHJlZSBwYXJ0czpcbiAqICAgLSAgU2lnbiBiaXRcbiAqICAgLSAgRXhwb25lbnQgKFVzaW5nIGJpYXMgbm90YXRpb24pXG4gKiAgIC0gIE1hbnRpc3NhXG4gKlxuICogfHN8ZWVlZWVlZWV8bW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbXxcbiAqIDMxfCAzMC0yMyAgfCAgMjIgICAgXHQtICAgICAgIDAgICAgICAgfFxuICpcbiAqIFRoZSBleHBvbmVudCBpcyBzdG9yZWQgaW4gYSBiaWFzZWQgaW5wdXQuIFRoZSBiaWFzIGluIHRoaXMgY2FzZSAxMjcuXG4gKiBUaGVyZWZvcmUsIG91ciBleHBvbmVudCBpcyBlcXVhbCB0byB0aGUgOC1iaXQgdmFsdWUgLSAxMjcuXG4gKlxuICogQnkgZGVmYXVsdCwgYSBudW1iZXIgaXMgbm9ybWFsaXplZCBpbiBJRUVFLCB0aGF0IG1lYW5zIHRoYXQgdGhlIG1hbnRpc3NhIGhhc1xuICogYW4gaW1wbGljaXQgb25lIHRoYXQgd2UgZG9uJ3Qgc2VlLiBTbyByZWFsbHkgdGhlIHZhbHVlIHN0b3JlZCBpcyAxLm0uXG4gKiBIb3dldmVyLCBpZiB0aGUgZXhwb25lbnQgaXMgYWxsIHplcm9zLCB0aGVuIGluc3RlYWQgd2UgaGF2ZSB0byBzaGlmdFxuICogZXZlcnl0aGluZyB0byB0aGUgcmlnaHQgb25lIGFuZCB0aGVyZSBpcyBubyBtb3JlIGltcGxpY2l0IG9uZS5cbiAqXG4gKiBTcGVjaWFsIHZhbHVlczpcbiAqICAtIFBvc2l0aXZlIEluZmluaXR5OlxuICpcdFNpZ246XHRcdDBcbiAqXHRFeHBvbmVudDogXHRBbGwgMXNcbiAqXHRNYW50aXNzYTpcdDBcbiAqICAtIE5lZ2F0aXZlIEluZmluaXR5OlxuICpcdFNpZ246XHRcdDFcbiAqXHRFeHBvbmVudDogXHRBbGwgMXNcbiAqXHRNYW50aXNzYTpcdDBcbiAqICAtIE5hTjpcbiAqXHRTaWduOlx0XHQqXG4gKlx0RXhwb25lbnQ6IFx0QWxsIDFzXG4gKlx0TWFudGlzc2E6XHRub24temVyb1xuICogIC0gWmVybzpcbiAqXHRTaWduOlx0XHQqXG4gKlx0RXhwb25lbnQ6XHRBbGwgMHNcbiAqXHRNYW50aXNzYTpcdDBcbiAqXG4gKiBJbiB0aGUgY2FzZSBvZiB6ZXJvLCB0aGUgc2lnbiBiaXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHdlIGdldCBhIHBvc2l0aXZlIG9yXG4gKiBuZWdhdGl2ZSB6ZXJvLiBIb3dldmVyLCBzaW5jZSBKYXZhc2NyaXB0IGNhbm5vdCBkZXRlcm1pbmUgdGhlIGRpZmZlcmVuY2VcbiAqIGJldHdlZW4gdGhlIHR3bzogaS5lLiAtMCA9PSAwLCB3ZSBqdXN0IGFsd2F5cyByZXR1cm4gMC5cbiAqXG4gKi9cbmZ1bmN0aW9uIHJmbG9hdChidWZmZXIsIGVuZGlhbiwgb2Zmc2V0KVxue1xuXHR2YXIgYnl0ZXMgPSBbXTtcblx0dmFyIHNpZ24sIGV4cG9uZW50LCBtYW50aXNzYSwgdmFsO1xuXHR2YXIgYmlhcyA9IDEyNztcblx0dmFyIG1heGV4cCA9IDB4ZmY7XG5cblx0aWYgKGVuZGlhbiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZW5kaWFuJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlcicpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQnKSk7XG5cblx0aWYgKG9mZnNldCArIDMgPj0gYnVmZmVyLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpKTtcblxuXHQvKiBOb3JtYWxpemUgdGhlIGJ5dGVzIHRvIGJlIGluIGVuZGlhbiBvcmRlciAqL1xuXHRpZiAoZW5kaWFuID09ICdiaWcnKSB7XG5cdFx0Ynl0ZXNbMF0gPSBidWZmZXJbb2Zmc2V0XTtcblx0XHRieXRlc1sxXSA9IGJ1ZmZlcltvZmZzZXQrMV07XG5cdFx0Ynl0ZXNbMl0gPSBidWZmZXJbb2Zmc2V0KzJdO1xuXHRcdGJ5dGVzWzNdID0gYnVmZmVyW29mZnNldCszXTtcblx0fSBlbHNlIHtcblx0XHRieXRlc1szXSA9IGJ1ZmZlcltvZmZzZXRdO1xuXHRcdGJ5dGVzWzJdID0gYnVmZmVyW29mZnNldCsxXTtcblx0XHRieXRlc1sxXSA9IGJ1ZmZlcltvZmZzZXQrMl07XG5cdFx0Ynl0ZXNbMF0gPSBidWZmZXJbb2Zmc2V0KzNdO1xuXHR9XG5cblx0c2lnbiA9IGJ5dGVzWzBdICYgMHg4MDtcblx0ZXhwb25lbnQgPSAoYnl0ZXNbMF0gJiAweDdmKSA8PCAxO1xuXHRleHBvbmVudCB8PSAoYnl0ZXNbMV0gJiAweDgwKSA+Pj4gNztcblx0bWFudGlzc2EgPSAoYnl0ZXNbMV0gJiAweDdmKSA8PCAxNjtcblx0bWFudGlzc2EgfD0gYnl0ZXNbMl0gPDwgODtcblx0bWFudGlzc2EgfD0gYnl0ZXNbM107XG5cblx0LyogQ2hlY2sgZm9yIHNwZWNpYWwgY2FzZXMgYmVmb3JlIHdlIGRvIGdlbmVyYWwgcGFyc2luZyAqL1xuXHRpZiAoIXNpZ24gJiYgZXhwb25lbnQgPT0gbWF4ZXhwICYmIG1hbnRpc3NhID09PSAwKVxuXHRcdHJldHVybiAoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcblxuXHRpZiAoc2lnbiAmJiBleHBvbmVudCA9PSBtYXhleHAgJiYgbWFudGlzc2EgPT09IDApXG5cdFx0cmV0dXJuIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuXG5cdGlmIChleHBvbmVudCA9PSBtYXhleHAgJiYgbWFudGlzc2EgIT09IDApXG5cdFx0cmV0dXJuIChOdW1iZXIuTmFOKTtcblxuXHQvKlxuXHQgKiBKYXZhc2NyaXB0IHJlYWxseSBkb2Vzbid0IGhhdmUgc3VwcG9ydCBmb3IgcG9zaXRpdmUgb3IgbmVnYXRpdmUgemVyby5cblx0ICogU28gd2UncmUgbm90IGdvaW5nIHRvIHRyeSBhbmQgZ2l2ZSBpdCB0byB5b3UuIFRoYXQgd291bGQgYmUganVzdFxuXHQgKiBwbGFpbiB3ZWlyZC4gQmVzaWRlcyAtMCA9PSAwLlxuXHQgKi9cblx0aWYgKGV4cG9uZW50ID09PSAwICYmIG1hbnRpc3NhID09PSAwKVxuXHRcdHJldHVybiAoMCk7XG5cblx0Lypcblx0ICogTm93IHdlIGNhbiBkZWFsIHdpdGggdGhlIGJpYXMgYW5kIHRoZSBkZXRlcm1pbmUgd2hldGhlciB0aGUgbWFudGlzc2Fcblx0ICogaGFzIHRoZSBpbXBsaWNpdCBvbmUgb3Igbm90LlxuXHQgKi9cblx0ZXhwb25lbnQgLT0gYmlhcztcblx0aWYgKGV4cG9uZW50ID09IC1iaWFzKSB7XG5cdFx0ZXhwb25lbnQrKztcblx0XHR2YWwgPSAwO1xuXHR9IGVsc2Uge1xuXHRcdHZhbCA9IDE7XG5cdH1cblxuXHR2YWwgPSAodmFsICsgbWFudGlzc2EgKiBNYXRoLnBvdygyLCAtMjMpKSAqIE1hdGgucG93KDIsIGV4cG9uZW50KTtcblxuXHRpZiAoc2lnbilcblx0XHR2YWwgKj0gLTE7XG5cblx0cmV0dXJuICh2YWwpO1xufVxuXG4vKlxuICogRG91YmxlcyBpbiBJRUVFIDc1NCBhcmUgbGlrZSB0aGVpciBicm90aGVycyBleGNlcHQgZm9yIGEgZmV3IGNoYW5nZXMgYW5kXG4gKiBpbmNyZWFzZXMgaW4gc2l6ZTpcbiAqICAgLSBUaGUgZXhwb25lbnQgaXMgbm93IDExIGJpdHNcbiAqICAgLSBUaGUgbWFudGlzc2EgaXMgbm93IDUyIGJpdHNcbiAqICAgLSBUaGUgYmlhcyBpcyBub3cgMTAyM1xuICpcbiAqIHxzfGVlZWVlZWVlZWVlfG1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW1tbW18XG4gKiA2M3wgNjIgLSA1MiAgIHwgXHQ1MVx0XHQtXHRcdFx0MCAgICAgfFxuICogNjN8IDYyIC0gNTIgICB8ICAgICAgNTEgICAgICAgICAgICAgIC0gICAgICAgICAgICAgICAgICAgICAgIDAgICAgIHxcbiAqXG4gKiBXaGlsZSB0aGUgc2l6ZSBoYXMgaW5jcmVhc2VkIGEgZmFpciBhbW91bnQsIHdlJ3JlIGdvaW5nIHRvIGVuZCB1cCBrZWVwaW5nIHRoZVxuICogc2FtZSBnZW5lcmFsIGZvcm11bGEgZm9yIGNhbGN1bGF0aW5nIHRoZSBmaW5hbCB2YWx1ZS4gQXMgYSByZW1pbmRlciwgdGhpc1xuICogZm9ybXVsYSBpczpcbiAqXG4gKiAoLTEpXnMgKiAobiArIG0pICogMl4oZS1iKVxuICpcbiAqIFdoZXJlOlxuICpcdHNcdGlzIHRoZSBzaWduIGJpdFxuICpcdG5cdGlzIChleHBvbmVudCA+IDApID8gMSA6IDAgLS0gRGV0ZXJtaW5lcyB3aGV0aGVyIHdlJ3JlIG5vcm1hbGl6ZWRcbiAqXHRcdFx0XHRcdCAgICAgb3Igbm90XG4gKlx0bVx0aXMgdGhlIG1hbnRpc3NhXG4gKlx0ZVx0aXMgdGhlIGV4cG9uZW50IHNwZWNpZmllZFxuICpcdGJcdGlzIHRoZSBiaWFzIGZvciB0aGUgZXhwb25lbnRcbiAqXG4gKi9cbmZ1bmN0aW9uIHJkb3VibGUoYnVmZmVyLCBlbmRpYW4sIG9mZnNldClcbntcblx0dmFyIGJ5dGVzID0gW107XG5cdHZhciBzaWduLCBleHBvbmVudCwgbWFudGlzc2EsIHZhbCwgbG93bWFudDtcblx0dmFyIGJpYXMgPSAxMDIzO1xuXHR2YXIgbWF4ZXhwID0gMHg3ZmY7XG5cblx0aWYgKGVuZGlhbiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZW5kaWFuJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlcicpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQnKSk7XG5cblx0aWYgKG9mZnNldCArIDcgPj0gYnVmZmVyLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpKTtcblxuXHQvKiBOb3JtYWxpemUgdGhlIGJ5dGVzIHRvIGJlIGluIGVuZGlhbiBvcmRlciAqL1xuXHRpZiAoZW5kaWFuID09ICdiaWcnKSB7XG5cdFx0Ynl0ZXNbMF0gPSBidWZmZXJbb2Zmc2V0XTtcblx0XHRieXRlc1sxXSA9IGJ1ZmZlcltvZmZzZXQrMV07XG5cdFx0Ynl0ZXNbMl0gPSBidWZmZXJbb2Zmc2V0KzJdO1xuXHRcdGJ5dGVzWzNdID0gYnVmZmVyW29mZnNldCszXTtcblx0XHRieXRlc1s0XSA9IGJ1ZmZlcltvZmZzZXQrNF07XG5cdFx0Ynl0ZXNbNV0gPSBidWZmZXJbb2Zmc2V0KzVdO1xuXHRcdGJ5dGVzWzZdID0gYnVmZmVyW29mZnNldCs2XTtcblx0XHRieXRlc1s3XSA9IGJ1ZmZlcltvZmZzZXQrN107XG5cdH0gZWxzZSB7XG5cdFx0Ynl0ZXNbN10gPSBidWZmZXJbb2Zmc2V0XTtcblx0XHRieXRlc1s2XSA9IGJ1ZmZlcltvZmZzZXQrMV07XG5cdFx0Ynl0ZXNbNV0gPSBidWZmZXJbb2Zmc2V0KzJdO1xuXHRcdGJ5dGVzWzRdID0gYnVmZmVyW29mZnNldCszXTtcblx0XHRieXRlc1szXSA9IGJ1ZmZlcltvZmZzZXQrNF07XG5cdFx0Ynl0ZXNbMl0gPSBidWZmZXJbb2Zmc2V0KzVdO1xuXHRcdGJ5dGVzWzFdID0gYnVmZmVyW29mZnNldCs2XTtcblx0XHRieXRlc1swXSA9IGJ1ZmZlcltvZmZzZXQrN107XG5cdH1cblxuXHQvKlxuXHQgKiBXZSBjYW4gY29uc3RydWN0IHRoZSBleHBvbmVudCBhbmQgbWFudGlzc2EgdGhlIHNhbWUgd2F5IGFzIHdlIGRpZCBpblxuXHQgKiB0aGUgY2FzZSBvZiBhIGZsb2F0LCBqdXN0IGluY3JlYXNlIHRoZSByYW5nZSBvZiB0aGUgZXhwb25lbnQuXG5cdCAqL1xuXHRzaWduID0gYnl0ZXNbMF0gJiAweDgwO1xuXHRleHBvbmVudCA9IChieXRlc1swXSAmIDB4N2YpIDw8IDQ7XG5cdGV4cG9uZW50IHw9IChieXRlc1sxXSAmIDB4ZjApID4+PiA0O1xuXG5cdC8qXG5cdCAqIFRoaXMgaXMgZ29pbmcgdG8gYmUgdWdseSBidXQgdGhlbiBhZ2Fpbiwgd2UncmUgZGVhbGluZyB3aXRoIElFRUUgNzU0LlxuXHQgKiBUaGlzIGNvdWxkIHByb2JhYmx5IGJlIGRvbmUgYXMgYSBub2RlIGFkZCBvbiBpbiBhIGZldyBsaW5lcyBvZiBDKyssXG5cdCAqIGJ1dCBvaCB3ZSdsbCwgd2UndmUgbWFkZSBpdCB0aGlzIGZhciBzbyBsZXQncyBiZSBuYXRpdmUgdGhlIHJlc3Qgb2Zcblx0ICogdGhlIHdheS4uLlxuXHQgKlxuXHQgKiBXaGF0IHdlJ3JlIGdvaW5nIHRvIGRvIGlzIGJyZWFrIHRoZSBtYW50aXNzYSBpbnRvIHR3byBwYXJ0cywgdGhlXG5cdCAqIGxvd2VyIDI0IGJpdHMgYW5kIHRoZSB1cHBlciAyOCBiaXRzLiBXZSdsbCBtdWx0aXBseSB0aGUgdXBwZXIgMjggYml0c1xuXHQgKiBieSB0aGUgYXBwcm9wcmlhdGUgcG93ZXIgYW5kIHRoZW4gYWRkIGluIHRoZSBsb3dlciAyNC1iaXRzLiBOb3Rcblx0ICogcmVhbGx5IHRoYXQgZ3JlYXQuIEl0J3MgcHJldHR5IG11Y2ggYSBnaWFudCBrbHVkZ2UgdG8gZGVhbCB3aXRoXG5cdCAqIEphdmFzY3JpcHQgZWNjZW50cmljaXRpZXMgYXJvdW5kIG51bWJlcnMuXG5cdCAqL1xuXHRsb3dtYW50ID0gYnl0ZXNbN107XG5cdGxvd21hbnQgfD0gYnl0ZXNbNl0gPDwgODtcblx0bG93bWFudCB8PSBieXRlc1s1XSA8PCAxNjtcblx0bWFudGlzc2EgPSBieXRlc1s0XTtcblx0bWFudGlzc2EgfD0gYnl0ZXNbM10gPDwgODtcblx0bWFudGlzc2EgfD0gYnl0ZXNbMl0gPDwgMTY7XG5cdG1hbnRpc3NhIHw9IChieXRlc1sxXSAmIDB4MGYpIDw8IDI0O1xuXHRtYW50aXNzYSAqPSBNYXRoLnBvdygyLCAyNCk7IC8qIEVxdWl2YWxlbnQgdG8gPDwgMjQsIGJ1dCBKUyBjb21wYXQgKi9cblx0bWFudGlzc2EgKz0gbG93bWFudDtcblxuXHQvKiBDaGVjayBmb3Igc3BlY2lhbCBjYXNlcyBiZWZvcmUgd2UgZG8gZ2VuZXJhbCBwYXJzaW5nICovXG5cdGlmICghc2lnbiAmJiBleHBvbmVudCA9PSBtYXhleHAgJiYgbWFudGlzc2EgPT09IDApXG5cdFx0cmV0dXJuIChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuXG5cdGlmIChzaWduICYmIGV4cG9uZW50ID09IG1heGV4cCAmJiBtYW50aXNzYSA9PT0gMClcblx0XHRyZXR1cm4gKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG5cblx0aWYgKGV4cG9uZW50ID09IG1heGV4cCAmJiBtYW50aXNzYSAhPT0gMClcblx0XHRyZXR1cm4gKE51bWJlci5OYU4pO1xuXG5cdC8qXG5cdCAqIEphdmFzY3JpcHQgcmVhbGx5IGRvZXNuJ3QgaGF2ZSBzdXBwb3J0IGZvciBwb3NpdGl2ZSBvciBuZWdhdGl2ZSB6ZXJvLlxuXHQgKiBTbyB3ZSdyZSBub3QgZ29pbmcgdG8gdHJ5IGFuZCBnaXZlIGl0IHRvIHlvdS4gVGhhdCB3b3VsZCBiZSBqdXN0XG5cdCAqIHBsYWluIHdlaXJkLiBCZXNpZGVzIC0wID09IDAuXG5cdCAqL1xuXHRpZiAoZXhwb25lbnQgPT09IDAgJiYgbWFudGlzc2EgPT09IDApXG5cdFx0cmV0dXJuICgwKTtcblxuXHQvKlxuXHQgKiBOb3cgd2UgY2FuIGRlYWwgd2l0aCB0aGUgYmlhcyBhbmQgdGhlIGRldGVybWluZSB3aGV0aGVyIHRoZSBtYW50aXNzYVxuXHQgKiBoYXMgdGhlIGltcGxpY2l0IG9uZSBvciBub3QuXG5cdCAqL1xuXHRleHBvbmVudCAtPSBiaWFzO1xuXHRpZiAoZXhwb25lbnQgPT0gLWJpYXMpIHtcblx0XHRleHBvbmVudCsrO1xuXHRcdHZhbCA9IDA7XG5cdH0gZWxzZSB7XG5cdFx0dmFsID0gMTtcblx0fVxuXG5cdHZhbCA9ICh2YWwgKyBtYW50aXNzYSAqIE1hdGgucG93KDIsIC01MikpICogTWF0aC5wb3coMiwgZXhwb25lbnQpO1xuXG5cdGlmIChzaWduKVxuXHRcdHZhbCAqPSAtMTtcblxuXHRyZXR1cm4gKHZhbCk7XG59XG5cbi8qXG4gKiBOb3cgdGhhdCB3ZSBoYXZlIGdvbmUgdGhyb3VnaCB0aGUgcGFpbiBvZiByZWFkaW5nIHRoZSBpbmRpdmlkdWFsIHR5cGVzLCB3ZSdyZVxuICogcHJvYmFibHkgZ29pbmcgdG8gd2FudCBzb21lIHdheSB0byB3cml0ZSB0aGVzZSBiYWNrLiBOb25lIG9mIHRoaXMgaXMgZ29pbmcgdG9cbiAqIGJlIGdvb2QuIEJ1dCBzaW5jZSB3ZSBoYXZlIEphdmFzY3JpcHQgbnVtYmVycyB0aGlzIHNob3VsZCBjZXJ0YWlubHkgYmUgbW9yZVxuICogaW50ZXJlc3RpbmcuIFRob3VnaCB3ZSBjYW4gY29uc3RyYWluIHRoaXMgZW5kIGEgbGl0dGxlIGJpdCBtb3JlIGluIHdoYXQgaXNcbiAqIHZhbGlkLiBGb3Igbm93LCBsZXQncyBnbyBiYWNrIHRvIG91ciBmcmllbmRzIHRoZSB1bnNpZ25lZCB2YWx1ZS5cbiAqL1xuXG4vKlxuICogVW5zaWduZWQgbnVtYmVycyBzZWVtIGRlY2VwdGl2ZWx5IGVhc3kuIEhlcmUgYXJlIHRoZSBnZW5lcmFsIHN0ZXBzIGFuZCBydWxlc1xuICogdGhhdCB3ZSBhcmUgZ29pbmcgdG8gdGFrZTpcbiAqICAgLSAgSWYgdGhlIG51bWJlciBpcyBuZWdhdGl2ZSwgdGhyb3cgYW4gRXJyb3JcbiAqICAgLSAgVHJ1bmNhdGUgYW55IGZsb2F0aW5nIHBvaW50IHBvcnRpb25cbiAqICAgLSAgVGFrZSB0aGUgbW9kdWx1cyBvZiB0aGUgbnVtYmVyIGluIG91ciBiYXNlXG4gKiAgIC0gIFdyaXRlIGl0IG91dCB0byB0aGUgYnVmZmVyIGluIHRoZSBlbmRpYW4gZm9ybWF0IHJlcXVlc3RlZCBhdCB0aGUgb2Zmc2V0XG4gKi9cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0IGlzXG4gKiBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdCBleGNlZWQgdGhlXG4gKiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKlxuICpcdHZhbHVlXHRcdFRoZSBudW1iZXIgdG8gY2hlY2sgZm9yIHZhbGlkaXR5XG4gKlxuICpcdG1heFx0XHRUaGUgbWF4aW11bSB2YWx1ZVxuICovXG5mdW5jdGlvbiBwcmVwdWludCh2YWx1ZSwgbWF4KVxue1xuXHRpZiAodHlwZW9mICh2YWx1ZSkgIT0gJ251bWJlcicpXG5cdFx0dGhyb3cgKG5ldyAoRXJyb3IoJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKSkpO1xuXG5cdGlmICh2YWx1ZSA8IDApXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gJyArXG5cdFx0ICAgICd1bnNpZ25lZCB2YWx1ZScpKTtcblxuXHRpZiAodmFsdWUgPiBtYXgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcigndmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgJyArXG5cdFx0ICAgICd0eXBlJykpO1xuXG5cdGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcigndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKSk7XG5cblx0cmV0dXJuICh2YWx1ZSk7XG59XG5cbi8qXG4gKiA4LWJpdCB2ZXJzaW9uLCBjbGFzc3kuIFdlIGNhbiBpZ25vcmUgZW5kaWFubmVzcyB3aGljaCBpcyBnb29kLlxuICovXG5mdW5jdGlvbiB3dWludDgodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciB2YWw7XG5cblx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyB2YWx1ZScpKTtcblxuXHRpZiAoZW5kaWFuID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBlbmRpYW4nKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCcpKTtcblxuXHRpZiAob2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKSk7XG5cblx0dmFsID0gcHJlcHVpbnQodmFsdWUsIDB4ZmYpO1xuXHRidWZmZXJbb2Zmc2V0XSA9IHZhbDtcbn1cblxuLypcbiAqIFByZXR0eSBtdWNoIHRoZSBzYW1lIGFzIHRoZSA4LWJpdCB2ZXJzaW9uLCBqdXN0IHRoaXMgdGltZSB3ZSBuZWVkIHRvIHdvcnJ5XG4gKiBhYm91dCBlbmRpYW4gcmVsYXRlZCBpc3N1ZXMuXG4gKi9cbmZ1bmN0aW9uIHdnaW50MTYodmFsLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHRpZiAoZW5kaWFuID09ICdiaWcnKSB7XG5cdFx0YnVmZmVyW29mZnNldF0gPSAodmFsICYgMHhmZjAwKSA+Pj4gODtcblx0XHRidWZmZXJbb2Zmc2V0KzFdID0gdmFsICYgMHgwMGZmO1xuXHR9IGVsc2Uge1xuXHRcdGJ1ZmZlcltvZmZzZXQrMV0gPSAodmFsICYgMHhmZjAwKSA+Pj4gODtcblx0XHRidWZmZXJbb2Zmc2V0XSA9IHZhbCAmIDB4MDBmZjtcblx0fVxufVxuXG5mdW5jdGlvbiB3dWludDE2KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgdmFsO1xuXG5cdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgdmFsdWUnKSk7XG5cblx0aWYgKGVuZGlhbiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZW5kaWFuJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlcicpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQnKSk7XG5cblx0aWYgKG9mZnNldCArIDEgPj0gYnVmZmVyLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpKTtcblxuXHR2YWwgPSBwcmVwdWludCh2YWx1ZSwgMHhmZmZmKTtcblx0d2dpbnQxNih2YWwsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xufVxuXG4vKlxuICogVGhlIDMyLWJpdCB2ZXJzaW9uIGlzIGdvaW5nIHRvIGhhdmUgdG8gYmUgYSBsaXR0bGUgZGlmZmVyZW50IHVuZm9ydHVuYXRlbHkuXG4gKiBXZSBjYW4ndCBxdWl0ZSBiaXRzaGlmdCB0byBnZXQgdGhlIGxhcmdlc3QgYnl0ZSwgYmVjYXVzZSB0aGF0IHdvdWxkIGVuZCB1cFxuICogZ2V0dGluZyB1cyBjYXVnaHQgYnkgdGhlIHNpZ25lZCB2YWx1ZXMuXG4gKlxuICogQW5kIHllcywgd2UgZG8gd2FudCB0byBzdWJ0cmFjdCBvdXQgdGhlIGxvd2VyIHBhcnQgYnkgZGVmYXVsdC4gVGhpcyBtZWFuc1xuICogdGhhdCB3aGVuIHdlIGRvIHRoZSBkaXZpc2lvbiwgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgYml0IHNoaWZ0IGFuZCB3ZSB3b24ndFxuICogZW5kIHVwIGdlbmVyYXRpbmcgYSBmbG9hdGluZyBwb2ludCB2YWx1ZS4gSWYgd2UgZGlkIGdlbmVyYXRlIGEgZmxvYXRpbmcgcG9pbnRcbiAqIHZhbHVlIHdlJ2QgaGF2ZSB0byB0cnVuY2F0ZSBpdCBpbnRlbGxpZ2VudGx5LCB0aGlzIHNhdmVzIHVzIHRoYXQgcHJvYmxlbSBhbmRcbiAqIG1heSBldmVuIGJlIHNvbWV3aGF0IGZhc3RlciB1bmRlciB0aGUgaG9vZC5cbiAqL1xuZnVuY3Rpb24gd2dpbnQzMih2YWwsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdGlmIChlbmRpYW4gPT0gJ2JpZycpIHtcblx0XHRidWZmZXJbb2Zmc2V0XSA9ICh2YWwgLSAodmFsICYgMHgwMGZmZmZmZikpIC8gTWF0aC5wb3coMiwgMjQpO1xuXHRcdGJ1ZmZlcltvZmZzZXQrMV0gPSAodmFsID4+PiAxNikgJiAweGZmO1xuXHRcdGJ1ZmZlcltvZmZzZXQrMl0gPSAodmFsID4+PiA4KSAmIDB4ZmY7XG5cdFx0YnVmZmVyW29mZnNldCszXSA9IHZhbCAmIDB4ZmY7XG5cdH0gZWxzZSB7XG5cdFx0YnVmZmVyW29mZnNldCszXSA9ICh2YWwgLSAodmFsICYgMHgwMGZmZmZmZikpIC9cblx0XHQgICAgTWF0aC5wb3coMiwgMjQpO1xuXHRcdGJ1ZmZlcltvZmZzZXQrMl0gPSAodmFsID4+PiAxNikgJiAweGZmO1xuXHRcdGJ1ZmZlcltvZmZzZXQrMV0gPSAodmFsID4+PiA4KSAmIDB4ZmY7XG5cdFx0YnVmZmVyW29mZnNldF0gPSB2YWwgJiAweGZmO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHd1aW50MzIodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciB2YWw7XG5cblx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyB2YWx1ZScpKTtcblxuXHRpZiAoZW5kaWFuID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBlbmRpYW4nKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCcpKTtcblxuXHRpZiAob2Zmc2V0ICsgMyA+PSBidWZmZXIubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJykpO1xuXG5cdHZhbCA9IHByZXB1aW50KHZhbHVlLCAweGZmZmZmZmZmKTtcblx0d2dpbnQzMih2YWwsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xufVxuXG4vKlxuICogVW5saWtlIHRoZSBvdGhlciB2ZXJzaW9ucywgd2UgZXhwZWN0IHRoZSB2YWx1ZSB0byBiZSBpbiB0aGUgZm9ybSBvZiB0d29cbiAqIGFycmF5cyB3aGVyZSB2YWx1ZVswXSA8PCAzMiArIHZhbHVlWzFdIHdvdWxkIHJlc3VsdCBpbiB0aGUgdmFsdWUgdGhhdCB3ZVxuICogd2FudC5cbiAqL1xuZnVuY3Rpb24gd2dpbnQ2NCh2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0aWYgKGVuZGlhbiA9PSAnYmlnJykge1xuXHRcdHdnaW50MzIodmFsdWVbMF0sIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHRcdHdnaW50MzIodmFsdWVbMV0sIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQrNCk7XG5cdH0gZWxzZSB7XG5cdFx0d2dpbnQzMih2YWx1ZVswXSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCs0KTtcblx0XHR3Z2ludDMyKHZhbHVlWzFdLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblx0fVxufVxuXG5mdW5jdGlvbiB3dWludDY0KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIHZhbHVlJykpO1xuXG5cdGlmICghKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ3ZhbHVlIG11c3QgYmUgYW4gYXJyYXknKSk7XG5cblx0aWYgKHZhbHVlLmxlbmd0aCAhPSAyKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ3ZhbHVlIG11c3QgYmUgYW4gYXJyYXkgb2YgbGVuZ3RoIDInKSk7XG5cblx0aWYgKGVuZGlhbiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZW5kaWFuJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlcicpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQnKSk7XG5cblx0aWYgKG9mZnNldCArIDcgPj0gYnVmZmVyLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpKTtcblxuXHRwcmVwdWludCh2YWx1ZVswXSwgMHhmZmZmZmZmZik7XG5cdHByZXB1aW50KHZhbHVlWzFdLCAweGZmZmZmZmZmKTtcblx0d2dpbnQ2NCh2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG59XG5cbi8qXG4gKiBXZSBub3cgbW92ZSBvbnRvIG91ciBmcmllbmRzIGluIHRoZSBzaWduZWQgbnVtYmVyIGNhdGVnb3J5LiBVbmxpa2UgdW5zaWduZWRcbiAqIG51bWJlcnMsIHdlJ3JlIGdvaW5nIHRvIGhhdmUgdG8gd29ycnkgYSBiaXQgbW9yZSBhYm91dCBob3cgd2UgcHV0IHZhbHVlcyBpbnRvXG4gKiBhcnJheXMuIFNpbmNlIHdlIGFyZSBvbmx5IHdvcnJ5aW5nIGFib3V0IHNpZ25lZCAzMi1iaXQgdmFsdWVzLCB3ZSdyZSBpblxuICogc2xpZ2h0bHkgYmV0dGVyIHNoYXBlLiBVbmZvcnR1bmF0ZWx5LCB3ZSByZWFsbHkgY2FuJ3QgZG8gb3VyIGZhdm9yaXRlIGJpbmFyeVxuICogJiBpbiB0aGlzIHN5c3RlbS4gSXQgcmVhbGx5IHNlZW1zIHRvIGRvIHRoZSB3cm9uZyB0aGluZy4gRm9yIGV4YW1wbGU6XG4gKlxuICogPiAtMzIgJiAweGZmXG4gKiAyMjRcbiAqXG4gKiBXaGF0J3MgaGFwcGVuaW5nIGFib3ZlIGlzIHJlYWxseTogMHhlMCAmIDB4ZmYgPSAweGUwLiBIb3dldmVyLCB0aGUgcmVzdWx0cyBvZlxuICogdGhpcyBhcmVuJ3QgdHJlYXRlZCBhcyBhIHNpZ25lZCBudW1iZXIuIFVsdGltYXRlbHkgYSBiYWQgdGhpbmcuXG4gKlxuICogV2hhdCB3ZSdyZSBnb2luZyB0byB3YW50IHRvIGRvIGlzIGJhc2ljYWxseSBjcmVhdGUgdGhlIHVuc2lnbmVkIGVxdWl2YWxlbnQgb2ZcbiAqIG91ciByZXByZXNlbnRhdGlvbiBhbmQgcGFzcyB0aGF0IG9mZiB0byB0aGUgd3VpbnQqIGZ1bmN0aW9ucy4gVG8gZG8gdGhhdFxuICogd2UncmUgZ29pbmcgdG8gZG8gdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAgLSBpZiB0aGUgdmFsdWUgaXMgcG9zaXRpdmVcbiAqXHR3ZSBjYW4gcGFzcyBpdCBkaXJlY3RseSBvZmYgdG8gdGhlIGVxdWl2YWxlbnQgd3VpbnRcbiAqICAtIGlmIHRoZSB2YWx1ZSBpcyBuZWdhdGl2ZVxuICpcdHdlIGRvIHRoZSBmb2xsb3dpbmcgY29tcHV0YXRpb246XG4gKlx0bWIgKyB2YWwgKyAxLCB3aGVyZVxuICpcdG1iXHRpcyB0aGUgbWF4aW11bSB1bnNpZ25lZCB2YWx1ZSBpbiB0aGF0IGJ5dGUgc2l6ZVxuICpcdHZhbFx0aXMgdGhlIEphdmFzY3JpcHQgbmVnYXRpdmUgaW50ZWdlclxuICpcbiAqXG4gKiBBcyBhIGNvbmNyZXRlIHZhbHVlLCB0YWtlIC0xMjguIEluIHNpZ25lZCAxNiBiaXRzIHRoaXMgd291bGQgYmUgMHhmZjgwLiBJZlxuICogeW91IGRvIG91dCB0aGUgY29tcHV0YXRpb25zOlxuICpcbiAqIDB4ZmZmZiAtIDEyOCArIDFcbiAqIDB4ZmZmZiAtIDEyN1xuICogMHhmZjgwXG4gKlxuICogWW91IGNhbiB0aGVuIGVuY29kZSB0aGlzIHZhbHVlIGFzIHRoZSBzaWduZWQgdmVyc2lvbi4gVGhpcyBpcyByZWFsbHkgcmF0aGVyXG4gKiBoYWNreSwgYnV0IGl0IHNob3VsZCB3b3JrIGFuZCBnZXQgdGhlIGpvYiBkb25lIHdoaWNoIGlzIG91ciBnb2FsIGhlcmUuXG4gKlxuICogVGh1cyB0aGUgb3ZlcmFsbCBmbG93IGlzOlxuICogICAtICBUcnVuY2F0ZSB0aGUgZmxvYXRpbmcgcG9pbnQgcGFydCBvZiB0aGUgbnVtYmVyXG4gKiAgIC0gIFdlIGRvbid0IGhhdmUgdG8gdGFrZSB0aGUgbW9kdWx1cywgYmVjYXVzZSB0aGUgdW5zaWduZWQgdmVyc2lvbnMgd2lsbFxuICogICBcdHRha2UgY2FyZSBvZiB0aGF0IGZvciB1cy4gQW5kIHdlIGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgdGhhdFxuICogICBcdHBvdGVudGlhbGx5IGNhdXNpbmcgYmFkIHRoaW5ncyB0byBoYXBwZW4gYmVjYXVzZSBvZiBzaWduIGV4dGVuc2lvblxuICogICAtICBQYXNzIGl0IG9mZiB0byB0aGUgYXBwcm9wcmlhdGUgdW5zaWduZWQgdmVyc2lvbiwgcG90ZW50aWFsbHkgbW9kaWZ5aW5nXG4gKlx0dGhlIG5lZ2F0aXZlIHBvcnRpb25zIGFzIG5lY2Vzc2FyeS5cbiAqL1xuXG4vKlxuICogQSBzZXJpZXMgb2YgY2hlY2tzIHRvIG1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIGEgc2lnbmVkIDMyLWJpdCBudW1iZXJcbiAqL1xuZnVuY3Rpb24gcHJlcHNpbnQodmFsdWUsIG1heCwgbWluKVxue1xuXHRpZiAodHlwZW9mICh2YWx1ZSkgIT0gJ251bWJlcicpXG5cdFx0dGhyb3cgKG5ldyAoRXJyb3IoJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKSkpO1xuXG5cdGlmICh2YWx1ZSA+IG1heClcblx0XHR0aHJvdyAobmV3IEVycm9yKCd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKSk7XG5cblx0aWYgKHZhbHVlIDwgbWluKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKSk7XG5cblx0aWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSlcblx0XHR0aHJvdyAobmV3IEVycm9yKCd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpKTtcblxuXHRyZXR1cm4gKHZhbHVlKTtcbn1cblxuLypcbiAqIFRoZSA4LWJpdCB2ZXJzaW9uIG9mIHRoZSBzaWduZWQgdmFsdWUuIE92ZXJhbGwsIGZhaXJseSBzdHJhaWdodGZvcndhcmQuXG4gKi9cbmZ1bmN0aW9uIHdzaW50OCh2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0dmFyIHZhbDtcblxuXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIHZhbHVlJykpO1xuXG5cdGlmIChlbmRpYW4gPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGVuZGlhbicpKTtcblxuXHRpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBidWZmZXInKSk7XG5cblx0aWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3Npbmcgb2Zmc2V0JykpO1xuXG5cdGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpKTtcblxuXHR2YWwgPSBwcmVwc2ludCh2YWx1ZSwgMHg3ZiwgLTB4ODApO1xuXHRpZiAodmFsID49IDApXG5cdFx0d3VpbnQ4KHZhbCwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG5cdGVsc2Vcblx0XHR3dWludDgoMHhmZiArIHZhbCArIDEsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xufVxuXG4vKlxuICogVGhlIDE2LWJpdCB2ZXJzaW9uIG9mIHRoZSBzaWduZWQgdmFsdWUuIEFsc28sIGZhaXJseSBzdHJhaWdodGZvcndhcmQuXG4gKi9cbmZ1bmN0aW9uIHdzaW50MTYodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciB2YWw7XG5cblx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyB2YWx1ZScpKTtcblxuXHRpZiAoZW5kaWFuID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBlbmRpYW4nKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCcpKTtcblxuXHRpZiAob2Zmc2V0ICsgMSA+PSBidWZmZXIubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJykpO1xuXG5cdHZhbCA9IHByZXBzaW50KHZhbHVlLCAweDdmZmYsIC0weDgwMDApO1xuXHRpZiAodmFsID49IDApXG5cdFx0d2dpbnQxNih2YWwsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpO1xuXHRlbHNlXG5cdFx0d2dpbnQxNigweGZmZmYgKyB2YWwgKyAxLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcblxufVxuXG4vKlxuICogV2UgY2FuIGRvIHRoaXMgcmVsYXRpdmVseSBlYXNpbHkgYnkgbGV2ZXJhZ2luZyB0aGUgY29kZSB1c2VkIGZvciAzMi1iaXRcbiAqIHVuc2lnbmVkIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHdzaW50MzIodmFsdWUsIGVuZGlhbiwgYnVmZmVyLCBvZmZzZXQpXG57XG5cdHZhciB2YWw7XG5cblx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyB2YWx1ZScpKTtcblxuXHRpZiAoZW5kaWFuID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBlbmRpYW4nKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCcpKTtcblxuXHRpZiAob2Zmc2V0ICsgMyA+PSBidWZmZXIubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJykpO1xuXG5cdHZhbCA9IHByZXBzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG5cdGlmICh2YWwgPj0gMClcblx0XHR3Z2ludDMyKHZhbCwgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG5cdGVsc2Vcblx0XHR3Z2ludDMyKDB4ZmZmZmZmZmYgKyB2YWwgKyAxLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KTtcbn1cblxuLypcbiAqIFRoZSBzaWduZWQgNjQgYml0IGludGVnZXIgc2hvdWxkIGJ5IGluIHRoZSBzYW1lIGZvcm1hdCBhcyB3aGVuIHJlY2VpdmVkLlxuICogTWFpbmx5IGl0IHNob3VsZCBlbnN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYW4gYXJyYXkgb2YgdHdvIGludGVnZXJzIHdoZXJlXG4gKiB2YWx1ZVswXSA8PCAzMiArIHZhbHVlWzFdIGlzIHRoZSBkZXNpcmVkIG51bWJlci4gRnVydGhlcm1vcmUsIHRoZSB0d28gdmFsdWVzXG4gKiBuZWVkIHRvIGJlIGVxdWFsLlxuICovXG5mdW5jdGlvbiB3c2ludDY0KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgdnpwb3MsIHZvcG9zO1xuXHR2YXIgdmFscyA9IG5ldyBBcnJheSgyKTtcblxuXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIHZhbHVlJykpO1xuXG5cdGlmICghKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ3ZhbHVlIG11c3QgYmUgYW4gYXJyYXknKSk7XG5cblx0aWYgKHZhbHVlLmxlbmd0aCAhPSAyKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ3ZhbHVlIG11c3QgYmUgYW4gYXJyYXkgb2YgbGVuZ3RoIDInKSk7XG5cblx0aWYgKGVuZGlhbiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZW5kaWFuJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlcicpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQnKSk7XG5cblx0aWYgKG9mZnNldCArIDcgPj0gYnVmZmVyLmxlbmd0aClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpKTtcblxuXHQvKlxuXHQgKiBXZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgdGhlIHNhbWUgc2lnbiBvbiBib3RoIHZhbHVlcy4gVGhlXG5cdCAqIGhva2llc3Qgd2F5IHRvIHRvIGRvIHRoaXMgaXMgdG8gbXVsdGlwbHkgdGhlIG51bWJlciBieSAraW5mLiBJZiB3ZSBkb1xuXHQgKiB0aGlzLCB3ZSdsbCBnZXQgZWl0aGVyICsvLWluZiBkZXBlbmRpbmcgb24gdGhlIHNpZ24gb2YgdGhlIHZhbHVlLlxuXHQgKiBPbmNlIHdlIGhhdmUgdGhpcywgd2UgY2FuIGNvbXBhcmUgaXQgdG8gK2luZiB0byBzZWUgaWYgdGhlIG51bWJlciBpc1xuXHQgKiBwb3NpdGl2ZSBvciBub3QuXG5cdCAqL1xuXHR2enBvcyA9ICh2YWx1ZVswXSAqIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkgPT1cblx0ICAgIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblx0dm9wb3MgPSAodmFsdWVbMV0gKiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpID09XG5cdCAgICBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cblx0Lypcblx0ICogSWYgZWl0aGVyIG9mIHRoZXNlIGlzIHplcm8sIHRoZW4gd2UgZG9uJ3QgYWN0dWFsbHkgbmVlZCB0aGlzIGNoZWNrLlxuXHQgKi9cblx0aWYgKHZhbHVlWzBdICE9IDAgJiYgdmFsdWVbMV0gIT0gMCAmJiB2enBvcyAhPSB2b3Bvcylcblx0XHR0aHJvdyAobmV3IEVycm9yKCdCb3RoIGVudHJpZXMgaW4gdGhlIGFycmF5IG11c3QgaGF2ZSAnICtcblx0XHQgICAgJ3RoZSBzYW1lIHNpZ24nKSk7XG5cblx0Lypcblx0ICogRG9pbmcgdmVyaWZpY2F0aW9uIGZvciBhIHNpZ25lZCA2NC1iaXQgaW50ZWdlciBpcyBhY3R1YWxseSBhIGJpZ1xuXHQgKiB0cmlja2llciB0aGFuIGl0IGFwcGVhcnMuIFdlIGNhbid0IHF1aXRlIHVzZSBvdXIgc3RhbmRhcmQgdGVjaG5pcXVlc1xuXHQgKiBiZWNhdXNlIHdlIG5lZWQgdG8gY29tcGFyZSBib3RoIHNldHMgb2YgdmFsdWVzLiBUaGUgZmlyc3QgdmFsdWUgaXNcblx0ICogcHJldHR5IHN0cmFpZ2h0Zm9yd2FyZC4gSWYgdGhlIGZpcnN0IHZhbHVlIGlzIGJlb25kIHRoZSBleHRyZW1lcyB0aGFuXG5cdCAqIHdlIGVycm9yIG91dC4gSG93ZXZlciwgdGhlIHZhbGlkIHJhbmdlIG9mIHRoZSBzZWNvbmQgdmFsdWUgdmFyaWVzXG5cdCAqIGJhc2VkIG9uIHRoZSBmaXJzdCBvbmUuIElmIHRoZSBmaXJzdCB2YWx1ZSBpcyBuZWdhdGl2ZSwgYW5kICpub3QqIHRoZVxuXHQgKiBsYXJnZXN0IG5lZ2F0aXZlIHZhbHVlLCB0aGFuIGl0IGNhbiBiZSBhbnkgaW50ZWdlciB3aXRoaW4gdGhlIHJhbmdlIFtcblx0ICogMCwgMHhmZmZmZmZmZiBdLiBJZiBpdCBpcyB0aGUgbGFyZ2VzdCBuZWdhdGl2ZSBudW1iZXIsIGl0IG11c3QgYmVcblx0ICogemVyby5cblx0ICpcblx0ICogSWYgdGhlIGZpcnN0IG51bWJlciBpcyBwb3NpdGl2ZSwgdGhhbiBpdCBkb2Vzbid0IG1hdHRlciB3aGF0IHRoZVxuXHQgKiB2YWx1ZSBpcy4gV2UganVzdCBzaW1wbHkgaGF2ZSB0byBtYWtlIHN1cmUgd2UgaGF2ZSBhIHZhbGlkIHBvc2l0aXZlXG5cdCAqIGludGVnZXIuXG5cdCAqL1xuXHRpZiAodnpwb3MpIHtcblx0XHRwcmVwdWludCh2YWx1ZVswXSwgMHg3ZmZmZmZmZik7XG5cdFx0cHJlcHVpbnQodmFsdWVbMV0sIDB4ZmZmZmZmZmYpO1xuXHR9IGVsc2Uge1xuXHRcdHByZXBzaW50KHZhbHVlWzBdLCAwLCAtMHg4MDAwMDAwMCk7XG5cdFx0cHJlcHNpbnQodmFsdWVbMV0sIDAsIC0weGZmZmZmZmZmKTtcblx0XHRpZiAodmFsdWVbMF0gPT0gLTB4ODAwMDAwMDAgJiYgdmFsdWVbMV0gIT0gMClcblx0XHRcdHRocm93IChuZXcgRXJyb3IoJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtICcgK1xuXHRcdFx0ICAgICdhbGxvd2VkIHZhbHVlJykpO1xuXHR9XG5cblx0LyogRml4IG5lZ2F0aXZlIG51bWJlcnMgKi9cblx0aWYgKHZhbHVlWzBdIDwgMCB8fCB2YWx1ZVsxXSA8IDApIHtcblx0XHR2YWxzWzBdID0gMHhmZmZmZmZmZiAtIE1hdGguYWJzKHZhbHVlWzBdKTtcblx0XHR2YWxzWzFdID0gMHgxMDAwMDAwMDAgLSBNYXRoLmFicyh2YWx1ZVsxXSk7XG5cdFx0aWYgKHZhbHNbMV0gPT0gMHgxMDAwMDAwMDApIHtcblx0XHRcdHZhbHNbMV0gPSAwO1xuXHRcdFx0dmFsc1swXSsrO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHR2YWxzWzBdID0gdmFsdWVbMF07XG5cdFx0dmFsc1sxXSA9IHZhbHVlWzFdO1xuXHR9XG5cdHdnaW50NjQodmFscywgZW5kaWFuLCBidWZmZXIsIG9mZnNldCk7XG59XG5cbi8qXG4gKiBOb3cgd2UgYXJlIG1vdmluZyBvbnRvIHRoZSB3ZWlyZGVyIG9mIHRoZXNlLCB0aGUgZmxvYXQgYW5kIGRvdWJsZS4gRm9yIHRoaXNcbiAqIHdlJ3JlIGdvaW5nIHRvIGp1c3QgaGF2ZSB0byBkbyBzb21ldGhpbmcgdGhhdCdzIHByZXR0eSB3ZWlyZC4gRmlyc3Qgb2ZmLCB3ZVxuICogaGF2ZSBubyB3YXkgdG8gZ2V0IGF0IHRoZSB1bmRlcmx5aW5nIGZsb2F0IHJlcHJlc2VudGF0aW9uLCBhdCBsZWFzdCBub3RcbiAqIGVhc2lseS4gQnV0IHRoYXQgZG9lc24ndCBtZWFuIHdlIGNhbid0IGZpZ3VyZSBpdCBvdXQsIHdlIGp1c3QgaGF2ZSB0byB1c2Ugb3VyXG4gKiBoZWFkcy5cbiAqXG4gKiBPbmUgbWlnaHQgcHJvcG9zZSB0byB1c2UgTnVtYmVyLnRvU3RyaW5nKDIpLiBPZiBjb3Vyc2UsIHRoaXMgaXMgbm90IHJlYWxseVxuICogdGhhdCBnb29kLCBiZWNhdXNlIHRoZSBFQ01BU2NyaXB0IDI2MiB2MyBTdGFuZGFyZCBzYXlzIHRoZSBmb2xsb3dpbmcgU2VjdGlvblxuICogMTUuNy40LjItTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZyAocmFkaXgpOlxuICpcbiAqIElmIHJhZGl4IGlzIGFuIGludGVnZXIgZnJvbSAyIHRvIDM2LCBidXQgbm90IDEwLCB0aGUgcmVzdWx0IGlzIGEgc3RyaW5nLCB0aGVcbiAqIGNob2ljZSBvZiB3aGljaCBpcyBpbXBsZW1lbnRhdGlvbi1kZXBlbmRlbnQuXG4gKlxuICogV2VsbCB0aGF0IGRvZXNuJ3QgcmVhbGx5IGhlbHAgdXMgb25lIGJpdCBub3cgZG9lcyBpdD8gV2UgY291bGQgdXNlIHRoZVxuICogc3RhbmRhcmQgYmFzZSAxMCB2ZXJzaW9uIG9mIHRoZSBzdHJpbmcsIGJ1dCB0aGF0J3MganVzdCBnb2luZyB0byBjcmVhdGUgbW9yZVxuICogZXJyb3JzIGFzIHdlIGVuZCB1cCB0cnlpbmcgdG8gY29udmVydCBpdCBiYWNrIHRvIGEgYmluYXJ5IHZhbHVlLiBTbywgcmVhbGx5XG4gKiB0aGlzIGp1c3QgbWVhbnMgd2UgaGF2ZSB0byBiZSBub24tbGF6eSBhbmQgcGFyc2UgdGhlIHN0cnVjdHVyZSBpbnRlbGxpZ2VudGx5LlxuICpcbiAqIEZpcnN0IG9mZiwgd2UgY2FuIGRvIHRoZSBiYXNpYyBjaGVja3M6IE5hTiwgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIGluZmluaXR5LlxuICpcbiAqIE5vdyB0aGF0IHRob3NlIGFyZSBkb25lIHdlIGNhbiB3b3JrIGJhY2t3YXJkcyB0byBnZW5lcmF0ZSB0aGUgbWFudGlzc2EgYW5kXG4gKiBleHBvbmVudC5cbiAqXG4gKiBUaGUgZmlyc3QgdGhpbmcgd2UgbmVlZCB0byBkbyBpcyBkZXRlcm1pbmUgdGhlIHNpZ24gYml0LCBlYXN5IHRvIGRvLCBjaGVja1xuICogd2hldGhlciB0aGUgdmFsdWUgaXMgbGVzcyB0aGFuIDAuIEFuZCBjb252ZXJ0IHRoZSBudW1iZXIgdG8gaXRzIGFic29sdXRlXG4gKiB2YWx1ZSByZXByZXNlbnRhdGlvbi4gTmV4dCwgd2UgbmVlZCB0byBkZXRlcm1pbmUgaWYgdGhlIHZhbHVlIGlzIGxlc3MgdGhhblxuICogb25lIG9yIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBvbmUgYW5kIGZyb20gdGhlcmUgZGV0ZXJtaW5lIHdoYXQgcG93ZXIgd2FzXG4gKiB1c2VkIHRvIGdldCB0aGVyZS4gV2hhdCBmb2xsb3dzIGlzIG5vdyBzcGVjaWZpYyB0byBmbG9hdHMsIHRob3VnaCB0aGUgZ2VuZXJhbFxuICogaWRlYXMgYmVoaW5kIHRoaXMgd2lsbCBob2xkIGZvciBkb3VibGVzIGFzIHdlbGwsIGJ1dCB0aGUgZXhhY3QgbnVtYmVyc1xuICogaW52b2x2ZWQgd2lsbCBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBoYXZlIHRoYXQgcG93ZXIgd2UgY2FuIGRldGVybWluZSB0aGUgZXhwb25lbnQgYW5kIHRoZSBtYW50aXNzYS4gQ2FsbFxuICogdGhlIHZhbHVlIHRoYXQgaGFzIHRoZSBudW1iZXIgb2YgYml0cyB0byByZWFjaCB0aGUgcG93ZXIgZWJpdHMuIEluIHRoZVxuICogZ2VuZXJhbCBjYXNlIHRoZXkgaGF2ZSB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiAqXG4gKlx0ZXhwb25lbnRcdDEyNyArIGViaXRzXG4gKlx0bWFudGlzc2FcdHZhbHVlICogMl4oMjMgLSBlYml0cykgJiAweDdmZmZmZlxuICpcbiAqIEluIHRoZSBjYXNlIHdoZXJlIHRoZSB2YWx1ZSBvZiBlYml0cyBpcyA8PSAtMTI3IHdlIGFyZSBub3cgaW4gdGhlIGNhc2Ugd2hlcmVcbiAqIHdlIG5vIGxvbmdlciBoYXZlIG5vcm1hbGl6ZWQgbnVtYmVycy4gSW4gdGhpcyBjYXNlIHRoZSB2YWx1ZXMgdGFrZSBvbiB0aGVcbiAqIGZvbGxvd2luZyB2YWx1ZXM6XG4gKlxuICogXHRleHBvbmVudFx0MFxuICpcdG1hbnRpc3NhXHR2YWx1ZSAqIDJeMTQ5ICYgMHg3ZmZmZmZcbiAqXG4gKiBPbmNlIHdlIGhhdmUgdGhlIHZhbHVlcyBmb3IgdGhlIHNpZ24sIG1hbnRpc3NhLCBhbmQgZXhwb25lbnQuIFdlIHJlY29uc3RydWN0XG4gKiB0aGUgZm91ciBieXRlcyBhcyBmb2xsb3dzOlxuICpcbiAqXHRieXRlMFx0XHRzaWduIGJpdCBhbmQgc2V2ZW4gbW9zdCBzaWduaWZpY2FudCBiaXRzIGZyb20gdGhlIGV4cFxuICpcdFx0XHRzaWduIDw8IDcgfCAoZXhwb25lbnQgJiAweGZlKSA+Pj4gMVxuICpcbiAqXHRieXRlMVx0XHRsc2IgZnJvbSB0aGUgZXhwb25lbnQgYW5kIDcgdG9wIGJpdHMgZnJvbSB0aGUgbWFudGlzc2FcbiAqXHRcdFx0KGV4cG9uZW50ICYgMHgwMSkgPDwgNyB8IChtYW50aXNzYSAmIDB4N2YwMDAwKSA+Pj4gMTZcbiAqXG4gKlx0Ynl0ZTJcdFx0Yml0cyA4LTE1ICh6ZXJvIGluZGV4aW5nKSBmcm9tIG1hbnRpc3NhXG4gKlx0XHRcdG1hbnRpc3NhICYgMHhmZjAwID4+IDhcbiAqXG4gKlx0Ynl0ZTNcdFx0Yml0cyAwLTcgZnJvbSBtYW50aXNzYVxuICpcdFx0XHRtYW50aXNzYSAmIDB4ZmZcbiAqXG4gKiBPbmNlIHdlIGhhdmUgdGhpcyB3ZSBoYXZlIHRvIGFzc2lnbiB0aGVtIGludG8gdGhlIGJ1ZmZlciBpbiBwcm9wZXIgZW5kaWFuXG4gKiBvcmRlci5cbiAqL1xuXG4vKlxuICogQ29tcHV0ZSB0aGUgbG9nIGJhc2UgMiBvZiB0aGUgdmFsdWUuIE5vdywgc29tZW9uZSB3aG8gcmVtZW1iZXJzIGJhc2ljXG4gKiBwcm9wZXJ0aWVzIG9mIGxvZ2FyaXRobXMgd2lsbCBwb2ludCBvdXQgdGhhdCB3ZSBjb3VsZCB1c2UgdGhlIGNoYW5nZSBvZiBiYXNlXG4gKiBmb3JtdWxhIGZvciBsb2dzLCBhbmQgaW4gZmFjdCB0aGF0IHdvdWxkIGJlIGFzdHV0ZSwgYmVjYXVzZSB0aGF0J3Mgd2hhdCB3ZSdsbFxuICogZG8gZm9yIG5vdy4gSXQgZmVlbHMgY2xlYW5lciwgYWxiZWl0IGl0IG1heSBiZSBsZXNzIGVmZmljaWVudCB0aGFuIGp1c3RcbiAqIGl0ZXJhdGluZyBhbmQgZGl2aWRpbmcgYnkgMi4gV2UgbWF5IHdhbnQgdG8gY29tZSBiYWNrIGFuZCByZXZpc2l0IHRoYXQgc29tZVxuICogZGF5LlxuICovXG5mdW5jdGlvbiBsb2cyKHZhbHVlKVxue1xuXHRyZXR1cm4gKE1hdGgubG9nKHZhbHVlKSAvIE1hdGgubG9nKDIpKTtcbn1cblxuLypcbiAqIEhlbHBlciB0byBkZXRlcm1pbmUgdGhlIGV4cG9uZW50IG9mIHRoZSBudW1iZXIgd2UncmUgbG9va2luZyBhdC5cbiAqL1xuZnVuY3Rpb24gaW50ZXhwKHZhbHVlKVxue1xuXHRyZXR1cm4gKE1hdGguZmxvb3IobG9nMih2YWx1ZSkpKTtcbn1cblxuLypcbiAqIEhlbHBlciB0byBkZXRlcm1pbmUgdGhlIGV4cG9uZW50IG9mIHRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgdGhlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBmcmFjZXhwKHZhbHVlKVxue1xuXHRyZXR1cm4gKE1hdGguZmxvb3IobG9nMih2YWx1ZSkpKTtcbn1cblxuZnVuY3Rpb24gd2Zsb2F0KHZhbHVlLCBlbmRpYW4sIGJ1ZmZlciwgb2Zmc2V0KVxue1xuXHR2YXIgc2lnbiwgZXhwb25lbnQsIG1hbnRpc3NhLCBlYml0cztcblx0dmFyIGJ5dGVzID0gW107XG5cblx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyB2YWx1ZScpKTtcblxuXHRpZiAoZW5kaWFuID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBlbmRpYW4nKSk7XG5cblx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgYnVmZmVyJykpO1xuXG5cdGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIG9mZnNldCcpKTtcblxuXG5cdGlmIChvZmZzZXQgKyAzID49IGJ1ZmZlci5sZW5ndGgpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKSk7XG5cblx0aWYgKGlzTmFOKHZhbHVlKSkge1xuXHRcdHNpZ24gPSAwO1xuXHRcdGV4cG9uZW50ID0gMHhmZjtcblx0XHRtYW50aXNzYSA9IDIzO1xuXHR9IGVsc2UgaWYgKHZhbHVlID09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuXHRcdHNpZ24gPSAwO1xuXHRcdGV4cG9uZW50ID0gMHhmZjtcblx0XHRtYW50aXNzYSA9IDA7XG5cdH0gZWxzZSBpZiAodmFsdWUgPT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSB7XG5cdFx0c2lnbiA9IDE7XG5cdFx0ZXhwb25lbnQgPSAweGZmO1xuXHRcdG1hbnRpc3NhID0gMDtcblx0fSBlbHNlIHtcblx0XHQvKiBXZWxsIHdlIGhhdmUgc29tZSB3b3JrIHRvIGRvICovXG5cblx0XHQvKiBUaGFua2Z1bGx5IHRoZSBzaWduIGJpdCBpcyB0cml2aWFsICovXG5cdFx0aWYgKHZhbHVlIDwgMCkge1xuXHRcdFx0c2lnbiA9IDE7XG5cdFx0XHR2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2lnbiA9IDA7XG5cdFx0fVxuXG5cdFx0LyogVXNlIHRoZSBjb3JyZWN0IGZ1bmN0aW9uIHRvIGRldGVybWluZSBudW1iZXIgb2YgYml0cyAqL1xuXHRcdGlmICh2YWx1ZSA8IDEpXG5cdFx0XHRlYml0cyA9IGZyYWNleHAodmFsdWUpO1xuXHRcdGVsc2Vcblx0XHRcdGViaXRzID0gaW50ZXhwKHZhbHVlKTtcblxuXHRcdC8qIFRpbWUgdG8gZGVhbCB3aXRoIHRoZSBpc3N1ZXMgc3Vycm91bmRpbmcgbm9ybWFsaXphdGlvbiAqL1xuXHRcdGlmIChlYml0cyA8PSAtMTI3KSB7XG5cdFx0XHRleHBvbmVudCA9IDA7XG5cdFx0XHRtYW50aXNzYSA9ICh2YWx1ZSAqIE1hdGgucG93KDIsIDE0OSkpICYgMHg3ZmZmZmY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9uZW50ID0gMTI3ICsgZWJpdHM7XG5cdFx0XHRtYW50aXNzYSA9IHZhbHVlICogTWF0aC5wb3coMiwgMjMgLSBlYml0cyk7XG5cdFx0XHRtYW50aXNzYSAmPSAweDdmZmZmZjtcblx0XHR9XG5cdH1cblxuXHRieXRlc1swXSA9IHNpZ24gPDwgNyB8IChleHBvbmVudCAmIDB4ZmUpID4+PiAxO1xuXHRieXRlc1sxXSA9IChleHBvbmVudCAmIDB4MDEpIDw8IDcgfCAobWFudGlzc2EgJiAweDdmMDAwMCkgPj4+IDE2O1xuXHRieXRlc1syXSA9IChtYW50aXNzYSAmIDB4MDBmZjAwKSA+Pj4gODtcblx0Ynl0ZXNbM10gPSBtYW50aXNzYSAmIDB4MDAwMGZmO1xuXG5cdGlmIChlbmRpYW4gPT0gJ2JpZycpIHtcblx0XHRidWZmZXJbb2Zmc2V0XSA9IGJ5dGVzWzBdO1xuXHRcdGJ1ZmZlcltvZmZzZXQrMV0gPSBieXRlc1sxXTtcblx0XHRidWZmZXJbb2Zmc2V0KzJdID0gYnl0ZXNbMl07XG5cdFx0YnVmZmVyW29mZnNldCszXSA9IGJ5dGVzWzNdO1xuXHR9IGVsc2Uge1xuXHRcdGJ1ZmZlcltvZmZzZXRdID0gYnl0ZXNbM107XG5cdFx0YnVmZmVyW29mZnNldCsxXSA9IGJ5dGVzWzJdO1xuXHRcdGJ1ZmZlcltvZmZzZXQrMl0gPSBieXRlc1sxXTtcblx0XHRidWZmZXJbb2Zmc2V0KzNdID0gYnl0ZXNbMF07XG5cdH1cbn1cblxuLypcbiAqIE5vdyB3ZSBtb3ZlIG9udG8gZG91Ymxlcy4gRG91YmxlcyBhcmUgc2ltaWxhciB0byBmbG9hdHMgaW4gcHJldHR5IG11Y2ggYWxsXG4gKiB3YXlzIGV4Y2VwdCB0aGF0IHRoZSBwcm9jZXNzaW5nIGlzbid0IHF1aXRlIGFzIHN0cmFpZ2h0Zm9yd2FyZCBiZWNhdXNlIHdlXG4gKiBjYW4ndCBhbHdheXMgdXNlIHNoaWZ0aW5nLCBpLmUuIHdlIGhhdmUgPiAzMiBiaXQgdmFsdWVzLlxuICpcbiAqIFdlJ3JlIGdvaW5nIHRvIHByb2NlZWQgaW4gYW4gaWRlbnRpY2FsIGZhc2hpb24gdG8gZmxvYXRzIGFuZCB1dGlsaXplIHRoZSBzYW1lXG4gKiBoZWxwZXIgZnVuY3Rpb25zLiBBbGwgdGhhdCByZWFsbHkgaXMgY2hhbmdpbmcgYXJlIHRoZSBzcGVjaWZpYyB2YWx1ZXMgdGhhdCB3ZVxuICogdXNlIHRvIGRvIHRoZSBjYWxjdWxhdGlvbnMuIFRodXMsIHRvIHJldmlldyB3ZSBoYXZlIHRvIGRvIHRoZSBmb2xsb3dpbmcuXG4gKlxuICogRmlyc3QgZ2V0IHRoZSBzaWduIGJpdCBhbmQgY29udmVydCB0aGUgdmFsdWUgdG8gaXRzIGFic29sdXRlIHZhbHVlXG4gKiByZXByZXNlbnRhdGlvbi4gTmV4dCwgd2UgZGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYml0cyB0aGF0IHdlIHVzZWQgdG8gZ2V0IHRvXG4gKiB0aGUgdmFsdWUsIGJyYW5jaGluZyB3aGV0aGVyIHRoZSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgbGVzcyB0aGFuIDEuIE9uY2VcbiAqIHdlIGhhdmUgdGhhdCB2YWx1ZSB3aGljaCB3ZSB3aWxsIGFnYWluIGNhbGwgZWJpdHMsIHdlIGhhdmUgdG8gZG8gdGhlXG4gKiBmb2xsb3dpbmcgaW4gdGhlIGdlbmVyYWwgY2FzZTpcbiAqXG4gKlx0ZXhwb25lbnRcdDEwMjMgKyBlYml0c1xuICpcdG1hbnRpc3NhXHRbdmFsdWUgKiAyXig1MiAtIGViaXRzKV0gJSAyXjUyXG4gKlxuICogSW4gdGhlIGNhc2Ugd2hlcmUgdGhlIHZhbHVlIG9mIGViaXRzIDw9IC0xMDIzIHdlIG5vIGxvbmdlciB1c2Ugbm9ybWFsaXplZFxuICogbnVtYmVycywgdGh1cyBsaWtlIHdpdGggZmxvYXRzIHdlIGhhdmUgdG8gZG8gc2xpZ2h0bHkgZGlmZmVyZW50IHByb2Nlc3Npbmc6XG4gKlxuICpcdGV4cG9uZW50XHQwXG4gKlx0bWFudGlzc2FcdFt2YWx1ZSAqIDJeMTA3NF0gJSAyXjUyXG4gKlxuICogT25jZSB3ZSBoYXZlIGRldGVybWluZWQgdGhlIHNpZ24sIGV4cG9uZW50IGFuZCBtYW50aXNzYSB3ZSBjYW4gY29uc3RydWN0IHRoZVxuICogYnl0ZXMgYXMgZm9sbG93czpcbiAqXG4gKlx0Ynl0ZTBcdFx0c2lnbiBiaXQgYW5kIHNldmVuIG1vc3Qgc2lnbmlmaWNhbnQgYml0cyBmb3JtIHRoZSBleHBcbiAqXHRcdFx0c2lnbiA8PCA3IHwgKGV4cG9uZW50ICYgMHg3ZjApID4+PiA0XG4gKlxuICpcdGJ5dGUxXHRcdFJlbWFpbmluZyA0IGJpdHMgZnJvbSB0aGUgZXhwb25lbnQgYW5kIHRoZSBmb3VyIG1vc3RcbiAqXHRcdFx0c2lnbmlmaWNhbnQgYml0cyBmcm9tIHRoZSBtYW50aXNzYSA0OC01MVxuICpcdFx0XHQoZXhwb25lbnQgJiAweDAwZikgPDwgNCB8IG1hbnRpc3NhID4+PiA0OFxuICpcbiAqXHRieXRlMlx0XHRCaXRzIDQwLTQ3IGZyb20gdGhlIG1hbnRpc3NhXG4gKlx0XHRcdChtYW50aXNzYSA+Pj4gNDApICYgMHhmZlxuICpcbiAqXHRieXRlM1x0XHRCaXRzIDMyLTM5IGZyb20gdGhlIG1hbnRpc3NhXG4gKlx0XHRcdChtYW50aXNzYSA+Pj4gMzIpICYgMHhmZlxuICpcbiAqXHRieXRlNFx0XHRCaXRzIDI0LTMxIGZyb20gdGhlIG1hbnRpc3NhXG4gKlx0XHRcdChtYW50aXNzYSA+Pj4gMjQpICYgMHhmZlxuICpcbiAqXHRieXRlNVx0XHRCaXRzIDE2LTIzIGZyb20gdGhlIE1hbnRpc3NhXG4gKlx0XHRcdChtYW50aXNzYSA+Pj4gMTYpICYgMHhmZlxuICpcbiAqXHRieXRlNlx0XHRCaXRzIDgtMTUgZnJvbSB0aGUgbWFudGlzc2FcbiAqXHRcdFx0KG1hbnRpc3NhID4+PiA4KSAmIDB4ZmZcbiAqXG4gKlx0Ynl0ZTdcdFx0Qml0cyAwLTcgZnJvbSB0aGUgbWFudGlzc2FcbiAqXHRcdFx0bWFudGlzc2EgJiAweGZmXG4gKlxuICogTm93IHdlIGNhbid0IHF1aXRlIGRvIHRoZSByaWdodCBzaGlmdGluZyB0aGF0IHdlIHdhbnQgaW4gYnl0ZXMgMSAtIDMsIGJlY2F1c2VcbiAqIHdlJ2xsIGhhdmUgZXh0ZW5kZWQgdG9vIGZhciBhbmQgd2UnbGwgbG9zZSB0aG9zZSB2YWx1ZXMgd2hlbiB3ZSB0cnkgYW5kIGRvXG4gKiB0aGUgc2hpZnQuIEluc3RlYWQgd2UgaGF2ZSB0byB1c2UgYW4gYWx0ZXJuYXRlIGFwcHJvYWNoLiBUbyB0cnkgYW5kIHN0YXkgb3V0XG4gKiBvZiBmbG9hdGluZyBwb2ludCwgd2hhdCB3ZSdsbCBkbyBpcyBzYXkgdGhhdCBtYW50aXNzYSAtPSBieXRlc1s0LTddIGFuZCB0aGVuXG4gKiBkaXZpZGUgYnkgMl4zMi4gT25jZSB3ZSd2ZSBkb25lIHRoYXQgd2UgY2FuIHVzZSBiaW5hcnkgYXJpdGhtZXRpYy4gT29mLFxuICogdGhhdCdzIHVnbHksIGJ1dCBpdCBzZWVtcyB0byBhdm9pZCB1c2luZyBmbG9hdGluZyBwb2ludCAoanVzdCBiYXNlZCBvbiBob3cgdjhcbiAqIHNlZW1zIHRvIGJlIG9wdGltaXppbmcgZm9yIGJhc2UgMiBhcml0aG1ldGljKS5cbiAqL1xuZnVuY3Rpb24gd2RvdWJsZSh2YWx1ZSwgZW5kaWFuLCBidWZmZXIsIG9mZnNldClcbntcblx0dmFyIHNpZ24sIGV4cG9uZW50LCBtYW50aXNzYSwgZWJpdHM7XG5cdHZhciBieXRlcyA9IFtdO1xuXG5cdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgdmFsdWUnKSk7XG5cblx0aWYgKGVuZGlhbiA9PT0gdW5kZWZpbmVkKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ21pc3NpbmcgZW5kaWFuJykpO1xuXG5cdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHR0aHJvdyAobmV3IEVycm9yKCdtaXNzaW5nIGJ1ZmZlcicpKTtcblxuXHRpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpXG5cdFx0dGhyb3cgKG5ldyBFcnJvcignbWlzc2luZyBvZmZzZXQnKSk7XG5cblxuXHRpZiAob2Zmc2V0ICsgNyA+PSBidWZmZXIubGVuZ3RoKVxuXHRcdHRocm93IChuZXcgRXJyb3IoJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJykpO1xuXG5cdGlmIChpc05hTih2YWx1ZSkpIHtcblx0XHRzaWduID0gMDtcblx0XHRleHBvbmVudCA9IDB4N2ZmO1xuXHRcdG1hbnRpc3NhID0gMjM7XG5cdH0gZWxzZSBpZiAodmFsdWUgPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG5cdFx0c2lnbiA9IDA7XG5cdFx0ZXhwb25lbnQgPSAweDdmZjtcblx0XHRtYW50aXNzYSA9IDA7XG5cdH0gZWxzZSBpZiAodmFsdWUgPT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSB7XG5cdFx0c2lnbiA9IDE7XG5cdFx0ZXhwb25lbnQgPSAweDdmZjtcblx0XHRtYW50aXNzYSA9IDA7XG5cdH0gZWxzZSB7XG5cdFx0LyogV2VsbCB3ZSBoYXZlIHNvbWUgd29yayB0byBkbyAqL1xuXG5cdFx0LyogVGhhbmtmdWxseSB0aGUgc2lnbiBiaXQgaXMgdHJpdmlhbCAqL1xuXHRcdGlmICh2YWx1ZSA8IDApIHtcblx0XHRcdHNpZ24gPSAxO1xuXHRcdFx0dmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNpZ24gPSAwO1xuXHRcdH1cblxuXHRcdC8qIFVzZSB0aGUgY29ycmVjdCBmdW5jdGlvbiB0byBkZXRlcm1pbmUgbnVtYmVyIG9mIGJpdHMgKi9cblx0XHRpZiAodmFsdWUgPCAxKVxuXHRcdFx0ZWJpdHMgPSBmcmFjZXhwKHZhbHVlKTtcblx0XHRlbHNlXG5cdFx0XHRlYml0cyA9IGludGV4cCh2YWx1ZSk7XG5cblx0XHQvKlxuXHRcdCAqIFRoaXMgaXMgYSB0b3RhbCBoYWNrIHRvIGRldGVybWluZSBhIGRlbm9ybWFsaXplZCB2YWx1ZS5cblx0XHQgKiBVbmZvcnR1bmF0ZWx5LCB3ZSBzb21ldGltZXMgZG8gbm90IGdldCBhIHByb3BlciB2YWx1ZSBmb3Jcblx0XHQgKiBlYml0cywgaS5lLiB3ZSBsb3NlIHRoZSB2YWx1ZXMgdGhhdCB3b3VsZCBnZXQgcm91bmRlZCBvZmYuXG5cdFx0ICpcblx0XHQgKlxuXHRcdCAqIFRoZSBhc3R1dGUgb2JzZXJ2ZXIgbWF5IHdvbmRlciB3aHkgd2Ugd291bGQgYmVcblx0XHQgKiBtdWx0aXBseWluZyBieSB0d28gTWF0aC5wb3dzIHJhdGhlciB0aGFuIGp1c3Qgc3VtbWluZ1xuXHRcdCAqIHRoZW0uIFdlbGwsIHRoYXQncyB0byBnZXQgYXJvdW5kIGEgc21hbGwgYnVnIGluIHRoZVxuXHRcdCAqIHdheSB2OCBzZWVtcyB0byBpbXBsZW1lbnQgdGhlIGZ1bmN0aW9uLiBPbiBvY2Nhc2lvblxuXHRcdCAqIGRvaW5nOlxuXHRcdCAqXG5cdFx0ICogZm9vICogTWF0aC5wb3coMiwgMTAyMyArIDUxKVxuXHRcdCAqXG5cdFx0ICogQ2F1c2VzIHVzIHRvIG92ZXJmbG93IHRvIGluZmluaXR5LCB3aGVyZSBhcyBkb2luZzpcblx0XHQgKlxuXHRcdCAqIGZvbyAqIE1hdGgucG93KDIsIDEwMjMpICogTWF0aC5wb3coMiwgNTEpXG5cdFx0ICpcblx0XHQgKiBEb2VzIG5vdCBjYXVzZSB1cyB0byBvdmVyZmxvdy4gR28gZmlndXJlLlxuXHRcdCAqXG5cdFx0ICovXG5cdFx0aWYgKHZhbHVlIDw9IDIuMjI1MDczODU4NTA3MjAxZS0zMDggfHwgZWJpdHMgPD0gLTEwMjMpIHtcblx0XHRcdGV4cG9uZW50ID0gMDtcblx0XHRcdG1hbnRpc3NhID0gdmFsdWUgKiBNYXRoLnBvdygyLCAxMDIzKSAqIE1hdGgucG93KDIsIDUxKTtcblx0XHRcdG1hbnRpc3NhICU9IE1hdGgucG93KDIsIDUyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Lypcblx0XHRcdCAqIFdlIG1pZ2h0IGhhdmUgZ290dGVuIGZ1Y2tlZCBieSBvdXIgZmxvYXRpbmcgcG9pbnRcblx0XHRcdCAqIGxvZ2FyaXRobSBtYWdpYy4gVGhpcyBpcyByYXRoZXIgY3JhcHB5LCBidXQgdGhhdCdzXG5cdFx0XHQgKiBvdXIgbHVjay4gSWYgd2UganVzdCBoYWQgYSBsb2cgYmFzZSAyIG9yIGFjY2VzcyB0b1xuXHRcdFx0ICogdGhlIHN0dXBpZCB1bmRlcmx5aW5nIHJlcHJlc2VudGF0aW9uIHRoaXMgd291bGQgaGF2ZVxuXHRcdFx0ICogYmVlbiBtdWNoIGVhc2llciBhbmQgd2Ugd291bGRuJ3QgaGF2ZSBzdWNoIHN0dXBpZFxuXHRcdFx0ICoga2x1ZGdlcyBvciBoYWNrcy5cblx0XHRcdCAqL1xuXHRcdFx0aWYgKGViaXRzID4gMTAyMylcblx0XHRcdFx0ZWJpdHMgPSAxMDIzO1xuXHRcdFx0ZXhwb25lbnQgPSAxMDIzICsgZWJpdHM7XG5cdFx0XHRtYW50aXNzYSA9IHZhbHVlICogTWF0aC5wb3coMiwgLWViaXRzKTtcblx0XHRcdG1hbnRpc3NhICo9IE1hdGgucG93KDIsIDUyKTtcblx0XHRcdG1hbnRpc3NhICU9IE1hdGgucG93KDIsIDUyKTtcblx0XHR9XG5cdH1cblxuXHQvKiBGaWxsIHRoZSBieXRlcyBpbiBiYWNrd2FyZHMgdG8gZGVhbCB3aXRoIHRoZSBzaXplIGlzc3VlcyAqL1xuXHRieXRlc1s3XSA9IG1hbnRpc3NhICYgMHhmZjtcblx0Ynl0ZXNbNl0gPSAobWFudGlzc2EgPj4+IDgpICYgMHhmZjtcblx0Ynl0ZXNbNV0gPSAobWFudGlzc2EgPj4+IDE2KSAmIDB4ZmY7XG5cdG1hbnRpc3NhID0gKG1hbnRpc3NhIC0gKG1hbnRpc3NhICYgMHhmZmZmZmYpKSAvIE1hdGgucG93KDIsIDI0KTtcblx0Ynl0ZXNbNF0gPSBtYW50aXNzYSAmIDB4ZmY7XG5cdGJ5dGVzWzNdID0gKG1hbnRpc3NhID4+PiA4KSAmIDB4ZmY7XG5cdGJ5dGVzWzJdID0gKG1hbnRpc3NhID4+PiAxNikgJiAweGZmO1xuXHRieXRlc1sxXSA9IChleHBvbmVudCAmIDB4MDBmKSA8PCA0IHwgbWFudGlzc2EgPj4+IDI0O1xuXHRieXRlc1swXSA9IChzaWduIDw8IDcpIHwgKGV4cG9uZW50ICYgMHg3ZjApID4+PiA0O1xuXG5cdGlmIChlbmRpYW4gPT0gJ2JpZycpIHtcblx0XHRidWZmZXJbb2Zmc2V0XSA9IGJ5dGVzWzBdO1xuXHRcdGJ1ZmZlcltvZmZzZXQrMV0gPSBieXRlc1sxXTtcblx0XHRidWZmZXJbb2Zmc2V0KzJdID0gYnl0ZXNbMl07XG5cdFx0YnVmZmVyW29mZnNldCszXSA9IGJ5dGVzWzNdO1xuXHRcdGJ1ZmZlcltvZmZzZXQrNF0gPSBieXRlc1s0XTtcblx0XHRidWZmZXJbb2Zmc2V0KzVdID0gYnl0ZXNbNV07XG5cdFx0YnVmZmVyW29mZnNldCs2XSA9IGJ5dGVzWzZdO1xuXHRcdGJ1ZmZlcltvZmZzZXQrN10gPSBieXRlc1s3XTtcblx0fSBlbHNlIHtcblx0XHRidWZmZXJbb2Zmc2V0KzddID0gYnl0ZXNbMF07XG5cdFx0YnVmZmVyW29mZnNldCs2XSA9IGJ5dGVzWzFdO1xuXHRcdGJ1ZmZlcltvZmZzZXQrNV0gPSBieXRlc1syXTtcblx0XHRidWZmZXJbb2Zmc2V0KzRdID0gYnl0ZXNbM107XG5cdFx0YnVmZmVyW29mZnNldCszXSA9IGJ5dGVzWzRdO1xuXHRcdGJ1ZmZlcltvZmZzZXQrMl0gPSBieXRlc1s1XTtcblx0XHRidWZmZXJbb2Zmc2V0KzFdID0gYnl0ZXNbNl07XG5cdFx0YnVmZmVyW29mZnNldF0gPSBieXRlc1s3XTtcblx0fVxufVxuXG4vKlxuICogQWN0dWFsbHkgZXhwb3J0IG91ciB3b3JrIGFib3ZlLiBPbmUgbWlnaHQgYXJndWUgdGhhdCB3ZSBzaG91bGRuJ3QgZXhwb3NlXG4gKiB0aGVzZSBpbnRlcmZhY2VzIGFuZCBqdXN0IGZvcmNlIHBlb3BsZSB0byB1c2UgdGhlIGhpZ2hlciBsZXZlbCBhYnN0cmFjdGlvbnNcbiAqIGFyb3VuZCB0aGlzIHdvcmsuIEhvd2V2ZXIsIHVubGlrZSBzYXkgb3RoZXIgbGlicmFyaWVzIHdlJ3ZlIGNvbWUgYWNyb3NzLCB0aGlzXG4gKiBpbnRlcmZhY2UgaGFzIHNldmVyYWwgcHJvcGVydGllczogaXQgbWFrZXMgc2Vuc2UsIGl0J3Mgc2ltcGxlLCBhbmQgaXQnc1xuICogdXNlZnVsLlxuICovXG5leHBvcnRzLnJ1aW50OCA9IHJ1aW50ODtcbmV4cG9ydHMucnVpbnQxNiA9IHJ1aW50MTY7XG5leHBvcnRzLnJ1aW50MzIgPSBydWludDMyO1xuZXhwb3J0cy5ydWludDY0ID0gcnVpbnQ2NDtcbmV4cG9ydHMud3VpbnQ4ID0gd3VpbnQ4O1xuZXhwb3J0cy53dWludDE2ID0gd3VpbnQxNjtcbmV4cG9ydHMud3VpbnQzMiA9IHd1aW50MzI7XG5leHBvcnRzLnd1aW50NjQgPSB3dWludDY0O1xuXG5leHBvcnRzLnJzaW50OCA9IHJzaW50ODtcbmV4cG9ydHMucnNpbnQxNiA9IHJzaW50MTY7XG5leHBvcnRzLnJzaW50MzIgPSByc2ludDMyO1xuZXhwb3J0cy5yc2ludDY0ID0gcnNpbnQ2NDtcbmV4cG9ydHMud3NpbnQ4ID0gd3NpbnQ4O1xuZXhwb3J0cy53c2ludDE2ID0gd3NpbnQxNjtcbmV4cG9ydHMud3NpbnQzMiA9IHdzaW50MzI7XG5leHBvcnRzLndzaW50NjQgPSB3c2ludDY0O1xuXG5leHBvcnRzLnJmbG9hdCA9IHJmbG9hdDtcbmV4cG9ydHMucmRvdWJsZSA9IHJkb3VibGU7XG5leHBvcnRzLndmbG9hdCA9IHdmbG9hdDtcbmV4cG9ydHMud2RvdWJsZSA9IHdkb3VibGU7XG4iLCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgbHR4ID0gcmVxdWlyZSgnbHR4Jyk7XG52YXIgU3RyZWFtUGFyc2VyID0gcmVxdWlyZSgnLi9zdHJlYW1fcGFyc2VyJyk7XG52YXIgV2ViU29ja2V0ID0gcmVxdWlyZSgnZmF5ZS13ZWJzb2NrZXQnKSA/XG4gICAgICAgICAgICAgICAgcmVxdWlyZSgnZmF5ZS13ZWJzb2NrZXQnKS5DbGllbnQgOlxuICAgICAgICAgICAgICAgIHdpbmRvdy5XZWJTb2NrZXQ7XG5cblxudmFyIE5TX1NUUkVBTSA9IGV4cG9ydHMuTlNfU1RSRUFNID0gJ2h0dHA6Ly9ldGhlcnguamFiYmVyLm9yZy9zdHJlYW1zJztcbnZhciBOU19YTVBQX1NUUkVBTVMgPSAndXJuOmlldGY6cGFyYW1zOnhtbDpuczp4bXBwLXN0cmVhbXMnO1xuXG5mdW5jdGlvbiBXU0Nvbm5lY3Rpb24odXJsKSB7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnhtbG5zID0ge307XG4gICAgdGhpcy53ZWJzb2NrZXQgPSBuZXcgV2ViU29ja2V0KHRoaXMudXJsLCBbJ3htcHAnXSk7XG4gICAgdGhpcy53ZWJzb2NrZXQub25vcGVuID0gdGhpcy5vbm9wZW4uYmluZCh0aGlzKTtcbiAgICB0aGlzLndlYnNvY2tldC5vbm1lc3NhZ2UgPSB0aGlzLm9ubWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMud2Vic29ja2V0Lm9uY2xvc2UgPSB0aGlzLm9uY2xvc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLndlYnNvY2tldC5vbmVycm9yID0gdGhpcy5vbmVycm9yLmJpbmQodGhpcyk7XG59XG51dGlsLmluaGVyaXRzKFdTQ29ubmVjdGlvbiwgRXZlbnRFbWl0dGVyKTtcbmV4cG9ydHMuV1NDb25uZWN0aW9uID0gV1NDb25uZWN0aW9uO1xuXG5XU0Nvbm5lY3Rpb24ucHJvdG90eXBlLm1heFN0YW56YVNpemUgPSA2NTUzNTtcblxuV1NDb25uZWN0aW9uLnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmVtaXQoJ2Nvbm5lY3RlZCcpO1xuICAgIHRoaXMuc3RhcnRQYXJzZXIoKTtcbn07XG5cbldTQ29ubmVjdGlvbi5wcm90b3R5cGUuc3RhcnRQYXJzZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5wYXJzZXIgPSBuZXcgU3RyZWFtUGFyc2VyLlN0cmVhbVBhcnNlcih0aGlzLm1heFN0YW56YVNpemUpO1xuXG4gICAgdGhpcy5wYXJzZXIuYWRkTGlzdGVuZXIoJ3N0YXJ0JywgZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgICAgc2VsZi5zdHJlYW1BdHRycyA9IGF0dHJzO1xuICAgICAgICAvKiBXZSBuZWVkIHRob3NlIHhtbG5zIG9mdGVuLCBzdG9yZSB0aGVtIGV4dHJhICovXG4gICAgICAgIHNlbGYuc3RyZWFtTnNBdHRycyA9IHt9O1xuICAgICAgICBmb3IodmFyIGsgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKGsgPT0gJ3htbG5zJyB8fFxuICAgICAgICAgICAgay5zdWJzdHIoMCwgNikgPT0gJ3htbG5zOicpXG4gICAgICAgICAgICAgICAgc2VsZi5zdHJlYW1Oc0F0dHJzW2tdID0gYXR0cnNba107XG4gICAgICAgIH1cblxuICAgICAgICAvKiBOb3RpZnkgaW4gY2FzZSB3ZSBkb24ndCB3YWl0IGZvciA8c3RyZWFtOmZlYXR1cmVzLz5cbiAgICAgICAgICAgKENvbXBvbmVudCBvciBub24tMS4wIHN0cmVhbXMpXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmVtaXQoJ3N0cmVhbVN0YXJ0JywgYXR0cnMpO1xuICAgIH0pO1xuICAgIHRoaXMucGFyc2VyLmFkZExpc3RlbmVyKCdzdGFuemEnLCBmdW5jdGlvbihzdGFuemEpIHtcbiAgICAgICAgLy9zZWxmLm9uU3RhbnphKHNlbGYuYWRkU3RyZWFtTnMoc3RhbnphKSk7XG4gICAgICAgIHNlbGYub25TdGFuemEoc3RhbnphKTtcbiAgICB9KTtcbiAgICB0aGlzLnBhcnNlci5hZGRMaXN0ZW5lcignZXJyb3InLCB0aGlzLm9uZXJyb3IuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5wYXJzZXIuYWRkTGlzdGVuZXIoJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLnN0b3BQYXJzZXIoKTtcbiAgICAgICAgc2VsZi5lbmQoKTtcbiAgICB9KTtcbn07XG5cbldTQ29ubmVjdGlvbi5wcm90b3R5cGUuc3RvcFBhcnNlciA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIE5vIG1vcmUgZXZlbnRzLCBwbGVhc2UgKG1heSBoYXBwZW4gaG93ZXZlcikgKi9cbiAgICBpZih0aGlzLnBhcnNlcikge1xuICAgICAgICAvKiBHZXQgR0MnZWQgKi9cbiAgICAgICAgZGVsZXRlIHRoaXMucGFyc2VyO1xuICAgIH1cbn07XG5cbldTQ29ubmVjdGlvbi5wcm90b3R5cGUub25tZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gICAgY29uc29sZS5sb2coXCJ3cyBtc2dcIiwgbXNnLmRhdGEpO1xuICAgIGlmIChtc2cgJiYgbXNnLmRhdGEgJiYgdGhpcy5wYXJzZXIpXG5cdHRoaXMucGFyc2VyLndyaXRlKG1zZy5kYXRhKTtcbn07XG5cbldTQ29ubmVjdGlvbi5wcm90b3R5cGUub25TdGFuemEgPSBmdW5jdGlvbihzdGFuemEpIHtcbiAgICBpZiAoc3RhbnphLmlzKCdlcnJvcicsIE5TX1NUUkVBTSkpIHtcbiAgICAgICAgLyogVE9ETzogZXh0cmFjdCBlcnJvciB0ZXh0ICovXG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBzdGFuemEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdCgnc3RhbnphJywgc3RhbnphKTtcbiAgICB9XG59O1xuXG5XU0Nvbm5lY3Rpb24ucHJvdG90eXBlLnN0YXJ0U3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGF0dHJzID0ge307XG4gICAgZm9yKHZhciBrIGluIHRoaXMueG1sbnMpIHtcbiAgICAgICAgaWYgKHRoaXMueG1sbnMuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgIGlmICghaylcbiAgICAgICAgICAgICAgICBhdHRycy54bWxucyA9IHRoaXMueG1sbnNba107XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYXR0cnNbJ3htbG5zOicgKyBrXSA9IHRoaXMueG1sbnNba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMueG1wcFZlcnNpb24pXG4gICAgICAgIGF0dHJzLnZlcnNpb24gPSB0aGlzLnhtcHBWZXJzaW9uO1xuICAgIGlmICh0aGlzLnN0cmVhbVRvKVxuICAgICAgICBhdHRycy50byA9IHRoaXMuc3RyZWFtVG87XG4gICAgaWYgKHRoaXMuc3RyZWFtSWQpXG4gICAgICAgIGF0dHJzLmlkID0gdGhpcy5zdHJlYW1JZDtcblxuICAgIHZhciBlbCA9IG5ldyBsdHguRWxlbWVudCgnc3RyZWFtOnN0cmVhbScsIGF0dHJzKTtcbiAgICAvLyBtYWtlIGl0IG5vbi1lbXB0eSB0byBjdXQgdGhlIGNsb3NpbmcgdGFnXG4gICAgZWwudCgnICcpO1xuICAgIHZhciBzID0gZWwudG9TdHJpbmcoKTtcbiAgICB0aGlzLnNlbmQocy5zdWJzdHIoMCwgcy5pbmRleE9mKCcgPC9zdHJlYW06c3RyZWFtPicpKSk7XG5cbiAgICB0aGlzLnN0cmVhbU9wZW5lZCA9IHRydWU7XG59O1xuXG5XU0Nvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihzdGFuemEpIHtcbiAgICBpZiAoc3RhbnphLnJvb3QpXG5cdHN0YW56YSA9IHN0YW56YS5yb290KCk7XG4gICAgc3RhbnphID0gc3RhbnphLnRvU3RyaW5nKCk7XG4gICAgY29uc29sZS5sb2coXCJ3cyBzZW5kXCIsIHN0YW56YSk7XG4gICAgdGhpcy53ZWJzb2NrZXQuc2VuZChzdGFuemEpO1xufTtcblxuV1NDb25uZWN0aW9uLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24oKSB7XG59O1xuXG5XU0Nvbm5lY3Rpb24ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2VuZChcIjwvc3RyZWFtOnN0cmVhbT5cIik7XG4gICAgaWYgKHRoaXMud2Vic29ja2V0KVxuXHR0aGlzLndlYnNvY2tldC5jbG9zZSgpO1xufTtcblxuV1NDb25uZWN0aW9uLnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlKTtcbn07XG4iLCIoZnVuY3Rpb24oQnVmZmVyKXt2YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW07XG52YXIgRGVsYXllZFN0cmVhbSA9IHJlcXVpcmUoJ2RlbGF5ZWQtc3RyZWFtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tYmluZWRTdHJlYW07XG5mdW5jdGlvbiBDb21iaW5lZFN0cmVhbSgpIHtcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5kYXRhU2l6ZSA9IDA7XG4gIHRoaXMubWF4RGF0YVNpemUgPSAyICogMTAyNCAqIDEwMjQ7XG4gIHRoaXMucGF1c2VTdHJlYW1zID0gdHJ1ZTtcblxuICB0aGlzLl9yZWxlYXNlZCA9IGZhbHNlO1xuICB0aGlzLl9zdHJlYW1zID0gW107XG4gIHRoaXMuX2N1cnJlbnRTdHJlYW0gPSBudWxsO1xufVxudXRpbC5pbmhlcml0cyhDb21iaW5lZFN0cmVhbSwgU3RyZWFtKTtcblxuQ29tYmluZWRTdHJlYW0uY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgY29tYmluZWRTdHJlYW0gPSBuZXcgdGhpcygpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBmb3IgKHZhciBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgIGNvbWJpbmVkU3RyZWFtW29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gIH1cblxuICByZXR1cm4gY29tYmluZWRTdHJlYW07XG59O1xuXG5Db21iaW5lZFN0cmVhbS5pc1N0cmVhbUxpa2UgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgcmV0dXJuICh0eXBlb2Ygc3RyZWFtICE9PSAnZnVuY3Rpb24nKVxuICAgICYmICh0eXBlb2Ygc3RyZWFtICE9PSAnc3RyaW5nJylcbiAgICAmJiAodHlwZW9mIHN0cmVhbSAhPT0gJ2Jvb2xlYW4nKSAgICBcbiAgICAmJiAodHlwZW9mIHN0cmVhbSAhPT0gJ251bWJlcicpXG4gICAgJiYgKCFCdWZmZXIuaXNCdWZmZXIoc3RyZWFtKSk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHZhciBpc1N0cmVhbUxpa2UgPSBDb21iaW5lZFN0cmVhbS5pc1N0cmVhbUxpa2Uoc3RyZWFtKTtcblxuICBpZiAoaXNTdHJlYW1MaWtlKSB7XG4gICAgaWYgKCEoc3RyZWFtIGluc3RhbmNlb2YgRGVsYXllZFN0cmVhbSkpIHtcbiAgICAgIHN0cmVhbS5vbignZGF0YScsIHRoaXMuX2NoZWNrRGF0YVNpemUuYmluZCh0aGlzKSk7XG5cbiAgICAgIHN0cmVhbSA9IERlbGF5ZWRTdHJlYW0uY3JlYXRlKHN0cmVhbSwge1xuICAgICAgICBtYXhEYXRhU2l6ZTogSW5maW5pdHksXG4gICAgICAgIHBhdXNlU3RyZWFtOiB0aGlzLnBhdXNlU3RyZWFtcyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX2hhbmRsZUVycm9ycyhzdHJlYW0pO1xuXG4gICAgaWYgKHRoaXMucGF1c2VTdHJlYW1zKSB7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9zdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgU3RyZWFtLnByb3RvdHlwZS5waXBlLmNhbGwodGhpcywgZGVzdCwgb3B0aW9ucyk7XG4gIHRoaXMucmVzdW1lKCk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuX2dldE5leHQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY3VycmVudFN0cmVhbSA9IG51bGw7XG4gIHZhciBzdHJlYW0gPSB0aGlzLl9zdHJlYW1zLnNoaWZ0KCk7XG5cblxuICBpZiAodHlwZW9mIHN0cmVhbSA9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuZW5kKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzdHJlYW0gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9waXBlTmV4dChzdHJlYW0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBnZXRTdHJlYW0gPSBzdHJlYW07XG4gIGdldFN0cmVhbShmdW5jdGlvbihzdHJlYW0pIHtcbiAgICB2YXIgaXNTdHJlYW1MaWtlID0gQ29tYmluZWRTdHJlYW0uaXNTdHJlYW1MaWtlKHN0cmVhbSk7XG4gICAgaWYgKGlzU3RyZWFtTGlrZSkge1xuICAgICAgc3RyZWFtLm9uKCdkYXRhJywgdGhpcy5fY2hlY2tEYXRhU2l6ZS5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX2hhbmRsZUVycm9ycyhzdHJlYW0pO1xuICAgIH1cblxuICAgIHRoaXMuX3BpcGVOZXh0KHN0cmVhbSk7XG4gIH0uYmluZCh0aGlzKSk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuX3BpcGVOZXh0ID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHRoaXMuX2N1cnJlbnRTdHJlYW0gPSBzdHJlYW07XG5cbiAgdmFyIGlzU3RyZWFtTGlrZSA9IENvbWJpbmVkU3RyZWFtLmlzU3RyZWFtTGlrZShzdHJlYW0pO1xuICBpZiAoaXNTdHJlYW1MaWtlKSB7XG4gICAgc3RyZWFtLm9uKCdlbmQnLCB0aGlzLl9nZXROZXh0LmJpbmQodGhpcykpXG4gICAgc3RyZWFtLnBpcGUodGhpcywge2VuZDogZmFsc2V9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdmFsdWUgPSBzdHJlYW07XG4gIHRoaXMud3JpdGUodmFsdWUpO1xuICB0aGlzLl9nZXROZXh0KCk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuX2hhbmRsZUVycm9ycyA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICBzZWxmLl9lbWl0RXJyb3IoZXJyKTtcbiAgfSk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5wYXVzZVN0cmVhbXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fcmVsZWFzZWQpIHtcbiAgICB0aGlzLl9yZWxlYXNlZCA9IHRydWU7XG4gICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgdGhpcy5fZ2V0TmV4dCgpO1xuICB9XG5cbiAgdGhpcy5lbWl0KCdyZXN1bWUnKTtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcmVzZXQoKTtcbiAgdGhpcy5lbWl0KCdlbmQnKTtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3Jlc2V0KCk7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICB0aGlzLl9zdHJlYW1zID0gW107XG4gIHRoaXMuX2N1cnJlbnRTdHJlYW0gPSBudWxsO1xufTtcblxuQ29tYmluZWRTdHJlYW0ucHJvdG90eXBlLl9jaGVja0RhdGFTaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3VwZGF0ZURhdGFTaXplKCk7XG4gIGlmICh0aGlzLmRhdGFTaXplIDw9IHRoaXMubWF4RGF0YVNpemUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbWVzc2FnZSA9XG4gICAgJ0RlbGF5ZWRTdHJlYW0jbWF4RGF0YVNpemUgb2YgJyArIHRoaXMubWF4RGF0YVNpemUgKyAnIGJ5dGVzIGV4Y2VlZGVkLidcbiAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihtZXNzYWdlKSk7XG59O1xuXG5Db21iaW5lZFN0cmVhbS5wcm90b3R5cGUuX3VwZGF0ZURhdGFTaXplID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGF0YVNpemUgPSAwO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fc3RyZWFtcy5mb3JFYWNoKGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIGlmICghc3RyZWFtLmRhdGFTaXplKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi5kYXRhU2l6ZSArPSBzdHJlYW0uZGF0YVNpemU7XG4gIH0pO1xuXG4gIGlmICh0aGlzLl9jdXJyZW50U3RyZWFtICYmIHRoaXMuX2N1cnJlbnRTdHJlYW0uZGF0YVNpemUpIHtcbiAgICB0aGlzLmRhdGFTaXplICs9IHRoaXMuX2N1cnJlbnRTdHJlYW0uZGF0YVNpemU7XG4gIH1cbn07XG5cbkNvbWJpbmVkU3RyZWFtLnByb3RvdHlwZS5fZW1pdEVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gIHRoaXMuX3Jlc2V0KCk7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xufTtcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9idWZmZXJcIikuQnVmZmVyKSIsIi8vIExvYWQgbW9kdWxlc1xyXG5cclxudmFyIEJvb20gPSByZXF1aXJlKCdib29tJyk7XHJcbnZhciBIb2VrID0gcmVxdWlyZSgnaG9laycpO1xyXG52YXIgQ3J5cHRpbGVzID0gcmVxdWlyZSgnY3J5cHRpbGVzJyk7XHJcbnZhciBDcnlwdG8gPSByZXF1aXJlKCcuL2NyeXB0bycpO1xyXG52YXIgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcblxyXG5cclxuLy8gRGVjbGFyZSBpbnRlcm5hbHNcclxuXHJcbnZhciBpbnRlcm5hbHMgPSB7fTtcclxuXHJcblxyXG4vLyBIYXdrIGF1dGhlbnRpY2F0aW9uXHJcblxyXG4vKlxyXG4gICByZXE6ICAgICAgICAgICAgICAgICBub2RlJ3MgSFRUUCByZXF1ZXN0IG9iamVjdCBvciBhbiBvYmplY3QgYXMgZm9sbG93czpcclxuICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAnL3Jlc291cmNlLzQ/YT0xJmI9MicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0OiAnZXhhbXBsZS5jb20nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogODA4MCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb246ICdIYXdrIGlkPVwiZGgzN2ZnajQ5MmplXCIsIHRzPVwiMTM1MzgzMjIzNFwiLCBub25jZT1cImo0aDNnMlwiLCBleHQ9XCJzb21lLWFwcC1leHQtZGF0YVwiLCBtYWM9XCI2UjRyVjVpRStOUG95bStXd2plSHpqQUdYVXRMTkl4bW8xdnBNb2ZwTEFFPVwiJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gIFxyXG4gICBjcmVkZW50aWFsc0Z1bmM6ICAgICByZXF1aXJlZCBmdW5jdGlvbiB0byBsb29rdXAgdGhlIHNldCBvZiBIYXdrIGNyZWRlbnRpYWxzIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBjcmVkZW50aWFscyBpZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGNyZWRlbnRpYWxzIGluY2x1ZGUgdGhlIE1BQyBrZXksIE1BQyBhbGdvcml0aG0sIGFuZCBvdGhlciBhdHRyaWJ1dGVzIChzdWNoIGFzIHVzZXJuYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkZWQgYnkgdGhlIGFwcGxpY2F0aW9uLiBUaGlzIGZ1bmN0aW9uIGlzIHRoZSBlcXVpdmFsZW50IG9mIHZlcmlmeWluZyB0aGUgdXNlcm5hbWUgYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkIGluIEJhc2ljIGF1dGhlbnRpY2F0aW9uLlxyXG4gIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3JlZGVudGlhbHNGdW5jID0gZnVuY3Rpb24gKGlkLCBjYWxsYmFjaykge1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMb29rdXAgY3JlZGVudGlhbHMgaW4gZGF0YWJhc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLmxvb2t1cChpZCwgZnVuY3Rpb24gKGVyciwgaXRlbSkge1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyciB8fCAhaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3JlZGVudGlhbHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcXVpcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogaXRlbS5rZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsZ29yaXRobTogaXRlbS5hbGdvcml0aG0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGxpY2F0aW9uIHNwZWNpZmljXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXI6IGl0ZW0udXNlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgY3JlZGVudGlhbHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgXHJcbiAgIG9wdGlvbnM6IHtcclxuXHJcbiAgICAgICAgaG9zdEhlYWRlck5hbWU6ICAgICAgICBvcHRpb25hbCBoZWFkZXIgZmllbGQgbmFtZSwgdXNlZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCAnSG9zdCcgaGVhZGVyIHdoZW4gdXNlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVoaW5kIGEgY2FjaGUgb2YgYSBwcm94eS4gQXBhY2hlMiBjaGFuZ2VzIHRoZSB2YWx1ZSBvZiB0aGUgJ0hvc3QnIGhlYWRlciB3aGlsZSBwcmVzZXJ2aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgb3JpZ2luYWwgKHdoaWNoIGlzIHdoYXQgdGhlIG1vZHVsZSBtdXN0IHZlcmlmeSkgaW4gdGhlICd4LWZvcndhcmRlZC1ob3N0JyBoZWFkZXIgZmllbGQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IHVzZWQgd2hlbiBwYXNzZWQgYSBub2RlIEh0dHAuU2VydmVyUmVxdWVzdCBvYmplY3QuXHJcbiAgXHJcbiAgICAgICAgbm9uY2VGdW5jOiAgICAgICAgICAgICBvcHRpb25hbCBub25jZSB2YWxpZGF0aW9uIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gc2lnbmF0dXJlIGlzIGZ1bmN0aW9uKG5vbmNlLCB0cywgY2FsbGJhY2spXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVyZSAnY2FsbGJhY2snIG11c3QgYmUgY2FsbGVkIHVzaW5nIHRoZSBzaWduYXR1cmUgZnVuY3Rpb24oZXJyKS5cclxuICBcclxuICAgICAgICB0aW1lc3RhbXBTa2V3U2VjOiAgICAgIG9wdGlvbmFsIG51bWJlciBvZiBzZWNvbmRzIG9mIHBlcm1pdHRlZCBjbG9jayBza2V3IGZvciBpbmNvbWluZyB0aW1lc3RhbXBzLiBEZWZhdWx0cyB0byA2MCBzZWNvbmRzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvdmlkZXMgYSArLy0gc2tldyB3aGljaCBtZWFucyBhY3R1YWwgYWxsb3dlZCB3aW5kb3cgaXMgZG91YmxlIHRoZSBudW1iZXIgb2Ygc2Vjb25kcy5cclxuICBcclxuICAgICAgICBsb2NhbHRpbWVPZmZzZXRNc2VjOiAgIG9wdGlvbmFsIGxvY2FsIGNsb2NrIHRpbWUgb2Zmc2V0IGV4cHJlc3MgaW4gYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIChwb3NpdGl2ZSBvciBuZWdhdGl2ZSkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byAwLlxyXG4gIFxyXG4gICAgICAgIHBheWxvYWQ6ICAgICAgICAgICAgICAgb3B0aW9uYWwgcGF5bG9hZCBmb3IgdmFsaWRhdGlvbi4gVGhlIGNsaWVudCBjYWxjdWxhdGVzIHRoZSBoYXNoIHZhbHVlIGFuZCBpbmNsdWRlcyBpdCB2aWEgdGhlICdoYXNoJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyIGF0dHJpYnV0ZS4gVGhlIHNlcnZlciBhbHdheXMgZW5zdXJlcyB0aGUgdmFsdWUgcHJvdmlkZWQgaGFzIGJlZW4gaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1BQy4gV2hlbiB0aGlzIG9wdGlvbiBpcyBwcm92aWRlZCwgaXQgdmFsaWRhdGVzIHRoZSBoYXNoIHZhbHVlIGl0c2VsZi4gVmFsaWRhdGlvbiBpcyBkb25lIGJ5IGNhbGN1bGF0aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIGhhc2ggdmFsdWUgb3ZlciB0aGUgZW50aXJlIHBheWxvYWQgKGFzc3VtaW5nIGl0IGhhcyBhbHJlYWR5IGJlIG5vcm1hbGl6ZWQgdG8gdGhlIHNhbWUgZm9ybWF0IGFuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmcgdXNlZCBieSB0aGUgY2xpZW50IHRvIGNhbGN1bGF0ZSB0aGUgaGFzaCBvbiByZXF1ZXN0KS4gSWYgdGhlIHBheWxvYWQgaXMgbm90IGF2YWlsYWJsZSBhdCB0aGUgdGltZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgYXV0aGVudGljYXRpb24sIHRoZSBhdXRoZW50aWNhdGVQYXlsb2FkKCkgbWV0aG9kIGNhbiBiZSB1c2VkIGJ5IHBhc3NpbmcgaXQgdGhlIGNyZWRlbnRpYWxzIGFuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5oYXNoIHJldHVybmVkIGluIHRoZSBhdXRoZW50aWNhdGUgY2FsbGJhY2suXHJcbiAgICB9XHJcblxyXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChlcnIsIGNyZWRlbnRpYWxzLCBhcnRpZmFjdHMpIHsgfVxyXG4gKi9cclxuXHJcbmV4cG9ydHMuYXV0aGVudGljYXRlID0gZnVuY3Rpb24gKHJlcSwgY3JlZGVudGlhbHNGdW5jLCBvcHRpb25zLCBjYWxsYmFjaykge1xyXG5cclxuICAgIGNhbGxiYWNrID0gVXRpbHMubmV4dFRpY2soY2FsbGJhY2spO1xyXG4gICAgXHJcbiAgICAvLyBEZWZhdWx0IG9wdGlvbnNcclxuXHJcbiAgICBvcHRpb25zLm5vbmNlRnVuYyA9IG9wdGlvbnMubm9uY2VGdW5jIHx8IGZ1bmN0aW9uIChub25jZSwgdHMsIG5vbmNlQ2FsbGJhY2spIHsgcmV0dXJuIG5vbmNlQ2FsbGJhY2soKTsgfTsgICAvLyBObyB2YWxpZGF0aW9uXHJcbiAgICBvcHRpb25zLnRpbWVzdGFtcFNrZXdTZWMgPSBvcHRpb25zLnRpbWVzdGFtcFNrZXdTZWMgfHwgNjA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA2MCBzZWNvbmRzXHJcblxyXG4gICAgLy8gQXBwbGljYXRpb24gdGltZVxyXG5cclxuICAgIHZhciBub3cgPSBVdGlscy5ub3coKSArIChvcHRpb25zLmxvY2FsdGltZU9mZnNldE1zZWMgfHwgMCk7ICAgICAgICAgICAgICAgICAvLyBNZWFzdXJlIG5vdyBiZWZvcmUgYW55IG90aGVyIHByb2Nlc3NpbmdcclxuXHJcbiAgICAvLyBDb252ZXJ0IG5vZGUgSHR0cCByZXF1ZXN0IG9iamVjdCB0byBhIHJlcXVlc3QgY29uZmlndXJhdGlvbiBvYmplY3RcclxuXHJcbiAgICB2YXIgcmVxdWVzdCA9IFV0aWxzLnBhcnNlUmVxdWVzdChyZXEsIG9wdGlvbnMpO1xyXG4gICAgaWYgKHJlcXVlc3QgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhCb29tLmJhZFJlcXVlc3QocmVxdWVzdC5tZXNzYWdlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGFyc2UgSFRUUCBBdXRob3JpemF0aW9uIGhlYWRlclxyXG5cclxuICAgIHZhciBhdHRyaWJ1dGVzID0gVXRpbHMucGFyc2VBdXRob3JpemF0aW9uSGVhZGVyKHJlcXVlc3QuYXV0aG9yaXphdGlvbik7XHJcbiAgICBpZiAoYXR0cmlidXRlcyBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGF0dHJpYnV0ZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbnN0cnVjdCBhcnRpZmFjdHMgY29udGFpbmVyXHJcblxyXG4gICAgdmFyIGFydGlmYWN0cyA9IHtcclxuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxyXG4gICAgICAgIGhvc3Q6IHJlcXVlc3QuaG9zdCxcclxuICAgICAgICBwb3J0OiByZXF1ZXN0LnBvcnQsXHJcbiAgICAgICAgcmVzb3VyY2U6IHJlcXVlc3QudXJsLFxyXG4gICAgICAgIHRzOiBhdHRyaWJ1dGVzLnRzLFxyXG4gICAgICAgIG5vbmNlOiBhdHRyaWJ1dGVzLm5vbmNlLFxyXG4gICAgICAgIGhhc2g6IGF0dHJpYnV0ZXMuaGFzaCxcclxuICAgICAgICBleHQ6IGF0dHJpYnV0ZXMuZXh0LFxyXG4gICAgICAgIGFwcDogYXR0cmlidXRlcy5hcHAsXHJcbiAgICAgICAgZGxnOiBhdHRyaWJ1dGVzLmRsZyxcclxuICAgICAgICBtYWM6IGF0dHJpYnV0ZXMubWFjLFxyXG4gICAgICAgIGlkOiBhdHRyaWJ1dGVzLmlkXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFZlcmlmeSByZXF1aXJlZCBoZWFkZXIgYXR0cmlidXRlc1xyXG5cclxuICAgIGlmICghYXR0cmlidXRlcy5pZCB8fFxyXG4gICAgICAgICFhdHRyaWJ1dGVzLnRzIHx8XHJcbiAgICAgICAgIWF0dHJpYnV0ZXMubm9uY2UgfHxcclxuICAgICAgICAhYXR0cmlidXRlcy5tYWMpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEJvb20uYmFkUmVxdWVzdCgnTWlzc2luZyBhdHRyaWJ1dGVzJyksIG51bGwsIGFydGlmYWN0cyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmV0Y2ggSGF3ayBjcmVkZW50aWFsc1xyXG5cclxuICAgIGNyZWRlbnRpYWxzRnVuYyhhdHRyaWJ1dGVzLmlkLCBmdW5jdGlvbiAoZXJyLCBjcmVkZW50aWFscykge1xyXG5cclxuICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIGNyZWRlbnRpYWxzIHx8IG51bGwsIGFydGlmYWN0cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNyZWRlbnRpYWxzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhCb29tLnVuYXV0aG9yaXplZCgnVW5rbm93biBjcmVkZW50aWFscycsICdIYXdrJyksIG51bGwsIGFydGlmYWN0cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNyZWRlbnRpYWxzLmtleSB8fFxyXG4gICAgICAgICAgICAhY3JlZGVudGlhbHMuYWxnb3JpdGhtKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soQm9vbS5pbnRlcm5hbCgnSW52YWxpZCBjcmVkZW50aWFscycpLCBjcmVkZW50aWFscywgYXJ0aWZhY3RzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChDcnlwdG8uYWxnb3JpdGhtcy5pbmRleE9mKGNyZWRlbnRpYWxzLmFsZ29yaXRobSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhCb29tLmludGVybmFsKCdVbmtub3duIGFsZ29yaXRobScpLCBjcmVkZW50aWFscywgYXJ0aWZhY3RzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBNQUNcclxuXHJcbiAgICAgICAgdmFyIG1hYyA9IENyeXB0by5jYWxjdWxhdGVNYWMoJ2hlYWRlcicsIGNyZWRlbnRpYWxzLCBhcnRpZmFjdHMpO1xyXG4gICAgICAgIGlmICghQ3J5cHRpbGVzLmZpeGVkVGltZUNvbXBhcmlzb24obWFjLCBhdHRyaWJ1dGVzLm1hYykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEJvb20udW5hdXRob3JpemVkKCdCYWQgbWFjJywgJ0hhd2snKSwgY3JlZGVudGlhbHMsIGFydGlmYWN0cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBwYXlsb2FkIGhhc2hcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMucGF5bG9hZCAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICBvcHRpb25zLnBheWxvYWQgIT09IHVuZGVmaW5lZCkgeyAgICAgICAvLyAnJyBpcyB2YWxpZFxyXG5cclxuICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLmhhc2gpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhCb29tLnVuYXV0aG9yaXplZCgnTWlzc2luZyByZXF1aXJlZCBwYXlsb2FkIGhhc2gnLCAnSGF3aycpLCBjcmVkZW50aWFscywgYXJ0aWZhY3RzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGhhc2ggPSBDcnlwdG8uY2FsY3VsYXRlUGF5bG9hZEhhc2gob3B0aW9ucy5wYXlsb2FkLCBjcmVkZW50aWFscy5hbGdvcml0aG0sIHJlcXVlc3QuY29udGVudFR5cGUpO1xyXG4gICAgICAgICAgICBpZiAoIUNyeXB0aWxlcy5maXhlZFRpbWVDb21wYXJpc29uKGhhc2gsIGF0dHJpYnV0ZXMuaGFzaCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhCb29tLnVuYXV0aG9yaXplZCgnQmFkIHBheWxvYWQgaGFzaCcsICdIYXdrJyksIGNyZWRlbnRpYWxzLCBhcnRpZmFjdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBub25jZVxyXG5cclxuICAgICAgICBvcHRpb25zLm5vbmNlRnVuYyhhdHRyaWJ1dGVzLm5vbmNlLCBhdHRyaWJ1dGVzLnRzLCBmdW5jdGlvbiAoZXJyKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soQm9vbS51bmF1dGhvcml6ZWQoJ0ludmFsaWQgbm9uY2UnLCAnSGF3aycpLCBjcmVkZW50aWFscywgYXJ0aWZhY3RzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgdGltZXN0YW1wIHN0YWxlbmVzc1xyXG5cclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKChhdHRyaWJ1dGVzLnRzICogMTAwMCkgLSBub3cpID4gKG9wdGlvbnMudGltZXN0YW1wU2tld1NlYyAqIDEwMDApKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJlc2ggPSBNYXRoLmZsb29yKChVdGlscy5ub3coKSArIChvcHRpb25zLmxvY2FsdGltZU9mZnNldE1zZWMgfHwgMCkpIC8gMTAwMCk7ICAgICAgICAgICAgLy8gR2V0IGZyZXNoIG5vd1xyXG4gICAgICAgICAgICAgICAgdmFyIHRzbSA9IENyeXB0by5jYWxjdWxhdGVUc01hYyhmcmVzaCwgY3JlZGVudGlhbHMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEJvb20udW5hdXRob3JpemVkKCdTdGFsZSB0aW1lc3RhbXAnLCAnSGF3aycsIHsgdHM6IGZyZXNoLCB0c206IHRzbSB9KSwgY3JlZGVudGlhbHMsIGFydGlmYWN0cyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFN1Y2Nlc3NmdWwgYXV0aGVudGljYXRpb25cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBjcmVkZW50aWFscywgYXJ0aWZhY3RzKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuXHJcbi8vIEF1dGhlbnRpY2F0ZSBwYXlsb2FkIGhhc2ggLSB1c2VkIHdoZW4gcGF5bG9hZCBjYW5ub3QgYmUgcHJvdmlkZWQgZHVyaW5nIGF1dGhlbnRpY2F0ZSgpXHJcblxyXG4vKlxyXG4gICAgcGF5bG9hZDogICAgICAgIHJhdyByZXF1ZXN0IHBheWxvYWRcclxuICAgIGNyZWRlbnRpYWxzOiAgICBmcm9tIGF1dGhlbnRpY2F0ZSBjYWxsYmFja1xyXG4gICAgYXJ0aWZhY3RzOiAgICAgIGZyb20gYXV0aGVudGljYXRlIGNhbGxiYWNrXHJcbiAgICBjb250ZW50VHlwZTogICAgcmVxLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXHJcbiovXHJcblxyXG5leHBvcnRzLmF1dGhlbnRpY2F0ZVBheWxvYWQgPSBmdW5jdGlvbiAocGF5bG9hZCwgY3JlZGVudGlhbHMsIGFydGlmYWN0cywgY29udGVudFR5cGUpIHtcclxuXHJcbiAgICB2YXIgY2FsY3VsYXRlZEhhc2ggPSBDcnlwdG8uY2FsY3VsYXRlUGF5bG9hZEhhc2gocGF5bG9hZCwgY3JlZGVudGlhbHMuYWxnb3JpdGhtLCBjb250ZW50VHlwZSk7XHJcbiAgICByZXR1cm4gQ3J5cHRpbGVzLmZpeGVkVGltZUNvbXBhcmlzb24oY2FsY3VsYXRlZEhhc2gsIGFydGlmYWN0cy5oYXNoKTtcclxufTtcclxuXHJcblxyXG4vLyBHZW5lcmF0ZSBhIFNlcnZlci1BdXRob3JpemF0aW9uIGhlYWRlciBmb3IgYSBnaXZlbiByZXNwb25zZVxyXG5cclxuLypcclxuICAgIGNyZWRlbnRpYWxzOiB7fSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2JqZWN0IHJlY2VpdmVkIGZyb20gYXV0aGVudGljYXRlKClcclxuICAgIGFydGlmYWN0czoge30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2JqZWN0IHJlY2VpdmVkIGZyb20gYXV0aGVudGljYXRlKCk7ICdtYWMnLCAnaGFzaCcsIGFuZCAnZXh0JyAtIGlnbm9yZWRcclxuICAgIG9wdGlvbnM6IHtcclxuICAgICAgICBleHQ6ICdhcHBsaWNhdGlvbi1zcGVjaWZpYycsICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbGljYXRpb24gc3BlY2lmaWMgZGF0YSBzZW50IHZpYSB0aGUgZXh0IGF0dHJpYnV0ZVxyXG4gICAgICAgIHBheWxvYWQ6ICd7XCJzb21lXCI6XCJwYXlsb2FkXCJ9JywgICAgICAgICAgICAgICAgICAgICAgLy8gVVRGLTggZW5jb2RlZCBzdHJpbmcgZm9yIGJvZHkgaGFzaCBnZW5lcmF0aW9uIChpZ25vcmVkIGlmIGhhc2ggcHJvdmlkZWQpXHJcbiAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJywgICAgICAgICAgICAgICAgICAgIC8vIFBheWxvYWQgY29udGVudC10eXBlIChpZ25vcmVkIGlmIGhhc2ggcHJvdmlkZWQpXHJcbiAgICAgICAgaGFzaDogJ1U0TUtLU21pVnhrMzdKQ0NyQVZJalY9JyAgICAgICAgICAgICAgICAgICAgIC8vIFByZS1jYWxjdWxhdGVkIHBheWxvYWQgaGFzaFxyXG4gICAgfVxyXG4qL1xyXG5cclxuZXhwb3J0cy5oZWFkZXIgPSBmdW5jdGlvbiAoY3JlZGVudGlhbHMsIGFydGlmYWN0cywgb3B0aW9ucykge1xyXG5cclxuICAgIC8vIFByZXBhcmUgaW5wdXRzXHJcblxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgaWYgKCFhcnRpZmFjdHMgfHxcclxuICAgICAgICB0eXBlb2YgYXJ0aWZhY3RzICE9PSAnb2JqZWN0JyB8fFxyXG4gICAgICAgIHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgYXJ0aWZhY3RzID0gSG9lay5jbG9uZShhcnRpZmFjdHMpO1xyXG4gICAgZGVsZXRlIGFydGlmYWN0cy5tYWM7XHJcbiAgICBhcnRpZmFjdHMuaGFzaCA9IG9wdGlvbnMuaGFzaDtcclxuICAgIGFydGlmYWN0cy5leHQgPSBvcHRpb25zLmV4dDtcclxuXHJcbiAgICAvLyBWYWxpZGF0ZSBjcmVkZW50aWFsc1xyXG5cclxuICAgIGlmICghY3JlZGVudGlhbHMgfHxcclxuICAgICAgICAhY3JlZGVudGlhbHMua2V5IHx8XHJcbiAgICAgICAgIWNyZWRlbnRpYWxzLmFsZ29yaXRobSkge1xyXG5cclxuICAgICAgICAvLyBJbnZhbGlkIGNyZWRlbnRpYWwgb2JqZWN0XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChDcnlwdG8uYWxnb3JpdGhtcy5pbmRleE9mKGNyZWRlbnRpYWxzLmFsZ29yaXRobSkgPT09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBwYXlsb2FkIGhhc2hcclxuXHJcbiAgICBpZiAoIWFydGlmYWN0cy5oYXNoICYmXHJcbiAgICAgICAgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgncGF5bG9hZCcpKSB7XHJcblxyXG4gICAgICAgIGFydGlmYWN0cy5oYXNoID0gQ3J5cHRvLmNhbGN1bGF0ZVBheWxvYWRIYXNoKG9wdGlvbnMucGF5bG9hZCwgY3JlZGVudGlhbHMuYWxnb3JpdGhtLCBvcHRpb25zLmNvbnRlbnRUeXBlKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbWFjID0gQ3J5cHRvLmNhbGN1bGF0ZU1hYygncmVzcG9uc2UnLCBjcmVkZW50aWFscywgYXJ0aWZhY3RzKTtcclxuXHJcbiAgICAvLyBDb25zdHJ1Y3QgaGVhZGVyXHJcblxyXG4gICAgdmFyIGhlYWRlciA9ICdIYXdrIG1hYz1cIicgKyBtYWMgKyAnXCInICtcclxuICAgICAgICAgICAgICAgICAoYXJ0aWZhY3RzLmhhc2ggPyAnLCBoYXNoPVwiJyArIGFydGlmYWN0cy5oYXNoICsgJ1wiJyA6ICcnKTtcclxuXHJcbiAgICBpZiAoYXJ0aWZhY3RzLmV4dCAhPT0gbnVsbCAmJlxyXG4gICAgICAgIGFydGlmYWN0cy5leHQgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgIGFydGlmYWN0cy5leHQgIT09ICcnKSB7ICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlciBmYWxzZXkgdmFsdWVzIGFsbG93ZWRcclxuXHJcbiAgICAgICAgaGVhZGVyICs9ICcsIGV4dD1cIicgKyBVdGlscy5lc2NhcGVIZWFkZXJBdHRyaWJ1dGUoYXJ0aWZhY3RzLmV4dCkgKyAnXCInO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBoZWFkZXI7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogQXJndW1lbnRzIGFuZCBvcHRpb25zIGFyZSB0aGUgc2FtZSBhcyBpbmRleC5qcyB3aXRoIHRoZSBleGNlcHRpb24gdGhhdCB0aGUgb25seSBzdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XHJcbiAqICdob3N0SGVhZGVyTmFtZScsICdsb2NhbHRpbWVPZmZzZXRNc2VjJ1xyXG4gKi9cclxuXHJcbmV4cG9ydHMuYXV0aGVudGljYXRlQmV3aXQgPSBmdW5jdGlvbiAocmVxLCBjcmVkZW50aWFsc0Z1bmMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcblxyXG4gICAgY2FsbGJhY2sgPSBVdGlscy5uZXh0VGljayhjYWxsYmFjayk7XHJcblxyXG4gICAgLy8gQXBwbGljYXRpb24gdGltZVxyXG5cclxuICAgIHZhciBub3cgPSBVdGlscy5ub3coKSArIChvcHRpb25zLmxvY2FsdGltZU9mZnNldE1zZWMgfHwgMCk7XHJcblxyXG4gICAgLy8gQ29udmVydCBub2RlIEh0dHAgcmVxdWVzdCBvYmplY3QgdG8gYSByZXF1ZXN0IGNvbmZpZ3VyYXRpb24gb2JqZWN0XHJcblxyXG4gICAgdmFyIHJlcXVlc3QgPSBVdGlscy5wYXJzZVJlcXVlc3QocmVxLCBvcHRpb25zKTtcclxuICAgIGlmIChyZXF1ZXN0IGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gY2FsbGJhY2soQm9vbS5iYWRSZXF1ZXN0KHJlcXVlc3QubWVzc2FnZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4dHJhY3QgYmV3aXRcclxuXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEgICAgIDIgICAgICAgICAgICAgMyAgICAgICAgICAgNCAgICAgXHJcbiAgICB2YXIgcmVzb3VyY2UgPSByZXF1ZXN0LnVybC5tYXRjaCgvXihcXC8uKikoW1xcPyZdKWJld2l0XFw9KFteJiRdKikoPzomKC4rKSk/JC8pO1xyXG4gICAgaWYgKCFyZXNvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhCb29tLnVuYXV0aG9yaXplZChudWxsLCAnSGF3aycpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBCZXdpdCBub3QgZW1wdHlcclxuXHJcbiAgICBpZiAoIXJlc291cmNlWzNdKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEJvb20udW5hdXRob3JpemVkKCdFbXB0eSBiZXdpdCcsICdIYXdrJykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFZlcmlmeSBtZXRob2QgaXMgR0VUXHJcblxyXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSAnR0VUJyAmJlxyXG4gICAgICAgIHJlcXVlc3QubWV0aG9kICE9PSAnSEVBRCcpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEJvb20udW5hdXRob3JpemVkKCdJbnZhbGlkIG1ldGhvZCcsICdIYXdrJykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vIG90aGVyIGF1dGhlbnRpY2F0aW9uXHJcblxyXG4gICAgaWYgKHJlcXVlc3QuYXV0aG9yaXphdGlvbikge1xyXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhCb29tLmJhZFJlcXVlc3QoJ011bHRpcGxlIGF1dGhlbnRpY2F0aW9ucycsICdIYXdrJykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBhcnNlIGJld2l0XHJcblxyXG4gICAgdmFyIGJld2l0U3RyaW5nID0gVXRpbHMuYmFzZTY0dXJsRGVjb2RlKHJlc291cmNlWzNdKTtcclxuICAgIGlmIChiZXdpdFN0cmluZyBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEJvb20uYmFkUmVxdWVzdCgnSW52YWxpZCBiZXdpdCBlbmNvZGluZycpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBCZXdpdCBmb3JtYXQ6IGlkXFxleHBcXG1hY1xcZXh0ICgnXFwnIGlzIHVzZWQgYmVjYXVzZSBpdCBpcyBhIHJlc2VydmVkIGhlYWRlciBhdHRyaWJ1dGUgY2hhcmFjdGVyKVxyXG5cclxuICAgIHZhciBiZXdpdFBhcnRzID0gYmV3aXRTdHJpbmcuc3BsaXQoJ1xcXFwnKTtcclxuICAgIGlmICghYmV3aXRQYXJ0cyB8fFxyXG4gICAgICAgIGJld2l0UGFydHMubGVuZ3RoICE9PSA0KSB7XHJcblxyXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhCb29tLmJhZFJlcXVlc3QoJ0ludmFsaWQgYmV3aXQgc3RydWN0dXJlJykpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBiZXdpdCA9IHtcclxuICAgICAgICBpZDogYmV3aXRQYXJ0c1swXSxcclxuICAgICAgICBleHA6IHBhcnNlSW50KGJld2l0UGFydHNbMV0sIDEwKSxcclxuICAgICAgICBtYWM6IGJld2l0UGFydHNbMl0sXHJcbiAgICAgICAgZXh0OiBiZXdpdFBhcnRzWzNdIHx8ICcnXHJcbiAgICB9O1xyXG5cclxuICAgIGlmICghYmV3aXQuaWQgfHxcclxuICAgICAgICAhYmV3aXQuZXhwIHx8XHJcbiAgICAgICAgIWJld2l0Lm1hYykge1xyXG5cclxuICAgICAgICByZXR1cm4gY2FsbGJhY2soQm9vbS5iYWRSZXF1ZXN0KCdNaXNzaW5nIGJld2l0IGF0dHJpYnV0ZXMnKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29uc3RydWN0IFVSTCB3aXRob3V0IGJld2l0XHJcblxyXG4gICAgdmFyIHVybCA9IHJlc291cmNlWzFdO1xyXG4gICAgaWYgKHJlc291cmNlWzRdKSB7XHJcbiAgICAgICAgdXJsICs9IHJlc291cmNlWzJdICsgcmVzb3VyY2VbNF07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgZXhwaXJhdGlvblxyXG5cclxuICAgIGlmIChiZXdpdC5leHAgKiAxMDAwIDw9IG5vdykge1xyXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhCb29tLnVuYXV0aG9yaXplZCgnQWNjZXNzIGV4cGlyZWQnLCAnSGF3aycpLCBudWxsLCBiZXdpdCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmV0Y2ggSGF3ayBjcmVkZW50aWFsc1xyXG5cclxuICAgIGNyZWRlbnRpYWxzRnVuYyhiZXdpdC5pZCwgZnVuY3Rpb24gKGVyciwgY3JlZGVudGlhbHMpIHtcclxuXHJcbiAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBjcmVkZW50aWFscyB8fCBudWxsLCBiZXdpdC5leHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFjcmVkZW50aWFscykge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soQm9vbS51bmF1dGhvcml6ZWQoJ1Vua25vd24gY3JlZGVudGlhbHMnLCAnSGF3aycpLCBudWxsLCBiZXdpdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNyZWRlbnRpYWxzLmtleSB8fFxyXG4gICAgICAgICAgICAhY3JlZGVudGlhbHMuYWxnb3JpdGhtKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soQm9vbS5pbnRlcm5hbCgnSW52YWxpZCBjcmVkZW50aWFscycpLCBjcmVkZW50aWFscywgYmV3aXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKENyeXB0by5hbGdvcml0aG1zLmluZGV4T2YoY3JlZGVudGlhbHMuYWxnb3JpdGhtKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEJvb20uaW50ZXJuYWwoJ1Vua25vd24gYWxnb3JpdGhtJyksIGNyZWRlbnRpYWxzLCBiZXdpdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgTUFDXHJcblxyXG4gICAgICAgIHZhciBtYWMgPSBDcnlwdG8uY2FsY3VsYXRlTWFjKCdiZXdpdCcsIGNyZWRlbnRpYWxzLCB7XHJcbiAgICAgICAgICAgIHRzOiBiZXdpdC5leHAsXHJcbiAgICAgICAgICAgIG5vbmNlOiAnJyxcclxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICAgICAgcmVzb3VyY2U6IHVybCxcclxuICAgICAgICAgICAgaG9zdDogcmVxdWVzdC5ob3N0LFxyXG4gICAgICAgICAgICBwb3J0OiByZXF1ZXN0LnBvcnQsXHJcbiAgICAgICAgICAgIGV4dDogYmV3aXQuZXh0XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmICghQ3J5cHRpbGVzLmZpeGVkVGltZUNvbXBhcmlzb24obWFjLCBiZXdpdC5tYWMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhCb29tLnVuYXV0aG9yaXplZCgnQmFkIG1hYycsICdIYXdrJyksIGNyZWRlbnRpYWxzLCBiZXdpdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdWNjZXNzZnVsIGF1dGhlbnRpY2F0aW9uXHJcblxyXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBjcmVkZW50aWFscywgYmV3aXQpO1xyXG4gICAgfSk7XHJcbn07XHJcbiIsIi8vIExvYWQgbW9kdWxlc1xyXG5cclxudmFyIFVybCA9IHJlcXVpcmUoJ3VybCcpO1xyXG52YXIgSG9layA9IHJlcXVpcmUoJ2hvZWsnKTtcclxudmFyIENyeXB0aWxlcyA9IHJlcXVpcmUoJ2NyeXB0aWxlcycpO1xyXG52YXIgQ3J5cHRvID0gcmVxdWlyZSgnLi9jcnlwdG8nKTtcclxudmFyIFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xyXG5cclxuXHJcbi8vIERlY2xhcmUgaW50ZXJuYWxzXHJcblxyXG52YXIgaW50ZXJuYWxzID0ge307XHJcblxyXG5cclxuLy8gR2VuZXJhdGUgYW4gQXV0aG9yaXphdGlvbiBoZWFkZXIgZm9yIGEgZ2l2ZW4gcmVxdWVzdFxyXG5cclxuLypcclxuICAgIHVyaTogJ2h0dHA6Ly9leGFtcGxlLmNvbS9yZXNvdXJjZT9hPWInIG9yIG9iamVjdCBmcm9tIFVybC5wYXJzZSgpXHJcbiAgICBtZXRob2Q6IEhUVFAgdmVyYiAoZS5nLiAnR0VUJywgJ1BPU1QnKVxyXG4gICAgb3B0aW9uczoge1xyXG5cclxuICAgICAgICAvLyBSZXF1aXJlZFxyXG5cclxuICAgICAgICBjcmVkZW50aWFsczoge1xyXG4gICAgICAgICAgICBpZDogJ2RoMzdmZ2o0OTJqZScsXHJcbiAgICAgICAgICAgIGtleTogJ2FvaWplZG9haWpzZGxha3NqZGwnLFxyXG4gICAgICAgICAgICBhbGdvcml0aG06ICdzaGEyNTYnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ3NoYTEnLCAnc2hhMjU2J1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIE9wdGlvbmFsXHJcblxyXG4gICAgICAgIGV4dDogJ2FwcGxpY2F0aW9uLXNwZWNpZmljJywgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBsaWNhdGlvbiBzcGVjaWZpYyBkYXRhIHNlbnQgdmlhIHRoZSBleHQgYXR0cmlidXRlXHJcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgcHJlLWNhbGN1bGF0ZWQgdGltZXN0YW1wXHJcbiAgICAgICAgbm9uY2U6ICcyMzM0ZjM0ZicsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgcHJlLWdlbmVyYXRlZCBub25jZVxyXG4gICAgICAgIGxvY2FsdGltZU9mZnNldE1zZWM6IDQwMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaW1lIG9mZnNldCB0byBzeW5jIHdpdGggc2VydmVyIHRpbWUgKGlnbm9yZWQgaWYgdGltZXN0YW1wIHByb3ZpZGVkKVxyXG4gICAgICAgIHBheWxvYWQ6ICd7XCJzb21lXCI6XCJwYXlsb2FkXCJ9JywgICAgICAgICAgICAgICAgICAgICAgLy8gVVRGLTggZW5jb2RlZCBzdHJpbmcgZm9yIGJvZHkgaGFzaCBnZW5lcmF0aW9uIChpZ25vcmVkIGlmIGhhc2ggcHJvdmlkZWQpXHJcbiAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJywgICAgICAgICAgICAgICAgICAgIC8vIFBheWxvYWQgY29udGVudC10eXBlIChpZ25vcmVkIGlmIGhhc2ggcHJvdmlkZWQpXHJcbiAgICAgICAgaGFzaDogJ1U0TUtLU21pVnhrMzdKQ0NyQVZJalY9JywgICAgICAgICAgICAgICAgICAgIC8vIFByZS1jYWxjdWxhdGVkIHBheWxvYWQgaGFzaFxyXG4gICAgICAgIGFwcDogJzI0czIzNDIzZjM0ZHgnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPeiBhcHBsaWNhdGlvbiBpZFxyXG4gICAgICAgIGRsZzogJzIzNHN6MzR0d3czc2QnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPeiBkZWxlZ2F0ZWQtYnkgYXBwbGljYXRpb24gaWRcclxuICAgIH1cclxuKi9cclxuXHJcbmV4cG9ydHMuaGVhZGVyID0gZnVuY3Rpb24gKHVyaSwgbWV0aG9kLCBvcHRpb25zKSB7XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICBmaWVsZDogJycsXHJcbiAgICAgICAgYXJ0aWZhY3RzOiB7fVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBWYWxpZGF0ZSBpbnB1dHNcclxuXHJcbiAgICBpZiAoIXVyaSB8fCAodHlwZW9mIHVyaSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHVyaSAhPT0gJ29iamVjdCcpIHx8XHJcbiAgICAgICAgIW1ldGhvZCB8fCB0eXBlb2YgbWV0aG9kICE9PSAnc3RyaW5nJyB8fFxyXG4gICAgICAgICFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFwcGxpY2F0aW9uIHRpbWVcclxuXHJcbiAgICB2YXIgdGltZXN0YW1wID0gb3B0aW9ucy50aW1lc3RhbXAgfHwgTWF0aC5mbG9vcigoVXRpbHMubm93KCkgKyAob3B0aW9ucy5sb2NhbHRpbWVPZmZzZXRNc2VjIHx8IDApKSAvIDEwMDApXHJcblxyXG4gICAgLy8gVmFsaWRhdGUgY3JlZGVudGlhbHNcclxuXHJcbiAgICB2YXIgY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzO1xyXG4gICAgaWYgKCFjcmVkZW50aWFscyB8fFxyXG4gICAgICAgICFjcmVkZW50aWFscy5pZCB8fFxyXG4gICAgICAgICFjcmVkZW50aWFscy5rZXkgfHxcclxuICAgICAgICAhY3JlZGVudGlhbHMuYWxnb3JpdGhtKSB7XHJcblxyXG4gICAgICAgIC8vIEludmFsaWQgY3JlZGVudGlhbCBvYmplY3RcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChDcnlwdG8uYWxnb3JpdGhtcy5pbmRleE9mKGNyZWRlbnRpYWxzLmFsZ29yaXRobSkgPT09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQYXJzZSBVUklcclxuXHJcbiAgICBpZiAodHlwZW9mIHVyaSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB1cmkgPSBVcmwucGFyc2UodXJpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgc2lnbmF0dXJlXHJcblxyXG4gICAgdmFyIGFydGlmYWN0cyA9IHtcclxuICAgICAgICB0czogdGltZXN0YW1wLFxyXG4gICAgICAgIG5vbmNlOiBvcHRpb25zLm5vbmNlIHx8IENyeXB0aWxlcy5yYW5kb21TdHJpbmcoNiksXHJcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXHJcbiAgICAgICAgcmVzb3VyY2U6IHVyaS5wYXRobmFtZSArICh1cmkuc2VhcmNoIHx8ICcnKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFpbnRhaW4gdHJhaWxpbmcgJz8nXHJcbiAgICAgICAgaG9zdDogdXJpLmhvc3RuYW1lLFxyXG4gICAgICAgIHBvcnQ6IHVyaS5wb3J0IHx8ICh1cmkucHJvdG9jb2wgPT09ICdodHRwOicgPyA4MCA6IDQ0MyksXHJcbiAgICAgICAgaGFzaDogb3B0aW9ucy5oYXNoLFxyXG4gICAgICAgIGV4dDogb3B0aW9ucy5leHQsXHJcbiAgICAgICAgYXBwOiBvcHRpb25zLmFwcCxcclxuICAgICAgICBkbGc6IG9wdGlvbnMuZGxnXHJcbiAgICB9O1xyXG5cclxuICAgIHJlc3VsdC5hcnRpZmFjdHMgPSBhcnRpZmFjdHM7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHBheWxvYWQgaGFzaFxyXG5cclxuICAgIGlmICghYXJ0aWZhY3RzLmhhc2ggJiZcclxuICAgICAgICBvcHRpb25zLmhhc093blByb3BlcnR5KCdwYXlsb2FkJykpIHtcclxuXHJcbiAgICAgICAgYXJ0aWZhY3RzLmhhc2ggPSBDcnlwdG8uY2FsY3VsYXRlUGF5bG9hZEhhc2gob3B0aW9ucy5wYXlsb2FkLCBjcmVkZW50aWFscy5hbGdvcml0aG0sIG9wdGlvbnMuY29udGVudFR5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBtYWMgPSBDcnlwdG8uY2FsY3VsYXRlTWFjKCdoZWFkZXInLCBjcmVkZW50aWFscywgYXJ0aWZhY3RzKTtcclxuXHJcbiAgICAvLyBDb25zdHJ1Y3QgaGVhZGVyXHJcblxyXG4gICAgdmFyIGhhc0V4dCA9IGFydGlmYWN0cy5leHQgIT09IG51bGwgJiYgYXJ0aWZhY3RzLmV4dCAhPT0gdW5kZWZpbmVkICYmIGFydGlmYWN0cy5leHQgIT09ICcnOyAgICAgICAvLyBPdGhlciBmYWxzZXkgdmFsdWVzIGFsbG93ZWRcclxuICAgIHZhciBoZWFkZXIgPSAnSGF3ayBpZD1cIicgKyBjcmVkZW50aWFscy5pZCArXHJcbiAgICAgICAgICAgICAgICAgJ1wiLCB0cz1cIicgKyBhcnRpZmFjdHMudHMgK1xyXG4gICAgICAgICAgICAgICAgICdcIiwgbm9uY2U9XCInICsgYXJ0aWZhY3RzLm5vbmNlICtcclxuICAgICAgICAgICAgICAgICAoYXJ0aWZhY3RzLmhhc2ggPyAnXCIsIGhhc2g9XCInICsgYXJ0aWZhY3RzLmhhc2ggOiAnJykgK1xyXG4gICAgICAgICAgICAgICAgIChoYXNFeHQgPyAnXCIsIGV4dD1cIicgKyBVdGlscy5lc2NhcGVIZWFkZXJBdHRyaWJ1dGUoYXJ0aWZhY3RzLmV4dCkgOiAnJykgK1xyXG4gICAgICAgICAgICAgICAgICdcIiwgbWFjPVwiJyArIG1hYyArICdcIic7XHJcblxyXG4gICAgaWYgKGFydGlmYWN0cy5hcHApIHtcclxuICAgICAgICBoZWFkZXIgKz0gJywgYXBwPVwiJyArIGFydGlmYWN0cy5hcHAgK1xyXG4gICAgICAgICAgICAgICAgICAoYXJ0aWZhY3RzLmRsZyA/ICdcIiwgZGxnPVwiJyArIGFydGlmYWN0cy5kbGcgOiAnJykgKyAnXCInO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc3VsdC5maWVsZCA9IGhlYWRlcjtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuXHJcbi8vIFZhbGlkYXRlIHNlcnZlciByZXNwb25zZVxyXG5cclxuLypcclxuICAgIHJlczogICAgICAgIG5vZGUncyByZXNwb25zZSBvYmplY3RcclxuICAgIGFydGlmYWN0czogIG9iamVjdCByZWNpZXZlZCBmcm9tIGhlYWRlcigpLmFydGlmYWN0c1xyXG4gICAgb3B0aW9uczoge1xyXG4gICAgICAgIHBheWxvYWQ6ICAgIG9wdGlvbmFsIHBheWxvYWQgcmVjZWl2ZWRcclxuICAgICAgICByZXF1aXJlZDogICBzcGVjaWZpZXMgaWYgYSBTZXJ2ZXItQXV0aG9yaXphdGlvbiBoZWFkZXIgaXMgcmVxdWlyZWQuIERlZmF1bHRzIHRvICdmYWxzZSdcclxuICAgIH1cclxuKi9cclxuXHJcbmV4cG9ydHMuYXV0aGVudGljYXRlID0gZnVuY3Rpb24gKHJlcywgY3JlZGVudGlhbHMsIGFydGlmYWN0cywgb3B0aW9ucykge1xyXG5cclxuICAgIGFydGlmYWN0cyA9IEhvZWsuY2xvbmUoYXJ0aWZhY3RzKTtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIGlmIChyZXMuaGVhZGVyc1snd3d3LWF1dGhlbnRpY2F0ZSddKSB7XHJcblxyXG4gICAgICAgIC8vIFBhcnNlIEhUVFAgV1dXLUF1dGhlbnRpY2F0ZSBoZWFkZXJcclxuXHJcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBVdGlscy5wYXJzZUF1dGhvcml6YXRpb25IZWFkZXIocmVzLmhlYWRlcnNbJ3d3dy1hdXRoZW50aWNhdGUnXSwgWyd0cycsICd0c20nLCAnZXJyb3InXSk7XHJcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYXR0cmlidXRlcy50cykge1xyXG4gICAgICAgICAgICB2YXIgdHNtID0gQ3J5cHRvLmNhbGN1bGF0ZVRzTWFjKGF0dHJpYnV0ZXMudHMsIGNyZWRlbnRpYWxzKTtcclxuICAgICAgICAgICAgaWYgKHRzbSAhPT0gYXR0cmlidXRlcy50c20pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBQYXJzZSBIVFRQIFNlcnZlci1BdXRob3JpemF0aW9uIGhlYWRlclxyXG5cclxuICAgIGlmICghcmVzLmhlYWRlcnNbJ3NlcnZlci1hdXRob3JpemF0aW9uJ10gJiZcclxuICAgICAgICAhb3B0aW9ucy5yZXF1aXJlZCkge1xyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYXR0cmlidXRlcyA9IFV0aWxzLnBhcnNlQXV0aG9yaXphdGlvbkhlYWRlcihyZXMuaGVhZGVyc1snc2VydmVyLWF1dGhvcml6YXRpb24nXSwgWydtYWMnLCAnZXh0JywgJ2hhc2gnXSk7XHJcbiAgICBpZiAoYXR0cmlidXRlcyBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGFydGlmYWN0cy5leHQgPSBhdHRyaWJ1dGVzLmV4dDtcclxuICAgIGFydGlmYWN0cy5oYXNoID0gYXR0cmlidXRlcy5oYXNoO1xyXG5cclxuICAgIHZhciBtYWMgPSBDcnlwdG8uY2FsY3VsYXRlTWFjKCdyZXNwb25zZScsIGNyZWRlbnRpYWxzLCBhcnRpZmFjdHMpO1xyXG4gICAgaWYgKG1hYyAhPT0gYXR0cmlidXRlcy5tYWMpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFvcHRpb25zLmhhc093blByb3BlcnR5KCdwYXlsb2FkJykpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWF0dHJpYnV0ZXMuaGFzaCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2FsY3VsYXRlZEhhc2ggPSBDcnlwdG8uY2FsY3VsYXRlUGF5bG9hZEhhc2gob3B0aW9ucy5wYXlsb2FkLCBjcmVkZW50aWFscy5hbGdvcml0aG0sIHJlcy5oZWFkZXJzWydjb250ZW50LXR5cGUnXSk7XHJcbiAgICByZXR1cm4gKGNhbGN1bGF0ZWRIYXNoID09PSBhdHRyaWJ1dGVzLmhhc2gpO1xyXG59O1xyXG5cclxuXHJcbi8vIEdlbmVyYXRlIGEgYmV3aXQgdmFsdWUgZm9yIGEgZ2l2ZW4gVVJJXHJcblxyXG4vKlxyXG4gKiBjcmVkZW50aWFscyBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGtleXM6ICdpZCwgJ2tleScsICdhbGdvcml0aG0nLlxyXG4gKiBvcHRpb25zIGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWwga2V5czogJ2V4dCcsICdsb2NhbHRpbWVPZmZzZXRNc2VjJ1xyXG4gKi9cclxuLypcclxuICAgIHVyaTogJ2h0dHA6Ly9leGFtcGxlLmNvbS9yZXNvdXJjZT9hPWInIG9yIG9iamVjdCBmcm9tIFVybC5wYXJzZSgpXHJcbiAgICBvcHRpb25zOiB7XHJcblxyXG4gICAgICAgIC8vIFJlcXVpcmVkXHJcblxyXG4gICAgICAgIGNyZWRlbnRpYWxzOiB7XHJcbiAgICAgICAgICAgIGlkOiAnZGgzN2ZnajQ5MmplJyxcclxuICAgICAgICAgICAga2V5OiAnYW9pamVkb2FpanNkbGFrc2pkbCcsXHJcbiAgICAgICAgICAgIGFsZ29yaXRobTogJ3NoYTI1NicgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICdzaGExJywgJ3NoYTI1NidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHR0bFNlYzogNjAgKiA2MCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUVEwgaW4gc2Vjb25kc1xyXG5cclxuICAgICAgICAvLyBPcHRpb25hbFxyXG5cclxuICAgICAgICBleHQ6ICdhcHBsaWNhdGlvbi1zcGVjaWZpYycsICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbGljYXRpb24gc3BlY2lmaWMgZGF0YSBzZW50IHZpYSB0aGUgZXh0IGF0dHJpYnV0ZVxyXG4gICAgICAgIGxvY2FsdGltZU9mZnNldE1zZWM6IDQwMCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaW1lIG9mZnNldCB0byBzeW5jIHdpdGggc2VydmVyIHRpbWVcclxuICAgIH07XHJcbiovXHJcblxyXG5leHBvcnRzLmdldEJld2l0ID0gZnVuY3Rpb24gKHVyaSwgb3B0aW9ucykge1xyXG5cclxuICAgIC8vIFZhbGlkYXRlIGlucHV0c1xyXG5cclxuICAgIGlmICghdXJpIHx8XHJcbiAgICAgICAgKHR5cGVvZiB1cmkgIT09ICdzdHJpbmcnICYmIHR5cGVvZiB1cmkgIT09ICdvYmplY3QnKSB8fFxyXG4gICAgICAgICFvcHRpb25zIHx8XHJcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8XHJcbiAgICAgICAgIW9wdGlvbnMudHRsU2VjKSB7XHJcblxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuXHJcbiAgICBvcHRpb25zLmV4dCA9IChvcHRpb25zLmV4dCA9PT0gbnVsbCB8fCBvcHRpb25zLmV4dCA9PT0gdW5kZWZpbmVkID8gJycgOiBvcHRpb25zLmV4dCk7ICAgICAgIC8vIFplcm8gaXMgdmFsaWQgdmFsdWVcclxuXHJcbiAgICAvLyBBcHBsaWNhdGlvbiB0aW1lXHJcblxyXG4gICAgdmFyIG5vdyA9IFV0aWxzLm5vdygpICsgKG9wdGlvbnMubG9jYWx0aW1lT2Zmc2V0TXNlYyB8fCAwKTtcclxuXHJcbiAgICAvLyBWYWxpZGF0ZSBjcmVkZW50aWFsc1xyXG5cclxuICAgIHZhciBjcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHM7XHJcbiAgICBpZiAoIWNyZWRlbnRpYWxzIHx8XHJcbiAgICAgICAgIWNyZWRlbnRpYWxzLmlkIHx8XHJcbiAgICAgICAgIWNyZWRlbnRpYWxzLmtleSB8fFxyXG4gICAgICAgICFjcmVkZW50aWFscy5hbGdvcml0aG0pIHtcclxuXHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChDcnlwdG8uYWxnb3JpdGhtcy5pbmRleE9mKGNyZWRlbnRpYWxzLmFsZ29yaXRobSkgPT09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBhcnNlIFVSSVxyXG5cclxuICAgIGlmICh0eXBlb2YgdXJpID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHVyaSA9IFVybC5wYXJzZSh1cmkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSBzaWduYXR1cmVcclxuXHJcbiAgICB2YXIgZXhwID0gTWF0aC5mbG9vcihub3cgLyAxMDAwKSArIG9wdGlvbnMudHRsU2VjO1xyXG4gICAgdmFyIG1hYyA9IENyeXB0by5jYWxjdWxhdGVNYWMoJ2Jld2l0JywgY3JlZGVudGlhbHMsIHtcclxuICAgICAgICB0czogZXhwLFxyXG4gICAgICAgIG5vbmNlOiAnJyxcclxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgIHJlc291cmNlOiB1cmkucGF0aG5hbWUgKyAodXJpLnNlYXJjaCB8fCAnJyksICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1haW50YWluIHRyYWlsaW5nICc/J1xyXG4gICAgICAgIGhvc3Q6IHVyaS5ob3N0bmFtZSxcclxuICAgICAgICBwb3J0OiB1cmkucG9ydCB8fCAodXJpLnByb3RvY29sID09PSAnaHR0cDonID8gODAgOiA0NDMpLFxyXG4gICAgICAgIGV4dDogb3B0aW9ucy5leHRcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENvbnN0cnVjdCBiZXdpdDogaWRcXGV4cFxcbWFjXFxleHRcclxuXHJcbiAgICB2YXIgYmV3aXQgPSBjcmVkZW50aWFscy5pZCArICdcXFxcJyArIGV4cCArICdcXFxcJyArIG1hYyArICdcXFxcJyArIG9wdGlvbnMuZXh0O1xyXG4gICAgcmV0dXJuIFV0aWxzLmJhc2U2NHVybEVuY29kZShiZXdpdCk7XHJcbn07XHJcblxyXG4iLCIoZnVuY3Rpb24oX19kaXJuYW1lKXsvLyBMb2FkIG1vZHVsZXNcblxudmFyIEhvZWsgPSByZXF1aXJlKCdob2VrJyk7XG52YXIgU250cCA9IHJlcXVpcmUoJ3NudHAnKTtcbnZhciBCb29tID0gcmVxdWlyZSgnYm9vbScpO1xuXG5cbi8vIERlY2xhcmUgaW50ZXJuYWxzXG5cbnZhciBpbnRlcm5hbHMgPSB7fTtcblxuXG4vLyBJbXBvcnQgSG9layBVdGlsaXRpZXNcblxuaW50ZXJuYWxzLmltcG9ydCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGZvciAodmFyIGkgaW4gSG9laykge1xuICAgICAgICBpZiAoSG9lay5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgZXhwb3J0c1tpXSA9IEhvZWtbaV07XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5pbnRlcm5hbHMuaW1wb3J0KCk7XG5cblxuLy8gSGF3ayB2ZXJzaW9uXG5cbmV4cG9ydHMudmVyc2lvbiA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBleHBvcnRzLmxvYWRQYWNrYWdlKF9fZGlybmFtZSArICcvLi4nKS52ZXJzaW9uO1xufTtcblxuXG4vLyBFeHRyYWN0IGhvc3QgYW5kIHBvcnQgZnJvbSByZXF1ZXN0XG5cbmV4cG9ydHMucGFyc2VIb3N0ID0gZnVuY3Rpb24gKHJlcSwgaG9zdEhlYWRlck5hbWUpIHtcblxuICAgIGhvc3RIZWFkZXJOYW1lID0gKGhvc3RIZWFkZXJOYW1lID8gaG9zdEhlYWRlck5hbWUudG9Mb3dlckNhc2UoKSA6ICdob3N0Jyk7XG4gICAgdmFyIGhvc3RIZWFkZXIgPSByZXEuaGVhZGVyc1tob3N0SGVhZGVyTmFtZV07XG4gICAgaWYgKCFob3N0SGVhZGVyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBob3N0SGVhZGVyUmVnZXggPSAvXig/Oig/Olxcclxcbik/W1xcdCBdKSooW146XSspKD86OihcXGQrKSk/KD86KD86XFxyXFxuKT9bXFx0IF0pKiQvOyAgICAgLy8gRG9lcyBub3Qgc3VwcG9ydCBJUHY2XG4gICAgdmFyIGhvc3RQYXJ0cyA9IGhvc3RIZWFkZXIubWF0Y2goaG9zdEhlYWRlclJlZ2V4KTtcblxuICAgIGlmICghaG9zdFBhcnRzIHx8XG4gICAgICAgIGhvc3RQYXJ0cy5sZW5ndGggIT09IDMgfHxcbiAgICAgICAgIWhvc3RQYXJ0c1sxXSkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGhvc3RQYXJ0c1sxXSxcbiAgICAgICAgcG9ydDogKGhvc3RQYXJ0c1syXSA/IGhvc3RQYXJ0c1syXSA6IChyZXEuY29ubmVjdGlvbiAmJiByZXEuY29ubmVjdGlvbi5lbmNyeXB0ZWQgPyA0NDMgOiA4MCkpXG4gICAgfTtcbn07XG5cblxuLy8gUGFyc2UgQ29udGVudC1UeXBlIGhlYWRlciBjb250ZW50XG5cbmV4cG9ydHMucGFyc2VDb250ZW50VHlwZSA9IGZ1bmN0aW9uIChoZWFkZXIpIHtcblxuICAgIGlmICghaGVhZGVyKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVyLnNwbGl0KCc7JylbMF0udHJpbSgpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG5cbi8vIENvbnZlcnQgbm9kZSdzICB0byByZXF1ZXN0IGNvbmZpZ3VyYXRpb24gb2JqZWN0XG5cbmV4cG9ydHMucGFyc2VSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcSwgb3B0aW9ucykge1xuXG4gICAgaWYgKCFyZXEuaGVhZGVycykge1xuICAgICAgICByZXR1cm4gcmVxO1xuICAgIH1cblxuICAgIC8vIE9idGFpbiBob3N0IGFuZCBwb3J0IGluZm9ybWF0aW9uXG5cbiAgICB2YXIgaG9zdCA9IGV4cG9ydHMucGFyc2VIb3N0KHJlcSwgb3B0aW9ucy5ob3N0SGVhZGVyTmFtZSk7XG4gICAgaWYgKCFob3N0KSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgSG9zdCBoZWFkZXInKTtcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgbWV0aG9kOiByZXEubWV0aG9kLFxuICAgICAgICB1cmw6IHJlcS51cmwsXG4gICAgICAgIGhvc3Q6IGhvc3QubmFtZSxcbiAgICAgICAgcG9ydDogaG9zdC5wb3J0LFxuICAgICAgICBhdXRob3JpemF0aW9uOiByZXEuaGVhZGVycy5hdXRob3JpemF0aW9uLFxuICAgICAgICBjb250ZW50VHlwZTogcmVxLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddIHx8ICcnXG4gICAgfTtcblxuICAgIHJldHVybiByZXF1ZXN0O1xufTtcblxuXG5leHBvcnRzLm5vdyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBTbnRwLm5vdygpO1xufTtcblxuXG4vLyBQYXJzZSBIYXdrIEhUVFAgQXV0aG9yaXphdGlvbiBoZWFkZXJcblxuZXhwb3J0cy5wYXJzZUF1dGhvcml6YXRpb25IZWFkZXIgPSBmdW5jdGlvbiAoaGVhZGVyLCBrZXlzKSB7XG5cbiAgICBrZXlzID0ga2V5cyB8fCBbJ2lkJywgJ3RzJywgJ25vbmNlJywgJ2hhc2gnLCAnZXh0JywgJ21hYycsICdhcHAnLCAnZGxnJ107XG5cbiAgICBpZiAoIWhlYWRlcikge1xuICAgICAgICByZXR1cm4gQm9vbS51bmF1dGhvcml6ZWQobnVsbCwgJ0hhd2snKTtcbiAgICB9XG5cbiAgICB2YXIgaGVhZGVyUGFydHMgPSBoZWFkZXIubWF0Y2goL14oXFx3KykoPzpcXHMrKC4qKSk/JC8pOyAgICAgICAvLyBIZWFkZXI6IHNjaGVtZVsgc29tZXRoaW5nXVxuICAgIGlmICghaGVhZGVyUGFydHMpIHtcbiAgICAgICAgcmV0dXJuIEJvb20uYmFkUmVxdWVzdCgnSW52YWxpZCBoZWFkZXIgc3ludGF4Jyk7XG4gICAgfVxuXG4gICAgdmFyIHNjaGVtZSA9IGhlYWRlclBhcnRzWzFdO1xuICAgIGlmIChzY2hlbWUudG9Mb3dlckNhc2UoKSAhPT0gJ2hhd2snKSB7XG4gICAgICAgIHJldHVybiBCb29tLnVuYXV0aG9yaXplZChudWxsLCAnSGF3aycpO1xuICAgIH1cblxuICAgIHZhciBhdHRyaWJ1dGVzU3RyaW5nID0gaGVhZGVyUGFydHNbMl07XG4gICAgaWYgKCFhdHRyaWJ1dGVzU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBCb29tLmJhZFJlcXVlc3QoJ0ludmFsaWQgaGVhZGVyIHN5bnRheCcpO1xuICAgIH1cblxuICAgIHZhciBhdHRyaWJ1dGVzID0ge307XG4gICAgdmFyIGVycm9yTWVzc2FnZSA9ICcnO1xuICAgIHZhciB2ZXJpZnkgPSBhdHRyaWJ1dGVzU3RyaW5nLnJlcGxhY2UoLyhcXHcrKT1cIihbXlwiXFxcXF0qKVwiXFxzKig/OixcXHMqfCQpL2csIGZ1bmN0aW9uICgkMCwgJDEsICQyKSB7XG5cbiAgICAgICAgLy8gQ2hlY2sgdmFsaWQgYXR0cmlidXRlIG5hbWVzXG5cbiAgICAgICAgaWYgKGtleXMuaW5kZXhPZigkMSkgPT09IC0xKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnVW5rbm93biBhdHRyaWJ1dGU6ICcgKyAkMTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbG93ZWQgYXR0cmlidXRlIHZhbHVlIGNoYXJhY3RlcnM6ICEjJCUmJygpKissLS4vOjs8PT4/QFtdXl9ge3x9fiBhbmQgc3BhY2UsIGEteiwgQS1aLCAwLTlcblxuICAgICAgICBpZiAoJDIubWF0Y2goL15bIFxcd1xcISNcXCQlJidcXChcXClcXCpcXCssXFwtXFwuXFwvXFw6OzxcXD0+XFw/QFxcW1xcXVxcXmBcXHtcXHxcXH1+XSskLykgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdCYWQgYXR0cmlidXRlIHZhbHVlOiAnICsgJDE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlc1xuXG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KCQxKSkge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gJ0R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyAkMTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJpYnV0ZXNbJDFdID0gJDI7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9KTtcblxuICAgIGlmICh2ZXJpZnkgIT09ICcnKSB7XG4gICAgICAgIHJldHVybiBCb29tLmJhZFJlcXVlc3QoZXJyb3JNZXNzYWdlIHx8ICdCYWQgaGVhZGVyIGZvcm1hdCcpO1xuICAgIH1cblxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xufTtcblxuXG5leHBvcnRzLnVuYXV0aG9yaXplZCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cbiAgICByZXR1cm4gQm9vbS51bmF1dGhvcml6ZWQobWVzc2FnZSwgJ0hhd2snKTtcbn07XG5cblxufSkoXCIvcmVxdWVzdC9ub2RlX21vZHVsZXMvaGF3ay9saWJcIikiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJyk7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYicpOyIsIihmdW5jdGlvbihwcm9jZXNzKXt2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgcmVxdWVzdCA9IHJlcXVpcmUoJ3JlcXVlc3QnKTtcbnZhciBsdHggPSByZXF1aXJlKCdsdHgnKTtcblxuXG5mdW5jdGlvbiBCT1NIQ29ubmVjdGlvbihvcHRzKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5ib3NoVVJMID0gb3B0cy5ib3NoVVJMO1xuICAgIHRoaXMuamlkID0gb3B0cy5qaWQ7XG4gICAgdGhpcy54bWxuc0F0dHJzID0ge1xuXHR4bWxuczogXCJodHRwOi8vamFiYmVyLm9yZy9wcm90b2NvbC9odHRwYmluZFwiLFxuXHQneG1sbnM6eG1wcCc6IFwidXJuOnhtcHA6eGJvc2hcIixcblx0J3htbG5zOnN0cmVhbSc6IFwiaHR0cDovL2V0aGVyeC5qYWJiZXIub3JnL3N0cmVhbXNcIlxuICAgIH07XG4gICAgaWYgKG9wdHMueG1sbnMpXG5cdGZvcih2YXIgcHJlZml4IGluIG9wdHMueG1sbnMpXG5cdCAgICBpZiAocHJlZml4KVxuXHRcdHRoaXMueG1sbnNBdHRyc1tcInhtbG5zOlwiICsgcHJlZml4XSA9IG9wdHMueG1sbnNbcHJlZml4XTtcblx0ICAgIGVsc2Vcblx0XHR0aGlzLnhtbG5zQXR0cnNbXCJ4bWxuc1wiXSA9IG9wdHMueG1sbnNbcHJlZml4XTtcbiAgICB0aGlzLmN1cnJlbnRSZXF1ZXN0cyA9IDA7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHRoaXMucmlkID0gTWF0aC5jZWlsKE1hdGgucmFuZG9tKCkgKiA5OTk5OTk5OTk5KTtcblxuICAgIHRoaXMucmVxdWVzdCh7XG5cdHRvOiB0aGlzLmppZC5kb21haW4sXG5cdHZlcjogXCIxLjZcIixcblx0d2FpdDogXCIxMFwiLFxuXHRob2xkOiBcIjFcIixcblx0Y29udGVudDogdGhpcy5jb250ZW50VHlwZVxuICAgIH0sIFtdLCBmdW5jdGlvbihlcnIsIGJvZHlFbCkge1xuXHRpZiAoZXJyKSB7XG5cdCAgICB0aGF0LmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0fSBlbHNlIGlmIChib2R5RWwgJiYgYm9keUVsLmF0dHJzKSB7XG5cdCAgICB0aGF0LnNpZCA9IGJvZHlFbC5hdHRycy5zaWQ7XG5cdCAgICB0aGF0Lm1heFJlcXVlc3RzID0gcGFyc2VJbnQoYm9keUVsLmF0dHJzLnJlcXVlc3RzLCAxMCkgfHwgMjtcblx0ICAgIGlmICh0aGF0LnNpZCAmJiB0aGF0Lm1heFJlcXVlc3RzID4gMCkge1xuXHRcdHRoYXQuZW1pdCgnY29ubmVjdCcpO1xuXHRcdHRoYXQucHJvY2Vzc1Jlc3BvbnNlKGJvZHlFbCk7XG5cdFx0cHJvY2Vzcy5uZXh0VGljayh0aGF0Lm1heVJlcXVlc3QuYmluZCh0aGF0KSk7XG5cdCAgICB9IGVsc2Vcblx0XHR0aGF0LmVtaXQoJ2Vycm9yJywgXCJJbnZhbGlkIHBhcmFtZXRlcnNcIik7XG5cdH1cbiAgICB9KTtcbn1cbnV0aWwuaW5oZXJpdHMoQk9TSENvbm5lY3Rpb24sIEV2ZW50RW1pdHRlcik7XG5leHBvcnRzLkJPU0hDb25uZWN0aW9uID0gQk9TSENvbm5lY3Rpb247XG5cbkJPU0hDb25uZWN0aW9uLnByb3RvdHlwZS5jb250ZW50VHlwZSA9IFwidGV4dC94bWw7IGNoYXJzZXQ9dXRmLThcIjtcblxuQk9TSENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihzdGFuemEpIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2goc3RhbnphLnJvb3QoKSk7XG4gICAgcHJvY2Vzcy5uZXh0VGljayh0aGlzLm1heVJlcXVlc3QuYmluZCh0aGlzKSk7XG59O1xuXG5CT1NIQ29ubmVjdGlvbi5wcm90b3R5cGUucHJvY2Vzc1Jlc3BvbnNlID0gZnVuY3Rpb24oYm9keUVsKSB7XG4gICAgaWYgKGJvZHlFbCAmJiBib2R5RWwuY2hpbGRyZW4pIHtcblx0Zm9yKHZhciBpID0gMDsgaSA8IGJvZHlFbC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHQgICAgdmFyIGNoaWxkID0gYm9keUVsLmNoaWxkcmVuW2ldO1xuXHQgICAgaWYgKGNoaWxkLm5hbWUgJiYgY2hpbGQuYXR0cnMgJiYgY2hpbGQuY2hpbGRyZW4pXG5cdFx0dGhpcy5lbWl0KCdzdGFuemEnLCBjaGlsZCk7XG5cdH1cbiAgICB9XG4gICAgaWYgKGJvZHlFbCAmJiBib2R5RWwuYXR0cnMudHlwZSA9PT0gJ3Rlcm1pbmF0ZScpIHtcblx0dGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihib2R5RWwuYXR0cnMuY29uZGl0aW9uIHx8IFwiU2Vzc2lvbiB0ZXJtaW5hdGVkXCIpKTtcblx0dGhpcy5lbWl0KCdjbG9zZScpO1xuICAgIH1cbn07XG5cbkJPU0hDb25uZWN0aW9uLnByb3RvdHlwZS5tYXlSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBjYW5SZXF1ZXN0ID1cblx0LyogTXVzdCBoYXZlIGEgc2Vzc2lvbiBhbHJlYWR5ICovXG5cdHRoaXMuc2lkICYmXG5cdC8qIFdlIGNhbiBvbmx5IHJlY2VpdmUgd2hlbiBvbmUgcmVxdWVzdCBpcyBpbiBmbGlnaHQgKi9cblx0KHRoaXMuY3VycmVudFJlcXVlc3RzID09PSAwIHx8XG5cdCAvKiBJcyB0aGVyZSBzb21ldGhpbmcgdG8gc2VuZCwgYW5kIGFyZSB3ZSBhbGxvd2VkPyAqL1xuXHQgKCh0aGlzLnF1ZXVlLmxlbmd0aCA+IDAgJiYgdGhpcy5jdXJyZW50UmVxdWVzdHMgPCB0aGlzLm1heFJlcXVlc3RzKSlcblx0KTtcbiAgICBpZiAoIWNhblJlcXVlc3QpXG5cdHJldHVybjtcblxuICAgIHZhciBzdGFuemFzID0gdGhpcy5xdWV1ZTtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5yaWQrKztcbiAgICB0aGlzLnJlcXVlc3Qoe30sIHN0YW56YXMsIGZ1bmN0aW9uKGVyciwgYm9keUVsKSB7XG5cdGlmIChlcnIpIHtcblx0ICAgIHRoYXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuXHQgICAgdGhhdC5lbWl0KCdjbG9zZScpO1xuXHQgICAgZGVsZXRlIHRoYXQuc2lkO1xuXHR9IGVsc2Uge1xuXHQgICAgaWYgKGJvZHlFbClcblx0XHR0aGF0LnByb2Nlc3NSZXNwb25zZShib2R5RWwpO1xuXG5cdCAgICBwcm9jZXNzLm5leHRUaWNrKHRoYXQubWF5UmVxdWVzdC5iaW5kKHRoYXQpKTtcblx0fVxuICAgIH0pO1xufTtcblxuQk9TSENvbm5lY3Rpb24ucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKHN0YW56YXMpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICBzdGFuemFzID0gc3RhbnphcyB8fCBbXTtcbiAgICBpZiAodHlwZW9mIHN0YW56YXMgIT09ICdhcnJheScpXG5cdHN0YW56YXMgPSBbc3Rhbnphc107XG5cbiAgICBzdGFuemFzID0gdGhpcy5xdWV1ZS5jb25jYXQoc3Rhbnphcyk7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIHRoaXMucmlkKys7XG4gICAgdGhpcy5yZXF1ZXN0KHsgdHlwZTogJ3Rlcm1pbmF0ZScgfSwgc3RhbnphcywgZnVuY3Rpb24oZXJyLCBib2R5RWwpIHtcblx0aWYgKGJvZHlFbClcblx0ICAgIHRoYXQucHJvY2Vzc1Jlc3BvbnNlKGJvZHlFbCk7XG5cblx0dGhhdC5lbWl0KCdlbmQnKTtcblx0dGhhdC5lbWl0KCdjbG9zZScpO1xuXHRkZWxldGUgdGhhdC5zaWQ7XG4gICAgfSk7XG59O1xuXG5CT1NIQ29ubmVjdGlvbi5wcm90b3R5cGUubWF4SFRUUFJldHJpZXMgPSA1O1xuXG5CT1NIQ29ubmVjdGlvbi5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uKGF0dHJzLCBjaGlsZHJlbiwgY2IsIHJldHJ5KSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHJldHJ5ID0gcmV0cnkgfHwgMDtcblxuICAgIGF0dHJzLnJpZCA9IHRoaXMucmlkLnRvU3RyaW5nKCk7XG4gICAgaWYgKHRoaXMuc2lkKVxuXHRhdHRycy5zaWQgPSB0aGlzLnNpZDtcblxuICAgIGZvcih2YXIgayBpbiB0aGlzLnhtbG5zQXR0cnMpXG5cdGF0dHJzW2tdID0gdGhpcy54bWxuc0F0dHJzW2tdO1xuICAgIHZhciBib3NoRWwgPSBuZXcgbHR4LkVsZW1lbnQoJ2JvZHknLCBhdHRycyk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKVxuXHRib3NoRWwuY25vZGUoY2hpbGRyZW5baV0pO1xuXG4gICAgcmVxdWVzdCh7XG5cdHVyaTogdGhpcy5ib3NoVVJMLFxuXHRtZXRob2Q6ICdQT1NUJyxcblx0aGVhZGVyczoge1xuXHQgICAgXCJDb250ZW50LVR5cGVcIjogdGhpcy5jb250ZW50VHlwZVxuXHR9LFxuXHRib2R5OiBib3NoRWwudG9TdHJpbmcoKVxuICAgIH0sIGZ1bmN0aW9uKGVyciwgcmVzLCBib2R5KSB7XG5cdHRoYXQuY3VycmVudFJlcXVlc3RzLS07XG5cblx0aWYgKGVycikge1xuXHQgICAgaWYgKHJldHJ5IDwgdGhhdC5tYXhIVFRQUmV0cmllcylcblx0XHRyZXR1cm4gdGhhdC5yZXF1ZXN0KGF0dHJzLCBjaGlsZHJlbiwgY2IsIHJldHJ5ICsgMSk7XG5cdCAgICBlbHNlXG5cdFx0cmV0dXJuIGNiKGVycik7XG5cdH1cblx0aWYgKHJlcy5zdGF0dXNDb2RlIDwgMjAwIHx8IHJlcy5zdGF0dXNDb2RlID49IDQwMClcblx0ICAgIHJldHVybiBjYihuZXcgRXJyb3IoXCJIVFRQIHN0YXR1cyBcIiArIHJlcy5zdGF0dXNDb2RlKSk7XG5cblx0dmFyIGJvZHlFbDtcblx0dHJ5IHtcblx0ICAgIGJvZHlFbCA9IGx0eC5wYXJzZShib2R5KTtcblx0fSBjYXRjaChlKSB7XG5cdCAgICByZXR1cm4gY2IoZSk7XG5cdH1cblxuXHRpZiAoYm9keUVsICYmIGJvZHlFbC5hdHRycy50eXBlID09PSAndGVybWluYXRlJylcblx0ICAgIGNiKG5ldyBFcnJvcihib2R5RWwuYXR0cnMuY29uZGl0aW9uKSk7XG5cdGVsc2UgaWYgKGJvZHlFbClcblx0ICAgIGNiKG51bGwsIGJvZHlFbCk7XG5cdGVsc2Vcblx0ICAgIGNiKG5ldyBFcnJvcignbm8gPGJvZHkvPicpKTtcbiAgICB9KTtcbiAgICB0aGlzLmN1cnJlbnRSZXF1ZXN0cysrO1xufTtcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpKSIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW07XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWxheWVkU3RyZWFtO1xuZnVuY3Rpb24gRGVsYXllZFN0cmVhbSgpIHtcbiAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICB0aGlzLmRhdGFTaXplID0gMDtcbiAgdGhpcy5tYXhEYXRhU2l6ZSA9IDEwMjQgKiAxMDI0O1xuICB0aGlzLnBhdXNlU3RyZWFtID0gdHJ1ZTtcblxuICB0aGlzLl9tYXhEYXRhU2l6ZUV4Y2VlZGVkID0gZmFsc2U7XG4gIHRoaXMuX3JlbGVhc2VkID0gZmFsc2U7XG4gIHRoaXMuX2J1ZmZlcmVkRXZlbnRzID0gW107XG59XG51dGlsLmluaGVyaXRzKERlbGF5ZWRTdHJlYW0sIFN0cmVhbSk7XG5cbkRlbGF5ZWRTdHJlYW0uY3JlYXRlID0gZnVuY3Rpb24oc291cmNlLCBvcHRpb25zKSB7XG4gIHZhciBkZWxheWVkU3RyZWFtID0gbmV3IHRoaXMoKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZm9yICh2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICBkZWxheWVkU3RyZWFtW29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gIH1cblxuICBkZWxheWVkU3RyZWFtLnNvdXJjZSA9IHNvdXJjZTtcblxuICB2YXIgcmVhbEVtaXQgPSBzb3VyY2UuZW1pdDtcbiAgc291cmNlLmVtaXQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWxheWVkU3RyZWFtLl9oYW5kbGVFbWl0KGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHJlYWxFbWl0LmFwcGx5KHNvdXJjZSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICBzb3VyY2Uub24oJ2Vycm9yJywgZnVuY3Rpb24oKSB7fSk7XG4gIGlmIChkZWxheWVkU3RyZWFtLnBhdXNlU3RyZWFtKSB7XG4gICAgc291cmNlLnBhdXNlKCk7XG4gIH1cblxuICByZXR1cm4gZGVsYXllZFN0cmVhbTtcbn07XG5cbkRlbGF5ZWRTdHJlYW0ucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18oJ3JlYWRhYmxlJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnNvdXJjZS5yZWFkYWJsZTtcbn0pO1xuXG5EZWxheWVkU3RyZWFtLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9yZWxlYXNlZCkge1xuICAgIHRoaXMucmVsZWFzZSgpO1xuICB9XG5cbiAgdGhpcy5zb3VyY2UucmVzdW1lKCk7XG59O1xuXG5EZWxheWVkU3RyZWFtLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNvdXJjZS5wYXVzZSgpO1xufTtcblxuRGVsYXllZFN0cmVhbS5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9yZWxlYXNlZCA9IHRydWU7XG5cbiAgdGhpcy5fYnVmZmVyZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihhcmdzKSB7XG4gICAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9LmJpbmQodGhpcykpO1xuICB0aGlzLl9idWZmZXJlZEV2ZW50cyA9IFtdO1xufTtcblxuRGVsYXllZFN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgciA9IFN0cmVhbS5wcm90b3R5cGUucGlwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB0aGlzLnJlc3VtZSgpO1xuICByZXR1cm4gcjtcbn07XG5cbkRlbGF5ZWRTdHJlYW0ucHJvdG90eXBlLl9oYW5kbGVFbWl0ID0gZnVuY3Rpb24oYXJncykge1xuICBpZiAodGhpcy5fcmVsZWFzZWQpIHtcbiAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGFyZ3NbMF0gPT09ICdkYXRhJykge1xuICAgIHRoaXMuZGF0YVNpemUgKz0gYXJnc1sxXS5sZW5ndGg7XG4gICAgdGhpcy5fY2hlY2tJZk1heERhdGFTaXplRXhjZWVkZWQoKTtcbiAgfVxuXG4gIHRoaXMuX2J1ZmZlcmVkRXZlbnRzLnB1c2goYXJncyk7XG59O1xuXG5EZWxheWVkU3RyZWFtLnByb3RvdHlwZS5fY2hlY2tJZk1heERhdGFTaXplRXhjZWVkZWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX21heERhdGFTaXplRXhjZWVkZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5kYXRhU2l6ZSA8PSB0aGlzLm1heERhdGFTaXplKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fbWF4RGF0YVNpemVFeGNlZWRlZCA9IHRydWU7XG4gIHZhciBtZXNzYWdlID1cbiAgICAnRGVsYXllZFN0cmVhbSNtYXhEYXRhU2l6ZSBvZiAnICsgdGhpcy5tYXhEYXRhU2l6ZSArICcgYnl0ZXMgZXhjZWVkZWQuJ1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKG1lc3NhZ2UpKTtcbn07XG4iLCIvLyBDb3B5cmlnaHQgMjAxMSBNYXJrIENhdmFnZSA8bWNhdmFnZUBnbWFpbC5jb20+IEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuXG52YXIgUmVhZGVyID0gcmVxdWlyZSgnLi9yZWFkZXInKTtcbnZhciBXcml0ZXIgPSByZXF1aXJlKCcuL3dyaXRlcicpO1xuXG5cbi8vLy0tLSBFeHBvcnRzXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIFJlYWRlcjogUmVhZGVyLFxuXG4gIFdyaXRlcjogV3JpdGVyXG5cbn07XG5cbmZvciAodmFyIHQgaW4gdHlwZXMpIHtcbiAgaWYgKHR5cGVzLmhhc093blByb3BlcnR5KHQpKVxuICAgIG1vZHVsZS5leHBvcnRzW3RdID0gdHlwZXNbdF07XG59XG5mb3IgKHZhciBlIGluIGVycm9ycykge1xuICBpZiAoZXJyb3JzLmhhc093blByb3BlcnR5KGUpKVxuICAgIG1vZHVsZS5leHBvcnRzW2VdID0gZXJyb3JzW2VdO1xufVxuIixudWxsLCIvLyBDb3B5cmlnaHQgMjAxMSBNYXJrIENhdmFnZSA8bWNhdmFnZUBnbWFpbC5jb20+IEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgbmV3SW52YWxpZEFzbjFFcnJvcjogZnVuY3Rpb24obXNnKSB7XG4gICAgdmFyIGUgPSBuZXcgRXJyb3IoKTtcbiAgICBlLm5hbWUgPSAnSW52YWxpZEFzbjFFcnJvcic7XG4gICAgZS5tZXNzYWdlID0gbXNnIHx8ICcnO1xuICAgIHJldHVybiBlO1xuICB9XG5cbn07XG4iLCIvLyBDb3B5cmlnaHQgMjAxMSBNYXJrIENhdmFnZSA8bWNhdmFnZUBnbWFpbC5jb20+IEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVPQzogMCxcbiAgQm9vbGVhbjogMSxcbiAgSW50ZWdlcjogMixcbiAgQml0U3RyaW5nOiAzLFxuICBPY3RldFN0cmluZzogNCxcbiAgTnVsbDogNSxcbiAgT0lEOiA2LFxuICBPYmplY3REZXNjcmlwdG9yOiA3LFxuICBFeHRlcm5hbDogOCxcbiAgUmVhbDogOSwgLy8gZmxvYXRcbiAgRW51bWVyYXRpb246IDEwLFxuICBQRFY6IDExLFxuICBVdGY4U3RyaW5nOiAxMixcbiAgUmVsYXRpdmVPSUQ6IDEzLFxuICBTZXF1ZW5jZTogMTYsXG4gIFNldDogMTcsXG4gIE51bWVyaWNTdHJpbmc6IDE4LFxuICBQcmludGFibGVTdHJpbmc6IDE5LFxuICBUNjFTdHJpbmc6IDIwLFxuICBWaWRlb3RleFN0cmluZzogMjEsXG4gIElBNVN0cmluZzogMjIsXG4gIFVUQ1RpbWU6IDIzLFxuICBHZW5lcmFsaXplZFRpbWU6IDI0LFxuICBHcmFwaGljU3RyaW5nOiAyNSxcbiAgVmlzaWJsZVN0cmluZzogMjYsXG4gIEdlbmVyYWxTdHJpbmc6IDI4LFxuICBVbml2ZXJzYWxTdHJpbmc6IDI5LFxuICBDaGFyYWN0ZXJTdHJpbmc6IDMwLFxuICBCTVBTdHJpbmc6IDMxLFxuICBDb25zdHJ1Y3RvcjogMzIsXG4gIENvbnRleHQ6IDEyOFxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWInKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJyk7IiwiKGZ1bmN0aW9uKEJ1ZmZlcil7Ly8gQ29weXJpZ2h0IDIwMTEgTWFyayBDYXZhZ2UgPG1jYXZhZ2VAZ21haWwuY29tPiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgQVNOMSA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5cbi8vLy0tLSBHbG9iYWxzXG5cbnZhciBuZXdJbnZhbGlkQXNuMUVycm9yID0gZXJyb3JzLm5ld0ludmFsaWRBc24xRXJyb3I7XG5cbnZhciBERUZBVUxUX09QVFMgPSB7XG4gIHNpemU6IDEwMjQsXG4gIGdyb3d0aEZhY3RvcjogOFxufTtcblxuXG4vLy8tLS0gSGVscGVyc1xuXG5mdW5jdGlvbiBtZXJnZShmcm9tLCB0bykge1xuICBhc3NlcnQub2soZnJvbSk7XG4gIGFzc2VydC5lcXVhbCh0eXBlb2YoZnJvbSksICdvYmplY3QnKTtcbiAgYXNzZXJ0Lm9rKHRvKTtcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZih0byksICdvYmplY3QnKTtcblxuICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGZyb20pO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKHRvW2tleV0pXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgdmFsdWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZyb20sIGtleSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBrZXksIHZhbHVlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRvO1xufVxuXG5cblxuLy8vLS0tIEFQSVxuXG5mdW5jdGlvbiBXcml0ZXIob3B0aW9ucykge1xuICBvcHRpb25zID0gbWVyZ2UoREVGQVVMVF9PUFRTLCBvcHRpb25zIHx8IHt9KTtcblxuICB0aGlzLl9idWYgPSBuZXcgQnVmZmVyKG9wdGlvbnMuc2l6ZSB8fCAxMDI0KTtcbiAgdGhpcy5fc2l6ZSA9IHRoaXMuX2J1Zi5sZW5ndGg7XG4gIHRoaXMuX29mZnNldCA9IDA7XG4gIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuXG4gIC8vIEEgbGlzdCBvZiBvZmZzZXRzIGluIHRoZSBidWZmZXIgd2hlcmUgd2UgbmVlZCB0byBpbnNlcnRcbiAgLy8gc2VxdWVuY2UgdGFnL2xlbiBwYWlycy5cbiAgdGhpcy5fc2VxID0gW107XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9fZGVmaW5lR2V0dGVyX18oJ2J1ZmZlcicsIGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLl9zZXEubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBc24xRXJyb3Ioc2VsZi5fc2VxLmxlbmd0aCArICcgdW5lbmRlZCBzZXF1ZW5jZShzKScpO1xuXG4gICAgcmV0dXJuIHNlbGYuX2J1Zi5zbGljZSgwLCBzZWxmLl9vZmZzZXQpO1xuICB9KTtcbn1cblxuXG5Xcml0ZXIucHJvdG90eXBlLndyaXRlQnl0ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgaWYgKHR5cGVvZihiKSAhPT0gJ251bWJlcicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhIE51bWJlcicpO1xuXG4gIHRoaXMuX2Vuc3VyZSgxKTtcbiAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IGI7XG59O1xuXG5cbldyaXRlci5wcm90b3R5cGUud3JpdGVJbnQgPSBmdW5jdGlvbihpLCB0YWcpIHtcbiAgaWYgKHR5cGVvZihpKSAhPT0gJ251bWJlcicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhIE51bWJlcicpO1xuICBpZiAodHlwZW9mKHRhZykgIT09ICdudW1iZXInKVxuICAgIHRhZyA9IEFTTjEuSW50ZWdlcjtcblxuICB2YXIgc3ogPSA0O1xuXG4gIHdoaWxlICgoKChpICYgMHhmZjgwMDAwMCkgPT09IDApIHx8ICgoaSAmIDB4ZmY4MDAwMDApID09PSAweGZmODAwMDAwKSkgJiZcbiAgICAgICAgIChzeiA+IDEpKSB7XG4gICAgc3otLTtcbiAgICBpIDw8PSA4O1xuICB9XG5cbiAgaWYgKHN6ID4gNClcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFzbjFFcnJvcignQkVSIGludHMgY2Fubm90IGJlID4gMHhmZmZmZmZmZicpO1xuXG4gIHRoaXMuX2Vuc3VyZSgyICsgc3opO1xuICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gdGFnO1xuICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gc3o7XG5cbiAgd2hpbGUgKHN6LS0gPiAwKSB7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9ICgoaSAmIDB4ZmYwMDAwMDApID4+IDI0KTtcbiAgICBpIDw8PSA4O1xuICB9XG5cbn07XG5cblxuV3JpdGVyLnByb3RvdHlwZS53cml0ZU51bGwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy53cml0ZUJ5dGUoQVNOMS5OdWxsKTtcbiAgdGhpcy53cml0ZUJ5dGUoMHgwMCk7XG59O1xuXG5cbldyaXRlci5wcm90b3R5cGUud3JpdGVFbnVtZXJhdGlvbiA9IGZ1bmN0aW9uKGksIHRhZykge1xuICBpZiAodHlwZW9mKGkpICE9PSAnbnVtYmVyJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gIGlmICh0eXBlb2YodGFnKSAhPT0gJ251bWJlcicpXG4gICAgdGFnID0gQVNOMS5FbnVtZXJhdGlvbjtcblxuICByZXR1cm4gdGhpcy53cml0ZUludChpLCB0YWcpO1xufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLndyaXRlQm9vbGVhbiA9IGZ1bmN0aW9uKGIsIHRhZykge1xuICBpZiAodHlwZW9mKGIpICE9PSAnYm9vbGVhbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhIEJvb2xlYW4nKTtcbiAgaWYgKHR5cGVvZih0YWcpICE9PSAnbnVtYmVyJylcbiAgICB0YWcgPSBBU04xLkJvb2xlYW47XG5cbiAgdGhpcy5fZW5zdXJlKDMpO1xuICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gdGFnO1xuICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gMHgwMTtcbiAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IGIgPyAweGZmIDogMHgwMDtcbn07XG5cblxuV3JpdGVyLnByb3RvdHlwZS53cml0ZVN0cmluZyA9IGZ1bmN0aW9uKHMsIHRhZykge1xuICBpZiAodHlwZW9mKHMpICE9PSAnc3RyaW5nJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nICh3YXM6ICcgKyB0eXBlb2YocykgKyAnKScpO1xuICBpZiAodHlwZW9mKHRhZykgIT09ICdudW1iZXInKVxuICAgIHRhZyA9IEFTTjEuT2N0ZXRTdHJpbmc7XG5cbiAgdmFyIGxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHMpO1xuICB0aGlzLndyaXRlQnl0ZSh0YWcpO1xuICB0aGlzLndyaXRlTGVuZ3RoKGxlbik7XG4gIGlmIChsZW4pIHtcbiAgICB0aGlzLl9lbnN1cmUobGVuKTtcbiAgICB0aGlzLl9idWYud3JpdGUocywgdGhpcy5fb2Zmc2V0KTtcbiAgICB0aGlzLl9vZmZzZXQgKz0gbGVuO1xuICB9XG59O1xuXG5cbldyaXRlci5wcm90b3R5cGUud3JpdGVCdWZmZXIgPSBmdW5jdGlvbihidWYsIHRhZykge1xuICBpZiAodHlwZW9mKHRhZykgIT09ICdudW1iZXInKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RhZyBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhIGJ1ZmZlcicpO1xuXG4gIHRoaXMud3JpdGVCeXRlKHRhZyk7XG4gIHRoaXMud3JpdGVMZW5ndGgoYnVmLmxlbmd0aCk7XG4gIHRoaXMuX2Vuc3VyZShidWYubGVuZ3RoKTtcbiAgYnVmLmNvcHkodGhpcy5fYnVmLCB0aGlzLl9vZmZzZXQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLl9vZmZzZXQgKz0gYnVmLmxlbmd0aDtcbn07XG5cblxuV3JpdGVyLnByb3RvdHlwZS53cml0ZVN0cmluZ0FycmF5ID0gZnVuY3Rpb24oc3RyaW5ncykge1xuICBpZiAoKCFzdHJpbmdzIGluc3RhbmNlb2YgQXJyYXkpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXlbU3RyaW5nXScpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICBzZWxmLndyaXRlU3RyaW5nKHMpO1xuICB9KTtcbn07XG5cbi8vIFRoaXMgaXMgcmVhbGx5IHRvIHNvbHZlIERFUiBjYXNlcywgYnV0IHdoYXRldmVyIGZvciBub3dcbldyaXRlci5wcm90b3R5cGUud3JpdGVPSUQgPSBmdW5jdGlvbihzLCB0YWcpIHtcbiAgaWYgKHR5cGVvZihzKSAhPT0gJ3N0cmluZycpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuICBpZiAodHlwZW9mKHRhZykgIT09ICdudW1iZXInKVxuICAgIHRhZyA9IEFTTjEuT0lEO1xuXG4gIGlmICghL14oWzAtOV0rXFwuKXszLH1bMC05XSskLy50ZXN0KHMpKVxuICAgIHRocm93IG5ldyBFcnJvcignYXJndW1lbnQgaXMgbm90IGEgdmFsaWQgT0lEIHN0cmluZycpO1xuXG4gIGZ1bmN0aW9uIGVuY29kZU9jdGV0KGJ5dGVzLCBvY3RldCkge1xuICAgIGlmIChvY3RldCA8IDEyOCkge1xuICAgICAgICBieXRlcy5wdXNoKG9jdGV0KTtcbiAgICB9IGVsc2UgaWYgKG9jdGV0IDwgMTYzODQpIHtcbiAgICAgICAgYnl0ZXMucHVzaCgob2N0ZXQgPj4+IDcpIHwgMHg4MCk7XG4gICAgICAgIGJ5dGVzLnB1c2gob2N0ZXQgJiAweDdGKTtcbiAgICB9IGVsc2UgaWYgKG9jdGV0IDwgMjA5NzE1Mikge1xuICAgICAgYnl0ZXMucHVzaCgob2N0ZXQgPj4+IDE0KSB8IDB4ODApO1xuICAgICAgYnl0ZXMucHVzaCgoKG9jdGV0ID4+PiA3KSB8IDB4ODApICYgMHhGRik7XG4gICAgICBieXRlcy5wdXNoKG9jdGV0ICYgMHg3Rik7XG4gICAgfSBlbHNlIGlmIChvY3RldCA8IDI2ODQzNTQ1Nikge1xuICAgICAgYnl0ZXMucHVzaCgob2N0ZXQgPj4+IDIxKSB8IDB4ODApO1xuICAgICAgYnl0ZXMucHVzaCgoKG9jdGV0ID4+PiAxNCkgfCAweDgwKSAmIDB4RkYpO1xuICAgICAgYnl0ZXMucHVzaCgoKG9jdGV0ID4+PiA3KSB8IDB4ODApICYgMHhGRik7XG4gICAgICBieXRlcy5wdXNoKG9jdGV0ICYgMHg3Rik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ5dGVzLnB1c2goKChvY3RldCA+Pj4gMjgpIHwgMHg4MCkgJiAweEZGKTtcbiAgICAgIGJ5dGVzLnB1c2goKChvY3RldCA+Pj4gMjEpIHwgMHg4MCkgJiAweEZGKTtcbiAgICAgIGJ5dGVzLnB1c2goKChvY3RldCA+Pj4gMTQpIHwgMHg4MCkgJiAweEZGKTtcbiAgICAgIGJ5dGVzLnB1c2goKChvY3RldCA+Pj4gNykgfCAweDgwKSAmIDB4RkYpO1xuICAgICAgYnl0ZXMucHVzaChvY3RldCAmIDB4N0YpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0bXAgPSBzLnNwbGl0KCcuJyk7XG4gIHZhciBieXRlcyA9IFtdO1xuICBieXRlcy5wdXNoKHBhcnNlSW50KHRtcFswXSwgMTApICogNDAgKyBwYXJzZUludCh0bXBbMV0sIDEwKSk7XG4gIHRtcC5zbGljZSgyKS5mb3JFYWNoKGZ1bmN0aW9uKGIpIHtcbiAgICBlbmNvZGVPY3RldChieXRlcywgcGFyc2VJbnQoYiwgMTApKTtcbiAgfSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9lbnN1cmUoMiArIGJ5dGVzLmxlbmd0aCk7XG4gIHRoaXMud3JpdGVCeXRlKHRhZyk7XG4gIHRoaXMud3JpdGVMZW5ndGgoYnl0ZXMubGVuZ3RoKTtcbiAgYnl0ZXMuZm9yRWFjaChmdW5jdGlvbihiKSB7XG4gICAgc2VsZi53cml0ZUJ5dGUoYik7XG4gIH0pO1xufTtcblxuXG5Xcml0ZXIucHJvdG90eXBlLndyaXRlTGVuZ3RoID0gZnVuY3Rpb24obGVuKSB7XG4gIGlmICh0eXBlb2YobGVuKSAhPT0gJ251bWJlcicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhIE51bWJlcicpO1xuXG4gIHRoaXMuX2Vuc3VyZSg0KTtcblxuICBpZiAobGVuIDw9IDB4N2YpIHtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gbGVuO1xuICB9IGVsc2UgaWYgKGxlbiA8PSAweGZmKSB7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IDB4ODE7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IGxlbjtcbiAgfSBlbHNlIGlmIChsZW4gPD0gMHhmZmZmKSB7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IDB4ODI7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IGxlbiA+PiA4O1xuICAgIHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXQrK10gPSBsZW47XG4gIH0gZWxzZSBpZiAobGVuIDw9IDB4ZmZmZmZmKSB7XG4gICAgdGhpcy5fc2hpZnQoc3RhcnQsIGxlbiwgMSk7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IDB4ODM7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IGxlbiA+PiAxNjtcbiAgICB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdID0gbGVuID4+IDg7XG4gICAgdGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSA9IGxlbjtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFzbjFFUnJvcignTGVuZ3RoIHRvbyBsb25nICg+IDQgYnl0ZXMpJyk7XG4gIH1cbn07XG5cbldyaXRlci5wcm90b3R5cGUuc3RhcnRTZXF1ZW5jZSA9IGZ1bmN0aW9uKHRhZykge1xuICBpZiAodHlwZW9mKHRhZykgIT09ICdudW1iZXInKVxuICAgIHRhZyA9IEFTTjEuU2VxdWVuY2UgfCBBU04xLkNvbnN0cnVjdG9yO1xuXG4gIHRoaXMud3JpdGVCeXRlKHRhZyk7XG4gIHRoaXMuX3NlcS5wdXNoKHRoaXMuX29mZnNldCk7XG4gIHRoaXMuX2Vuc3VyZSgzKTtcbiAgdGhpcy5fb2Zmc2V0ICs9IDM7XG59O1xuXG5cbldyaXRlci5wcm90b3R5cGUuZW5kU2VxdWVuY2UgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlcSA9IHRoaXMuX3NlcS5wb3AoKTtcbiAgdmFyIHN0YXJ0ID0gc2VxICsgMztcbiAgdmFyIGxlbiA9IHRoaXMuX29mZnNldCAtIHN0YXJ0O1xuXG4gIGlmIChsZW4gPD0gMHg3Zikge1xuICAgIHRoaXMuX3NoaWZ0KHN0YXJ0LCBsZW4sIC0yKTtcbiAgICB0aGlzLl9idWZbc2VxXSA9IGxlbjtcbiAgfSBlbHNlIGlmIChsZW4gPD0gMHhmZikge1xuICAgIHRoaXMuX3NoaWZ0KHN0YXJ0LCBsZW4sIC0xKTtcbiAgICB0aGlzLl9idWZbc2VxXSA9IDB4ODE7XG4gICAgdGhpcy5fYnVmW3NlcSArIDFdID0gbGVuO1xuICB9IGVsc2UgaWYgKGxlbiA8PSAweGZmZmYpIHtcbiAgICB0aGlzLl9idWZbc2VxXSA9IDB4ODI7XG4gICAgdGhpcy5fYnVmW3NlcSArIDFdID0gbGVuID4+IDg7XG4gICAgdGhpcy5fYnVmW3NlcSArIDJdID0gbGVuO1xuICB9IGVsc2UgaWYgKGxlbiA8PSAweGZmZmZmZikge1xuICAgIHRoaXMuX3NoaWZ0KHN0YXJ0LCBsZW4sIDEpO1xuICAgIHRoaXMuX2J1ZltzZXFdID0gMHg4MztcbiAgICB0aGlzLl9idWZbc2VxICsgMV0gPSBsZW4gPj4gMTY7XG4gICAgdGhpcy5fYnVmW3NlcSArIDJdID0gbGVuID4+IDg7XG4gICAgdGhpcy5fYnVmW3NlcSArIDNdID0gbGVuO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXNuMUVycm9yKCdTZXF1ZW5jZSB0b28gbG9uZycpO1xuICB9XG59O1xuXG5cbldyaXRlci5wcm90b3R5cGUuX3NoaWZ0ID0gZnVuY3Rpb24oc3RhcnQsIGxlbiwgc2hpZnQpIHtcbiAgYXNzZXJ0Lm9rKHN0YXJ0ICE9PSB1bmRlZmluZWQpO1xuICBhc3NlcnQub2sobGVuICE9PSB1bmRlZmluZWQpO1xuICBhc3NlcnQub2soc2hpZnQpO1xuXG4gIHRoaXMuX2J1Zi5jb3B5KHRoaXMuX2J1Ziwgc3RhcnQgKyBzaGlmdCwgc3RhcnQsIHN0YXJ0ICsgbGVuKTtcbiAgdGhpcy5fb2Zmc2V0ICs9IHNoaWZ0O1xufTtcblxuV3JpdGVyLnByb3RvdHlwZS5fZW5zdXJlID0gZnVuY3Rpb24obGVuKSB7XG4gIGFzc2VydC5vayhsZW4pO1xuXG4gIGlmICh0aGlzLl9zaXplIC0gdGhpcy5fb2Zmc2V0IDwgbGVuKSB7XG4gICAgdmFyIHN6ID0gdGhpcy5fc2l6ZSAqIHRoaXMuX29wdGlvbnMuZ3Jvd3RoRmFjdG9yO1xuICAgIGlmIChzeiAtIHRoaXMuX29mZnNldCA8IGxlbilcbiAgICAgIHN6ICs9IGxlbjtcblxuICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKHN6KTtcblxuICAgIHRoaXMuX2J1Zi5jb3B5KGJ1ZiwgMCwgMCwgdGhpcy5fb2Zmc2V0KTtcbiAgICB0aGlzLl9idWYgPSBidWY7XG4gICAgdGhpcy5fc2l6ZSA9IHN6O1xuICB9XG59O1xuXG5cblxuLy8vLS0tIEV4cG9ydGVkIEFQSVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRlcjtcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9idWZmZXJcIikuQnVmZmVyKSIsIihmdW5jdGlvbihCdWZmZXIpey8vIENvcHlyaWdodCAyMDExIE1hcmsgQ2F2YWdlIDxtY2F2YWdlQGdtYWlsLmNvbT4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG52YXIgQVNOMSA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5cbi8vLy0tLSBHbG9iYWxzXG5cbnZhciBuZXdJbnZhbGlkQXNuMUVycm9yID0gZXJyb3JzLm5ld0ludmFsaWRBc24xRXJyb3I7XG5cblxuXG4vLy8tLS0gQVBJXG5cbmZ1bmN0aW9uIFJlYWRlcihkYXRhKSB7XG4gIGlmICghZGF0YSB8fCAhQnVmZmVyLmlzQnVmZmVyKGRhdGEpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RhdGEgbXVzdCBiZSBhIG5vZGUgQnVmZmVyJyk7XG5cbiAgdGhpcy5fYnVmID0gZGF0YTtcbiAgdGhpcy5fc2l6ZSA9IGRhdGEubGVuZ3RoO1xuXG4gIC8vIFRoZXNlIGhvbGQgdGhlIFwiY3VycmVudFwiIHN0YXRlXG4gIHRoaXMuX2xlbiA9IDA7XG4gIHRoaXMuX29mZnNldCA9IDA7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9fZGVmaW5lR2V0dGVyX18oJ2xlbmd0aCcsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5fbGVuOyB9KTtcbiAgdGhpcy5fX2RlZmluZUdldHRlcl9fKCdvZmZzZXQnLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNlbGYuX29mZnNldDsgfSk7XG4gIHRoaXMuX19kZWZpbmVHZXR0ZXJfXygncmVtYWluJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlbGYuX3NpemUgLSBzZWxmLl9vZmZzZXQ7XG4gIH0pO1xuICB0aGlzLl9fZGVmaW5lR2V0dGVyX18oJ2J1ZmZlcicsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLl9idWYuc2xpY2Uoc2VsZi5fb2Zmc2V0KTtcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBSZWFkcyBhIHNpbmdsZSBieXRlIGFuZCBhZHZhbmNlcyBvZmZzZXQ7IHlvdSBjYW4gcGFzcyBpbiBgdHJ1ZWAgdG8gbWFrZSB0aGlzXG4gKiBhIFwicGVla1wiIG9wZXJhdGlvbiAoaS5lLiwgZ2V0IHRoZSBieXRlLCBidXQgZG9uJ3QgYWR2YW5jZSB0aGUgb2Zmc2V0KS5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBlZWsgdHJ1ZSBtZWFucyBkb24ndCBtb3ZlIG9mZnNldC5cbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIG5leHQgYnl0ZSwgbnVsbCBpZiBub3QgZW5vdWdoIGRhdGEuXG4gKi9cblJlYWRlci5wcm90b3R5cGUucmVhZEJ5dGUgPSBmdW5jdGlvbihwZWVrKSB7XG4gIGlmICh0aGlzLl9zaXplIC0gdGhpcy5fb2Zmc2V0IDwgMSlcbiAgICByZXR1cm4gbnVsbDtcblxuICB2YXIgYiA9IHRoaXMuX2J1Zlt0aGlzLl9vZmZzZXRdICYgMHhmZjtcblxuICBpZiAoIXBlZWspXG4gICAgdGhpcy5fb2Zmc2V0ICs9IDE7XG5cbiAgcmV0dXJuIGI7XG59O1xuXG5cblJlYWRlci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yZWFkQnl0ZSh0cnVlKTtcbn07XG5cblxuLyoqXG4gKiBSZWFkcyBhIChwb3RlbnRpYWxseSkgdmFyaWFibGUgbGVuZ3RoIG9mZiB0aGUgQkVSIGJ1ZmZlci4gIFRoaXMgY2FsbCBpc1xuICogbm90IHJlYWxseSBtZWFudCB0byBiZSBjYWxsZWQgZGlyZWN0bHksIGFzIGNhbGxlcnMgaGF2ZSB0byBtYW5pcHVsYXRlXG4gKiB0aGUgaW50ZXJuYWwgYnVmZmVyIGFmdGVyd2FyZHMuXG4gKlxuICogQXMgYSByZXN1bHQgb2YgdGhpcyBjYWxsLCB5b3UgY2FuIGNhbGwgYFJlYWRlci5sZW5ndGhgLCB1bnRpbCB0aGVcbiAqIG5leHQgdGhpbmcgY2FsbGVkIHRoYXQgZG9lcyBhIHJlYWRMZW5ndGguXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgYW1vdW50IG9mIG9mZnNldCB0byBhZHZhbmNlIHRoZSBidWZmZXIuXG4gKiBAdGhyb3dzIHtJbnZhbGlkQXNuMUVycm9yfSBvbiBiYWQgQVNOLjFcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5yZWFkTGVuZ3RoID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZClcbiAgICBvZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLl9zaXplKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHZhciBsZW5CID0gdGhpcy5fYnVmW29mZnNldCsrXSAmIDB4ZmY7XG4gIGlmIChsZW5CID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmICgobGVuQiAmIDB4ODApID09IDB4ODApIHtcbiAgICBsZW5CICY9IDB4N2Y7XG5cbiAgICBpZiAobGVuQiA9PSAwKVxuICAgICAgdGhyb3cgbmV3SW52YWxpZEFzbjFFcnJvcignSW5kZWZpbml0ZSBsZW5ndGggbm90IHN1cHBvcnRlZCcpO1xuXG4gICAgaWYgKGxlbkIgPiA0KVxuICAgICAgdGhyb3cgbmV3SW52YWxpZEFzbjFFcnJvcignZW5jb2RpbmcgdG9vIGxvbmcnKTtcblxuICAgIGlmICh0aGlzLl9zaXplIC0gb2Zmc2V0IDwgbGVuQilcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgdGhpcy5fbGVuID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbkI7IGkrKylcbiAgICAgIHRoaXMuX2xlbiA9ICh0aGlzLl9sZW4gPDwgOCkgKyAodGhpcy5fYnVmW29mZnNldCsrXSAmIDB4ZmYpO1xuXG4gIH0gZWxzZSB7XG4gICAgLy8gV2Fzbid0IGEgdmFyaWFibGUgbGVuZ3RoXG4gICAgdGhpcy5fbGVuID0gbGVuQjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQ7XG59O1xuXG5cbi8qKlxuICogUGFyc2VzIHRoZSBuZXh0IHNlcXVlbmNlIGluIHRoaXMgQkVSIGJ1ZmZlci5cbiAqXG4gKiBUbyBnZXQgdGhlIGxlbmd0aCBvZiB0aGUgc2VxdWVuY2UsIGNhbGwgYFJlYWRlci5sZW5ndGhgLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIHNlcXVlbmNlJ3MgdGFnLlxuICovXG5SZWFkZXIucHJvdG90eXBlLnJlYWRTZXF1ZW5jZSA9IGZ1bmN0aW9uKHRhZykge1xuICB2YXIgc2VxID0gdGhpcy5wZWVrKCk7XG4gIGlmIChzZXEgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmICh0YWcgIT09IHVuZGVmaW5lZCAmJiB0YWcgIT09IHNlcSlcbiAgICB0aHJvdyBuZXdJbnZhbGlkQXNuMUVycm9yKCdFeHBlY3RlZCAweCcgKyB0YWcudG9TdHJpbmcoMTYpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc6IGdvdCAweCcgKyBzZXEudG9TdHJpbmcoMTYpKTtcblxuICB2YXIgbyA9IHRoaXMucmVhZExlbmd0aCh0aGlzLl9vZmZzZXQgKyAxKTsgLy8gc3RvcmVkIGluIGBsZW5ndGhgXG4gIGlmIChvID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHRoaXMuX29mZnNldCA9IG87XG4gIHJldHVybiBzZXE7XG59O1xuXG5cblJlYWRlci5wcm90b3R5cGUucmVhZEludCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZFRhZyhBU04xLkludGVnZXIpO1xufTtcblxuXG5SZWFkZXIucHJvdG90eXBlLnJlYWRCb29sZWFuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5fcmVhZFRhZyhBU04xLkJvb2xlYW4pID09PSAwID8gZmFsc2UgOiB0cnVlKTtcbn07XG5cblxuUmVhZGVyLnByb3RvdHlwZS5yZWFkRW51bWVyYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRUYWcoQVNOMS5FbnVtZXJhdGlvbik7XG59O1xuXG5cblJlYWRlci5wcm90b3R5cGUucmVhZFN0cmluZyA9IGZ1bmN0aW9uKHRhZywgcmV0YnVmKSB7XG4gIGlmICghdGFnKVxuICAgIHRhZyA9IEFTTjEuT2N0ZXRTdHJpbmc7XG5cbiAgdmFyIGIgPSB0aGlzLnBlZWsoKTtcbiAgaWYgKGIgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGIgIT09IHRhZylcbiAgICB0aHJvdyBuZXdJbnZhbGlkQXNuMUVycm9yKCdFeHBlY3RlZCAweCcgKyB0YWcudG9TdHJpbmcoMTYpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc6IGdvdCAweCcgKyBiLnRvU3RyaW5nKDE2KSk7XG5cbiAgdmFyIG8gPSB0aGlzLnJlYWRMZW5ndGgodGhpcy5fb2Zmc2V0ICsgMSk7IC8vIHN0b3JlZCBpbiBgbGVuZ3RoYFxuXG4gIGlmIChvID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmICh0aGlzLmxlbmd0aCA+IHRoaXMuX3NpemUgLSBvKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHRoaXMuX29mZnNldCA9IG87XG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiAnJztcblxuICB2YXIgc3RyID0gdGhpcy5fYnVmLnNsaWNlKHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0ICsgdGhpcy5sZW5ndGgpO1xuICB0aGlzLl9vZmZzZXQgKz0gdGhpcy5sZW5ndGg7XG5cbiAgcmV0dXJuIHJldGJ1ZiA/IHN0ciA6IHN0ci50b1N0cmluZygndXRmOCcpO1xufTtcblxuUmVhZGVyLnByb3RvdHlwZS5yZWFkT0lEID0gZnVuY3Rpb24odGFnKSB7XG4gIGlmICghdGFnKVxuICAgIHRhZyA9IEFTTjEuT0lEO1xuXG4gIHZhciBiID0gdGhpcy5wZWVrKCk7XG4gIGlmIChiID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmIChiICE9PSB0YWcpXG4gICAgdGhyb3cgbmV3SW52YWxpZEFzbjFFcnJvcignRXhwZWN0ZWQgMHgnICsgdGFnLnRvU3RyaW5nKDE2KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnOiBnb3QgMHgnICsgYi50b1N0cmluZygxNikpO1xuXG4gIHZhciBvID0gdGhpcy5yZWFkTGVuZ3RoKHRoaXMuX29mZnNldCArIDEpOyAvLyBzdG9yZWQgaW4gYGxlbmd0aGBcbiAgaWYgKG8gPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKHRoaXMubGVuZ3RoID4gdGhpcy5fc2l6ZSAtIG8pXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdGhpcy5fb2Zmc2V0ID0gbztcblxuICB2YXIgdmFsdWVzID0gW107XG4gIHZhciB2YWx1ZSA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdICYgMHhmZjtcblxuICAgIHZhbHVlIDw8PSA3O1xuICAgIHZhbHVlICs9IGJ5dGUgJiAweDdmO1xuICAgIGlmICgoYnl0ZSAmIDB4ODApID09IDApIHtcbiAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgIHZhbHVlID0gMDtcbiAgICB9XG4gIH1cblxuICB2YWx1ZSA9IHZhbHVlcy5zaGlmdCgpO1xuICB2YWx1ZXMudW5zaGlmdCh2YWx1ZSAlIDQwKTtcbiAgdmFsdWVzLnVuc2hpZnQoKHZhbHVlIC8gNDApID4+IDApO1xuXG4gIHJldHVybiB2YWx1ZXMuam9pbignLicpO1xufTtcblxuXG5SZWFkZXIucHJvdG90eXBlLl9yZWFkVGFnID0gZnVuY3Rpb24odGFnKSB7XG4gIGFzc2VydC5vayh0YWcgIT09IHVuZGVmaW5lZCk7XG5cbiAgdmFyIGIgPSB0aGlzLnBlZWsoKTtcblxuICBpZiAoYiA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAoYiAhPT0gdGFnKVxuICAgIHRocm93IG5ld0ludmFsaWRBc24xRXJyb3IoJ0V4cGVjdGVkIDB4JyArIHRhZy50b1N0cmluZygxNikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzogZ290IDB4JyArIGIudG9TdHJpbmcoMTYpKTtcblxuICB2YXIgbyA9IHRoaXMucmVhZExlbmd0aCh0aGlzLl9vZmZzZXQgKyAxKTsgLy8gc3RvcmVkIGluIGBsZW5ndGhgXG4gIGlmIChvID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmICh0aGlzLmxlbmd0aCA+IDQpXG4gICAgdGhyb3cgbmV3SW52YWxpZEFzbjFFcnJvcignSW50ZWdlciB0b28gbG9uZzogJyArIHRoaXMubGVuZ3RoKTtcblxuICBpZiAodGhpcy5sZW5ndGggPiB0aGlzLl9zaXplIC0gbylcbiAgICByZXR1cm4gbnVsbDtcbiAgdGhpcy5fb2Zmc2V0ID0gbztcblxuICB2YXIgZmIgPSB0aGlzLl9idWZbdGhpcy5fb2Zmc2V0KytdO1xuICB2YXIgdmFsdWUgPSAwO1xuXG4gIHZhbHVlID0gZmIgJiAweDdGO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWx1ZSA8PD0gODtcbiAgICB2YWx1ZSB8PSAodGhpcy5fYnVmW3RoaXMuX29mZnNldCsrXSAmIDB4ZmYpO1xuICB9XG5cbiAgaWYgKChmYiAmIDB4ODApID09IDB4ODApXG4gICAgdmFsdWUgPSAtdmFsdWU7XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuXG5cbi8vLy0tLSBFeHBvcnRlZCBBUElcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkZXI7XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfYnVmZmVyXCIpLkJ1ZmZlcikiLCIoZnVuY3Rpb24ocHJvY2VzcyxCdWZmZXIpey8vIExvYWQgbW9kdWxlc1xyXG5cclxudmFyIEZzID0gcmVxdWlyZSgnZnMnKTtcclxudmFyIEVzY2FwZSA9IHJlcXVpcmUoJy4vZXNjYXBlJyk7XHJcblxyXG5cclxuLy8gRGVjbGFyZSBpbnRlcm5hbHNcclxuXHJcbnZhciBpbnRlcm5hbHMgPSB7fTtcclxuXHJcblxyXG4vLyBDbG9uZSBvYmplY3Qgb3IgYXJyYXlcclxuXHJcbmV4cG9ydHMuY2xvbmUgPSBmdW5jdGlvbiAob2JqLCBzZWVuKSB7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8XHJcbiAgICAgICAgb2JqID09PSBudWxsKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcblxyXG4gICAgc2VlbiA9IHNlZW4gfHwgeyBvcmlnOiBbXSwgY29weTogW10gfTtcclxuXHJcbiAgICB2YXIgbG9va3VwID0gc2Vlbi5vcmlnLmluZGV4T2Yob2JqKTtcclxuICAgIGlmIChsb29rdXAgIT09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlZW4uY29weVtsb29rdXBdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBuZXdPYmogPSAob2JqIGluc3RhbmNlb2YgQXJyYXkpID8gW10gOiB7fTtcclxuXHJcbiAgICBzZWVuLm9yaWcucHVzaChvYmopO1xyXG4gICAgc2Vlbi5jb3B5LnB1c2gobmV3T2JqKTtcclxuXHJcbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcclxuICAgICAgICAgICAgaWYgKG9ialtpXSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgbmV3T2JqW2ldID0gbmV3IEJ1ZmZlcihvYmpbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9ialtpXSBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgICAgIG5ld09ialtpXSA9IG5ldyBEYXRlKG9ialtpXS5nZXRUaW1lKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9ialtpXSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZsYWdzID0gJycgKyAob2JqW2ldLmdsb2JhbCA/ICdnJyA6ICcnKSArIChvYmpbaV0uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArIChvYmpbaV0ubXVsdGlsaW5lID8gJ20nIDogJycpO1xyXG4gICAgICAgICAgICAgICAgbmV3T2JqW2ldID0gbmV3IFJlZ0V4cChvYmpbaV0uc291cmNlLCBmbGFncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdPYmpbaV0gPSBleHBvcnRzLmNsb25lKG9ialtpXSwgc2Vlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ld09iajtcclxufTtcclxuXHJcblxyXG4vLyBNZXJnZSBhbGwgdGhlIHByb3BlcnRpZXMgb2Ygc291cmNlIGludG8gdGFyZ2V0LCBzb3VyY2Ugd2lucyBpbiBjb25mbGljLCBhbmQgYnkgZGVmYXVsdCBudWxsIGFuZCB1bmRlZmluZWQgZnJvbSBzb3VyY2UgYXJlIGFwcGxpZWRcclxuXHJcbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGlzTnVsbE92ZXJyaWRlIC8qID0gdHJ1ZSAqLywgaXNNZXJnZUFycmF5cyAvKiA9IHRydWUgKi8pIHtcclxuXHJcbiAgICBleHBvcnRzLmFzc2VydCh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PSAnb2JqZWN0JywgJ0ludmFsaWQgdGFyZ2V0IHZhbHVlOiBtdXN0IGJlIGFuIG9iamVjdCcpO1xyXG4gICAgZXhwb3J0cy5hc3NlcnQoc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnLCAnSW52YWxpZCBzb3VyY2UgdmFsdWU6IG11c3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBvciBhbiBvYmplY3QnKTtcclxuXHJcbiAgICBpZiAoIXNvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgZXhwb3J0cy5hc3NlcnQodGFyZ2V0IGluc3RhbmNlb2YgQXJyYXksICdDYW5ub3QgbWVyZ2UgYXJyYXkgb250byBhbiBvYmplY3QnKTtcclxuICAgICAgICBpZiAoaXNNZXJnZUFycmF5cyA9PT0gZmFsc2UpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzTWVyZ2VBcnJheXMgZGVmYXVsdHMgdG8gdHJ1ZVxyXG4gICAgICAgICAgICB0YXJnZXQubGVuZ3RoID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTXVzdCBub3QgY2hhbmdlIHRhcmdldCBhc3NpZ25tZW50XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzb3VyY2UuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG5cclxuICAgICAgICAgICAgdGFyZ2V0LnB1c2goaXRlbSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuXHJcbiAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW2tleV07XHJcbiAgICAgICAgaWYgKHZhbHVlICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0W2tleV0gfHxcclxuICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRba2V5XSAhPT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IGV4cG9ydHMuY2xvbmUodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5tZXJnZSh0YXJnZXRba2V5XSwgc291cmNlW2tleV0sIGlzTnVsbE92ZXJyaWRlLCBpc01lcmdlQXJyYXlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHsgICAgICAgICAgICAvLyBFeHBsaWNpdCB0byBwcmVzZXJ2ZSBlbXB0eSBzdHJpbmdzXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTnVsbE92ZXJyaWRlICE9PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG5cclxuLy8gQXBwbHkgb3B0aW9ucyB0byBhIGNvcHkgb2YgdGhlIGRlZmF1bHRzXHJcblxyXG5leHBvcnRzLmFwcGx5VG9EZWZhdWx0cyA9IGZ1bmN0aW9uIChkZWZhdWx0cywgb3B0aW9ucykge1xyXG5cclxuICAgIGV4cG9ydHMuYXNzZXJ0KGRlZmF1bHRzICYmIHR5cGVvZiBkZWZhdWx0cyA9PSAnb2JqZWN0JywgJ0ludmFsaWQgZGVmYXVsdHMgdmFsdWU6IG11c3QgYmUgYW4gb2JqZWN0Jyk7XHJcbiAgICBleHBvcnRzLmFzc2VydCghb3B0aW9ucyB8fCBvcHRpb25zID09PSB0cnVlIHx8IHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JywgJ0ludmFsaWQgb3B0aW9ucyB2YWx1ZTogbXVzdCBiZSB0cnVlLCBmYWxzeSBvciBhbiBvYmplY3QnKTtcclxuXHJcbiAgICBpZiAoIW9wdGlvbnMpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm8gb3B0aW9ucywgcmV0dXJuIG51bGxcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY29weSA9IGV4cG9ydHMuY2xvbmUoZGVmYXVsdHMpO1xyXG5cclxuICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBvcHRpb25zIGlzIHNldCB0byB0cnVlLCB1c2UgZGVmYXVsdHNcclxuICAgICAgICByZXR1cm4gY29weTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZXhwb3J0cy5tZXJnZShjb3B5LCBvcHRpb25zLCBmYWxzZSwgZmFsc2UpO1xyXG59O1xyXG5cclxuXHJcbi8vIFJlbW92ZSBkdXBsaWNhdGUgaXRlbXMgZnJvbSBhcnJheVxyXG5cclxuZXhwb3J0cy51bmlxdWUgPSBmdW5jdGlvbiAoYXJyYXksIGtleSkge1xyXG5cclxuICAgIHZhciBpbmRleCA9IHt9O1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuICAgICAgICB2YXIgaWQgPSAoa2V5ID8gYXJyYXlbaV1ba2V5XSA6IGFycmF5W2ldKTtcclxuICAgICAgICBpZiAoaW5kZXhbaWRdICE9PSB0cnVlKSB7XHJcblxyXG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XHJcbiAgICAgICAgICAgIGluZGV4W2lkXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5cclxuLy8gQ29udmVydCBhcnJheSBpbnRvIG9iamVjdFxyXG5cclxuZXhwb3J0cy5tYXBUb09iamVjdCA9IGZ1bmN0aW9uIChhcnJheSwga2V5KSB7XHJcblxyXG4gICAgaWYgKCFhcnJheSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBvYmogPSB7fTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuICAgICAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChhcnJheVtpXVtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICBvYmpbYXJyYXlbaV1ba2V5XV0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvYmpbYXJyYXlbaV1dID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG9iajtcclxufTtcclxuXHJcblxyXG4vLyBGaW5kIHRoZSBjb21tb24gdW5pcXVlIGl0ZW1zIGluIHR3byBhcnJheXNcclxuXHJcbmV4cG9ydHMuaW50ZXJzZWN0ID0gZnVuY3Rpb24gKGFycmF5MSwgYXJyYXkyKSB7XHJcblxyXG4gICAgaWYgKCFhcnJheTEgfHwgIWFycmF5Mikge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY29tbW9uID0gW107XHJcbiAgICB2YXIgaGFzaCA9IChhcnJheTEgaW5zdGFuY2VvZiBBcnJheSA/IGV4cG9ydHMubWFwVG9PYmplY3QoYXJyYXkxKSA6IGFycmF5MSk7XHJcbiAgICB2YXIgZm91bmQgPSB7fTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGFycmF5Mi5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XHJcbiAgICAgICAgaWYgKGhhc2hbYXJyYXkyW2ldXSAmJiAhZm91bmRbYXJyYXkyW2ldXSkge1xyXG4gICAgICAgICAgICBjb21tb24ucHVzaChhcnJheTJbaV0pO1xyXG4gICAgICAgICAgICBmb3VuZFthcnJheTJbaV1dID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbW1vbjtcclxufTtcclxuXHJcblxyXG4vLyBGaW5kIHdoaWNoIGtleXMgYXJlIHByZXNlbnRcclxuXHJcbmV4cG9ydHMubWF0Y2hLZXlzID0gZnVuY3Rpb24gKG9iaiwga2V5cykge1xyXG5cclxuICAgIHZhciBtYXRjaGVkID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBrZXlzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleXNbaV0pKSB7XHJcbiAgICAgICAgICAgIG1hdGNoZWQucHVzaChrZXlzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF0Y2hlZDtcclxufTtcclxuXHJcblxyXG4vLyBGbGF0dGVuIGFycmF5XHJcblxyXG5leHBvcnRzLmZsYXR0ZW4gPSBmdW5jdGlvbiAoYXJyYXksIHRhcmdldCkge1xyXG5cclxuICAgIHZhciByZXN1bHQgPSB0YXJnZXQgfHwgW107XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5W2ldKSkge1xyXG4gICAgICAgICAgICBleHBvcnRzLmZsYXR0ZW4oYXJyYXlbaV0sIHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5cclxuLy8gUmVtb3ZlIGtleXNcclxuXHJcbmV4cG9ydHMucmVtb3ZlS2V5cyA9IGZ1bmN0aW9uIChvYmplY3QsIGtleXMpIHtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBrZXlzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcclxuICAgICAgICBkZWxldGUgb2JqZWN0W2tleXNbaV1dO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbi8vIENvbnZlcnQgYW4gb2JqZWN0IGtleSBjaGFpbiBzdHJpbmcgKCdhLmIuYycpIHRvIHJlZmVyZW5jZSAob2JqZWN0W2FdW2JdW2NdKVxyXG5cclxuZXhwb3J0cy5yZWFjaCA9IGZ1bmN0aW9uIChvYmosIGNoYWluKSB7XHJcblxyXG4gICAgdmFyIHBhdGggPSBjaGFpbi5zcGxpdCgnLicpO1xyXG4gICAgdmFyIHJlZiA9IG9iajtcclxuICAgIHBhdGguZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcclxuXHJcbiAgICAgICAgaWYgKHJlZikge1xyXG4gICAgICAgICAgICByZWYgPSByZWZbbGV2ZWxdO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZWY7XHJcbn07XHJcblxyXG5cclxuLy8gSW5oZXJpdHMgYSBzZWxlY3RlZCBzZXQgb2YgbWV0aG9kcyBmcm9tIGFuIG9iamVjdCwgd3JhcHBpbmcgZnVuY3Rpb25zIGluIGFzeW5jaHJvbm91cyBzeW50YXggYW5kIGNhdGNoaW5nIGVycm9yc1xyXG5cclxuZXhwb3J0cy5pbmhlcml0QXN5bmMgPSBmdW5jdGlvbiAoc2VsZiwgb2JqLCBrZXlzKSB7XHJcblxyXG4gICAga2V5cyA9IGtleXMgfHwgbnVsbDtcclxuXHJcbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcclxuICAgICAgICAgICAgaWYgKGtleXMgaW5zdGFuY2VvZiBBcnJheSAmJlxyXG4gICAgICAgICAgICAgICAga2V5cy5pbmRleE9mKGkpIDwgMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZWxmLnByb3RvdHlwZVtpXSA9IChmdW5jdGlvbiAoZm4pIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4oKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQobnVsbCwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pKG9ialtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuZm9ybWF0U3RhY2sgPSBmdW5jdGlvbiAoc3RhY2spIHtcclxuXHJcbiAgICB2YXIgdHJhY2UgPSBbXTtcclxuICAgIHN0YWNrLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuXHJcbiAgICAgICAgdHJhY2UucHVzaChbaXRlbS5nZXRGaWxlTmFtZSgpLCBpdGVtLmdldExpbmVOdW1iZXIoKSwgaXRlbS5nZXRDb2x1bW5OdW1iZXIoKSwgaXRlbS5nZXRGdW5jdGlvbk5hbWUoKSwgaXRlbS5pc0NvbnN0cnVjdG9yKCldKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0cmFjZTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmZvcm1hdFRyYWNlID0gZnVuY3Rpb24gKHRyYWNlKSB7XHJcblxyXG4gICAgdmFyIGRpc3BsYXkgPSBbXTtcclxuICAgIHRyYWNlLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xyXG5cclxuICAgICAgICBkaXNwbGF5LnB1c2goKHJvd1s0XSA/ICduZXcgJyA6ICcnKSArIHJvd1szXSArICcgKCcgKyByb3dbMF0gKyAnOicgKyByb3dbMV0gKyAnOicgKyByb3dbMl0gKyAnKScpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGRpc3BsYXk7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5jYWxsU3RhY2sgPSBmdW5jdGlvbiAoc2xpY2UpIHtcclxuXHJcbiAgICAvLyBodHRwOi8vY29kZS5nb29nbGUuY29tL3Avdjgvd2lraS9KYXZhU2NyaXB0U3RhY2tUcmFjZUFwaVxyXG5cclxuICAgIHZhciB2OCA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xyXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmdW5jdGlvbiAoZXJyLCBzdGFjaykge1xyXG5cclxuICAgICAgICByZXR1cm4gc3RhY2s7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBjYXB0dXJlID0ge307XHJcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShjYXB0dXJlLCBhcmd1bWVudHMuY2FsbGVlKTtcclxuICAgIHZhciBzdGFjayA9IGNhcHR1cmUuc3RhY2s7XHJcblxyXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2ODtcclxuXHJcbiAgICB2YXIgdHJhY2UgPSBleHBvcnRzLmZvcm1hdFN0YWNrKHN0YWNrKTtcclxuXHJcbiAgICBpZiAoc2xpY2UpIHtcclxuICAgICAgICByZXR1cm4gdHJhY2Uuc2xpY2Uoc2xpY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cmFjZTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmRpc3BsYXlTdGFjayA9IGZ1bmN0aW9uIChzbGljZSkge1xyXG5cclxuICAgIHZhciB0cmFjZSA9IGV4cG9ydHMuY2FsbFN0YWNrKHNsaWNlID09PSB1bmRlZmluZWQgPyAxIDogc2xpY2UgKyAxKTtcclxuXHJcbiAgICByZXR1cm4gZXhwb3J0cy5mb3JtYXRUcmFjZSh0cmFjZSk7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5hYm9ydFRocm93ID0gZmFsc2U7XHJcblxyXG5cclxuZXhwb3J0cy5hYm9ydCA9IGZ1bmN0aW9uIChtZXNzYWdlLCBoaWRlU3RhY2spIHtcclxuXHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0JyB8fCBleHBvcnRzLmFib3J0VGhyb3cgPT09IHRydWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcicpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzdGFjayA9ICcnO1xyXG4gICAgaWYgKCFoaWRlU3RhY2spIHtcclxuICAgICAgICBzdGFjayA9IGV4cG9ydHMuZGlzcGxheVN0YWNrKDEpLmpvaW4oJ1xcblxcdCcpO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coJ0FCT1JUOiAnICsgbWVzc2FnZSArICdcXG5cXHQnICsgc3RhY2spO1xyXG4gICAgcHJvY2Vzcy5leGl0KDEpO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuYXNzZXJ0ID0gZnVuY3Rpb24gKGNvbmRpdGlvbiAvKiwgbXNnMSwgbXNnMiwgbXNnMyAqLykge1xyXG5cclxuICAgIGlmIChjb25kaXRpb24pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1zZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgbXNncyA9IG1zZ3MubWFwKGZ1bmN0aW9uIChtc2cpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnID8gbXNnIDogbXNnIGluc3RhbmNlb2YgRXJyb3IgPyBtc2cubWVzc2FnZSA6IEpTT04uc3RyaW5naWZ5KG1zZyk7XHJcbiAgICB9KTtcclxuICAgIHRocm93IG5ldyBFcnJvcihtc2dzLmpvaW4oJyAnKSB8fCAnVW5rbm93biBlcnJvcicpO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMubG9hZERpck1vZHVsZXMgPSBmdW5jdGlvbiAocGF0aCwgZXhjbHVkZUZpbGVzLCB0YXJnZXQpIHsgICAgICAvLyB0YXJnZXQoZmlsZW5hbWUsIG5hbWUsIGNhcE5hbWUpXHJcblxyXG4gICAgdmFyIGV4Y2x1ZGUgPSB7fTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGV4Y2x1ZGVGaWxlcy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XHJcbiAgICAgICAgZXhjbHVkZVtleGNsdWRlRmlsZXNbaV0gKyAnLmpzJ10gPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIEZzLnJlYWRkaXJTeW5jKHBhdGgpLmZvckVhY2goZnVuY3Rpb24gKGZpbGVuYW1lKSB7XHJcblxyXG4gICAgICAgIGlmICgvXFwuanMkLy50ZXN0KGZpbGVuYW1lKSAmJlxyXG4gICAgICAgICAgICAhZXhjbHVkZVtmaWxlbmFtZV0pIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gZmlsZW5hbWUuc3Vic3RyKDAsIGZpbGVuYW1lLmxhc3RJbmRleE9mKCcuJykpO1xyXG4gICAgICAgICAgICB2YXIgY2FwTmFtZSA9IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldFtjYXBOYW1lXSA9IHJlcXVpcmUocGF0aCArICcvJyArIG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0KHBhdGggKyAnLycgKyBuYW1lLCBuYW1lLCBjYXBOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMucmVuYW1lID0gZnVuY3Rpb24gKG9iaiwgZnJvbSwgdG8pIHtcclxuXHJcbiAgICBvYmpbdG9dID0gb2JqW2Zyb21dO1xyXG4gICAgZGVsZXRlIG9ialtmcm9tXTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLlRpbWVyID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHRoaXMucmVzZXQoKTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLlRpbWVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB0aGlzLnRzID0gRGF0ZS5ub3coKTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLlRpbWVyLnByb3RvdHlwZS5lbGFwc2VkID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy50cztcclxufTtcclxuXHJcblxyXG4vLyBMb2FkIGFuZCBwYXJzZSBwYWNrYWdlLmpzb24gcHJvY2VzcyByb290IG9yIGdpdmVuIGRpcmVjdG9yeVxyXG5cclxuZXhwb3J0cy5sb2FkUGFja2FnZSA9IGZ1bmN0aW9uIChkaXIpIHtcclxuXHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICB2YXIgZmlsZXBhdGggPSAoZGlyIHx8IHByb2Nlc3MuZW52LlBXRCkgKyAnL3BhY2thZ2UuanNvbic7XHJcbiAgICBpZiAoRnMuZXhpc3RzU3luYyhmaWxlcGF0aCkpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKEZzLnJlYWRGaWxlU3luYyhmaWxlcGF0aCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblxyXG4vLyBFc2NhcGUgc3RyaW5nIGZvciBSZWdleCBjb25zdHJ1Y3Rpb25cclxuXHJcbmV4cG9ydHMuZXNjYXBlUmVnZXggPSBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcblxyXG4gICAgLy8gRXNjYXBlIF4kLiorLT89ITp8XFwvKClbXXt9LFxyXG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bXFxeXFwkXFwuXFwqXFwrXFwtXFw/XFw9XFwhXFw6XFx8XFxcXFxcL1xcKFxcKVxcW1xcXVxce1xcfVxcLF0vZywgJ1xcXFwkJicpO1xyXG59O1xyXG5cclxuXHJcbi8vIFJldHVybiBhbiBlcnJvciBhcyBmaXJzdCBhcmd1bWVudCBvZiBhIGNhbGxiYWNrXHJcblxyXG5leHBvcnRzLnRvc3MgPSBmdW5jdGlvbiAoY29uZGl0aW9uIC8qLCBbbWVzc2FnZV0sIG5leHQgKi8pIHtcclxuXHJcbiAgICB2YXIgbWVzc2FnZSA9IChhcmd1bWVudHMubGVuZ3RoID09PSAzID8gYXJndW1lbnRzWzFdIDogJycpO1xyXG4gICAgdmFyIG5leHQgPSAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyA/IGFyZ3VtZW50c1syXSA6IGFyZ3VtZW50c1sxXSk7XHJcblxyXG4gICAgdmFyIGVyciA9IChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IgPyBtZXNzYWdlIDogKG1lc3NhZ2UgPyBuZXcgRXJyb3IobWVzc2FnZSkgOiAoY29uZGl0aW9uIGluc3RhbmNlb2YgRXJyb3IgPyBjb25kaXRpb24gOiBuZXcgRXJyb3IoKSkpKTtcclxuXHJcbiAgICBpZiAoY29uZGl0aW9uIGluc3RhbmNlb2YgRXJyb3IgfHxcclxuICAgICAgICAhY29uZGl0aW9uKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXh0KGVycik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuLy8gQmFzZTY0dXJsIChSRkMgNDY0OCkgZW5jb2RlXHJcblxyXG5leHBvcnRzLmJhc2U2NHVybEVuY29kZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cclxuICAgIHJldHVybiAobmV3IEJ1ZmZlcih2YWx1ZSwgJ2JpbmFyeScpKS50b1N0cmluZygnYmFzZTY0JykucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJykucmVwbGFjZSgvXFw9L2csICcnKTtcclxufTtcclxuXHJcblxyXG4vLyBCYXNlNjR1cmwgKFJGQyA0NjQ4KSBkZWNvZGVcclxuXHJcbmV4cG9ydHMuYmFzZTY0dXJsRGVjb2RlID0gZnVuY3Rpb24gKGVuY29kZWQpIHtcclxuXHJcbiAgICBpZiAoZW5jb2RlZCAmJlxyXG4gICAgICAgICFlbmNvZGVkLm1hdGNoKC9eW1xcd1xcLV0qJC8pKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gKG5ldyBCdWZmZXIoZW5jb2RlZC5yZXBsYWNlKC8tL2csICcrJykucmVwbGFjZSgvOi9nLCAnLycpLCAnYmFzZTY0JykpLnRvU3RyaW5nKCdiaW5hcnknKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICByZXR1cm4gZXJyO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbi8vIEVzY2FwZSBhdHRyaWJ1dGUgdmFsdWUgZm9yIHVzZSBpbiBIVFRQIGhlYWRlclxyXG5cclxuZXhwb3J0cy5lc2NhcGVIZWFkZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XHJcblxyXG4gICAgLy8gQWxsb3dlZCB2YWx1ZSBjaGFyYWN0ZXJzOiAhIyQlJicoKSorLC0uLzo7PD0+P0BbXV5fYHt8fX4gYW5kIHNwYWNlLCBhLXosIEEtWiwgMC05LCBcXCwgXCJcclxuXHJcbiAgICBleHBvcnRzLmFzc2VydChhdHRyaWJ1dGUubWF0Y2goL15bIFxcd1xcISNcXCQlJidcXChcXClcXCpcXCssXFwtXFwuXFwvXFw6OzxcXD0+XFw/QFxcW1xcXVxcXmBcXHtcXHxcXH1+XFxcIlxcXFxdKiQvKSwgJ0JhZCBhdHRyaWJ1dGUgdmFsdWUgKCcgKyBhdHRyaWJ1dGUgKyAnKScpO1xyXG5cclxuICAgIHJldHVybiBhdHRyaWJ1dGUucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9cXFwiL2csICdcXFxcXCInKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVzY2FwZSBxdW90ZXMgYW5kIHNsYXNoXHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5lc2NhcGVIdG1sID0gZnVuY3Rpb24gKHN0cmluZykge1xyXG5cclxuICAgIHJldHVybiBFc2NhcGUuZXNjYXBlSHRtbChzdHJpbmcpO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuZXNjYXBlSmF2YVNjcmlwdCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuXHJcbiAgICByZXR1cm4gRXNjYXBlLmVzY2FwZUphdmFTY3JpcHQoc3RyaW5nKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG52YXIgZXZlbnQgPSB7XHJcbiAgICB0aW1lc3RhbXA6IG5vdy5nZXRUaW1lKCksXHJcbiAgICB0YWdzOiBbJ3RhZyddLFxyXG4gICAgZGF0YTogeyBzb21lOiAnZGF0YScgfVxyXG59O1xyXG4qL1xyXG5cclxuZXhwb3J0cy5jb25zb2xlRnVuYyA9IGNvbnNvbGUubG9nO1xyXG5cclxuZXhwb3J0cy5wcmludEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblxyXG4gICAgdmFyIHBhZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cclxuICAgICAgICByZXR1cm4gKHZhbHVlIDwgMTAgPyAnMCcgOiAnJykgKyB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKGV2ZW50LnRpbWVzdGFtcCk7XHJcbiAgICB2YXIgdGltZXN0cmluZyA9IChub3cuZ2V0WWVhcigpIC0gMTAwKS50b1N0cmluZygpICtcclxuICAgICAgICBwYWQobm93LmdldE1vbnRoKCkgKyAxKSArXHJcbiAgICAgICAgcGFkKG5vdy5nZXREYXRlKCkpICtcclxuICAgICAgICAnLycgK1xyXG4gICAgICAgIHBhZChub3cuZ2V0SG91cnMoKSkgK1xyXG4gICAgICAgIHBhZChub3cuZ2V0TWludXRlcygpKSArXHJcbiAgICAgICAgcGFkKG5vdy5nZXRTZWNvbmRzKCkpICtcclxuICAgICAgICAnLicgK1xyXG4gICAgICAgIG5vdy5nZXRNaWxsaXNlY29uZHMoKTtcclxuXHJcbiAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XHJcbiAgICBpZiAodHlwZW9mIGV2ZW50LmRhdGEgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZGF0YSA9IEpTT04uc3RyaW5naWZ5KGV2ZW50LmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBkYXRhID0gJ0pTT04gRXJyb3I6ICcgKyBlLm1lc3NhZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBvdXRwdXQgPSB0aW1lc3RyaW5nICsgJywgJyArIGV2ZW50LnRhZ3NbMF0gKyAnLCAnICsgZGF0YTtcclxuICAgIGV4cG9ydHMuY29uc29sZUZ1bmMob3V0cHV0KTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLm5leHRUaWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmdzKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn07XHJcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpLHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfYnVmZmVyXCIpLkJ1ZmZlcikiLCIoZnVuY3Rpb24ocHJvY2VzcyxCdWZmZXIpey8vIExvYWQgbW9kdWxlc1xuXG52YXIgRGdyYW0gPSByZXF1aXJlKCdkZ3JhbScpO1xudmFyIERucyA9IHJlcXVpcmUoJ2RucycpO1xudmFyIEhvZWsgPSByZXF1aXJlKCdob2VrJyk7XG5cblxuLy8gRGVjbGFyZSBpbnRlcm5hbHNcblxudmFyIGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMudGltZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgc2V0dGluZ3MgPSBIb2VrLmNsb25lKG9wdGlvbnMpO1xuICAgIHNldHRpbmdzLmhvc3QgPSBzZXR0aW5ncy5ob3N0IHx8ICdwb29sLm50cC5vcmcnO1xuICAgIHNldHRpbmdzLnBvcnQgPSBzZXR0aW5ncy5wb3J0IHx8IDEyMztcbiAgICBzZXR0aW5ncy5yZXNvbHZlUmVmZXJlbmNlID0gc2V0dGluZ3MucmVzb2x2ZVJlZmVyZW5jZSB8fCBmYWxzZTtcblxuICAgIC8vIERlY2xhcmUgdmFyaWFibGVzIHVzZWQgYnkgY2FsbGJhY2tcblxuICAgIHZhciB0aW1lb3V0SWQgPSAwO1xuICAgIHZhciBzZW50ID0gMDtcblxuICAgIC8vIEVuc3VyZSBjYWxsYmFjayBpcyBvbmx5IGNhbGxlZCBvbmNlXG5cbiAgICB2YXIgaXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgIHZhciBmaW5pc2ggPSBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcblxuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIGlzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIENyZWF0ZSBVRFAgc29ja2V0XG5cbiAgICB2YXIgc29ja2V0ID0gRGdyYW0uY3JlYXRlU29ja2V0KCd1ZHA0Jyk7XG5cbiAgICBzb2NrZXQub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG5cbiAgICAgICAgcmV0dXJuIGZpbmlzaChlcnIpO1xuICAgIH0pO1xuXG4gICAgLy8gTGlzdGVuIHRvIGluY29taW5nIG1lc3NhZ2VzXG5cbiAgICBzb2NrZXQub24oJ21lc3NhZ2UnLCBmdW5jdGlvbiAoYnVmZmVyLCByaW5mbykge1xuXG4gICAgICAgIHZhciByZWNlaXZlZCA9IERhdGUubm93KCk7XG5cbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgaW50ZXJuYWxzLk50cE1lc3NhZ2UoYnVmZmVyKTtcbiAgICAgICAgaWYgKCFtZXNzYWdlLmlzVmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5pc2gobmV3IEVycm9yKCdJbnZhbGlkIHNlcnZlciByZXNwb25zZScpLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXNzYWdlLm9yaWdpbmF0ZVRpbWVzdGFtcCAhPT0gc2VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaChuZXcgRXJyb3IoJ1dyb25nIG9yaWdpbmF0ZSB0aW1lc3RhbXAnKSwgbWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaW1lc3RhbXAgTmFtZSAgICAgICAgICBJRCAgIFdoZW4gR2VuZXJhdGVkXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyBPcmlnaW5hdGUgVGltZXN0YW1wICAgICBUMSAgIHRpbWUgcmVxdWVzdCBzZW50IGJ5IGNsaWVudFxuICAgICAgICAvLyBSZWNlaXZlIFRpbWVzdGFtcCAgICAgICBUMiAgIHRpbWUgcmVxdWVzdCByZWNlaXZlZCBieSBzZXJ2ZXJcbiAgICAgICAgLy8gVHJhbnNtaXQgVGltZXN0YW1wICAgICAgVDMgICB0aW1lIHJlcGx5IHNlbnQgYnkgc2VydmVyXG4gICAgICAgIC8vIERlc3RpbmF0aW9uIFRpbWVzdGFtcCAgIFQ0ICAgdGltZSByZXBseSByZWNlaXZlZCBieSBjbGllbnRcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIHJvdW5kdHJpcCBkZWxheSBkIGFuZCBzeXN0ZW0gY2xvY2sgb2Zmc2V0IHQgYXJlIGRlZmluZWQgYXM6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGQgPSAoVDQgLSBUMSkgLSAoVDMgLSBUMikgICAgIHQgPSAoKFQyIC0gVDEpICsgKFQzIC0gVDQpKSAvIDJcblxuICAgICAgICB2YXIgVDEgPSBtZXNzYWdlLm9yaWdpbmF0ZVRpbWVzdGFtcDtcbiAgICAgICAgdmFyIFQyID0gbWVzc2FnZS5yZWNlaXZlVGltZXN0YW1wO1xuICAgICAgICB2YXIgVDMgPSBtZXNzYWdlLnRyYW5zbWl0VGltZXN0YW1wO1xuICAgICAgICB2YXIgVDQgPSByZWNlaXZlZDtcblxuICAgICAgICBtZXNzYWdlLmQgPSAoVDQgLSBUMSkgLSAoVDMgLSBUMik7XG4gICAgICAgIG1lc3NhZ2UudCA9ICgoVDIgLSBUMSkgKyAoVDMgLSBUNCkpIC8gMjtcbiAgICAgICAgbWVzc2FnZS5yZWNlaXZlZExvY2FsbHkgPSByZWNlaXZlZDtcblxuICAgICAgICBpZiAoIXNldHRpbmdzLnJlc29sdmVSZWZlcmVuY2UgfHxcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3RyYXR1bSAhPT0gJ3NlY29uZGFyeScpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaChudWxsLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc29sdmUgcmVmZXJlbmNlIElQIGFkZHJlc3NcblxuICAgICAgICBEbnMucmV2ZXJzZShtZXNzYWdlLnJlZmVyZW5jZUlkLCBmdW5jdGlvbiAoZXJyLCBkb21haW5zKSB7XG5cbiAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5yZWZlcmVuY2VIb3N0ID0gZG9tYWluc1swXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaChudWxsLCBtZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBTZXQgdGltZW91dFxuXG4gICAgaWYgKHNldHRpbmdzLnRpbWVvdXQpIHtcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gZmluaXNoKG5ldyBFcnJvcignVGltZW91dCcpKTtcbiAgICAgICAgfSwgc2V0dGluZ3MudGltZW91dCk7XG4gICAgfVxuXG4gICAgLy8gQ29uc3RydWN0IE5UUCBtZXNzYWdlXG5cbiAgICB2YXIgbWVzc2FnZSA9IG5ldyBCdWZmZXIoNDgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDg7IGkrKykgeyAgICAgICAgICAgICAgICAgICAgICAvLyBaZXJvIG1lc3NhZ2VcbiAgICAgICAgbWVzc2FnZVtpXSA9IDA7XG4gICAgfVxuXG4gICAgbWVzc2FnZVswXSA9ICgwIDw8IDYpICsgKDQgPDwgMykgKyAoMyA8PCAwKSAgICAgICAgIC8vIFNldCB2ZXJzaW9uIG51bWJlciB0byA0IGFuZCBNb2RlIHRvIDMgKGNsaWVudClcbiAgICBzZW50ID0gRGF0ZS5ub3coKTtcbiAgICBpbnRlcm5hbHMuZnJvbU1zZWNzKHNlbnQsIG1lc3NhZ2UsIDQwKTsgICAgICAgICAgICAgICAvLyBTZXQgdHJhbnNtaXQgdGltZXN0YW1wIChyZXR1cm5zIGFzIG9yaWdpbmF0ZSlcblxuICAgIC8vIFNlbmQgTlRQIHJlcXVlc3RcblxuICAgIHNvY2tldC5zZW5kKG1lc3NhZ2UsIDAsIG1lc3NhZ2UubGVuZ3RoLCBzZXR0aW5ncy5wb3J0LCBzZXR0aW5ncy5ob3N0LCBmdW5jdGlvbiAoZXJyLCBieXRlcykge1xuXG4gICAgICAgIGlmIChlcnIgfHxcbiAgICAgICAgICAgIGJ5dGVzICE9PSA0OCkge1xuXG4gICAgICAgICAgICByZXR1cm4gZmluaXNoKGVyciB8fCBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBzZW5kIGVudGlyZSBtZXNzYWdlJykpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5cbmludGVybmFscy5OdHBNZXNzYWdlID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuXG4gICAgdGhpcy5pc1ZhbGlkID0gZmFsc2U7XG5cbiAgICAvLyBWYWxpZGF0ZVxuXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggIT09IDQ4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBMZWFwIGluZGljYXRvclxuXG4gICAgdmFyIGxpID0gKGJ1ZmZlclswXSA+PiA2KTtcbiAgICBzd2l0Y2ggKGxpKSB7XG4gICAgICAgIGNhc2UgMDogdGhpcy5sZWFwSW5kaWNhdG9yID0gJ25vLXdhcm5pbmcnOyBicmVhaztcbiAgICAgICAgY2FzZSAxOiB0aGlzLmxlYXBJbmRpY2F0b3IgPSAnbGFzdC1taW51dGUtNjEnOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiB0aGlzLmxlYXBJbmRpY2F0b3IgPSAnbGFzdC1taW51dGUtNTknOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiB0aGlzLmxlYXBJbmRpY2F0b3IgPSAnYWxhcm0nOyBicmVhaztcbiAgICB9XG5cbiAgICAvLyBWZXJzaW9uXG5cbiAgICB2YXIgdm4gPSAoKGJ1ZmZlclswXSAmIDB4MzgpID4+IDMpO1xuICAgIHRoaXMudmVyc2lvbiA9IHZuO1xuXG4gICAgLy8gTW9kZVxuXG4gICAgdmFyIG1vZGUgPSAoYnVmZmVyWzBdICYgMHg3KTtcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgY2FzZSAxOiB0aGlzLm1vZGUgPSAnc3ltbWV0cmljLWFjdGl2ZSc7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IHRoaXMubW9kZSA9ICdzeW1tZXRyaWMtcGFzc2l2ZSc7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IHRoaXMubW9kZSA9ICdjbGllbnQnOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiB0aGlzLm1vZGUgPSAnc2VydmVyJzsgYnJlYWs7XG4gICAgICAgIGNhc2UgNTogdGhpcy5tb2RlID0gJ2Jyb2FkY2FzdCc7IGJyZWFrO1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgY2FzZSA3OiB0aGlzLm1vZGUgPSAncmVzZXJ2ZWQnOyBicmVhaztcbiAgICB9XG5cbiAgICAvLyBTdHJhdHVtXG5cbiAgICB2YXIgc3RyYXR1bSA9IGJ1ZmZlclsxXTtcbiAgICBpZiAoc3RyYXR1bSA9PT0gMCkge1xuICAgICAgICB0aGlzLnN0cmF0dW0gPSAnZGVhdGgnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdHJhdHVtID09PSAxKSB7XG4gICAgICAgIHRoaXMuc3RyYXR1bSA9ICdwcmltYXJ5JztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RyYXR1bSA8PSAxNSkge1xuICAgICAgICB0aGlzLnN0cmF0dW0gPSAnc2Vjb25kYXJ5JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuc3RyYXR1bSA9ICdyZXNlcnZlZCc7XG4gICAgfVxuXG4gICAgLy8gUG9sbCBpbnRlcnZhbCAobXNlYylcblxuICAgIHRoaXMucG9sbEludGVydmFsID0gTWF0aC5yb3VuZChNYXRoLnBvdygyLCBidWZmZXJbMl0pKSAqIDEwMDA7XG5cbiAgICAvLyBQcmVjaXNpb24gKG1zZWNzKVxuXG4gICAgdGhpcy5wcmVjaXNpb24gPSBNYXRoLnBvdygyLCBidWZmZXJbM10pICogMTAwMDtcblxuICAgIC8vIFJvb3QgZGVsYXkgKG1zZWNzKVxuXG4gICAgdmFyIHJvb3REZWxheSA9IDI1NiAqICgyNTYgKiAoMjU2ICogYnVmZmVyWzRdICsgYnVmZmVyWzVdKSArIGJ1ZmZlcls2XSkgKyBidWZmZXJbN107XG4gICAgdGhpcy5yb290RGVsYXkgPSAxMDAwICogKHJvb3REZWxheSAvIDB4MTAwMDApO1xuXG4gICAgLy8gUm9vdCBkaXNwZXJzaW9uIChtc2VjcylcblxuICAgIHRoaXMucm9vdERpc3BlcnNpb24gPSAoKGJ1ZmZlcls4XSA8PCA4KSArIGJ1ZmZlcls5XSArICgoYnVmZmVyWzEwXSA8PCA4KSArIGJ1ZmZlclsxMV0pIC8gTWF0aC5wb3coMiwgMTYpKSAqIDEwMDA7XG5cbiAgICAvLyBSZWZlcmVuY2UgaWRlbnRpZmllclxuXG4gICAgdGhpcy5yZWZlcmVuY2VJZCA9ICcnO1xuICAgIHN3aXRjaCAodGhpcy5zdHJhdHVtKSB7XG4gICAgICAgIGNhc2UgJ2RlYXRoJzpcbiAgICAgICAgY2FzZSAncHJpbWFyeSc6XG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jZUlkID0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXJbMTJdKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZmVyWzEzXSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlclsxNF0pICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXJbMTVdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzZWNvbmRhcnknOlxuICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2VJZCA9ICcnICsgYnVmZmVyWzEyXSArICcuJyArIGJ1ZmZlclsxM10gKyAnLicgKyBidWZmZXJbMTRdICsgJy4nICsgYnVmZmVyWzE1XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFJlZmVyZW5jZSB0aW1lc3RhbXBcblxuICAgIHRoaXMucmVmZXJlbmNlVGltZXN0YW1wID0gaW50ZXJuYWxzLnRvTXNlY3MoYnVmZmVyLCAxNik7XG5cbiAgICAvLyBPcmlnaW5hdGUgdGltZXN0YW1wXG5cbiAgICB0aGlzLm9yaWdpbmF0ZVRpbWVzdGFtcCA9IGludGVybmFscy50b01zZWNzKGJ1ZmZlciwgMjQpO1xuXG4gICAgLy8gUmVjZWl2ZSB0aW1lc3RhbXBcblxuICAgIHRoaXMucmVjZWl2ZVRpbWVzdGFtcCA9IGludGVybmFscy50b01zZWNzKGJ1ZmZlciwgMzIpO1xuXG4gICAgLy8gVHJhbnNtaXQgdGltZXN0YW1wXG5cbiAgICB0aGlzLnRyYW5zbWl0VGltZXN0YW1wID0gaW50ZXJuYWxzLnRvTXNlY3MoYnVmZmVyLCA0MCk7XG5cbiAgICAvLyBWYWxpZGF0ZVxuXG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gNCAmJlxuICAgICAgICB0aGlzLnN0cmF0dW0gIT09ICdyZXNlcnZlZCcgJiZcbiAgICAgICAgdGhpcy5tb2RlID09PSAnc2VydmVyJyAmJlxuICAgICAgICB0aGlzLm9yaWdpbmF0ZVRpbWVzdGFtcCAmJlxuICAgICAgICB0aGlzLnJlY2VpdmVUaW1lc3RhbXAgJiZcbiAgICAgICAgdGhpcy50cmFuc21pdFRpbWVzdGFtcCkge1xuXG4gICAgICAgIHRoaXMuaXNWYWxpZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbmludGVybmFscy50b01zZWNzID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0KSB7XG5cbiAgICB2YXIgc2Vjb25kcyA9IDA7XG4gICAgdmFyIGZyYWN0aW9uID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICAgIHNlY29uZHMgPSAoc2Vjb25kcyAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV07XG4gICAgfVxuXG4gICAgZm9yIChpID0gNDsgaSA8IDg7ICsraSkge1xuICAgICAgICBmcmFjdGlvbiA9IChmcmFjdGlvbiAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV07XG4gICAgfVxuXG4gICAgcmV0dXJuICgoc2Vjb25kcyAtIDIyMDg5ODg4MDAgKyAoZnJhY3Rpb24gLyBNYXRoLnBvdygyLCAzMikpKSAqIDEwMDApO1xufTtcblxuXG5pbnRlcm5hbHMuZnJvbU1zZWNzID0gZnVuY3Rpb24gKHRzLCBidWZmZXIsIG9mZnNldCkge1xuXG4gICAgdmFyIHNlY29uZHMgPSBNYXRoLmZsb29yKHRzIC8gMTAwMCkgKyAyMjA4OTg4ODAwO1xuICAgIHZhciBmcmFjdGlvbiA9IE1hdGgucm91bmQoKHRzICUgMTAwMCkgLyAxMDAwICogTWF0aC5wb3coMiwgMzIpKTtcblxuICAgIGJ1ZmZlcltvZmZzZXQgKyAwXSA9IChzZWNvbmRzICYgMHhGRjAwMDAwMCkgPj4gMjQ7XG4gICAgYnVmZmVyW29mZnNldCArIDFdID0gKHNlY29uZHMgJiAweDAwRkYwMDAwKSA+PiAxNjtcbiAgICBidWZmZXJbb2Zmc2V0ICsgMl0gPSAoc2Vjb25kcyAmIDB4MDAwMEZGMDApID4+IDg7XG4gICAgYnVmZmVyW29mZnNldCArIDNdID0gKHNlY29uZHMgJiAweDAwMDAwMEZGKTtcblxuICAgIGJ1ZmZlcltvZmZzZXQgKyA0XSA9IChmcmFjdGlvbiAmIDB4RkYwMDAwMDApID4+IDI0O1xuICAgIGJ1ZmZlcltvZmZzZXQgKyA1XSA9IChmcmFjdGlvbiAmIDB4MDBGRjAwMDApID4+IDE2O1xuICAgIGJ1ZmZlcltvZmZzZXQgKyA2XSA9IChmcmFjdGlvbiAmIDB4MDAwMEZGMDApID4+IDg7XG4gICAgYnVmZmVyW29mZnNldCArIDddID0gKGZyYWN0aW9uICYgMHgwMDAwMDBGRik7XG59O1xuXG5cbi8vIE9mZnNldCBzaW5nbGV0b25cblxuaW50ZXJuYWxzLmxhc3QgPSB7XG4gICAgb2Zmc2V0OiAwLFxuICAgIGV4cGlyZXM6IDAsXG4gICAgaG9zdDogJycsXG4gICAgcG9ydDogMFxufTtcblxuXG5leHBvcnRzLm9mZnNldCA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgY2xvY2tTeW5jUmVmcmVzaCA9IG9wdGlvbnMuY2xvY2tTeW5jUmVmcmVzaCB8fCAyNCAqIDYwICogNjAgKiAxMDAwOyAgICAgICAgICAgICAgICAgICAgLy8gRGFpbHlcblxuICAgIGlmIChpbnRlcm5hbHMubGFzdC5vZmZzZXQgJiZcbiAgICAgICAgaW50ZXJuYWxzLmxhc3QuaG9zdCA9PT0gb3B0aW9ucy5ob3N0ICYmXG4gICAgICAgIGludGVybmFscy5sYXN0LnBvcnQgPT09IG9wdGlvbnMucG9ydCAmJlxuICAgICAgICBub3cgPCBpbnRlcm5hbHMubGFzdC5leHBpcmVzKSB7XG5cbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBpbnRlcm5hbHMubGFzdC5vZmZzZXQpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXhwb3J0cy50aW1lKG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIHRpbWUpIHtcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGludGVybmFscy5sYXN0ID0ge1xuICAgICAgICAgICAgb2Zmc2V0OiBNYXRoLnJvdW5kKHRpbWUudCksXG4gICAgICAgICAgICBleHBpcmVzOiBub3cgKyBjbG9ja1N5bmNSZWZyZXNoLFxuICAgICAgICAgICAgaG9zdDogb3B0aW9ucy5ob3N0LFxuICAgICAgICAgICAgcG9ydDogb3B0aW9ucy5wb3J0XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGludGVybmFscy5sYXN0Lm9mZnNldCk7XG4gICAgfSk7XG59O1xuXG5cbi8vIE5vdyBzaW5nbGV0b25cblxuaW50ZXJuYWxzLm5vdyA9IHtcbiAgICBpbnRlcnZhbElkOiAwXG59O1xuXG5cbmV4cG9ydHMuc3RhcnQgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKGludGVybmFscy5ub3cuaW50ZXJ2YWxJZCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXhwb3J0cy5vZmZzZXQob3B0aW9ucywgZnVuY3Rpb24gKGVyciwgb2Zmc2V0KSB7XG5cbiAgICAgICAgaW50ZXJuYWxzLm5vdy5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBleHBvcnRzLm9mZnNldChvcHRpb25zLCBmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICB9LCBvcHRpb25zLmNsb2NrU3luY1JlZnJlc2ggfHwgMjQgKiA2MCAqIDYwICogMTAwMCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEYWlseVxuXG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH0pO1xufTtcblxuXG5leHBvcnRzLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAoIWludGVybmFscy5ub3cuaW50ZXJ2YWxJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2xlYXJJbnRlcnZhbChpbnRlcm5hbHMubm93LmludGVydmFsSWQpO1xuICAgIGludGVybmFscy5ub3cuaW50ZXJ2YWxJZCA9IDA7XG59O1xuXG5cbmV4cG9ydHMuaXNMaXZlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuICEhaW50ZXJuYWxzLm5vdy5pbnRlcnZhbElkO1xufTtcblxuXG5leHBvcnRzLm5vdyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmICghZXhwb3J0cy5pc0xpdmUoKSB8fFxuICAgICAgICBub3cgPj0gaW50ZXJuYWxzLmxhc3QuZXhwaXJlcykge1xuXG4gICAgICAgIHJldHVybiBub3c7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vdyArIGludGVybmFscy5sYXN0Lm9mZnNldDtcbn07XG5cblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpLHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfYnVmZmVyXCIpLkJ1ZmZlcikiLCIvLyBMb2FkIG1vZHVsZXNcblxudmFyIEh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG52YXIgTm9kZVV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgSG9layA9IHJlcXVpcmUoJ2hvZWsnKTtcblxuXG4vLyBEZWNsYXJlIGludGVybmFsc1xuXG52YXIgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLkJvb20gPSBmdW5jdGlvbiAoLyogKG5ldyBFcnJvcikgb3IgKGNvZGUsIG1lc3NhZ2UpICovKSB7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBIb2VrLmFzc2VydCh0aGlzLmNvbnN0cnVjdG9yID09PSBpbnRlcm5hbHMuQm9vbSwgJ0Vycm9yIG11c3QgYmUgaW5zdGFudGlhdGVkIHVzaW5nIG5ldycpO1xuXG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmlzQm9vbSA9IHRydWU7XG5cbiAgICB0aGlzLnJlc3BvbnNlID0ge1xuICAgICAgICBjb2RlOiAwLFxuICAgICAgICBwYXlsb2FkOiB7fSxcbiAgICAgICAgaGVhZGVyczoge31cbiAgICAgICAgLy8gdHlwZTogJ2NvbnRlbnQtdHlwZSdcbiAgICB9O1xuXG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cbiAgICAgICAgLy8gRXJyb3JcblxuICAgICAgICB2YXIgZXJyb3IgPSBhcmd1bWVudHNbMF07XG5cbiAgICAgICAgdGhpcy5kYXRhID0gZXJyb3I7XG4gICAgICAgIHRoaXMucmVzcG9uc2UuY29kZSA9IGVycm9yLmNvZGUgfHwgNTAwO1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICAvLyBjb2RlLCBtZXNzYWdlXG5cbiAgICAgICAgdmFyIGNvZGUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBtZXNzYWdlID0gYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KCFpc05hTihwYXJzZUZsb2F0KGNvZGUpKSAmJiBpc0Zpbml0ZShjb2RlKSAmJiBjb2RlID49IDQwMCwgJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXIgKDQwMCspJyk7XG5cbiAgICAgICAgdGhpcy5yZXNwb25zZS5jb2RlID0gY29kZTtcbiAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXNwb25zZSBmb3JtYXRcblxuICAgIHRoaXMucmVmb3JtYXQoKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuTm9kZVV0aWwuaW5oZXJpdHMoaW50ZXJuYWxzLkJvb20sIEVycm9yKTtcblxuXG5pbnRlcm5hbHMuQm9vbS5wcm90b3R5cGUucmVmb3JtYXQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLnJlc3BvbnNlLnBheWxvYWQuY29kZSA9IHRoaXMucmVzcG9uc2UuY29kZTtcbiAgICB0aGlzLnJlc3BvbnNlLnBheWxvYWQuZXJyb3IgPSBIdHRwLlNUQVRVU19DT0RFU1t0aGlzLnJlc3BvbnNlLmNvZGVdIHx8ICdVbmtub3duJztcbiAgICBpZiAodGhpcy5tZXNzYWdlKSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2UucGF5bG9hZC5tZXNzYWdlID0gSG9lay5lc2NhcGVIdG1sKHRoaXMubWVzc2FnZSk7ICAgICAgICAgLy8gUHJldmVudCBYU1MgZnJvbSBlcnJvciBtZXNzYWdlXG4gICAgfVxufTtcblxuXG4vLyBVdGlsaXRpZXNcblxuaW50ZXJuYWxzLkJvb20uYmFkUmVxdWVzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cbiAgICByZXR1cm4gbmV3IGludGVybmFscy5Cb29tKDQwMCwgbWVzc2FnZSk7XG59O1xuXG5cbmludGVybmFscy5Cb29tLnVuYXV0aG9yaXplZCA9IGZ1bmN0aW9uIChtZXNzYWdlLCBzY2hlbWUsIGF0dHJpYnV0ZXMpIHsgICAgICAgICAgLy8gT3IgZnVuY3Rpb24gKG1lc3NhZ2UsIHd3d0F1dGhlbnRpY2F0ZVtdKVxuXG4gICAgdmFyIGVyciA9IG5ldyBpbnRlcm5hbHMuQm9vbSg0MDEsIG1lc3NhZ2UpO1xuXG4gICAgaWYgKCFzY2hlbWUpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG5cbiAgICB2YXIgd3d3QXV0aGVudGljYXRlID0gJyc7XG5cbiAgICBpZiAodHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAvLyBmdW5jdGlvbiAobWVzc2FnZSwgc2NoZW1lLCBhdHRyaWJ1dGVzKVxuXG4gICAgICAgIHd3d0F1dGhlbnRpY2F0ZSA9IHNjaGVtZTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gbmFtZXMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICAgICAgICAgIHd3d0F1dGhlbnRpY2F0ZSArPSAnLCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lc1tpXV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID09PSB1bmRlZmluZWQpIHsgICAgICAgICAgICAgIC8vIFZhbHVlIGNhbiBiZSB6ZXJvXG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd3d3QXV0aGVudGljYXRlICs9ICcgJyArIG5hbWVzW2ldICsgJz1cIicgKyBIb2VrLmVzY2FwZUhlYWRlckF0dHJpYnV0ZSh2YWx1ZS50b1N0cmluZygpKSArICdcIic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICB3d3dBdXRoZW50aWNhdGUgKz0gJywnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3d3QXV0aGVudGljYXRlICs9ICcgZXJyb3I9XCInICsgSG9lay5lc2NhcGVIZWFkZXJBdHRyaWJ1dGUobWVzc2FnZSkgKyAnXCInO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyLmlzTWlzc2luZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgLy8gZnVuY3Rpb24gKG1lc3NhZ2UsIHd3d0F1dGhlbnRpY2F0ZVtdKVxuXG4gICAgICAgIHZhciB3d3dBcnJheSA9IHNjaGVtZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gd3d3QXJyYXkubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICB3d3dBdXRoZW50aWNhdGUgKz0gJywgJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd3d3QXV0aGVudGljYXRlICs9IHd3d0FycmF5W2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXJyLnJlc3BvbnNlLmhlYWRlcnNbJ1dXVy1BdXRoZW50aWNhdGUnXSA9IHd3d0F1dGhlbnRpY2F0ZTtcblxuICAgIHJldHVybiBlcnI7XG59O1xuXG5cbmludGVybmFscy5Cb29tLmNsaWVudFRpbWVvdXQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuXG4gICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQm9vbSg0MDgsIG1lc3NhZ2UpO1xufTtcblxuXG5pbnRlcm5hbHMuQm9vbS5zZXJ2ZXJUaW1lb3V0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblxuICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkJvb20oNTAzLCBtZXNzYWdlKTtcbn07XG5cblxuaW50ZXJuYWxzLkJvb20uZm9yYmlkZGVuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblxuICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkJvb20oNDAzLCBtZXNzYWdlKTtcbn07XG5cblxuaW50ZXJuYWxzLkJvb20ubm90Rm91bmQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuXG4gICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQm9vbSg0MDQsIG1lc3NhZ2UpO1xufTtcblxuXG5pbnRlcm5hbHMuQm9vbS5pbnRlcm5hbCA9IGZ1bmN0aW9uIChtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICB2YXIgZXJyID0gbmV3IGludGVybmFscy5Cb29tKDUwMCwgbWVzc2FnZSk7XG5cbiAgICBpZiAoZGF0YSAmJiBkYXRhLnN0YWNrKSB7XG4gICAgICAgIGVyci50cmFjZSA9IGRhdGEuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgICBlcnIub3V0dGVyVHJhY2UgPSBIb2VrLmRpc3BsYXlTdGFjaygxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVyci50cmFjZSA9IEhvZWsuZGlzcGxheVN0YWNrKDEpO1xuICAgIH1cblxuICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICBlcnIucmVzcG9uc2UucGF5bG9hZC5tZXNzYWdlID0gJ0FuIGludGVybmFsIHNlcnZlciBlcnJvciBvY2N1cnJlZCc7ICAgICAgICAgICAgICAgICAgICAgLy8gSGlkZSBhY3R1YWwgZXJyb3IgZnJvbSB1c2VyXG5cbiAgICByZXR1cm4gZXJyO1xufTtcblxuXG5pbnRlcm5hbHMuQm9vbS5wYXNzVGhyb3VnaCA9IGZ1bmN0aW9uIChjb2RlLCBwYXlsb2FkLCBjb250ZW50VHlwZSwgaGVhZGVycykge1xuXG4gICAgdmFyIGVyciA9IG5ldyBpbnRlcm5hbHMuQm9vbSg1MDAsICdQYXNzLXRocm91Z2gnKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDUwMCBjb2RlIGlzIG9ubHkgdXNlZCB0byBpbml0aWFsaXplXG5cbiAgICBlcnIuZGF0YSA9IHtcbiAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgdHlwZTogY29udGVudFR5cGVcbiAgICB9O1xuXG4gICAgZXJyLnJlc3BvbnNlLmNvZGUgPSBjb2RlO1xuICAgIGVyci5yZXNwb25zZS50eXBlID0gY29udGVudFR5cGU7XG4gICAgZXJyLnJlc3BvbnNlLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIGVyci5yZXNwb25zZS5wYXlsb2FkID0gcGF5bG9hZDtcblxuICAgIHJldHVybiBlcnI7XG59O1xuXG5cbiIsIihmdW5jdGlvbihCdWZmZXIpey8vIERlY2xhcmUgaW50ZXJuYWxzXG5cbnZhciBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmVzY2FwZUphdmFTY3JpcHQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcblxuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHZhciBlc2NhcGVkID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBpbnB1dC5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG5cbiAgICAgICAgdmFyIGNoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoaW50ZXJuYWxzLmlzU2FmZShjaGFyQ29kZSkpIHtcbiAgICAgICAgICAgIGVzY2FwZWQgKz0gaW5wdXRbaV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlc2NhcGVkICs9IGludGVybmFscy5lc2NhcGVKYXZhU2NyaXB0Q2hhcihjaGFyQ29kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXNjYXBlZDtcbn07XG5cblxuZXhwb3J0cy5lc2NhcGVIdG1sID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgZXNjYXBlZCA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gaW5wdXQubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuXG4gICAgICAgIHZhciBjaGFyQ29kZSA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKGludGVybmFscy5pc1NhZmUoY2hhckNvZGUpKSB7XG4gICAgICAgICAgICBlc2NhcGVkICs9IGlucHV0W2ldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXNjYXBlZCArPSBpbnRlcm5hbHMuZXNjYXBlSHRtbENoYXIoY2hhckNvZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVzY2FwZWQ7XG59O1xuXG5cbmludGVybmFscy5lc2NhcGVKYXZhU2NyaXB0Q2hhciA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuXG4gICAgaWYgKGNoYXJDb2RlID49IDI1Nikge1xuICAgICAgICByZXR1cm4gJ1xcXFx1JyArIGludGVybmFscy5wYWRMZWZ0KCcnICsgY2hhckNvZGUsIDQpO1xuICAgIH1cblxuICAgIHZhciBoZXhWYWx1ZSA9IG5ldyBCdWZmZXIoU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSksICdhc2NpaScpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICByZXR1cm4gJ1xcXFx4JyArIGludGVybmFscy5wYWRMZWZ0KGhleFZhbHVlLCAyKTtcbn07XG5cblxuaW50ZXJuYWxzLmVzY2FwZUh0bWxDaGFyID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG5cbiAgICB2YXIgbmFtZWRFc2NhcGUgPSBpbnRlcm5hbHMubmFtZWRIdG1sW2NoYXJDb2RlXTtcbiAgICBpZiAodHlwZW9mIG5hbWVkRXNjYXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbmFtZWRFc2NhcGU7XG4gICAgfVxuXG4gICAgaWYgKGNoYXJDb2RlID49IDI1Nikge1xuICAgICAgICByZXR1cm4gJyYjJyArIGNoYXJDb2RlICsgJzsnO1xuICAgIH1cblxuICAgIHZhciBoZXhWYWx1ZSA9IG5ldyBCdWZmZXIoU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSksICdhc2NpaScpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICByZXR1cm4gJyYjeCcgKyBpbnRlcm5hbHMucGFkTGVmdChoZXhWYWx1ZSwgMikgKyAnOyc7XG59O1xuXG5cbmludGVybmFscy5wYWRMZWZ0ID0gZnVuY3Rpb24gKHN0ciwgbGVuKSB7XG5cbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IGxlbikge1xuICAgICAgICBzdHIgPSAnMCcgKyBzdHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbn07XG5cblxuaW50ZXJuYWxzLmlzU2FmZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuXG4gICAgcmV0dXJuICh0eXBlb2YgaW50ZXJuYWxzLnNhZmVDaGFyQ29kZXNbY2hhckNvZGVdICE9PSAndW5kZWZpbmVkJyk7XG59O1xuXG5cbmludGVybmFscy5uYW1lZEh0bWwgPSB7XG4gICAgJzM4JzogJyZhbXA7JyxcbiAgICAnNjAnOiAnJmx0OycsXG4gICAgJzYyJzogJyZndDsnLFxuICAgICczNCc6ICcmcXVvdDsnLFxuICAgICcxNjAnOiAnJm5ic3A7JyxcbiAgICAnMTYyJzogJyZjZW50OycsXG4gICAgJzE2Myc6ICcmcG91bmQ7JyxcbiAgICAnMTY0JzogJyZjdXJyZW47JyxcbiAgICAnMTY5JzogJyZjb3B5OycsXG4gICAgJzE3NCc6ICcmcmVnOydcbn07XG5cblxuaW50ZXJuYWxzLnNhZmVDaGFyQ29kZXMgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHNhZmUgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAzMjsgaSA8IDEyMzsgKytpKSB7XG5cbiAgICAgICAgaWYgKChpID49IDk3ICYmIGkgPD0gMTIyKSB8fCAgICAgICAgIC8vIGEtelxuICAgICAgICAgICAgKGkgPj0gNjUgJiYgaSA8PSA5MCkgfHwgICAgICAgICAgLy8gQS1aXG4gICAgICAgICAgICAoaSA+PSA0OCAmJiBpIDw9IDU3KSB8fCAgICAgICAgICAvLyAwLTlcbiAgICAgICAgICAgIGkgPT09IDMyIHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIHNwYWNlXG4gICAgICAgICAgICBpID09PSA0NiB8fCAgICAgICAgICAgICAgICAgICAgICAvLyAuXG4gICAgICAgICAgICBpID09PSA0NCB8fCAgICAgICAgICAgICAgICAgICAgICAvLyAsXG4gICAgICAgICAgICBpID09PSA0NSB8fCAgICAgICAgICAgICAgICAgICAgICAvLyAtXG4gICAgICAgICAgICBpID09PSA1OCB8fCAgICAgICAgICAgICAgICAgICAgICAvLyA6XG4gICAgICAgICAgICBpID09PSA5NSkgeyAgICAgICAgICAgICAgICAgICAgICAvLyBfXG5cbiAgICAgICAgICAgIHNhZmVbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNhZmU7XG59KCkpO1xufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9idWZmZXJcIikuQnVmZmVyKSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWInKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJyk7IiwiLy8gTG9hZCBtb2R1bGVzXG5cbnZhciBDcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBCb29tID0gcmVxdWlyZSgnYm9vbScpO1xuXG5cbi8vIERlY2xhcmUgaW50ZXJuYWxzXG5cbnZhciBpbnRlcm5hbHMgPSB7fTtcblxuXG4vLyBHZW5lcmF0ZSBhIGNyeXB0b2dyYXBoaWNhbGx5IHN0cm9uZyBwc2V1ZG8tcmFuZG9tIGRhdGFcblxuZXhwb3J0cy5yYW5kb21TdHJpbmcgPSBmdW5jdGlvbiAoc2l6ZSkge1xuXG4gICAgdmFyIGJ1ZmZlciA9IGV4cG9ydHMucmFuZG9tQml0cygoc2l6ZSArIDEpICogNik7XG4gICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuXG4gICAgdmFyIHN0cmluZyA9IGJ1ZmZlci50b1N0cmluZygnYmFzZTY0JykucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJykucmVwbGFjZSgvXFw9L2csICcnKTtcbiAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIHNpemUpO1xufTtcblxuXG5leHBvcnRzLnJhbmRvbUJpdHMgPSBmdW5jdGlvbiAoYml0cykge1xuXG4gICAgaWYgKCFiaXRzIHx8XG4gICAgICAgIGJpdHMgPCAwKSB7XG5cbiAgICAgICAgcmV0dXJuIEJvb20uaW50ZXJuYWwoJ0ludmFsaWQgcmFuZG9tIGJpdHMgY291bnQnKTtcbiAgICB9XG5cbiAgICB2YXIgYnl0ZXMgPSBNYXRoLmNlaWwoYml0cyAvIDgpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBDcnlwdG8ucmFuZG9tQnl0ZXMoYnl0ZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBCb29tLmludGVybmFsKCdGYWlsZWQgZ2VuZXJhdGluZyByYW5kb20gYml0czogJyArIGVyci5tZXNzYWdlKTtcbiAgICB9XG59O1xuXG5cbi8vIENvbXBhcmUgdHdvIHN0cmluZ3MgdXNpbmcgZml4ZWQgdGltZSBhbGdvcml0aG0gKHRvIHByZXZlbnQgdGltZS1iYXNlZCBhbmFseXNpcyBvZiBNQUMgZGlnZXN0IG1hdGNoKVxuXG5leHBvcnRzLmZpeGVkVGltZUNvbXBhcmlzb24gPSBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgaWYgKHR5cGVvZiBhICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlb2YgYiAhPT0gJ3N0cmluZycpIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG1pc21hdGNoID0gKGEubGVuZ3RoID09PSBiLmxlbmd0aCA/IDAgOiAxKTtcbiAgICBpZiAobWlzbWF0Y2gpIHtcbiAgICAgICAgYiA9IGE7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gYS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIHZhciBhYyA9IGEuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGJjID0gYi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBtaXNtYXRjaCArPSAoYWMgPT09IGJjID8gMCA6IDEpO1xuICAgIH1cblxuICAgIHJldHVybiAobWlzbWF0Y2ggPT09IDApO1xufTtcblxuXG4iLCIoZnVuY3Rpb24ocHJvY2VzcyxCdWZmZXIpey8vIExvYWQgbW9kdWxlc1xyXG5cclxudmFyIEZzID0gcmVxdWlyZSgnZnMnKTtcclxudmFyIEVzY2FwZSA9IHJlcXVpcmUoJy4vZXNjYXBlJyk7XHJcblxyXG5cclxuLy8gRGVjbGFyZSBpbnRlcm5hbHNcclxuXHJcbnZhciBpbnRlcm5hbHMgPSB7fTtcclxuXHJcblxyXG4vLyBDbG9uZSBvYmplY3Qgb3IgYXJyYXlcclxuXHJcbmV4cG9ydHMuY2xvbmUgPSBmdW5jdGlvbiAob2JqLCBzZWVuKSB7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8XHJcbiAgICAgICAgb2JqID09PSBudWxsKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcblxyXG4gICAgc2VlbiA9IHNlZW4gfHwgeyBvcmlnOiBbXSwgY29weTogW10gfTtcclxuXHJcbiAgICB2YXIgbG9va3VwID0gc2Vlbi5vcmlnLmluZGV4T2Yob2JqKTtcclxuICAgIGlmIChsb29rdXAgIT09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlZW4uY29weVtsb29rdXBdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBuZXdPYmogPSAob2JqIGluc3RhbmNlb2YgQXJyYXkpID8gW10gOiB7fTtcclxuXHJcbiAgICBzZWVuLm9yaWcucHVzaChvYmopO1xyXG4gICAgc2Vlbi5jb3B5LnB1c2gobmV3T2JqKTtcclxuXHJcbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcclxuICAgICAgICAgICAgaWYgKG9ialtpXSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgbmV3T2JqW2ldID0gbmV3IEJ1ZmZlcihvYmpbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9ialtpXSBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgICAgIG5ld09ialtpXSA9IG5ldyBEYXRlKG9ialtpXS5nZXRUaW1lKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9ialtpXSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZsYWdzID0gJycgKyAob2JqW2ldLmdsb2JhbCA/ICdnJyA6ICcnKSArIChvYmpbaV0uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArIChvYmpbaV0ubXVsdGlsaW5lID8gJ20nIDogJycpO1xyXG4gICAgICAgICAgICAgICAgbmV3T2JqW2ldID0gbmV3IFJlZ0V4cChvYmpbaV0uc291cmNlLCBmbGFncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdPYmpbaV0gPSBleHBvcnRzLmNsb25lKG9ialtpXSwgc2Vlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ld09iajtcclxufTtcclxuXHJcblxyXG4vLyBNZXJnZSBhbGwgdGhlIHByb3BlcnRpZXMgb2Ygc291cmNlIGludG8gdGFyZ2V0LCBzb3VyY2Ugd2lucyBpbiBjb25mbGljLCBhbmQgYnkgZGVmYXVsdCBudWxsIGFuZCB1bmRlZmluZWQgZnJvbSBzb3VyY2UgYXJlIGFwcGxpZWRcclxuXHJcbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGlzTnVsbE92ZXJyaWRlIC8qID0gdHJ1ZSAqLywgaXNNZXJnZUFycmF5cyAvKiA9IHRydWUgKi8pIHtcclxuXHJcbiAgICBleHBvcnRzLmFzc2VydCh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PSAnb2JqZWN0JywgJ0ludmFsaWQgdGFyZ2V0IHZhbHVlOiBtdXN0IGJlIGFuIG9iamVjdCcpO1xyXG4gICAgZXhwb3J0cy5hc3NlcnQoc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnLCAnSW52YWxpZCBzb3VyY2UgdmFsdWU6IG11c3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBvciBhbiBvYmplY3QnKTtcclxuXHJcbiAgICBpZiAoIXNvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgZXhwb3J0cy5hc3NlcnQodGFyZ2V0IGluc3RhbmNlb2YgQXJyYXksICdDYW5ub3QgbWVyZ2UgYXJyYXkgb250byBhbiBvYmplY3QnKTtcclxuICAgICAgICBpZiAoaXNNZXJnZUFycmF5cyA9PT0gZmFsc2UpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzTWVyZ2VBcnJheXMgZGVmYXVsdHMgdG8gdHJ1ZVxyXG4gICAgICAgICAgICB0YXJnZXQubGVuZ3RoID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTXVzdCBub3QgY2hhbmdlIHRhcmdldCBhc3NpZ25tZW50XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBzb3VyY2UubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgICAgICB0YXJnZXQucHVzaChzb3VyY2VbaV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XHJcbiAgICBmb3IgKHZhciBrID0gMCwga2wgPSBrZXlzLmxlbmd0aDsgayA8IGtsOyArK2spIHtcclxuICAgICAgICB2YXIga2V5ID0ga2V5c1trXTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2Vba2V5XTtcclxuICAgICAgICBpZiAodmFsdWUgJiZcclxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0YXJnZXRba2V5XSB8fFxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIHRhcmdldFtrZXldICE9PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gZXhwb3J0cy5jbG9uZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLm1lcmdlKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgaXNOdWxsT3ZlcnJpZGUsIGlzTWVyZ2VBcnJheXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkgeyAgICAgICAgICAgIC8vIEV4cGxpY2l0IHRvIHByZXNlcnZlIGVtcHR5IHN0cmluZ3NcclxuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNOdWxsT3ZlcnJpZGUgIT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG5cclxuLy8gQXBwbHkgb3B0aW9ucyB0byBhIGNvcHkgb2YgdGhlIGRlZmF1bHRzXHJcblxyXG5leHBvcnRzLmFwcGx5VG9EZWZhdWx0cyA9IGZ1bmN0aW9uIChkZWZhdWx0cywgb3B0aW9ucykge1xyXG5cclxuICAgIGV4cG9ydHMuYXNzZXJ0KGRlZmF1bHRzICYmIHR5cGVvZiBkZWZhdWx0cyA9PSAnb2JqZWN0JywgJ0ludmFsaWQgZGVmYXVsdHMgdmFsdWU6IG11c3QgYmUgYW4gb2JqZWN0Jyk7XHJcbiAgICBleHBvcnRzLmFzc2VydCghb3B0aW9ucyB8fCBvcHRpb25zID09PSB0cnVlIHx8IHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JywgJ0ludmFsaWQgb3B0aW9ucyB2YWx1ZTogbXVzdCBiZSB0cnVlLCBmYWxzeSBvciBhbiBvYmplY3QnKTtcclxuXHJcbiAgICBpZiAoIW9wdGlvbnMpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm8gb3B0aW9ucywgcmV0dXJuIG51bGxcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY29weSA9IGV4cG9ydHMuY2xvbmUoZGVmYXVsdHMpO1xyXG5cclxuICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBvcHRpb25zIGlzIHNldCB0byB0cnVlLCB1c2UgZGVmYXVsdHNcclxuICAgICAgICByZXR1cm4gY29weTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZXhwb3J0cy5tZXJnZShjb3B5LCBvcHRpb25zLCBmYWxzZSwgZmFsc2UpO1xyXG59O1xyXG5cclxuXHJcbi8vIFJlbW92ZSBkdXBsaWNhdGUgaXRlbXMgZnJvbSBhcnJheVxyXG5cclxuZXhwb3J0cy51bmlxdWUgPSBmdW5jdGlvbiAoYXJyYXksIGtleSkge1xyXG5cclxuICAgIHZhciBpbmRleCA9IHt9O1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuICAgICAgICB2YXIgaWQgPSAoa2V5ID8gYXJyYXlbaV1ba2V5XSA6IGFycmF5W2ldKTtcclxuICAgICAgICBpZiAoaW5kZXhbaWRdICE9PSB0cnVlKSB7XHJcblxyXG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XHJcbiAgICAgICAgICAgIGluZGV4W2lkXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5cclxuLy8gQ29udmVydCBhcnJheSBpbnRvIG9iamVjdFxyXG5cclxuZXhwb3J0cy5tYXBUb09iamVjdCA9IGZ1bmN0aW9uIChhcnJheSwga2V5KSB7XHJcblxyXG4gICAgaWYgKCFhcnJheSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBvYmogPSB7fTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuICAgICAgICBpZiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChhcnJheVtpXVtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICBvYmpbYXJyYXlbaV1ba2V5XV0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvYmpbYXJyYXlbaV1dID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG9iajtcclxufTtcclxuXHJcblxyXG4vLyBGaW5kIHRoZSBjb21tb24gdW5pcXVlIGl0ZW1zIGluIHR3byBhcnJheXNcclxuXHJcbmV4cG9ydHMuaW50ZXJzZWN0ID0gZnVuY3Rpb24gKGFycmF5MSwgYXJyYXkyLCBqdXN0Rmlyc3QpIHtcclxuXHJcbiAgICBpZiAoIWFycmF5MSB8fCAhYXJyYXkyKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjb21tb24gPSBbXTtcclxuICAgIHZhciBoYXNoID0gKGFycmF5MSBpbnN0YW5jZW9mIEFycmF5ID8gZXhwb3J0cy5tYXBUb09iamVjdChhcnJheTEpIDogYXJyYXkxKTtcclxuICAgIHZhciBmb3VuZCA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gYXJyYXkyLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuICAgICAgICBpZiAoaGFzaFthcnJheTJbaV1dICYmICFmb3VuZFthcnJheTJbaV1dKSB7XHJcbiAgICAgICAgICAgIGlmIChqdXN0Rmlyc3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTJbaV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbW1vbi5wdXNoKGFycmF5MltpXSk7XHJcbiAgICAgICAgICAgIGZvdW5kW2FycmF5MltpXV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKGp1c3RGaXJzdCA/IG51bGwgOiBjb21tb24pO1xyXG59O1xyXG5cclxuXHJcbi8vIEZpbmQgd2hpY2gga2V5cyBhcmUgcHJlc2VudFxyXG5cclxuZXhwb3J0cy5tYXRjaEtleXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XHJcblxyXG4gICAgdmFyIG1hdGNoZWQgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGtleXMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5c1tpXSkpIHtcclxuICAgICAgICAgICAgbWF0Y2hlZC5wdXNoKGtleXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtYXRjaGVkO1xyXG59O1xyXG5cclxuXHJcbi8vIEZsYXR0ZW4gYXJyYXlcclxuXHJcbmV4cG9ydHMuZmxhdHRlbiA9IGZ1bmN0aW9uIChhcnJheSwgdGFyZ2V0KSB7XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IHRhcmdldCB8fCBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlbaV0pKSB7XHJcbiAgICAgICAgICAgIGV4cG9ydHMuZmxhdHRlbihhcnJheVtpXSwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblxyXG4vLyBSZW1vdmUga2V5c1xyXG5cclxuZXhwb3J0cy5yZW1vdmVLZXlzID0gZnVuY3Rpb24gKG9iamVjdCwga2V5cykge1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGtleXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xyXG4gICAgICAgIGRlbGV0ZSBvYmplY3Rba2V5c1tpXV07XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuLy8gQ29udmVydCBhbiBvYmplY3Qga2V5IGNoYWluIHN0cmluZyAoJ2EuYi5jJykgdG8gcmVmZXJlbmNlIChvYmplY3RbYV1bYl1bY10pXHJcblxyXG5leHBvcnRzLnJlYWNoID0gZnVuY3Rpb24gKG9iaiwgY2hhaW4pIHtcclxuXHJcbiAgICB2YXIgcGF0aCA9IGNoYWluLnNwbGl0KCcuJyk7XHJcbiAgICB2YXIgcmVmID0gb2JqO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gcGF0aC5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XHJcbiAgICAgICAgaWYgKHJlZikge1xyXG4gICAgICAgICAgICByZWYgPSByZWZbcGF0aFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZWY7XHJcbn07XHJcblxyXG5cclxuLy8gSW5oZXJpdHMgYSBzZWxlY3RlZCBzZXQgb2YgbWV0aG9kcyBmcm9tIGFuIG9iamVjdCwgd3JhcHBpbmcgZnVuY3Rpb25zIGluIGFzeW5jaHJvbm91cyBzeW50YXggYW5kIGNhdGNoaW5nIGVycm9yc1xyXG5cclxuZXhwb3J0cy5pbmhlcml0QXN5bmMgPSBmdW5jdGlvbiAoc2VsZiwgb2JqLCBrZXlzKSB7XHJcblxyXG4gICAga2V5cyA9IGtleXMgfHwgbnVsbDtcclxuXHJcbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcclxuICAgICAgICAgICAgaWYgKGtleXMgaW5zdGFuY2VvZiBBcnJheSAmJlxyXG4gICAgICAgICAgICAgICAga2V5cy5pbmRleE9mKGkpIDwgMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZWxmLnByb3RvdHlwZVtpXSA9IChmdW5jdGlvbiAoZm4pIHtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5leHQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4oKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQobnVsbCwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pKG9ialtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuZm9ybWF0U3RhY2sgPSBmdW5jdGlvbiAoc3RhY2spIHtcclxuXHJcbiAgICB2YXIgdHJhY2UgPSBbXTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHN0YWNrLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuICAgICAgICB2YXIgaXRlbSA9IHN0YWNrW2ldO1xyXG4gICAgICAgIHRyYWNlLnB1c2goW2l0ZW0uZ2V0RmlsZU5hbWUoKSwgaXRlbS5nZXRMaW5lTnVtYmVyKCksIGl0ZW0uZ2V0Q29sdW1uTnVtYmVyKCksIGl0ZW0uZ2V0RnVuY3Rpb25OYW1lKCksIGl0ZW0uaXNDb25zdHJ1Y3RvcigpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRyYWNlO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuZm9ybWF0VHJhY2UgPSBmdW5jdGlvbiAodHJhY2UpIHtcclxuXHJcbiAgICB2YXIgZGlzcGxheSA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHRyYWNlLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuICAgICAgICB2YXIgcm93ID0gdHJhY2VbaV07XHJcbiAgICAgICAgZGlzcGxheS5wdXNoKChyb3dbNF0gPyAnbmV3ICcgOiAnJykgKyByb3dbM10gKyAnICgnICsgcm93WzBdICsgJzonICsgcm93WzFdICsgJzonICsgcm93WzJdICsgJyknKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGlzcGxheTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmNhbGxTdGFjayA9IGZ1bmN0aW9uIChzbGljZSkge1xyXG5cclxuICAgIC8vIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC93aWtpL0phdmFTY3JpcHRTdGFja1RyYWNlQXBpXHJcblxyXG4gICAgdmFyIHY4ID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XHJcbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IGZ1bmN0aW9uIChlcnIsIHN0YWNrKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBzdGFjaztcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGNhcHR1cmUgPSB7fTtcclxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGNhcHR1cmUsIGFyZ3VtZW50cy5jYWxsZWUpO1xyXG4gICAgdmFyIHN0YWNrID0gY2FwdHVyZS5zdGFjaztcclxuXHJcbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHY4O1xyXG5cclxuICAgIHZhciB0cmFjZSA9IGV4cG9ydHMuZm9ybWF0U3RhY2soc3RhY2spO1xyXG5cclxuICAgIGlmIChzbGljZSkge1xyXG4gICAgICAgIHJldHVybiB0cmFjZS5zbGljZShzbGljZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRyYWNlO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuZGlzcGxheVN0YWNrID0gZnVuY3Rpb24gKHNsaWNlKSB7XHJcblxyXG4gICAgdmFyIHRyYWNlID0gZXhwb3J0cy5jYWxsU3RhY2soc2xpY2UgPT09IHVuZGVmaW5lZCA/IDEgOiBzbGljZSArIDEpO1xyXG5cclxuICAgIHJldHVybiBleHBvcnRzLmZvcm1hdFRyYWNlKHRyYWNlKTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmFib3J0VGhyb3cgPSBmYWxzZTtcclxuXHJcblxyXG5leHBvcnRzLmFib3J0ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGhpZGVTdGFjaykge1xyXG5cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnIHx8IGV4cG9ydHMuYWJvcnRUaHJvdyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHN0YWNrID0gJyc7XHJcbiAgICBpZiAoIWhpZGVTdGFjaykge1xyXG4gICAgICAgIHN0YWNrID0gZXhwb3J0cy5kaXNwbGF5U3RhY2soMSkuam9pbignXFxuXFx0Jyk7XHJcbiAgICB9XHJcbiAgICBjb25zb2xlLmxvZygnQUJPUlQ6ICcgKyBtZXNzYWdlICsgJ1xcblxcdCcgKyBzdGFjayk7XHJcbiAgICBwcm9jZXNzLmV4aXQoMSk7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5hc3NlcnQgPSBmdW5jdGlvbiAoY29uZGl0aW9uIC8qLCBtc2cxLCBtc2cyLCBtc2czICovKSB7XHJcblxyXG4gICAgaWYgKGNvbmRpdGlvbikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbXNncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICBtc2dzID0gbXNncy5tYXAoZnVuY3Rpb24gKG1zZykge1xyXG5cclxuICAgICAgICByZXR1cm4gdHlwZW9mIG1zZyA9PT0gJ3N0cmluZycgPyBtc2cgOiBtc2cgaW5zdGFuY2VvZiBFcnJvciA/IG1zZy5tZXNzYWdlIDogSlNPTi5zdHJpbmdpZnkobXNnKTtcclxuICAgIH0pO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ3Muam9pbignICcpIHx8ICdVbmtub3duIGVycm9yJyk7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5sb2FkRGlyTW9kdWxlcyA9IGZ1bmN0aW9uIChwYXRoLCBleGNsdWRlRmlsZXMsIHRhcmdldCkgeyAgICAgIC8vIHRhcmdldChmaWxlbmFtZSwgbmFtZSwgY2FwTmFtZSlcclxuXHJcbiAgICB2YXIgZXhjbHVkZSA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZXhjbHVkZUZpbGVzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuICAgICAgICBleGNsdWRlW2V4Y2x1ZGVGaWxlc1tpXSArICcuanMnXSA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZpbGVzID0gRnMucmVhZGRpclN5bmMocGF0aCk7XHJcbiAgICBmb3IgKGkgPSAwLCBpbCA9IGZpbGVzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuICAgICAgICB2YXIgZmlsZW5hbWUgPSBmaWxlc1tpXTtcclxuICAgICAgICBpZiAoL1xcLmpzJC8udGVzdChmaWxlbmFtZSkgJiZcclxuICAgICAgICAgICAgIWV4Y2x1ZGVbZmlsZW5hbWVdKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IGZpbGVuYW1lLnN1YnN0cigwLCBmaWxlbmFtZS5sYXN0SW5kZXhPZignLicpKTtcclxuICAgICAgICAgICAgdmFyIGNhcE5hbWUgPSBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRbY2FwTmFtZV0gPSByZXF1aXJlKHBhdGggKyAnLycgKyBuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldChwYXRoICsgJy8nICsgbmFtZSwgbmFtZSwgY2FwTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5yZW5hbWUgPSBmdW5jdGlvbiAob2JqLCBmcm9tLCB0bykge1xyXG5cclxuICAgIG9ialt0b10gPSBvYmpbZnJvbV07XHJcbiAgICBkZWxldGUgb2JqW2Zyb21dO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuVGltZXIgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdGhpcy5yZXNldCgpO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuVGltZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHRoaXMudHMgPSBEYXRlLm5vdygpO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuVGltZXIucHJvdG90eXBlLmVsYXBzZWQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgcmV0dXJuIERhdGUubm93KCkgLSB0aGlzLnRzO1xyXG59O1xyXG5cclxuXHJcbi8vIExvYWQgYW5kIHBhcnNlIHBhY2thZ2UuanNvbiBwcm9jZXNzIHJvb3Qgb3IgZ2l2ZW4gZGlyZWN0b3J5XHJcblxyXG5leHBvcnRzLmxvYWRQYWNrYWdlID0gZnVuY3Rpb24gKGRpcikge1xyXG5cclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIHZhciBmaWxlcGF0aCA9IChkaXIgfHwgcHJvY2Vzcy5lbnYuUFdEKSArICcvcGFja2FnZS5qc29uJztcclxuICAgIGlmIChGcy5leGlzdHNTeW5jKGZpbGVwYXRoKSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UoRnMucmVhZEZpbGVTeW5jKGZpbGVwYXRoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7IH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuXHJcbi8vIEVzY2FwZSBzdHJpbmcgZm9yIFJlZ2V4IGNvbnN0cnVjdGlvblxyXG5cclxuZXhwb3J0cy5lc2NhcGVSZWdleCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuXHJcbiAgICAvLyBFc2NhcGUgXiQuKistPz0hOnxcXC8oKVtde30sXHJcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1tcXF5cXCRcXC5cXCpcXCtcXC1cXD9cXD1cXCFcXDpcXHxcXFxcXFwvXFwoXFwpXFxbXFxdXFx7XFx9XFwsXS9nLCAnXFxcXCQmJyk7XHJcbn07XHJcblxyXG5cclxuLy8gUmV0dXJuIGFuIGVycm9yIGFzIGZpcnN0IGFyZ3VtZW50IG9mIGEgY2FsbGJhY2tcclxuXHJcbmV4cG9ydHMudG9zcyA9IGZ1bmN0aW9uIChjb25kaXRpb24gLyosIFttZXNzYWdlXSwgbmV4dCAqLykge1xyXG5cclxuICAgIHZhciBtZXNzYWdlID0gKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgPyBhcmd1bWVudHNbMV0gOiAnJyk7XHJcbiAgICB2YXIgbmV4dCA9IChhcmd1bWVudHMubGVuZ3RoID09PSAzID8gYXJndW1lbnRzWzJdIDogYXJndW1lbnRzWzFdKTtcclxuXHJcbiAgICB2YXIgZXJyID0gKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvciA/IG1lc3NhZ2UgOiAobWVzc2FnZSA/IG5ldyBFcnJvcihtZXNzYWdlKSA6IChjb25kaXRpb24gaW5zdGFuY2VvZiBFcnJvciA/IGNvbmRpdGlvbiA6IG5ldyBFcnJvcigpKSkpO1xyXG5cclxuICAgIGlmIChjb25kaXRpb24gaW5zdGFuY2VvZiBFcnJvciB8fFxyXG4gICAgICAgICFjb25kaXRpb24pIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5leHQoZXJyKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vLyBCYXNlNjR1cmwgKFJGQyA0NjQ4KSBlbmNvZGVcclxuXHJcbmV4cG9ydHMuYmFzZTY0dXJsRW5jb2RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblxyXG4gICAgcmV0dXJuIChuZXcgQnVmZmVyKHZhbHVlLCAnYmluYXJ5JykpLnRvU3RyaW5nKCdiYXNlNjQnKS5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC9cXD0vZywgJycpO1xyXG59O1xyXG5cclxuXHJcbi8vIEJhc2U2NHVybCAoUkZDIDQ2NDgpIGRlY29kZVxyXG5cclxuZXhwb3J0cy5iYXNlNjR1cmxEZWNvZGUgPSBmdW5jdGlvbiAoZW5jb2RlZCkge1xyXG5cclxuICAgIGlmIChlbmNvZGVkICYmXHJcbiAgICAgICAgIWVuY29kZWQubWF0Y2goL15bXFx3XFwtXSokLykpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBjaGFyYWN0ZXInKTtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiAobmV3IEJ1ZmZlcihlbmNvZGVkLnJlcGxhY2UoLy0vZywgJysnKS5yZXBsYWNlKC86L2csICcvJyksICdiYXNlNjQnKSkudG9TdHJpbmcoJ2JpbmFyeScpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgIHJldHVybiBlcnI7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuLy8gRXNjYXBlIGF0dHJpYnV0ZSB2YWx1ZSBmb3IgdXNlIGluIEhUVFAgaGVhZGVyXHJcblxyXG5leHBvcnRzLmVzY2FwZUhlYWRlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcclxuXHJcbiAgICAvLyBBbGxvd2VkIHZhbHVlIGNoYXJhY3RlcnM6ICEjJCUmJygpKissLS4vOjs8PT4/QFtdXl9ge3x9fiBhbmQgc3BhY2UsIGEteiwgQS1aLCAwLTksIFxcLCBcIlxyXG5cclxuICAgIGV4cG9ydHMuYXNzZXJ0KGF0dHJpYnV0ZS5tYXRjaCgvXlsgXFx3XFwhI1xcJCUmJ1xcKFxcKVxcKlxcKyxcXC1cXC5cXC9cXDo7PFxcPT5cXD9AXFxbXFxdXFxeYFxce1xcfFxcfX5cXFwiXFxcXF0qJC8pLCAnQmFkIGF0dHJpYnV0ZSB2YWx1ZSAoJyArIGF0dHJpYnV0ZSArICcpJyk7XHJcblxyXG4gICAgcmV0dXJuIGF0dHJpYnV0ZS5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpLnJlcGxhY2UoL1xcXCIvZywgJ1xcXFxcIicpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXNjYXBlIHF1b3RlcyBhbmQgc2xhc2hcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmVzY2FwZUh0bWwgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcblxyXG4gICAgcmV0dXJuIEVzY2FwZS5lc2NhcGVIdG1sKHN0cmluZyk7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5lc2NhcGVKYXZhU2NyaXB0ID0gZnVuY3Rpb24gKHN0cmluZykge1xyXG5cclxuICAgIHJldHVybiBFc2NhcGUuZXNjYXBlSmF2YVNjcmlwdChzdHJpbmcpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbnZhciBldmVudCA9IHtcclxuICAgIHRpbWVzdGFtcDogbm93LmdldFRpbWUoKSxcclxuICAgIHRhZ3M6IFsndGFnJ10sXHJcbiAgICBkYXRhOiB7IHNvbWU6ICdkYXRhJyB9XHJcbn07XHJcbiovXHJcblxyXG5leHBvcnRzLmNvbnNvbGVGdW5jID0gY29uc29sZS5sb2c7XHJcblxyXG5leHBvcnRzLnByaW50RXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHJcbiAgICB2YXIgcGFkID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblxyXG4gICAgICAgIHJldHVybiAodmFsdWUgPCAxMCA/ICcwJyA6ICcnKSArIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgbm93ID0gbmV3IERhdGUoZXZlbnQudGltZXN0YW1wKTtcclxuICAgIHZhciB0aW1lc3RyaW5nID0gKG5vdy5nZXRZZWFyKCkgLSAxMDApLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgIHBhZChub3cuZ2V0TW9udGgoKSArIDEpICtcclxuICAgICAgICBwYWQobm93LmdldERhdGUoKSkgK1xyXG4gICAgICAgICcvJyArXHJcbiAgICAgICAgcGFkKG5vdy5nZXRIb3VycygpKSArXHJcbiAgICAgICAgcGFkKG5vdy5nZXRNaW51dGVzKCkpICtcclxuICAgICAgICBwYWQobm93LmdldFNlY29uZHMoKSkgK1xyXG4gICAgICAgICcuJyArXHJcbiAgICAgICAgbm93LmdldE1pbGxpc2Vjb25kcygpO1xyXG5cclxuICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YTtcclxuICAgIGlmICh0eXBlb2YgZXZlbnQuZGF0YSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBkYXRhID0gSlNPTi5zdHJpbmdpZnkoZXZlbnQuZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSAnSlNPTiBFcnJvcjogJyArIGUubWVzc2FnZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG91dHB1dCA9IHRpbWVzdHJpbmcgKyAnLCAnICsgZXZlbnQudGFnc1swXSArICcsICcgKyBkYXRhO1xyXG4gICAgZXhwb3J0cy5jb25zb2xlRnVuYyhvdXRwdXQpO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMubmV4dFRpY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufTtcclxuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikscmVxdWlyZShcIl9fYnJvd3NlcmlmeV9idWZmZXJcIikuQnVmZmVyKSIsIihmdW5jdGlvbihwcm9jZXNzLEJ1ZmZlcil7Ly8gTG9hZCBtb2R1bGVzXHJcblxyXG52YXIgRnMgPSByZXF1aXJlKCdmcycpO1xyXG52YXIgRXNjYXBlID0gcmVxdWlyZSgnLi9lc2NhcGUnKTtcclxuXHJcblxyXG4vLyBEZWNsYXJlIGludGVybmFsc1xyXG5cclxudmFyIGludGVybmFscyA9IHt9O1xyXG5cclxuXHJcbi8vIENsb25lIG9iamVjdCBvciBhcnJheVxyXG5cclxuZXhwb3J0cy5jbG9uZSA9IGZ1bmN0aW9uIChvYmosIHNlZW4pIHtcclxuXHJcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHxcclxuICAgICAgICBvYmogPT09IG51bGwpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuXHJcbiAgICBzZWVuID0gc2VlbiB8fCB7IG9yaWc6IFtdLCBjb3B5OiBbXSB9O1xyXG5cclxuICAgIHZhciBsb29rdXAgPSBzZWVuLm9yaWcuaW5kZXhPZihvYmopO1xyXG4gICAgaWYgKGxvb2t1cCAhPT0gLTEpIHtcclxuICAgICAgICByZXR1cm4gc2Vlbi5jb3B5W2xvb2t1cF07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5ld09iaiA9IChvYmogaW5zdGFuY2VvZiBBcnJheSkgPyBbXSA6IHt9O1xyXG5cclxuICAgIHNlZW4ub3JpZy5wdXNoKG9iaik7XHJcbiAgICBzZWVuLmNvcHkucHVzaChuZXdPYmopO1xyXG5cclxuICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG4gICAgICAgICAgICBpZiAob2JqW2ldIGluc3RhbmNlb2YgQnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdPYmpbaV0gPSBuZXcgQnVmZmVyKG9ialtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob2JqW2ldIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3T2JqW2ldID0gbmV3IERhdGUob2JqW2ldLmdldFRpbWUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob2JqW2ldIGluc3RhbmNlb2YgUmVnRXhwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmxhZ3MgPSAnJyArIChvYmpbaV0uZ2xvYmFsID8gJ2cnIDogJycpICsgKG9ialtpXS5pZ25vcmVDYXNlID8gJ2knIDogJycpICsgKG9ialtpXS5tdWx0aWxpbmUgPyAnbScgOiAnJyk7XHJcbiAgICAgICAgICAgICAgICBuZXdPYmpbaV0gPSBuZXcgUmVnRXhwKG9ialtpXS5zb3VyY2UsIGZsYWdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld09ialtpXSA9IGV4cG9ydHMuY2xvbmUob2JqW2ldLCBzZWVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3T2JqO1xyXG59O1xyXG5cclxuXHJcbi8vIE1lcmdlIGFsbCB0aGUgcHJvcGVydGllcyBvZiBzb3VyY2UgaW50byB0YXJnZXQsIHNvdXJjZSB3aW5zIGluIGNvbmZsaWMsIGFuZCBieSBkZWZhdWx0IG51bGwgYW5kIHVuZGVmaW5lZCBmcm9tIHNvdXJjZSBhcmUgYXBwbGllZFxyXG5cclxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgaXNOdWxsT3ZlcnJpZGUgLyogPSB0cnVlICovLCBpc01lcmdlQXJyYXlzIC8qID0gdHJ1ZSAqLykge1xyXG5cclxuICAgIGV4cG9ydHMuYXNzZXJ0KHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0ID09ICdvYmplY3QnLCAnSW52YWxpZCB0YXJnZXQgdmFsdWU6IG11c3QgYmUgYW4gb2JqZWN0Jyk7XHJcbiAgICBleHBvcnRzLmFzc2VydChzb3VyY2UgPT09IG51bGwgfHwgc291cmNlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHNvdXJjZSB2YWx1ZTogbXVzdCBiZSBudWxsLCB1bmRlZmluZWQsIG9yIGFuIG9iamVjdCcpO1xyXG5cclxuICAgIGlmICghc291cmNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICBleHBvcnRzLmFzc2VydCh0YXJnZXQgaW5zdGFuY2VvZiBBcnJheSwgJ0Nhbm5vdCBtZXJnZSBhcnJheSBvbnRvIGFuIG9iamVjdCcpO1xyXG4gICAgICAgIGlmIChpc01lcmdlQXJyYXlzID09PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXNNZXJnZUFycmF5cyBkZWZhdWx0cyB0byB0cnVlXHJcbiAgICAgICAgICAgIHRhcmdldC5sZW5ndGggPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNdXN0IG5vdCBjaGFuZ2UgdGFyZ2V0IGFzc2lnbm1lbnRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XHJcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHNvdXJjZVtpXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcclxuICAgIGZvciAodmFyIGsgPSAwLCBrbCA9IGtleXMubGVuZ3RoOyBrIDwga2w7ICsraykge1xyXG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2tdO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtrZXldO1xyXG4gICAgICAgIGlmICh2YWx1ZSAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRhcmdldFtrZXldIHx8XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0W2tleV0gIT09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBleHBvcnRzLmNsb25lKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV4cG9ydHMubWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBpc051bGxPdmVycmlkZSwgaXNNZXJnZUFycmF5cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7ICAgICAgICAgICAgLy8gRXhwbGljaXQgdG8gcHJlc2VydmUgZW1wdHkgc3RyaW5nc1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc051bGxPdmVycmlkZSAhPT0gZmFsc2UpIHsgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcclxuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufTtcclxuXHJcblxyXG4vLyBBcHBseSBvcHRpb25zIHRvIGEgY29weSBvZiB0aGUgZGVmYXVsdHNcclxuXHJcbmV4cG9ydHMuYXBwbHlUb0RlZmF1bHRzID0gZnVuY3Rpb24gKGRlZmF1bHRzLCBvcHRpb25zKSB7XHJcblxyXG4gICAgZXhwb3J0cy5hc3NlcnQoZGVmYXVsdHMgJiYgdHlwZW9mIGRlZmF1bHRzID09ICdvYmplY3QnLCAnSW52YWxpZCBkZWZhdWx0cyB2YWx1ZTogbXVzdCBiZSBhbiBvYmplY3QnKTtcclxuICAgIGV4cG9ydHMuYXNzZXJ0KCFvcHRpb25zIHx8IG9wdGlvbnMgPT09IHRydWUgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnLCAnSW52YWxpZCBvcHRpb25zIHZhbHVlOiBtdXN0IGJlIHRydWUsIGZhbHN5IG9yIGFuIG9iamVjdCcpO1xyXG5cclxuICAgIGlmICghb3B0aW9ucykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBvcHRpb25zLCByZXR1cm4gbnVsbFxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjb3B5ID0gZXhwb3J0cy5jbG9uZShkZWZhdWx0cyk7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG9wdGlvbnMgaXMgc2V0IHRvIHRydWUsIHVzZSBkZWZhdWx0c1xyXG4gICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBleHBvcnRzLm1lcmdlKGNvcHksIG9wdGlvbnMsIGZhbHNlLCBmYWxzZSk7XHJcbn07XHJcblxyXG5cclxuLy8gUmVtb3ZlIGR1cGxpY2F0ZSBpdGVtcyBmcm9tIGFycmF5XHJcblxyXG5leHBvcnRzLnVuaXF1ZSA9IGZ1bmN0aW9uIChhcnJheSwga2V5KSB7XHJcblxyXG4gICAgdmFyIGluZGV4ID0ge307XHJcbiAgICB2YXIgcmVzdWx0ID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIHZhciBpZCA9IChrZXkgPyBhcnJheVtpXVtrZXldIDogYXJyYXlbaV0pO1xyXG4gICAgICAgIGlmIChpbmRleFtpZF0gIT09IHRydWUpIHtcclxuXHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcclxuICAgICAgICAgICAgaW5kZXhbaWRdID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcblxyXG4vLyBDb252ZXJ0IGFycmF5IGludG8gb2JqZWN0XHJcblxyXG5leHBvcnRzLm1hcFRvT2JqZWN0ID0gZnVuY3Rpb24gKGFycmF5LCBrZXkpIHtcclxuXHJcbiAgICBpZiAoIWFycmF5KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG9iaiA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGFycmF5W2ldW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIG9ialthcnJheVtpXVtrZXldXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9ialthcnJheVtpXV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb2JqO1xyXG59O1xyXG5cclxuXHJcbi8vIEZpbmQgdGhlIGNvbW1vbiB1bmlxdWUgaXRlbXMgaW4gdHdvIGFycmF5c1xyXG5cclxuZXhwb3J0cy5pbnRlcnNlY3QgPSBmdW5jdGlvbiAoYXJyYXkxLCBhcnJheTIsIGp1c3RGaXJzdCkge1xyXG5cclxuICAgIGlmICghYXJyYXkxIHx8ICFhcnJheTIpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNvbW1vbiA9IFtdO1xyXG4gICAgdmFyIGhhc2ggPSAoYXJyYXkxIGluc3RhbmNlb2YgQXJyYXkgPyBleHBvcnRzLm1hcFRvT2JqZWN0KGFycmF5MSkgOiBhcnJheTEpO1xyXG4gICAgdmFyIGZvdW5kID0ge307XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBhcnJheTIubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIGlmIChoYXNoW2FycmF5MltpXV0gJiYgIWZvdW5kW2FycmF5MltpXV0pIHtcclxuICAgICAgICAgICAgaWYgKGp1c3RGaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5MltpXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29tbW9uLnB1c2goYXJyYXkyW2ldKTtcclxuICAgICAgICAgICAgZm91bmRbYXJyYXkyW2ldXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoanVzdEZpcnN0ID8gbnVsbCA6IGNvbW1vbik7XHJcbn07XHJcblxyXG5cclxuLy8gRmluZCB3aGljaCBrZXlzIGFyZSBwcmVzZW50XHJcblxyXG5leHBvcnRzLm1hdGNoS2V5cyA9IGZ1bmN0aW9uIChvYmosIGtleXMpIHtcclxuXHJcbiAgICB2YXIgbWF0Y2hlZCA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXlzW2ldKSkge1xyXG4gICAgICAgICAgICBtYXRjaGVkLnB1c2goa2V5c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1hdGNoZWQ7XHJcbn07XHJcblxyXG5cclxuLy8gRmxhdHRlbiBhcnJheVxyXG5cclxuZXhwb3J0cy5mbGF0dGVuID0gZnVuY3Rpb24gKGFycmF5LCB0YXJnZXQpIHtcclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0IHx8IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheVtpXSkpIHtcclxuICAgICAgICAgICAgZXhwb3J0cy5mbGF0dGVuKGFycmF5W2ldLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuXHJcbi8vIFJlbW92ZSBrZXlzXHJcblxyXG5leHBvcnRzLnJlbW92ZUtleXMgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXlzKSB7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XHJcbiAgICAgICAgZGVsZXRlIG9iamVjdFtrZXlzW2ldXTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vLyBDb252ZXJ0IGFuIG9iamVjdCBrZXkgY2hhaW4gc3RyaW5nICgnYS5iLmMnKSB0byByZWZlcmVuY2UgKG9iamVjdFthXVtiXVtjXSlcclxuXHJcbmV4cG9ydHMucmVhY2ggPSBmdW5jdGlvbiAob2JqLCBjaGFpbikge1xyXG5cclxuICAgIHZhciBwYXRoID0gY2hhaW4uc3BsaXQoJy4nKTtcclxuICAgIHZhciByZWYgPSBvYmo7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBwYXRoLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuICAgICAgICBpZiAocmVmKSB7XHJcbiAgICAgICAgICAgIHJlZiA9IHJlZltwYXRoW2ldXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlZjtcclxufTtcclxuXHJcblxyXG4vLyBJbmhlcml0cyBhIHNlbGVjdGVkIHNldCBvZiBtZXRob2RzIGZyb20gYW4gb2JqZWN0LCB3cmFwcGluZyBmdW5jdGlvbnMgaW4gYXN5bmNocm9ub3VzIHN5bnRheCBhbmQgY2F0Y2hpbmcgZXJyb3JzXHJcblxyXG5leHBvcnRzLmluaGVyaXRBc3luYyA9IGZ1bmN0aW9uIChzZWxmLCBvYmosIGtleXMpIHtcclxuXHJcbiAgICBrZXlzID0ga2V5cyB8fCBudWxsO1xyXG5cclxuICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG4gICAgICAgICAgICBpZiAoa2V5cyBpbnN0YW5jZW9mIEFycmF5ICYmXHJcbiAgICAgICAgICAgICAgICBrZXlzLmluZGV4T2YoaSkgPCAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNlbGYucHJvdG90eXBlW2ldID0gKGZ1bmN0aW9uIChmbikge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChudWxsLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSkob2JqW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5mb3JtYXRTdGFjayA9IGZ1bmN0aW9uIChzdGFjaykge1xyXG5cclxuICAgIHZhciB0cmFjZSA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gc3RhY2subGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIHZhciBpdGVtID0gc3RhY2tbaV07XHJcbiAgICAgICAgdHJhY2UucHVzaChbaXRlbS5nZXRGaWxlTmFtZSgpLCBpdGVtLmdldExpbmVOdW1iZXIoKSwgaXRlbS5nZXRDb2x1bW5OdW1iZXIoKSwgaXRlbS5nZXRGdW5jdGlvbk5hbWUoKSwgaXRlbS5pc0NvbnN0cnVjdG9yKCldKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJhY2U7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5mb3JtYXRUcmFjZSA9IGZ1bmN0aW9uICh0cmFjZSkge1xyXG5cclxuICAgIHZhciBkaXNwbGF5ID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdHJhY2UubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIHZhciByb3cgPSB0cmFjZVtpXTtcclxuICAgICAgICBkaXNwbGF5LnB1c2goKHJvd1s0XSA/ICduZXcgJyA6ICcnKSArIHJvd1szXSArICcgKCcgKyByb3dbMF0gKyAnOicgKyByb3dbMV0gKyAnOicgKyByb3dbMl0gKyAnKScpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkaXNwbGF5O1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuY2FsbFN0YWNrID0gZnVuY3Rpb24gKHNsaWNlKSB7XHJcblxyXG4gICAgLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L3dpa2kvSmF2YVNjcmlwdFN0YWNrVHJhY2VBcGlcclxuXHJcbiAgICB2YXIgdjggPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcclxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnVuY3Rpb24gKGVyciwgc3RhY2spIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN0YWNrO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgY2FwdHVyZSA9IHt9O1xyXG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoY2FwdHVyZSwgYXJndW1lbnRzLmNhbGxlZSk7XHJcbiAgICB2YXIgc3RhY2sgPSBjYXB0dXJlLnN0YWNrO1xyXG5cclxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdjg7XHJcblxyXG4gICAgdmFyIHRyYWNlID0gZXhwb3J0cy5mb3JtYXRTdGFjayhzdGFjayk7XHJcblxyXG4gICAgaWYgKHNsaWNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRyYWNlLnNsaWNlKHNsaWNlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJhY2U7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5kaXNwbGF5U3RhY2sgPSBmdW5jdGlvbiAoc2xpY2UpIHtcclxuXHJcbiAgICB2YXIgdHJhY2UgPSBleHBvcnRzLmNhbGxTdGFjayhzbGljZSA9PT0gdW5kZWZpbmVkID8gMSA6IHNsaWNlICsgMSk7XHJcblxyXG4gICAgcmV0dXJuIGV4cG9ydHMuZm9ybWF0VHJhY2UodHJhY2UpO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuYWJvcnRUaHJvdyA9IGZhbHNlO1xyXG5cclxuXHJcbmV4cG9ydHMuYWJvcnQgPSBmdW5jdGlvbiAobWVzc2FnZSwgaGlkZVN0YWNrKSB7XHJcblxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcgfHwgZXhwb3J0cy5hYm9ydFRocm93ID09PSB0cnVlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc3RhY2sgPSAnJztcclxuICAgIGlmICghaGlkZVN0YWNrKSB7XHJcbiAgICAgICAgc3RhY2sgPSBleHBvcnRzLmRpc3BsYXlTdGFjaygxKS5qb2luKCdcXG5cXHQnKTtcclxuICAgIH1cclxuICAgIGNvbnNvbGUubG9nKCdBQk9SVDogJyArIG1lc3NhZ2UgKyAnXFxuXFx0JyArIHN0YWNrKTtcclxuICAgIHByb2Nlc3MuZXhpdCgxKTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmFzc2VydCA9IGZ1bmN0aW9uIChjb25kaXRpb24gLyosIG1zZzEsIG1zZzIsIG1zZzMgKi8pIHtcclxuXHJcbiAgICBpZiAoY29uZGl0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBtc2dzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgIG1zZ3MgPSBtc2dzLm1hcChmdW5jdGlvbiAobXNnKSB7XHJcblxyXG4gICAgICAgIHJldHVybiB0eXBlb2YgbXNnID09PSAnc3RyaW5nJyA/IG1zZyA6IG1zZyBpbnN0YW5jZW9mIEVycm9yID8gbXNnLm1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeShtc2cpO1xyXG4gICAgfSk7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNncy5qb2luKCcgJykgfHwgJ1Vua25vd24gZXJyb3InKTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmxvYWREaXJNb2R1bGVzID0gZnVuY3Rpb24gKHBhdGgsIGV4Y2x1ZGVGaWxlcywgdGFyZ2V0KSB7ICAgICAgLy8gdGFyZ2V0KGZpbGVuYW1lLCBuYW1lLCBjYXBOYW1lKVxyXG5cclxuICAgIHZhciBleGNsdWRlID0ge307XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBleGNsdWRlRmlsZXMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIGV4Y2x1ZGVbZXhjbHVkZUZpbGVzW2ldICsgJy5qcyddID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZmlsZXMgPSBGcy5yZWFkZGlyU3luYyhwYXRoKTtcclxuICAgIGZvciAoaSA9IDAsIGlsID0gZmlsZXMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG4gICAgICAgIHZhciBmaWxlbmFtZSA9IGZpbGVzW2ldO1xyXG4gICAgICAgIGlmICgvXFwuanMkLy50ZXN0KGZpbGVuYW1lKSAmJlxyXG4gICAgICAgICAgICAhZXhjbHVkZVtmaWxlbmFtZV0pIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gZmlsZW5hbWUuc3Vic3RyKDAsIGZpbGVuYW1lLmxhc3RJbmRleE9mKCcuJykpO1xyXG4gICAgICAgICAgICB2YXIgY2FwTmFtZSA9IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldFtjYXBOYW1lXSA9IHJlcXVpcmUocGF0aCArICcvJyArIG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0KHBhdGggKyAnLycgKyBuYW1lLCBuYW1lLCBjYXBOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblxyXG5leHBvcnRzLnJlbmFtZSA9IGZ1bmN0aW9uIChvYmosIGZyb20sIHRvKSB7XHJcblxyXG4gICAgb2JqW3RvXSA9IG9ialtmcm9tXTtcclxuICAgIGRlbGV0ZSBvYmpbZnJvbV07XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5UaW1lciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB0aGlzLnJlc2V0KCk7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5UaW1lci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdGhpcy50cyA9IERhdGUubm93KCk7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5UaW1lci5wcm90b3R5cGUuZWxhcHNlZCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRoaXMudHM7XHJcbn07XHJcblxyXG5cclxuLy8gTG9hZCBhbmQgcGFyc2UgcGFja2FnZS5qc29uIHByb2Nlc3Mgcm9vdCBvciBnaXZlbiBkaXJlY3RvcnlcclxuXHJcbmV4cG9ydHMubG9hZFBhY2thZ2UgPSBmdW5jdGlvbiAoZGlyKSB7XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgdmFyIGZpbGVwYXRoID0gKGRpciB8fCBwcm9jZXNzLmVudi5QV0QpICsgJy9wYWNrYWdlLmpzb24nO1xyXG4gICAgaWYgKEZzLmV4aXN0c1N5bmMoZmlsZXBhdGgpKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShGcy5yZWFkRmlsZVN5bmMoZmlsZXBhdGgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5cclxuLy8gRXNjYXBlIHN0cmluZyBmb3IgUmVnZXggY29uc3RydWN0aW9uXHJcblxyXG5leHBvcnRzLmVzY2FwZVJlZ2V4ID0gZnVuY3Rpb24gKHN0cmluZykge1xyXG5cclxuICAgIC8vIEVzY2FwZSBeJC4qKy0/PSE6fFxcLygpW117fSxcclxuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW1xcXlxcJFxcLlxcKlxcK1xcLVxcP1xcPVxcIVxcOlxcfFxcXFxcXC9cXChcXClcXFtcXF1cXHtcXH1cXCxdL2csICdcXFxcJCYnKTtcclxufTtcclxuXHJcblxyXG4vLyBSZXR1cm4gYW4gZXJyb3IgYXMgZmlyc3QgYXJndW1lbnQgb2YgYSBjYWxsYmFja1xyXG5cclxuZXhwb3J0cy50b3NzID0gZnVuY3Rpb24gKGNvbmRpdGlvbiAvKiwgW21lc3NhZ2VdLCBuZXh0ICovKSB7XHJcblxyXG4gICAgdmFyIG1lc3NhZ2UgPSAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyA/IGFyZ3VtZW50c1sxXSA6ICcnKTtcclxuICAgIHZhciBuZXh0ID0gKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgPyBhcmd1bWVudHNbMl0gOiBhcmd1bWVudHNbMV0pO1xyXG5cclxuICAgIHZhciBlcnIgPSAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yID8gbWVzc2FnZSA6IChtZXNzYWdlID8gbmV3IEVycm9yKG1lc3NhZ2UpIDogKGNvbmRpdGlvbiBpbnN0YW5jZW9mIEVycm9yID8gY29uZGl0aW9uIDogbmV3IEVycm9yKCkpKSk7XHJcblxyXG4gICAgaWYgKGNvbmRpdGlvbiBpbnN0YW5jZW9mIEVycm9yIHx8XHJcbiAgICAgICAgIWNvbmRpdGlvbikge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV4dChlcnIpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbi8vIEJhc2U2NHVybCAoUkZDIDQ2NDgpIGVuY29kZVxyXG5cclxuZXhwb3J0cy5iYXNlNjR1cmxFbmNvZGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHJcbiAgICByZXR1cm4gKG5ldyBCdWZmZXIodmFsdWUsICdiaW5hcnknKSkudG9TdHJpbmcoJ2Jhc2U2NCcpLnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpLnJlcGxhY2UoL1xcPS9nLCAnJyk7XHJcbn07XHJcblxyXG5cclxuLy8gQmFzZTY0dXJsIChSRkMgNDY0OCkgZGVjb2RlXHJcblxyXG5leHBvcnRzLmJhc2U2NHVybERlY29kZSA9IGZ1bmN0aW9uIChlbmNvZGVkKSB7XHJcblxyXG4gICAgaWYgKGVuY29kZWQgJiZcclxuICAgICAgICAhZW5jb2RlZC5tYXRjaCgvXltcXHdcXC1dKiQvKSkge1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIGNoYXJhY3RlcicpO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKGVuY29kZWQucmVwbGFjZSgvLS9nLCAnKycpLnJlcGxhY2UoLzovZywgJy8nKSwgJ2Jhc2U2NCcpKS50b1N0cmluZygnYmluYXJ5Jyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIGVycjtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG4vLyBFc2NhcGUgYXR0cmlidXRlIHZhbHVlIGZvciB1c2UgaW4gSFRUUCBoZWFkZXJcclxuXHJcbmV4cG9ydHMuZXNjYXBlSGVhZGVyQXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xyXG5cclxuICAgIC8vIEFsbG93ZWQgdmFsdWUgY2hhcmFjdGVyczogISMkJSYnKCkqKywtLi86Ozw9Pj9AW11eX2B7fH1+IGFuZCBzcGFjZSwgYS16LCBBLVosIDAtOSwgXFwsIFwiXHJcblxyXG4gICAgZXhwb3J0cy5hc3NlcnQoYXR0cmlidXRlLm1hdGNoKC9eWyBcXHdcXCEjXFwkJSYnXFwoXFwpXFwqXFwrLFxcLVxcLlxcL1xcOjs8XFw9PlxcP0BcXFtcXF1cXF5gXFx7XFx8XFx9flxcXCJcXFxcXSokLyksICdCYWQgYXR0cmlidXRlIHZhbHVlICgnICsgYXR0cmlidXRlICsgJyknKTtcclxuXHJcbiAgICByZXR1cm4gYXR0cmlidXRlLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvXFxcIi9nLCAnXFxcXFwiJyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFc2NhcGUgcXVvdGVzIGFuZCBzbGFzaFxyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuZXNjYXBlSHRtbCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuXHJcbiAgICByZXR1cm4gRXNjYXBlLmVzY2FwZUh0bWwoc3RyaW5nKTtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLmVzY2FwZUphdmFTY3JpcHQgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcblxyXG4gICAgcmV0dXJuIEVzY2FwZS5lc2NhcGVKYXZhU2NyaXB0KHN0cmluZyk7XHJcbn07XHJcblxyXG5cclxuLypcclxudmFyIGV2ZW50ID0ge1xyXG4gICAgdGltZXN0YW1wOiBub3cuZ2V0VGltZSgpLFxyXG4gICAgdGFnczogWyd0YWcnXSxcclxuICAgIGRhdGE6IHsgc29tZTogJ2RhdGEnIH1cclxufTtcclxuKi9cclxuXHJcbmV4cG9ydHMuY29uc29sZUZ1bmMgPSBjb25zb2xlLmxvZztcclxuXHJcbmV4cG9ydHMucHJpbnRFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG5cclxuICAgIHZhciBwYWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuICh2YWx1ZSA8IDEwID8gJzAnIDogJycpICsgdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBub3cgPSBuZXcgRGF0ZShldmVudC50aW1lc3RhbXApO1xyXG4gICAgdmFyIHRpbWVzdHJpbmcgPSAobm93LmdldFllYXIoKSAtIDEwMCkudG9TdHJpbmcoKSArXHJcbiAgICAgICAgcGFkKG5vdy5nZXRNb250aCgpICsgMSkgK1xyXG4gICAgICAgIHBhZChub3cuZ2V0RGF0ZSgpKSArXHJcbiAgICAgICAgJy8nICtcclxuICAgICAgICBwYWQobm93LmdldEhvdXJzKCkpICtcclxuICAgICAgICBwYWQobm93LmdldE1pbnV0ZXMoKSkgK1xyXG4gICAgICAgIHBhZChub3cuZ2V0U2Vjb25kcygpKSArXHJcbiAgICAgICAgJy4nICtcclxuICAgICAgICBub3cuZ2V0TWlsbGlzZWNvbmRzKCk7XHJcblxyXG4gICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xyXG4gICAgaWYgKHR5cGVvZiBldmVudC5kYXRhICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnN0cmluZ2lmeShldmVudC5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgZGF0YSA9ICdKU09OIEVycm9yOiAnICsgZS5tZXNzYWdlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgb3V0cHV0ID0gdGltZXN0cmluZyArICcsICcgKyBldmVudC50YWdzWzBdICsgJywgJyArIGRhdGE7XHJcbiAgICBleHBvcnRzLmNvbnNvbGVGdW5jKG91dHB1dCk7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5uZXh0VGljayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59O1xyXG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSxyZXF1aXJlKFwiX19icm93c2VyaWZ5X2J1ZmZlclwiKS5CdWZmZXIpIiwiKGZ1bmN0aW9uKEJ1ZmZlcil7Ly8gRGVjbGFyZSBpbnRlcm5hbHNcclxuXHJcbnZhciBpbnRlcm5hbHMgPSB7fTtcclxuXHJcblxyXG5leHBvcnRzLmVzY2FwZUphdmFTY3JpcHQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcclxuXHJcbiAgICBpZiAoIWlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBlc2NhcGVkID0gJyc7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gaW5wdXQubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xyXG5cclxuICAgICAgICB2YXIgY2hhckNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xyXG5cclxuICAgICAgICBpZiAoaW50ZXJuYWxzLmlzU2FmZShjaGFyQ29kZSkpIHtcclxuICAgICAgICAgICAgZXNjYXBlZCArPSBpbnB1dFtpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVzY2FwZWQgKz0gaW50ZXJuYWxzLmVzY2FwZUphdmFTY3JpcHRDaGFyKGNoYXJDb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVzY2FwZWQ7XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5lc2NhcGVIdG1sID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcblxyXG4gICAgaWYgKCFpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZXNjYXBlZCA9ICcnO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGlucHV0Lmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuXHJcbiAgICAgICAgdmFyIGNoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpKTtcclxuXHJcbiAgICAgICAgaWYgKGludGVybmFscy5pc1NhZmUoY2hhckNvZGUpKSB7XHJcbiAgICAgICAgICAgIGVzY2FwZWQgKz0gaW5wdXRbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlc2NhcGVkICs9IGludGVybmFscy5lc2NhcGVIdG1sQ2hhcihjaGFyQ29kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlc2NhcGVkO1xyXG59O1xyXG5cclxuXHJcbmludGVybmFscy5lc2NhcGVKYXZhU2NyaXB0Q2hhciA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xyXG5cclxuICAgIGlmIChjaGFyQ29kZSA+PSAyNTYpIHtcclxuICAgICAgICByZXR1cm4gJ1xcXFx1JyArIGludGVybmFscy5wYWRMZWZ0KCcnICsgY2hhckNvZGUsIDQpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBoZXhWYWx1ZSA9IG5ldyBCdWZmZXIoU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSksICdhc2NpaScpLnRvU3RyaW5nKCdoZXgnKTtcclxuICAgIHJldHVybiAnXFxcXHgnICsgaW50ZXJuYWxzLnBhZExlZnQoaGV4VmFsdWUsIDIpO1xyXG59O1xyXG5cclxuXHJcbmludGVybmFscy5lc2NhcGVIdG1sQ2hhciA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xyXG5cclxuICAgIHZhciBuYW1lZEVzY2FwZSA9IGludGVybmFscy5uYW1lZEh0bWxbY2hhckNvZGVdO1xyXG4gICAgaWYgKHR5cGVvZiBuYW1lZEVzY2FwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gbmFtZWRFc2NhcGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNoYXJDb2RlID49IDI1Nikge1xyXG4gICAgICAgIHJldHVybiAnJiMnICsgY2hhckNvZGUgKyAnOyc7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGhleFZhbHVlID0gbmV3IEJ1ZmZlcihTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKSwgJ2FzY2lpJykudG9TdHJpbmcoJ2hleCcpO1xyXG4gICAgcmV0dXJuICcmI3gnICsgaW50ZXJuYWxzLnBhZExlZnQoaGV4VmFsdWUsIDIpICsgJzsnO1xyXG59O1xyXG5cclxuXHJcbmludGVybmFscy5wYWRMZWZ0ID0gZnVuY3Rpb24gKHN0ciwgbGVuKSB7XHJcblxyXG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCBsZW4pIHtcclxuICAgICAgICBzdHIgPSAnMCcgKyBzdHI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0cjtcclxufTtcclxuXHJcblxyXG5pbnRlcm5hbHMuaXNTYWZlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XHJcblxyXG4gICAgcmV0dXJuICh0eXBlb2YgaW50ZXJuYWxzLnNhZmVDaGFyQ29kZXNbY2hhckNvZGVdICE9PSAndW5kZWZpbmVkJyk7XHJcbn07XHJcblxyXG5cclxuaW50ZXJuYWxzLm5hbWVkSHRtbCA9IHtcclxuICAgICczOCc6ICcmYW1wOycsXHJcbiAgICAnNjAnOiAnJmx0OycsXHJcbiAgICAnNjInOiAnJmd0OycsXHJcbiAgICAnMzQnOiAnJnF1b3Q7JyxcclxuICAgICcxNjAnOiAnJm5ic3A7JyxcclxuICAgICcxNjInOiAnJmNlbnQ7JyxcclxuICAgICcxNjMnOiAnJnBvdW5kOycsXHJcbiAgICAnMTY0JzogJyZjdXJyZW47JyxcclxuICAgICcxNjknOiAnJmNvcHk7JyxcclxuICAgICcxNzQnOiAnJnJlZzsnXHJcbn07XHJcblxyXG5cclxuaW50ZXJuYWxzLnNhZmVDaGFyQ29kZXMgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhciBzYWZlID0ge307XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDMyOyBpIDwgMTIzOyArK2kpIHtcclxuXHJcbiAgICAgICAgaWYgKChpID49IDk3ICYmIGkgPD0gMTIyKSB8fCAgICAgICAgIC8vIGEtelxyXG4gICAgICAgICAgICAoaSA+PSA2NSAmJiBpIDw9IDkwKSB8fCAgICAgICAgICAvLyBBLVpcclxuICAgICAgICAgICAgKGkgPj0gNDggJiYgaSA8PSA1NykgfHwgICAgICAgICAgLy8gMC05XHJcbiAgICAgICAgICAgIGkgPT09IDMyIHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIHNwYWNlXHJcbiAgICAgICAgICAgIGkgPT09IDQ2IHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIC5cclxuICAgICAgICAgICAgaSA9PT0gNDQgfHwgICAgICAgICAgICAgICAgICAgICAgLy8gLFxyXG4gICAgICAgICAgICBpID09PSA0NSB8fCAgICAgICAgICAgICAgICAgICAgICAvLyAtXHJcbiAgICAgICAgICAgIGkgPT09IDU4IHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIDpcclxuICAgICAgICAgICAgaSA9PT0gOTUpIHsgICAgICAgICAgICAgICAgICAgICAgLy8gX1xyXG5cclxuICAgICAgICAgICAgc2FmZVtpXSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzYWZlO1xyXG59KCkpO1xufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9idWZmZXJcIikuQnVmZmVyKSIsIihmdW5jdGlvbihCdWZmZXIpey8vIERlY2xhcmUgaW50ZXJuYWxzXHJcblxyXG52YXIgaW50ZXJuYWxzID0ge307XHJcblxyXG5cclxuZXhwb3J0cy5lc2NhcGVKYXZhU2NyaXB0ID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcblxyXG4gICAgaWYgKCFpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZXNjYXBlZCA9ICcnO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGlucHV0Lmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcclxuXHJcbiAgICAgICAgdmFyIGNoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpKTtcclxuXHJcbiAgICAgICAgaWYgKGludGVybmFscy5pc1NhZmUoY2hhckNvZGUpKSB7XHJcbiAgICAgICAgICAgIGVzY2FwZWQgKz0gaW5wdXRbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlc2NhcGVkICs9IGludGVybmFscy5lc2NhcGVKYXZhU2NyaXB0Q2hhcihjaGFyQ29kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlc2NhcGVkO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuZXNjYXBlSHRtbCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG5cclxuICAgIGlmICghaW5wdXQpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGVzY2FwZWQgPSAnJztcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBpbnB1dC5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XHJcblxyXG4gICAgICAgIHZhciBjaGFyQ29kZSA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XHJcblxyXG4gICAgICAgIGlmIChpbnRlcm5hbHMuaXNTYWZlKGNoYXJDb2RlKSkge1xyXG4gICAgICAgICAgICBlc2NhcGVkICs9IGlucHV0W2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXNjYXBlZCArPSBpbnRlcm5hbHMuZXNjYXBlSHRtbENoYXIoY2hhckNvZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZXNjYXBlZDtcclxufTtcclxuXHJcblxyXG5pbnRlcm5hbHMuZXNjYXBlSmF2YVNjcmlwdENoYXIgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcclxuXHJcbiAgICBpZiAoY2hhckNvZGUgPj0gMjU2KSB7XHJcbiAgICAgICAgcmV0dXJuICdcXFxcdScgKyBpbnRlcm5hbHMucGFkTGVmdCgnJyArIGNoYXJDb2RlLCA0KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaGV4VmFsdWUgPSBuZXcgQnVmZmVyKFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpLCAnYXNjaWknKS50b1N0cmluZygnaGV4Jyk7XHJcbiAgICByZXR1cm4gJ1xcXFx4JyArIGludGVybmFscy5wYWRMZWZ0KGhleFZhbHVlLCAyKTtcclxufTtcclxuXHJcblxyXG5pbnRlcm5hbHMuZXNjYXBlSHRtbENoYXIgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcclxuXHJcbiAgICB2YXIgbmFtZWRFc2NhcGUgPSBpbnRlcm5hbHMubmFtZWRIdG1sW2NoYXJDb2RlXTtcclxuICAgIGlmICh0eXBlb2YgbmFtZWRFc2NhcGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIG5hbWVkRXNjYXBlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjaGFyQ29kZSA+PSAyNTYpIHtcclxuICAgICAgICByZXR1cm4gJyYjJyArIGNoYXJDb2RlICsgJzsnO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBoZXhWYWx1ZSA9IG5ldyBCdWZmZXIoU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSksICdhc2NpaScpLnRvU3RyaW5nKCdoZXgnKTtcclxuICAgIHJldHVybiAnJiN4JyArIGludGVybmFscy5wYWRMZWZ0KGhleFZhbHVlLCAyKSArICc7JztcclxufTtcclxuXHJcblxyXG5pbnRlcm5hbHMucGFkTGVmdCA9IGZ1bmN0aW9uIChzdHIsIGxlbikge1xyXG5cclxuICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbGVuKSB7XHJcbiAgICAgICAgc3RyID0gJzAnICsgc3RyO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHI7XHJcbn07XHJcblxyXG5cclxuaW50ZXJuYWxzLmlzU2FmZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xyXG5cclxuICAgIHJldHVybiAodHlwZW9mIGludGVybmFscy5zYWZlQ2hhckNvZGVzW2NoYXJDb2RlXSAhPT0gJ3VuZGVmaW5lZCcpO1xyXG59O1xyXG5cclxuXHJcbmludGVybmFscy5uYW1lZEh0bWwgPSB7XHJcbiAgICAnMzgnOiAnJmFtcDsnLFxyXG4gICAgJzYwJzogJyZsdDsnLFxyXG4gICAgJzYyJzogJyZndDsnLFxyXG4gICAgJzM0JzogJyZxdW90OycsXHJcbiAgICAnMTYwJzogJyZuYnNwOycsXHJcbiAgICAnMTYyJzogJyZjZW50OycsXHJcbiAgICAnMTYzJzogJyZwb3VuZDsnLFxyXG4gICAgJzE2NCc6ICcmY3VycmVuOycsXHJcbiAgICAnMTY5JzogJyZjb3B5OycsXHJcbiAgICAnMTc0JzogJyZyZWc7J1xyXG59O1xyXG5cclxuXHJcbmludGVybmFscy5zYWZlQ2hhckNvZGVzID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICB2YXIgc2FmZSA9IHt9O1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAzMjsgaSA8IDEyMzsgKytpKSB7XHJcblxyXG4gICAgICAgIGlmICgoaSA+PSA5NyAmJiBpIDw9IDEyMikgfHwgICAgICAgICAvLyBhLXpcclxuICAgICAgICAgICAgKGkgPj0gNjUgJiYgaSA8PSA5MCkgfHwgICAgICAgICAgLy8gQS1aXHJcbiAgICAgICAgICAgIChpID49IDQ4ICYmIGkgPD0gNTcpIHx8ICAgICAgICAgIC8vIDAtOVxyXG4gICAgICAgICAgICBpID09PSAzMiB8fCAgICAgICAgICAgICAgICAgICAgICAvLyBzcGFjZVxyXG4gICAgICAgICAgICBpID09PSA0NiB8fCAgICAgICAgICAgICAgICAgICAgICAvLyAuXHJcbiAgICAgICAgICAgIGkgPT09IDQ0IHx8ICAgICAgICAgICAgICAgICAgICAgIC8vICxcclxuICAgICAgICAgICAgaSA9PT0gNDUgfHwgICAgICAgICAgICAgICAgICAgICAgLy8gLVxyXG4gICAgICAgICAgICBpID09PSA1OCB8fCAgICAgICAgICAgICAgICAgICAgICAvLyA6XHJcbiAgICAgICAgICAgIGkgPT09IDk1KSB7ICAgICAgICAgICAgICAgICAgICAgIC8vIF9cclxuXHJcbiAgICAgICAgICAgIHNhZmVbaV0gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc2FmZTtcclxufSgpKTtcbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfYnVmZmVyXCIpLkJ1ZmZlcikiXX0=
;